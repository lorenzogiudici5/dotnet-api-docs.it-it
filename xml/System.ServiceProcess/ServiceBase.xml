<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e2912243db0e29abdb2e744262f17e23e80bfbe8" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39829241" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una classe base per un servizio che esisterà nel contesto di un'applicazione di servizio. È necessario derivare <see cref="T:System.ServiceProcess.ServiceBase" /> durante la creazione di una nuova classe di servizio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivare da <xref:System.ServiceProcess.ServiceBase> durante la definizione della classe di servizio in un'applicazione di servizio. Qualsiasi servizio utile esegue l'override di <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodi. Per aggiungere ulteriori funzionalità, è possibile eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> con comportamento specifico in risposta alle modifiche dello stato di servizio.  
  
 Un servizio è un eseguibile a esecuzione prolungata che non supporta un'interfaccia utente, e che potrebbero non essere eseguiti con l'account utente connesso. Il servizio può eseguire senza tutti gli utenti connessi al computer.  
  
 Per impostazione predefinita, i servizi eseguiti con l'account di sistema, che non è quello utilizzato per l'account amministratore. Non è possibile modificare i diritti dell'account di sistema. In alternativa, è possibile usare un <xref:System.ServiceProcess.ServiceProcessInstaller> per specificare un account utente con cui verrà eseguito il servizio.  
  
 Un file eseguibile può contenere più di un servizio, ma deve contenere un oggetto separato <xref:System.ServiceProcess.ServiceInstaller> per ogni servizio. Il <xref:System.ServiceProcess.ServiceInstaller> istanza registra il servizio con il sistema. Il programma di installazione associa anche ogni servizio con un log eventi che è possibile usare per registrare i comandi di servizio. Il `main()` funzione nel file eseguibile definisce quali servizi deve essere eseguito. Directory di lavoro corrente del servizio è la directory di sistema, non alla directory in cui si trova il file eseguibile.  
  
 Quando si avvia un servizio, il sistema individua il file eseguibile e viene eseguito il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo per il servizio, contenuta all'interno del file eseguibile. Tuttavia, che esegue il servizio non è quello utilizzato per il file eseguibile. Il file eseguibile viene caricato solo il servizio. Il servizio è accessibile (ad esempio, avviare e arrestare) tramite Gestione controllo servizi.  
  
 L'eseguibile chiama il <xref:System.ServiceProcess.ServiceBase> derivata ora il primo costruttore della classe si chiama il metodo Start nel servizio. Il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> la gestione dei comandi viene chiamato immediatamente dopo l'esecuzione del costruttore. Il costruttore non viene eseguito nuovamente dopo la prima volta il servizio è stato caricato, pertanto è necessario separare l'elaborazione eseguita dal costruttore da quella eseguita dal <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Tutte le risorse che possono essere rilasciate dal <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deve essere creata <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creazione di risorse nel costruttore ne impedisce la creazione corretta se il servizio viene avviato nuovamente dopo <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ha rilasciato le risorse.  
  
 Gestione controllo servizi (SCM) fornisce un modo per interagire con il servizio. È possibile utilizzare Gestione controllo servizi da passare a Start, Stop, Pause, continua o i comandi personalizzati al servizio. Gestione controllo servizi utilizza i valori delle <xref:System.ServiceProcess.ServiceBase.CanStop%2A> e <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> per determinare se il servizio accetta arrestare, sospendere o riprendere i comandi. Arresto, sospensione e continuazione sono abilitate nella finestra di scelta rapida solo se di SCM la proprietà corrispondente <xref:System.ServiceProcess.ServiceBase.CanStop%2A> oppure <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `true` nella classe del servizio. Se abilitata, il comando viene passato al servizio, e <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene chiamato. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `false`, il metodo di gestione dei comandi corrispondente (ad esempio <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) non verranno elaborati, anche se è stato implementato il metodo.  
  
 È possibile usare il <xref:System.ServiceProcess.ServiceController> classe a livello di programmazione quali Gestione controllo servizi esegue tramite un'interfaccia utente. È possibile automatizzare le attività disponibili nella console. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `true` ma non è stato implementato un metodo di gestione dei comandi corrispondente (ad esempio <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) il sistema genera un'eccezione e ignora il comando.  
  
 Non è necessario implementare <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, o qualsiasi altro metodo nel <xref:System.ServiceProcess.ServiceBase>. Tuttavia, il comportamento del servizio è descritto in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, pertanto come minimo, è necessario eseguire l'override di questo membro. Il `main()` funzione del file eseguibile registra il servizio nel file eseguibile con Gestione controllo servizi chiamando il <xref:System.ServiceProcess.ServiceBase.Run%2A> (metodo). Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> proprietà del <xref:System.ServiceProcess.ServiceBase> l'oggetto passato al <xref:System.ServiceProcess.ServiceBase.Run%2A> metodo deve corrispondere il <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> proprietà del programma di installazione del servizio per il servizio.  
  
 È possibile usare `InstallUtil.exe` per installare i servizi nel sistema.  
  
> [!NOTE]
>  È possibile specificare un log diverso dal registro eventi dell'applicazione per ricevere la notifica delle chiamate al servizio, ma nessuna il <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> né il <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà possa scrivere in un log personalizzato. Impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` se non si desidera utilizzare la registrazione automatica.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non creare un'istanza di <xref:System.ServiceProcess.ServiceBase> classe. Derivarla dalla <xref:System.ServiceProcess.ServiceBase> e creare un'istanza della classe derivata. Il valore minimo è necessario implementare nel costruttore per una classe ereditata da <xref:System.ServiceProcess.ServiceBase> consiste nell'impostare il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> nel componente. Nessuna altra elaborazione è necessaria in modo specifico nel costruttore. È necessario gestire la maggior parte delle inizializzazione in <xref:System.ServiceProcess.ServiceBase.OnStart%2A> invece che nel costruttore. In caso contrario, non c'è garanzia che verranno reinizializzati gli oggetti quando si riavvia un servizio dopo che è stato interrotto.  
  
 Se si esegue l'override del costruttore nella classe derivata, chiamare il costruttore di classe di base nel codice.  
  
 Il <xref:System.ServiceProcess.ServiceBase> costruttore imposta <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true`. Se non si desidera registrare automaticamente le chiamate al servizio da Gestione controllo servizi (SCM), impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false`.  
  
 Se il file eseguibile contiene un singolo servizio, il sistema chiama il costruttore del servizio quando viene selezionato da Gestione controllo servizi, Start e viene eseguito il distruttore se viene chiamato.  
  
 Se il file eseguibile contiene più servizi, chiamare Start su un servizio fa in modo che i costruttori da chiamare per tutti i servizi nel file eseguibile, ma solo il servizio specificato è stato avviato. I distruttori per i servizi vengono eseguiti insieme quando tutti i servizi siano stati arrestati, non singolarmente quando ogni servizio viene arrestato.  
  
> [!NOTE]
>  Se si sostituisce il costruttore di classe di base, è necessario chiamarlo in modo esplicito nel costruttore della classe derivata.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se registrare i comandi di avvio, interruzione, sospensione e continuazione nel log eventi.</summary>
        <value>
          <see langword="true" /> per  registrare le informazioni nel log eventi; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true` indica al servizio di usare il registro eventi dell'applicazione per gli errori di comando di report, nonché informazioni sulle modifiche di stato per l'avvio, arresto, pausa e continuare gli eventi nel servizio. Il nome del servizio viene utilizzato come il log <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Per registrare le informazioni in un log eventi personalizzato anziché nel registro dell'applicazione, impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> al `false` e la scrittura di istruzioni all'interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per registrare nel log appropriato.  
  
> [!NOTE]
>  Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, che fornisce la stringa di origine per il log eventi, deve essere impostato prima che il servizio tenta di scrivere nel registro eventi. Tentativo di accedere al registro eventi prima che venga impostato il nome dell'origine genera un'eccezione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio può gestire le notifiche relative alle variazioni di stato dell'alimentazione del computer.</summary>
        <value>
          <see langword="true" /> se il servizio gestisce le variazioni di stato dell'alimentazione del computer indicate nella classe <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando cambia lo stato di alimentazione del computer, Gestione controllo servizi (SCM) verifica se il servizio accetta power evento comandi utilizzando il valore di <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> viene `true`, il comando viene passato al servizio e il <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> metodo viene chiamato se definito. Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> non è implementato nella classe derivata, Gestione controllo servizi gestisce l'evento di risparmio energia tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa proprietà è stata modificata dopo l'avvio del servizio.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore che indica se il servizio è in grado di gestire gli eventi di modifica di sessione ricevuti dalla sessione Terminal Server.</summary>
        <value>
          <see langword="true" /> se il servizio è in grado di gestire gli eventi di modifica di sessione Terminal Server; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Questa proprietà è stata modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio può essere sospeso e riattivato.</summary>
        <value>
          <see langword="true" /> se il servizio può essere sospeso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il valore della <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> proprietà nel costruttore per il servizio.  
  
 Quando un servizio viene sospesa, interrompe di quanto accade. Se si continua del servizio (tramite Gestione controllo servizi o a livello di codice), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene eseguito.  
  
 L'invio di una richiesta di sospensione per il servizio, è possibile risparmiare risorse di sistema. Sospendi potrebbero non rilasciare tutte le risorse di sistema, l'interruzione. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> sono spesso implementate in modo per eseguire meno operazioni di elaborazione rispetto <xref:System.ServiceProcess.ServiceBase.OnStop%2A> e <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `true`, eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per specificare l'elaborazione che deve verificarsi quando Gestione controllo servizi (SCM) passa una richiesta di pausa o continuazione per il servizio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve essere implementato per annullare l'elaborazione in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `false`, Gestione controllo servizi non supererà pausa o continuazione richieste al servizio, pertanto, il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se vengono implementate. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se è necessario che il servizio riceva una notifica quando il sistema è in fase di chiusura.</summary>
        <value>
          <see langword="true" /> se è necessario che il servizio riceva una notifica quando il sistema è in fase di arresto; in caso contrario, <see langword="false" />.  Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> è `true`, il servizio riceve una notifica quando il sistema è in fase di chiusura. All'arresto del sistema, il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodo viene chiamato se è stato implementato nella classe derivata.  
  
> [!NOTE]
>  Solo il sistema deve generare il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodo da eseguire; il servizio è possibile chiamare questo metodo, ma questo non è consigliato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio, una volta avviato, può essere interrotto.</summary>
        <value>
          <see langword="true" /> se il servizio può essere arrestato e se può essere chiamato il metodo <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene chiamato su un servizio, Gestione controllo servizi (SCM) consente di verificare se il servizio accetta tali comandi utilizzando il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Per la maggior parte dei servizi, il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `true`, ma alcuni servizi di sistema operativo, ad esempio, non consentono all'utente di arrestare tali.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> viene `true`, il comando di interruzione viene passato al servizio e il <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodo viene chiamato se è definito. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> non è implementato nella classe derivata, il gestore SCM gestisce il comando di interruzione tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Elimina le risorse, diverse dalla memoria, usate dall'oggetto <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.ServiceProcess.ServiceBase.Dispose%2A> nella classe derivata (e tramite quest'ultimo, nel <xref:System.ServiceProcess.ServiceBase> classe) quando si è terminato di utilizzare la classe derivata. Il <xref:System.ServiceProcess.ServiceBase.Dispose%2A> metodo lascia la classe derivata in uno stato inutilizzabile. Dopo avere chiamato <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, è necessario rilasciare tutti i riferimenti alla classe derivata e <xref:System.ServiceProcess.ServiceBase> in modo che la memoria occupata può essere recuperata da garbage collection.  
  
> [!NOTE]
>  Chiamare sempre <xref:System.ServiceProcess.ServiceBase.Dispose%2A> prima di rilasciare l'ultimo riferimento alla classe derivata da <xref:System.ServiceProcess.ServiceBase>. In caso contrario, le risorse <xref:System.ServiceProcess.ServiceBase> e la classe derivata Usa will non verranno liberate finché l'operazione di garbage collection chiama i distruttori degli oggetti.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> viene spesso implementato per elaborare il codice nel <xref:System.ServiceProcess.ServiceBase.OnPause%2A>combinato con una chiamata a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Se si sceglie di eseguire questa operazione nella classe derivata, è facoltativa per implementare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> allocare qualsiasi <xref:System.ServiceProcess.ServiceBase.Dispose%2A> rilasciato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un log eventi da utilizzare per scrivere nel log eventi delle applicazioni le notifiche delle chiamate ai comandi di servizio, come Start e Stop.</summary>
        <value>Istanza di <see cref="T:System.Diagnostics.EventLog" /> la cui origine è registrata nel registro Applicazioni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore inizializza la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà a un'istanza con il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> set di proprietà. L'origine è il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servizio, e il log è log applicazione del computer. Questi valori vengono impostati automaticamente e non possono essere modificati per la registrazione automatica dei comandi di servizio.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è `true`, avvio, arresto, pausa, continua e i comandi personalizzati vengono registrati automaticamente nel registro eventi dell'applicazione. È possibile usare il <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà in cui scrivere i messaggi aggiuntivi che anche il log. Il componente chiama <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> usando questo <xref:System.ServiceProcess.ServiceBase.EventLog%2A> membro.  
  
 Per registrare le informazioni in un log eventi personalizzato anziché nel registro dell'applicazione, impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> al `false` e la scrittura di istruzioni all'interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per registrare nel log appropriato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il codice di uscita del servizio.</summary>
        <value>Codice di uscita del servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> proprietà su un valore diverso da zero prima di arrestare il servizio per indicare un errore in Gestione controllo servizi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indica la dimensione massima per il nome di un servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName e DisplayName prevedono le restrizioni della dimensione che devono essere osservate quando si impostano le proprietà nella classe del servizio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione di <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> avviene quando Gestione controllo servizi invia al servizio un comando Continue. Specifica le azioni da intraprendere quando un servizio riprende il normale funzionamento dopo essere stato sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementare <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per eseguire il mirroring di risposta dell'applicazione a <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Se si continua del servizio (tramite la console servizi o a livello di codice), il <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> esecuzioni di elaborazione e il servizio diventa nuovamente attiva.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> è previsto da sottoporre a override quando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è di proprietà `true`.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `false`, Gestione controllo servizi non supererà pausa o continuazione richieste al servizio, pertanto, il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se vengono implementate. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Messaggio di comando inviato al servizio.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione di <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> avviene quando Gestione controllo servizi passa al servizio un comando personalizzato. Specifica le azioni da intraprendere quando ricorre un comando con il parametro specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> è possibile specificare funzionalità aggiuntive rispetto all'avvio, arresto, sospensione e continuazione dei servizi.  
  
 Gestione controllo servizi non esamina il comando personalizzato per verificare se il servizio supporta il `command` parametro passato. Il comando personalizzato passa direttamente al servizio. Se il servizio non riconosce il `command` parametro, non esegue alcuna operazione.  
  
 Comandi personalizzati vengono generati da un <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> istruzione in un <xref:System.ServiceProcess.ServiceController> componente. Usare un'istruzione switch o if... Then per gestire i comandi personalizzati definiti nel servizio.  
  
 Gli unici valori validi per un comando personalizzato che è possibile definire all'interno dell'applicazione o usare in <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> sono quelle da 128 a 255. Numeri interi inferiori a 128 corrispondono ai valori riservati di sistema.  
  
 Se il <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è di proprietà `true`, comandi personalizzati, analogamente a tutti gli altri comandi, scriveranno voci nel registro eventi per segnalare se l'esecuzione del metodo ha avuto esito positivo o negativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando Gestione controllo servizi invia un comando Pause al servizio. Specifica le azioni da intraprendere quando un servizio viene sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.ServiceProcess.ServiceBase.OnPause%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando di sospensione. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> è previsto da sottoporre a override quando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è di proprietà `true`.  
  
 Se si continua un servizio sospeso (tramite la console servizi o a livello di codice), il <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene eseguita l'elaborazione e il servizio diventa nuovamente attivo.  
  
 Il comando pausa consente solo l'applicazione rispondere a un evento specifico. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> non esegue alcuna operazione per il servizio che non definite in modo esplicito.  
  
 L'invio di una richiesta di sospensione per il servizio può risparmiare risorse di sistema perché pausa non necessario rilasciare tutte le risorse di sistema. Ad esempio, se i thread sono stati aperti dal processo, la sospensione di un servizio piuttosto che averla arrestata può consentire il thread deve rimanere aperta, evitando la necessità di riallocarli quando il servizio continua. Se si definisce pausa per rilasciare tutte le risorse di sistema, si comporta come un comando Stop.  
  
 Impostare <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> al `true`ed eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per specificare l'elaborazione che deve verificarsi quando Gestione controllo servizi passa una richiesta di pausa o continuazione per il servizio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve essere implementato per annullare l'elaborazione in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> viene `false`, Gestione controllo servizi non supererà pausa o continuazione richieste al servizio, pertanto, il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se implementati. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Oggetto <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> che indica una notifica dal sistema riguardante il proprio stato di alimentazione.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene al variare dello stato di alimentazione dei computer laptop che entrano in modalità sospesa, una condizione che non corrisponde alla chiusura del sistema.</summary>
        <returns>Quando viene eseguita l'implementazione in una classe derivata, indica la necessità da parte dell'applicazione di determinare il valore da restituire. Se ad esempio viene passato uno stato trasmesso <see langword="QuerySuspend" />, è possibile provocare il rifiuto della query da parte dell'applicazione mediante la restituzione di <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uso <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> per specificare l'elaborazione che si verifica quando l'evento di sistema indicata nel <xref:System.ServiceProcess.PowerBroadcastStatus> enumerazione si verifica, ad esempio, quando il computer viene posizionato in modalità sospensione o indica potenza di batteria in esaurimento.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> è previsto da sottoporre a override quando la <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> è di proprietà `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Struttura che identifica il tipo di modifica.</param>
        <summary>Viene eseguito alla ricezione di un evento di modifica da una sessione Terminal Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare il <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> proprietà `true` per abilitare l'esecuzione di questo metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene alla chiusura del sistema. Specifica quali operazioni devono essere eseguite subito prima della chiusura del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> per specificare l'elaborazione che si verifica quando il sistema si arresta.  
  
 Questo evento si verifica solo quando il sistema operativo viene arrestato, non quando il computer è spento.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> è previsto da sottoporre a override quando la <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> è di proprietà `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dati passati dal comando di avvio.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando Gestione controllo servizi invia un comando Pause al servizio o quando viene avviato il sistema (nel caso di un servizio ad avvio automatico). Specifica le azioni da intraprendere all'avvio del servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando di avvio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> è il metodo in cui viene specificato il comportamento del servizio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> può accettare argomenti come un modo per passare i dati, ma questo utilizzo è raro.  
  
> [!CAUTION]
>  Non usare il costruttore per eseguire l'elaborazione che deve essere nel <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Usare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> per gestire tutte le operazioni di inizializzazione del servizio. Il costruttore viene chiamato quando l'eseguibile dell'applicazione viene eseguita, non quando viene eseguito il servizio. L'eseguibile verrà eseguito prima <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Quando si continua, ad esempio, è possibile che il costruttore non viene chiamato nuovamente perché Gestione controllo servizi già contiene l'oggetto in memoria. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> rilascia le risorse allocate nel costruttore anziché in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, le risorse necessarie non essere ricreate la seconda volta viene chiamato il servizio.  
  
 Servizi possono essere impostati per avviarsi automaticamente al riavvio del computer impostando il <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> nel programma di installazione del servizio <xref:System.ServiceProcess.ServiceStartMode.Automatic>. In questo caso, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> viene chiamato all'avvio del sistema.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> è previsto da sottoporre a override nella classe derivata. Per il servizio sia utile <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devono entrambi essere implementati nella classe del servizio.  
  
 Elaborare gli argomenti di inizializzazione per il servizio nel <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo, non nel metodo Main. Gli argomenti in di `args` matrice di parametri può essere impostati manualmente nella finestra proprietà per il servizio nella console servizi. Gli argomenti immessi nella console non vengono salvati; vengono passati al servizio una sola volta quando viene avviato il servizio dal Pannello di controllo. Gli argomenti che devono essere presenti quando il servizio viene avviato automaticamente possono essere inseriti nel valore di stringa della ImagePath per la chiave del Registro di sistema del servizio (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \< nome servizio >*). È possibile ottenere gli argomenti dal Registro di sistema usando il <xref:System.Environment.GetCommandLineArgs%2A> metodo, ad esempio: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando il gestore SCM invia un comando Stop al servizio. Specifica le azioni da intraprendere al termine dell'esecuzione del servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando Stop.  
  
 Quando Gestione controllo servizi riceve un comando Stop, viene usato il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A> per verificare se il servizio accetta i comandi di arresto. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> viene `true`, il comando di interruzione viene passato al servizio e il <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodo viene chiamato se è definito. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> non è implementata nel servizio di Gestione controllo servizi gestisce il comando Stop.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `false`, il comando di arresto viene ignorato. Non viene passato al servizio. Il comando Stop restituisce e genera un'eccezione.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> è previsto da sottoporre a override nella classe derivata. Per il servizio sia utile <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devono entrambi essere implementati nella classe del servizio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Tempo richiesto espresso in millisecondi.</param>
        <summary>Consente di richiedere tempo aggiuntivo per un'operazione in attesa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> metodo è destinato a essere chiamato da sottoposto a override <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodi per richiedere ulteriore tempo per un'operazione in sospeso, per impedire il contrassegno di Gestione controllo servizi (SCM) di servizio non risponde.  Se l'operazione in sospeso non è una continuazione, pausa, avviare o arrestare, un <xref:System.InvalidOperationException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio non è nello stato di attesa.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fornisce il punto di ingresso principale per un eseguibile di servizio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Classe <see cref="T:System.ServiceProcess.ServiceBase" /> che indica un servizio da avviare.</param>
        <summary>Registra il file eseguibile relativo a servizio con il gestore SCM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload nel `main()` funzionamento del servizio eseguibile per registrare il servizio con Gestione controllo servizi. Dopo aver chiamato <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, Gestione controllo servizi invia un comando di avvio, che comporta una chiamata al <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo nel servizio. Il servizio non viene avviato finché non viene eseguito il comando di avvio.  
  
 Il <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> viene chiamato in modo analogo a come <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> per applicazioni Windows Form.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> viene `true`, viene scritta una voce nel registro eventi, se il servizio specificato per il `service` parametro non viene avviato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Matrice di istanze ServiceBase, che indica i servizi da avviare.</param>
        <summary>Registra il file eseguibile relativo a più servizi con il gestore SCM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload nel `main()` funzionamento del servizio eseguibile per registrare i servizi con Gestione controllo servizi. Dopo aver chiamato <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, Gestione controllo servizi genera i comandi di avvio, che comportare chiamate al <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodi nei servizi. I servizi non siano stati avviati fino a quando non vengono eseguiti i comandi di avvio.  
  
 Il <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> viene chiamato in modo analogo a come il <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> metodo per le applicazioni Windows Form.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è `true`, viene scritta una voce nel registro eventi se non si avvia qualsiasi servizio nella matrice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è stato fornito alcun servizio da avviare. La matrice potrebbe essere <see langword="null" /> oppure vuota.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle del controllo di servizio.</summary>
        <value>Struttura <see cref="T:System.IntPtr" /> contenente l'handle del controllo di servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'handle del controllo del servizio viene utilizzato per comunicare con Gestione controllo servizi (SCM).  L'handle può essere usato per aggiornare le informazioni sullo stato di Gestione controllo servizi per il servizio chiamante usando non gestito `SetServiceStatus` (funzione).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Numero degli argomenti della matrice degli argomenti.</param>
        <param name="argPointer">Struttura <see cref="T:System.IntPtr" /> che punta a una matrice di argomenti.</param>
        <summary>Consente di registrare il gestore comando e di avviare il servizio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome breve utilizzato per identificare il servizio nel sistema.</summary>
        <value>Il nome del servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifica il servizio di Gestione controllo servizi. Il valore di questa proprietà deve essere identico al nome registrato per il servizio nel <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> proprietà della classe installer corrispondente. Nel codice, il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servizio è in genere impostata `main()` funzione del file eseguibile.  
  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> viene usato anche per specificare il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> associato il <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà. Ciò <xref:System.ServiceProcess.ServiceBase.EventLog%2A> è un'istanza che scrive informazioni sui comandi di servizio nel registro applicazioni.  
  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, che fornisce la stringa di origine per il log eventi, deve essere impostato prima che il servizio scrive nel registro eventi. Tentativo di accedere al registro eventi prima che venga impostato il nome dell'origine genera un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <exception cref="T:System.ArgumentException">Il nome specificato è una stringa di lunghezza zero o più lunga di <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> o il nome specificato contiene barre o barre rovesciate.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta il servizio in esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.Stop%2A> metodo imposta lo stato di servizio per indicare un arresto è in sospeso e le chiamate di <xref:System.ServiceProcess.ServiceBase.OnStop%2A> (metodo).  Dopo l'applicazione viene arrestata, lo stato del servizio viene impostato su arrestato. Se l'applicazione è un servizio ospitato, viene scaricato il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>