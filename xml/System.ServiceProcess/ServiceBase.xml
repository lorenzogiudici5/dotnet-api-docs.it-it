<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d659a5675f8e308404ab56d663607e4230bf1530" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530905" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una classe base per un servizio che esisterà nel contesto di un'applicazione di servizio. È necessario derivare <see cref="T:System.ServiceProcess.ServiceBase" /> durante la creazione di una nuova classe di servizio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivare da <xref:System.ServiceProcess.ServiceBase> quando si definisce la classe di servizio in un'applicazione di servizio. Qualsiasi servizio utile esegue l'override di <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodi. Per aggiungere ulteriori funzionalità, è possibile eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> con un funzionamento specifico in risposta alle modifiche dello stato di servizio.  
  
 Un servizio è un eseguibile a esecuzione prolungata che non supporta un'interfaccia utente, e che potrebbero non funzionare con l'account utente connesso. Il servizio è possibile eseguire senza tutti gli utenti connessi al computer.  
  
 Per impostazione predefinita, i servizi eseguiti con l'account di sistema, non è uguale all'account di amministratore. È possibile modificare i diritti dell'account di sistema. In alternativa, è possibile utilizzare un <xref:System.ServiceProcess.ServiceProcessInstaller> per specificare un account utente con cui verrà eseguito il servizio.  
  
 Un file eseguibile può contenere più di un servizio, ma deve contenere un apposito <xref:System.ServiceProcess.ServiceInstaller> per ogni servizio. Il <xref:System.ServiceProcess.ServiceInstaller> istanza registra il servizio con il sistema. Il programma di installazione associa anche ogni servizio a un registro eventi che è possibile utilizzare per registrare i comandi del servizio. Il `main()` funzione nell'eseguibile definisce quali servizi devono essere eseguiti. La directory di lavoro corrente del servizio è la directory di sistema, non la directory in cui si trova il file eseguibile.  
  
 Quando si avvia un servizio, il sistema individua l'eseguibile ed esegue il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo per tale servizio, contenuto all'interno dell'eseguibile. Tuttavia, in esecuzione il servizio non è lo stesso come il file eseguibile. Il file eseguibile carica solo il servizio. Il servizio avviene (ad esempio, avvio e arresto) tramite Gestione controllo servizi.  
  
 L'eseguibile chiama il <xref:System.ServiceProcess.ServiceBase> derivato costruttore la prima chiamata della classe avvia il servizio. Il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo di gestione del comando viene chiamato immediatamente dopo l'esecuzione del costruttore. Il costruttore non viene eseguito nuovamente dopo la prima volta che il servizio è stato caricato, pertanto è necessario separare l'elaborazione eseguita dal costruttore da quella eseguita dal <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Tutte le risorse che possono essere rilasciate dal <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deve essere creato <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. La creazione di risorse nel costruttore ne impedisce la creazione corretta se il servizio viene avviato dopo aver <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ha rilasciato le risorse.  
  
 Gestione controllo servizi (SCM) fornisce un modo per interagire con il servizio. È possibile utilizzare Gestione controllo servizi per passare a Start, Stop, Pause, continua o comandi personalizzati nel servizio. Gestione controllo servizi utilizza i valori di <xref:System.ServiceProcess.ServiceBase.CanStop%2A> e <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> per determinare se il servizio accetta arrestare, sospendere o riprendere i comandi. Stop, Pause e Continue abilitati scelta rapida solo se di SCM la proprietà corrispondente <xref:System.ServiceProcess.ServiceBase.CanStop%2A> o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `true` nella classe di servizio. Se abilitata, il comando viene passato al servizio, e <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene chiamato. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`, il corrispondente metodo di gestione dei comandi (ad esempio <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) non verranno elaborati, anche se il metodo è implementato.  
  
 È possibile utilizzare la <xref:System.ServiceProcess.ServiceController> classe per eseguire a livello di programmazione quali SCM esegue l'utilizzo di un'interfaccia utente. È possibile automatizzare le attività disponibili nella console. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `true` ma non è stato implementato un metodo di gestione dei comandi corrispondente (ad esempio <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) il sistema genera un'eccezione e ignora il comando.  
  
 Non è necessario implementare <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, o qualsiasi altro metodo nel <xref:System.ServiceProcess.ServiceBase>. Tuttavia, il comportamento del servizio è descritto in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, quindi come minimo, è necessario eseguire l'override di questo membro. Il `main()` funzione del file eseguibile registra il servizio nel file eseguibile con Gestione controllo servizi chiamando il <xref:System.ServiceProcess.ServiceBase.Run%2A> metodo. Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> proprietà del <xref:System.ServiceProcess.ServiceBase> oggetto passato al <xref:System.ServiceProcess.ServiceBase.Run%2A> (metodo) deve corrispondere il <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> proprietà del programma di installazione del servizio per il servizio.  
  
 È possibile utilizzare `InstallUtil.exe` per installare i servizi nel sistema.  
  
> [!NOTE]
>  È possibile specificare un log diverso dal registro eventi dell'applicazione per ricevere una notifica di chiamate al servizio, ma non il <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> né la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà è possibile scrivere in un log personalizzato. Impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> per `false` se non si desidera utilizzare la registrazione automatica.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non creare un'istanza di <xref:System.ServiceProcess.ServiceBase> classe. Al contrario, derivano da <xref:System.ServiceProcess.ServiceBase> e creare un'istanza della classe derivata. Il valore minimo è necessario implementare nel costruttore per una classe ereditata da <xref:System.ServiceProcess.ServiceBase> consiste nell'impostare il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> nel componente. Altre elaborazioni non sono specificamente richiesto nel costruttore. È necessario gestire la maggior parte di inizializzazione in <xref:System.ServiceProcess.ServiceBase.OnStart%2A> piuttosto che nel costruttore. In caso contrario, non è garantito che quando si riavvia un servizio dopo che è stato interrotto gli oggetti verranno reinizializzati.  
  
 Se si esegue l'override del costruttore nella classe derivata, chiamare il costruttore di classe di base nel codice.  
  
 Il <xref:System.ServiceProcess.ServiceBase> costruttore imposta <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true`. Se non si desidera registrare automaticamente le chiamate al servizio da Gestione controllo servizi (SCM), impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false`.  
  
 Se il file eseguibile contiene un singolo servizio, il sistema chiama il costruttore del servizio quando viene selezionato da Gestione controllo servizi, avvio e viene eseguito il distruttore se viene chiamato.  
  
 Se il file eseguibile contiene più servizi, chiamare Start su un servizio fa sì che il costruttore da chiamare per tutti i servizi nell'eseguibile, ma solo il servizio specificato è stato avviato. Quando tutti i servizi siano stati arrestati, non singolarmente quando ogni servizio viene arrestato, i distruttori per i servizi vengono eseguiti insieme.  
  
> [!NOTE]
>  Se si sostituisce il costruttore della classe base, è necessario chiamarlo in modo esplicito nel costruttore della classe derivata.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se registrare i comandi di avvio, interruzione, sospensione e continuazione nel log eventi.</summary>
        <value>
          <see langword="true" /> per  registrare le informazioni nel log eventi; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true` indica al servizio per utilizzare il registro eventi applicazione per i report non riuscite di comando, nonché informazioni sulle modifiche di stato per Start, Stop, Pause e Continue eventi sul servizio. Il nome del servizio viene utilizzato come il registro <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Per registrare le informazioni in un log eventi personalizzato anziché nel registro applicazioni, impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` e scrivere le istruzioni all'interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per registrare nel log appropriato.  
  
> [!NOTE]
>  Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, che fornisce la stringa di origine per il log eventi, deve essere impostata prima che il servizio tenta di scrivere nel registro eventi. Tentativo di accedere al registro eventi prima di imposta il nome dell'origine genera un'eccezione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio può gestire le notifiche relative alle variazioni di stato dell'alimentazione del computer.</summary>
        <value>
          <see langword="true" /> se il servizio gestisce le variazioni di stato dell'alimentazione del computer indicate nella classe <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando cambia lo stato di alimentazione del computer, Gestione controllo servizi (SCM) consente di verificare se il servizio accetta comandi evento power utilizzando il valore di <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> è `true`, il comando viene passato al servizio e <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> metodo viene chiamato se definito. Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> non è implementata nella classe derivata, SCM gestisce l'evento di risparmio energia tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa proprietà è stata modificata dopo l'avvio del servizio.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore che indica se il servizio è in grado di gestire gli eventi di modifica di sessione ricevuti dalla sessione Terminal Server.</summary>
        <value>
          <see langword="true" /> se il servizio è in grado di gestire gli eventi di modifica di sessione Terminal Server; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Questa proprietà è stata modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio può essere sospeso e riattivato.</summary>
        <value>
          <see langword="true" /> se il servizio può essere sospeso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il valore della <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> proprietà nel costruttore per il servizio.  
  
 Quando un servizio viene sospesa, arresta quanto accade. Quando si continua del servizio (tramite Gestione controllo servizi o a livello di codice), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene eseguito.  
  
 L'invio di una richiesta di sospensione per il servizio, è possibile risparmiare risorse di sistema. Sospensione potrebbe non rilasciare tutte le risorse di sistema, l'interruzione. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> sono spesso implementati per eseguire operazioni di elaborazione minore rispetto a <xref:System.ServiceProcess.ServiceBase.OnStop%2A> e <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `true`, eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per specificare l'elaborazione che deve verificarsi quando Gestione controllo servizi (SCM) passa una richiesta di sospensione o continuazione al servizio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve essere implementato per annullare l'elaborazione in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`, SCM non passerà sospensione o continua richieste al servizio, pertanto il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se sono implementate. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se è necessario che il servizio riceva una notifica quando il sistema è in fase di chiusura.</summary>
        <value>
          <see langword="true" /> se è necessario che il servizio riceva una notifica quando il sistema è in fase di arresto; in caso contrario, <see langword="false" />.  Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> è `true`, il servizio riceve una notifica quando il sistema è in corso l'arresto. Al momento della chiusura, il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodo viene chiamato se è stato implementato nella classe derivata.  
  
> [!NOTE]
>  Solo il sistema deve provocare il <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodo da eseguire; il servizio può essere chiamato, ma questa operazione è sconsigliata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il servizio, una volta avviato, può essere interrotto.</summary>
        <value>
          <see langword="true" /> se il servizio può essere arrestato e se può essere chiamato il metodo <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene chiamato su un servizio, Gestione controllo servizi (SCM) consente di verificare se il servizio accetta tali comandi utilizzando il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Per la maggior parte dei servizi, il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `true`, ma alcuni servizi del sistema operativo, ad esempio, consente all'utente di arrestarli.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `true`, il comando di interruzione viene passato al servizio e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodo viene chiamato se è definito. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> non è implementata nella classe derivata, il gestore SCM gestisce il comando di interruzione tramite la classe base vuota <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Elimina le risorse, diverse dalla memoria, usate dall'oggetto <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare <xref:System.ServiceProcess.ServiceBase.Dispose%2A> nella classe derivata (e attraverso di esso, nel <xref:System.ServiceProcess.ServiceBase> classe) dopo aver terminato di utilizzare la classe derivata. Il <xref:System.ServiceProcess.ServiceBase.Dispose%2A> metodo lascia la classe derivata in uno stato inutilizzabile. Dopo la chiamata <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, è necessario rilasciare tutti i riferimenti alla classe derivata e <xref:System.ServiceProcess.ServiceBase> in modo che la memoria occupata può essere recuperata tramite garbage collection.  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.ServiceProcess.ServiceBase.Dispose%2A> prima di rilasciare l'ultimo riferimento a una classe derivata da <xref:System.ServiceProcess.ServiceBase>. In caso contrario, le risorse <xref:System.ServiceProcess.ServiceBase> e verrà utilizza la classe derivata non verranno liberate finché l'operazione di garbage collection chiama i distruttori degli oggetti.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> viene spesso implementato per elaborare il codice in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinata con una chiamata a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Se si sceglie di eseguire questa operazione nella classe derivata, è facoltativa per implementare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> allocare qualsiasi <xref:System.ServiceProcess.ServiceBase.Dispose%2A> rilasciato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un log eventi da utilizzare per scrivere nel log eventi delle applicazioni le notifiche delle chiamate ai comandi di servizio, come Start e Stop.</summary>
        <value>Istanza di <see cref="T:System.Diagnostics.EventLog" /> la cui origine è registrata nel registro Applicazioni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore inizializza la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà a un'istanza con il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> set di proprietà. L'origine è il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servizio, e il log è registro applicazioni del computer. Questi valori vengono impostati automaticamente e non possono essere modificati per la registrazione automatica dei comandi di servizio.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è `true`, Start, Stop, Pause, continua e comandi personalizzati vengono registrati automaticamente nel registro eventi dell'applicazione. È possibile utilizzare il <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà per scrivere messaggi aggiuntivi in tale registro anche. Il componente chiama <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> usando questa <xref:System.ServiceProcess.ServiceBase.EventLog%2A> membro.  
  
 Per registrare le informazioni in un log eventi personalizzato anziché nel registro applicazioni, impostare <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` e scrivere le istruzioni all'interno dei metodi di gestione dei comandi <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per registrare nel log appropriato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il codice di uscita del servizio.</summary>
        <value>Codice di uscita del servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> su un valore diverso da zero prima di arrestare il servizio per indicare un errore in Gestione controllo servizi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indica la dimensione massima per il nome di un servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName e DisplayName hanno limitazioni di dimensione che devono essere osservate quando si impostano le proprietà della classe del servizio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione di <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> avviene quando Gestione controllo servizi invia al servizio un comando Continue. Specifica le azioni da intraprendere quando un servizio riprende il normale funzionamento dopo essere stato sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementare <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per riflettere la risposta dell'applicazione a <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Quando si continua del servizio (tramite la console servizi o a livello di codice), il <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> l'elaborazione viene eseguito e il servizio diventa nuovamente attiva.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> proprietà `true`.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`, SCM non passerà sospensione o continua richieste al servizio, pertanto il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se sono implementate. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Messaggio di comando inviato al servizio.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione di <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> avviene quando Gestione controllo servizi passa al servizio un comando personalizzato. Specifica le azioni da intraprendere quando ricorre un comando con il parametro specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> Consente di specificare funzionalità aggiuntive oltre all'avvio, arresto, sospensione e continuazione dei servizi.  
  
 Gestione controllo servizi non esamina il comando personalizzato per verificare se il servizio supporta il `command` parametro passato. Il comando personalizzato passa direttamente al servizio. Se il servizio non riconosce il `command` parametro, non esegue alcuna operazione.  
  
 Comandi personalizzati sono attivati da un <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> istruzione in un <xref:System.ServiceProcess.ServiceController> componente. Usare un'istruzione switch o se... Then per gestire i comandi personalizzati definiti nel servizio.  
  
 Gli unici valori per un comando personalizzato che è possibile definire nell'applicazione in uso o utilizzare in <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> sono quelli compresi tra 128 e 255. Gli integer sotto 128 corrispondono ai valori riservati al sistema.  
  
 Se il <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> proprietà `true`, comandi personalizzati, analogamente a tutti gli altri comandi, scriveranno voci nel registro eventi per segnalare se l'esecuzione del metodo ha avuto esito positivo o negativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando Gestione controllo servizi invia un comando Pause al servizio. Specifica le azioni da intraprendere quando un servizio viene sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.ServiceProcess.ServiceBase.OnPause%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando di sospensione. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> proprietà `true`.  
  
 Quando si continua un servizio sospeso (tramite la console servizi o a livello di codice), il <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> viene eseguita l'elaborazione e il servizio diventa nuovamente attivo.  
  
 Il comando pausa consente solo l'applicazione rispondere a un evento specifico. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> non esegue alcuna operazione per il servizio che non si definisce per l'esecuzione.  
  
 L'invio di una richiesta di sospensione per il servizio, è possibile risparmiare risorse di sistema perché Pause non è necessario rilasciare tutte le risorse di sistema. Ad esempio, se il processo, la sospensione di un servizio, anziché l'arresto possibile consentire i thread rimangano aperti, sono state aperte thread non dovranno quindi riallocarli quando il servizio continua. Se si definiscono Sospendi per rilasciare tutte le risorse di sistema, si comporta come un comando di arresto.  
  
 Impostare <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> a `true`ed eseguire l'override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> per specificare l'elaborazione che deve verificarsi quando il server passa una richiesta di sospensione o continuazione al servizio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve essere implementato per annullare l'elaborazione in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`, SCM non passerà sospensione o continua richieste al servizio, pertanto il <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metodi non verranno chiamati anche se è implementato. In Gestione controllo servizi, il `Pause` e `Continue` controlli sono disabilitati quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> è `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Oggetto <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> che indica una notifica dal sistema riguardante il proprio stato di alimentazione.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene al variare dello stato di alimentazione dei computer laptop che entrano in modalità sospesa, una condizione che non corrisponde alla chiusura del sistema.</summary>
        <returns>Quando viene eseguita l'implementazione in una classe derivata, indica la necessità da parte dell'applicazione di determinare il valore da restituire. Se ad esempio viene passato uno stato trasmesso <see langword="QuerySuspend" />, è possibile provocare il rifiuto della query da parte dell'applicazione mediante la restituzione di <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> per specificare l'elaborazione che si verifica quando l'evento di sistema indicata nel <xref:System.ServiceProcess.PowerBroadcastStatus> enumerazione si verifica, ad esempio, quando il computer si trova in modalità sospensione o indica consumo della batteria.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> proprietà `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Struttura che identifica il tipo di modifica.</param>
        <summary>Viene eseguito alla ricezione di un evento di modifica da una sessione Terminal Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare il <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> proprietà `true` per abilitare l'esecuzione di questo metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene alla chiusura del sistema. Specifica quali operazioni devono essere eseguite subito prima della chiusura del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> per specificare l'elaborazione che si verifica quando il sistema si arresta.  
  
 Questo evento si verifica solo quando il sistema operativo viene arrestato, non quando il computer è spento.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> deve essere sottoposto a override quando il <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> proprietà `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dati passati dal comando di avvio.</param>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando Gestione controllo servizi invia un comando Pause al servizio o quando viene avviato il sistema (nel caso di un servizio ad avvio automatico). Specifica le azioni da intraprendere all'avvio del servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando di avvio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> il metodo in cui specificare il comportamento del servizio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> può accettare argomenti come un modo per passare i dati, ma questo utilizzo è raro.  
  
> [!CAUTION]
>  Non utilizzare il costruttore per eseguire operazioni di elaborazione che deve essere <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Utilizzare <xref:System.ServiceProcess.ServiceBase.OnStart%2A> per gestire tutte le operazioni di inizializzazione del servizio. Il costruttore viene chiamato quando l'eseguibile dell'applicazione viene eseguito, non quando viene eseguito il servizio. L'eseguibile verrà eseguito prima <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Quando si continua, ad esempio, è possibile che il costruttore non viene chiamato nuovamente perché Gestione controllo servizi contengono già l'oggetto in memoria. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> rilascia le risorse allocate nel costruttore anziché in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, le risorse necessarie non creerebbe la seconda volta viene chiamato il servizio.  
  
 Servizi possono essere impostati per avviarsi automaticamente quando il riavvio del computer impostando il <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> nel programma di installazione del servizio di <xref:System.ServiceProcess.ServiceStartMode.Automatic>. In questo caso, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> deve essere chiamato all'avvio del sistema.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> deve essere sottoposto a override nella classe derivata. Per il servizio siano utili, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devono entrambi essere implementati nella classe del servizio.  
  
 Gli argomenti di inizializzazione per il servizio di elaborare il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> (metodo), non nel metodo Main. Gli argomenti di `args` matrice di parametri può essere impostata manualmente nella finestra proprietà per il servizio nella console servizi. Gli argomenti immessi nella console non vengono salvati; vengono passati al servizio una sola volta quando il servizio viene avviato dal Pannello di controllo. Gli argomenti che devono essere presenti quando il servizio viene avviato automaticamente possono essere inseriti nel valore della stringa ImagePath per la chiave del Registro di sistema del servizio (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \< nome servizio >*). È possibile ottenere gli argomenti dal Registro di sistema utilizzando il <xref:System.Environment.GetCommandLineArgs%2A> metodo, ad esempio: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene eseguita l'implementazione in una classe derivata, l'esecuzione avviene quando il gestore SCM invia un comando Stop al servizio. Specifica le azioni da intraprendere al termine dell'esecuzione del servizio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.ServiceProcess.ServiceBase.OnStop%2A> per specificare l'elaborazione che si verifica quando il servizio riceve un comando di arresto.  
  
 Quando il server riceve un comando di interruzione, viene utilizzato il valore di <xref:System.ServiceProcess.ServiceBase.CanStop%2A> per verificare se il servizio accetta comandi Stop. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `true`, il comando di interruzione viene passato al servizio e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodo viene chiamato se è definito. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> non è implementata nel servizio, il server gestisce il comando di arresto.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> è `false`, il comando di interruzione viene ignorato. Non viene passato al servizio. Il comando Stop restituisce e genera un'eccezione.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deve essere sottoposto a override nella classe derivata. Per il servizio siano utili, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devono entrambi essere implementati nella classe del servizio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Tempo richiesto espresso in millisecondi.</param>
        <summary>Consente di richiedere tempo aggiuntivo per un'operazione in attesa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> metodo è destinato a essere chiamato da sottoposto a override <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodi per richiedere ulteriore tempo per un'operazione in sospeso, per impedire l'indicazione di Gestione controllo servizi (SCM) di servizio non risponde.  Se l'operazione in sospeso non è una continuazione, pausa, start o stop, un <xref:System.InvalidOperationException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio non è nello stato di attesa.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fornisce il punto di ingresso principale per un eseguibile di servizio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Classe <see cref="T:System.ServiceProcess.ServiceBase" /> che indica un servizio da avviare.</param>
        <summary>Registra il file eseguibile relativo a servizio con il gestore SCM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload nella `main()` funzione del servizio eseguibile per registrare il servizio con Gestione controllo servizi. Dopo aver chiamato <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, Gestione controllo servizi esegue un comando di avvio, che comporta una chiamata al <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodo nel servizio. Il servizio non viene avviato finché non viene eseguito il comando di avvio.  
  
 Il <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> metodo viene chiamato in modo analogo a come <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> per applicazioni Windows Form.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è `true`, viene scritta una voce nel registro eventi se il servizio specificato per il `service` parametro non viene avviato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Matrice di istanze ServiceBase, che indica i servizi da avviare.</param>
        <summary>Registra il file eseguibile relativo a più servizi con il gestore SCM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload nella `main()` funzione del servizio eseguibile per registrare i servizi con Gestione controllo servizi. Dopo aver chiamato <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, Gestione controllo servizi esegue i comandi di avvio, generare chiamate per il <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodi nei servizi. I servizi non vengono avviati fino a quando non vengono eseguiti i comandi di avvio.  
  
 Il <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> metodo viene chiamato in modo analogo a come il <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> metodo per applicazioni Windows Form.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> è `true`, viene scritta una voce nel registro eventi se non si avvia qualsiasi servizio nella matrice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è stato fornito alcun servizio da avviare. La matrice potrebbe essere <see langword="null" /> oppure vuota.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle del controllo di servizio.</summary>
        <value>Struttura <see cref="T:System.IntPtr" /> contenente l'handle del controllo di servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'handle del controllo del servizio viene utilizzato per comunicare con Gestione controllo servizi (SCM).  L'handle può essere utilizzato per aggiornare le informazioni sullo stato della gestione controllo servizi per il servizio chiamante mediante non gestito `SetServiceStatus` (funzione).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Numero degli argomenti della matrice degli argomenti.</param>
        <param name="argPointer">Struttura <see cref="T:System.IntPtr" /> che punta a una matrice di argomenti.</param>
        <summary>Consente di registrare il gestore comando e di avviare il servizio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome breve utilizzato per identificare il servizio nel sistema.</summary>
        <value>Il nome del servizio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifica il servizio di Gestione controllo servizi. Il valore di questa proprietà deve essere identico al nome registrato per il servizio di <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> proprietà della classe installer corrispondente. Nel codice, il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servizio è in genere impostata `main()` funzione del file eseguibile.  
  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> viene inoltre utilizzato per specificare il <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> associato il <xref:System.ServiceProcess.ServiceBase.EventLog%2A> proprietà. Questo <xref:System.ServiceProcess.ServiceBase.EventLog%2A> è un'istanza che scrive le informazioni di comando di servizio nel registro applicazioni.  
  
 Il <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, che fornisce la stringa di origine per il log eventi, deve essere impostata prima che il servizio scrive nel registro eventi. Tentativo di accedere al registro eventi prima di imposta il nome dell'origine genererà un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il servizio è già stato avviato. La proprietà <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> non può essere modificata dopo l'avvio del servizio.</exception>
        <exception cref="T:System.ArgumentException">Il nome specificato è una stringa di lunghezza zero o più lunga di <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> o il nome specificato contiene barre o barre rovesciate.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta il servizio in esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ServiceProcess.ServiceBase.Stop%2A> metodo imposta la stato del servizio per indicare un arresto in sospeso e chiama il <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metodo.  Dopo l'applicazione è stato arrestato, lo stato del servizio è impostato su arrestato. Se l'applicazione è un servizio ospitato, viene scaricato il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>