<Type Name="HybridDictionary" FullName="System.Collections.Specialized.HybridDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0867f8e6f5826ef1ef2ff1dac1c736ee152dd034" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37700840" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HybridDictionary : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HybridDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Specialized.HybridDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class HybridDictionary&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class HybridDictionary : System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type HybridDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Specialized</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa <see langword="IDictionary" /> usando un oggetto <see cref="T:System.Collections.Specialized.ListDictionary" /> quando la raccolta è di piccole dimensioni e passa a un oggetto <see cref="T:System.Collections.Hashtable" /> quando le dimensioni della raccolta aumentano.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe è consigliabile per i casi in cui il numero di elementi in un oggetto dictionary è sconosciuto. Sfrutta il miglioramento delle prestazioni di un <xref:System.Collections.Specialized.ListDictionary> con le raccolte di piccole dimensioni e offre la flessibilità del passaggio a un <xref:System.Collections.Hashtable> che gestisce più grandi raccolte meglio <xref:System.Collections.Specialized.ListDictionary>.  
  
 Se le dimensioni iniziali della raccolta sono maggiore della dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, la raccolta viene archiviata un <xref:System.Collections.Hashtable> per evitare il sovraccarico di copiare gli elementi dalle <xref:System.Collections.Specialized.ListDictionary> a un <xref:System.Collections.Hashtable>.  
  
 Il costruttore accetta un parametro booleano che consente all'utente di specificare se la raccolta viene ignorato il caso quando si confrontano le stringhe. Se la raccolta è tra maiuscole e minuscole, Usa le implementazioni della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Se la raccolta è tra maiuscole e minuscole, verrà eseguito un semplice tra maiuscole e minuscole confronto ordinale, secondo le regole di maiuscole e minuscole proprie delle impostazioni cultura invarianti. Per impostazione predefinita, la raccolta è tra maiuscole e minuscole. Per altre informazioni sulle impostazioni cultura invariabili, vedere <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Una chiave non può essere null, ma un valore possibile.  
  
 Il `foreach` istruzione del linguaggio c# (`For Each` in Visual Basic) restituisce un oggetto del tipo degli elementi nella raccolta. Poiché ogni elemento del <xref:System.Collections.Specialized.HybridDictionary> è una coppia chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è <xref:System.Collections.DictionaryEntry>. Ad esempio:  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#2)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#2)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#2)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere da, non la scrittura, la raccolta.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra numerose proprietà e metodi di <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/hybriddictionary.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/hybriddictionary.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/hybriddictionary.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Questa implementazione non fornisce un oggetto sincronizzato wrapper (thread-safe) per un <see cref="T:System.Collections.Specialized.HybridDictionary" />, ma classi derivate possono creare le proprie versioni sincronizzate del <see cref="T:System.Collections.Specialized.HybridDictionary" /> usando il <see cref="P:System.Collections.Specialized.HybridDictionary.SyncRoot" /> proprietà.  L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Specialized.ListDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> vuoto con distinzione tra maiuscole e minuscole.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, la raccolta tra maiuscole e minuscole e Usa l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> come il provider di codice hash e l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType> come operatore di confronto.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Specialized.HybridDictionary> devono essere univoci.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra numerose proprietà e metodi di <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/hybriddictionary.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/hybriddictionary.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/hybriddictionary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (bool caseInsensitive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool caseInsensitive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (caseInsensitive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(bool caseInsensitive);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.HybridDictionary : bool -&gt; System.Collections.Specialized.HybridDictionary" Usage="new System.Collections.Specialized.HybridDictionary caseInsensitive" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="caseInsensitive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="caseInsensitive">Valore booleano che indica se <see cref="T:System.Collections.Specialized.HybridDictionary" /> non prevede la distinzione tra maiuscole e minuscole.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> vuoto con il comportamento relativo a maiuscole e minuscole specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `caseInsensitive` viene `false`, la raccolta utilizza le implementazioni della chiave del <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Se `caseInsensitive` è `true`, la raccolta esegue un semplice confronto ordinale tra maiuscole e minuscole, secondo le regole di maiuscole e minuscole proprie delle impostazioni cultura invarianti. Per altre informazioni sulle impostazioni cultura invariabili, vedere <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (int initialSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(int initialSize);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.HybridDictionary : int -&gt; System.Collections.Specialized.HybridDictionary" Usage="new System.Collections.Specialized.HybridDictionary initialSize" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialSize">Numero approssimativo di voci che l'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> può contenere inizialmente.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> con la distinzione tra maiuscole e minuscole e con le dimensioni iniziali specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le dimensioni iniziali della raccolta sono maggiore della dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, la raccolta viene archiviata un <xref:System.Collections.Hashtable> per evitare il sovraccarico di copiare gli elementi dalle <xref:System.Collections.Specialized.ListDictionary> per il <xref:System.Collections.Hashtable>.  
  
 Per impostazione predefinita, la raccolta tra maiuscole e minuscole e Usa l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> come il provider di codice hash e l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType> come operatore di confronto.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Specialized.HybridDictionary> devono essere univoci.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `initialSize`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (int initialSize, bool caseInsensitive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialSize, bool caseInsensitive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialSize As Integer, caseInsensitive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(int initialSize, bool caseInsensitive);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.HybridDictionary : int * bool -&gt; System.Collections.Specialized.HybridDictionary" Usage="new System.Collections.Specialized.HybridDictionary (initialSize, caseInsensitive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialSize" Type="System.Int32" />
        <Parameter Name="caseInsensitive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialSize">Numero approssimativo di voci che l'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> può contenere inizialmente.</param>
        <param name="caseInsensitive">Valore booleano che indica se <see cref="T:System.Collections.Specialized.HybridDictionary" /> non prevede la distinzione tra maiuscole e minuscole.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> con comportamento relativo a maiuscole e minuscole e dimensione iniziale specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le dimensioni iniziali della raccolta sono maggiore della dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, la raccolta viene archiviata un <xref:System.Collections.Hashtable> per evitare il sovraccarico di copiare gli elementi dalle <xref:System.Collections.Specialized.ListDictionary> per il <xref:System.Collections.Hashtable>.  
  
 Se `caseInsensitive` viene `false`, la raccolta utilizza le implementazioni della chiave del <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Se `caseInsensitive` è `true`, la raccolta esegue un semplice confronto ordinale tra maiuscole e minuscole, secondo le regole di maiuscole e minuscole proprie delle impostazioni cultura invarianti. Per altre informazioni sulle impostazioni cultura invariabili, vedere <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `initialSize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="hybridDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave della voce da aggiungere.</param>
        <param name="value">Valore della voce da aggiungere. Il valore può essere <see langword="null" />.</param>
        <summary>Aggiunge una voce con la chiave e il valore specificati nell'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto che non ha alcuna correlazione tra il proprio stato e il relativo valore di codice hash deve in genere non utilizzabile come chiave. Ad esempio, gli oggetti stringa sono migliori rispetto agli oggetti di StringBuilder per l'uso come chiavi.  
  
 Non può essere una chiave `null`, ma un valore possibile.  
  
 È anche possibile usare la <xref:System.Collections.Specialized.HybridDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel <xref:System.Collections.Specialized.HybridDictionary>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel <xref:System.Collections.Specialized.HybridDictionary>, impostando il <xref:System.Collections.Specialized.HybridDictionary.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Specialized.HybridDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Quando il numero di elementi supera la dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, gli elementi vengono copiati dal <xref:System.Collections.Specialized.ListDictionary> a un <xref:System.Collections.Hashtable>. Tuttavia, ciò si verifica solo una volta. Se la raccolta è già archiviata una <xref:System.Collections.Hashtable> e il numero di elementi non supera la dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, la raccolta rimane nel <xref:System.Collections.Hashtable>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge e rimuove gli elementi da un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Specialized.HybridDictionary" /> è già presente una voce con la stessa chiave.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hybridDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le voci da <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 Se la raccolta è già archiviata una <xref:System.Collections.Hashtable>, la raccolta rimane nel <xref:System.Collections.Hashtable>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Specialized.HybridDictionary.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge e rimuove gli elementi da un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="hybridDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Specialized.HybridDictionary" />.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> contiene una chiave specifica.</summary>
        <returns>
          <see langword="true" /> se la classe <see cref="T:System.Collections.Specialized.HybridDictionary" /> contiene una voce con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione o (1).  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi sul `key` per determinare se `item` esiste. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene cercato un elemento in un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/CPP/hybriddictionary_contains.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/CS/hybriddictionary_contains.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/VB/hybriddictionary_contains.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="hybridDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che corrisponde alla destinazione degli oggetti <see cref="T:System.Collections.DictionaryEntry" /> copiati da <see cref="T:System.Collections.Specialized.HybridDictionary" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia le voci dell'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> in un'istanza di <see cref="T:System.Array" /> unidimensionale in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Specialized.HybridDictionary>.  
  
 Per copiare solo le chiavi di <xref:System.Collections.Specialized.HybridDictionary>, usare `HybridDictionary.Keys.CopyTo`.  
  
 Per copiare solo i valori di <xref:System.Collections.Specialized.HybridDictionary>, usare `HybridDictionary.Values.CopyTo`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Specialized.HybridDictionary.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente copia gli elementi di un <xref:System.Collections.Specialized.HybridDictionary> a una matrice.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/CPP/hybriddictionary_copyto.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/CS/hybriddictionary_copyto.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/VB/hybriddictionary_copyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.Specialized.HybridDictionary" /> è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Specialized.HybridDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Specialized.HybridDictionary" />.  Il recupero del valore di questa proprietà è un'operazione O(1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="hybridDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Collections.IDictionaryEnumerator" /> che esegue l'iterazione di <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> per l'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.Specialized.HybridDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Specialized.HybridDictionary" /> ha dimensioni fisse.</summary>
        <value>Questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementa il <xref:System.Collections.Specialized.HybridDictionary.IsFixedSize%2A> proprietà perché è necessaria per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia.  
  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.Specialized.HybridDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Specialized.HybridDictionary" /> è di sola lettura.</summary>
        <value>Questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementa il <xref:System.Collections.Specialized.HybridDictionary.IsReadOnly%2A> proprietà perché è necessaria per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia.  
  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta che è di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Specialized.HybridDictionary.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Collections.Specialized.HybridDictionary" /> è sincronizzata (thread-safe).</summary>
        <value>Questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementa il <xref:System.Collections.Specialized.HybridDictionary.IsSynchronized%2A> proprietà perché è necessaria per il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.  
  
 Le classi derivate possono fornire una versione sincronizzata della <xref:System.Collections.Specialized.HybridDictionary> utilizzando il <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> proprietà.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta usando il <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#3)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#3)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.Specialized.HybridDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave di cui si deve ottenere o impostare il valore.</param>
        <summary>Ottiene o imposta il valore associato alla chiave specificata.</summary>
        <value>Valore associato alla chiave specificata. Se si prova a ottenere una chiave non rilevata, verrà restituito <see langword="null" />, mentre se si prova a impostarla verrà creata una nuova voce con la quale verrà usata la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[key]`.  
  
 È anche possibile usare la <xref:System.Collections.Specialized.HybridDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel <xref:System.Collections.Specialized.HybridDictionary>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel <xref:System.Collections.Specialized.HybridDictionary>, impostando il <xref:System.Collections.Specialized.HybridDictionary.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Specialized.HybridDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Non può essere una chiave `null`, ma un valore possibile. Per distinguere `null` che viene restituito perché la chiave specificata non è stata trovata e `null` che viene restituito perché il valore della chiave specificata `null`, usare il <xref:System.Collections.Specialized.HybridDictionary.Contains%2A> per determinare se la chiave presente nell'elenco.  
  
 Il linguaggio c# usa la parola chiave per definire gli indicizzatori anziché implementare il <xref:System.Collections.Specialized.HybridDictionary.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Specialized.HybridDictionary.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è anche un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.Specialized.HybridDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Collections.ICollection" /> contenente le chiavi presenti nell'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Oggetto <see cref="T:System.Collections.ICollection" /> contenente le chiavi presenti in <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori nel <xref:System.Collections.ICollection> non è specificato, ma è stesso ordine dei valori associati nel <xref:System.Collections.ICollection> restituiti dal <xref:System.Collections.Specialized.HybridDictionary.Values%2A> (metodo).  
  
 L'oggetto restituito <xref:System.Collections.ICollection> non è una copia statica; in alternativa, il <xref:System.Collections.ICollection> fa riferimento alle chiavi nel originale <xref:System.Collections.Specialized.HybridDictionary>. Di conseguenza, le modifiche apportate al <xref:System.Collections.Specialized.HybridDictionary> continuano a essere riflessi nel <xref:System.Collections.ICollection>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="hybridDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave della voce da rimuovere.</param>
        <summary>Rimuove la voce con la chiave specificata da <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Collections.Specialized.HybridDictionary> non contiene un elemento con la chiave specificata, il <xref:System.Collections.Specialized.HybridDictionary> rimane invariato. Non viene generata alcuna eccezione.  
  
 Se la raccolta è già archiviata una <xref:System.Collections.Hashtable> e il numero di elementi non supera la dimensione ottima per un <xref:System.Collections.Specialized.ListDictionary>, la raccolta rimane nel <xref:System.Collections.Hashtable> per evitare il sovraccarico di copiare gli elementi dal <xref:System.Collections.Hashtable> verso una <xref:System.Collections.Specialized.ListDictionary>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente aggiunge e rimuove gli elementi da un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Specialized.HybridDictionary.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate possono fornire la propria versione sincronizzata del <xref:System.Collections.Specialized.HybridDictionary> utilizzando il <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni sul <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> del <xref:System.Collections.Specialized.HybridDictionary>, non direttamente sul <xref:System.Collections.Specialized.HybridDictionary>. In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente i <xref:System.Collections.Specialized.HybridDictionary> oggetto.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta usando il <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#3)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#3)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Collections.IEnumerator" /> che esegue l'iterazione di <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> per l'oggetto <see cref="T:System.Collections.Specialized.HybridDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione. In questa posizione, la chiamata a <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, la chiamata <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>. Se la raccolta viene modificata tra <xref:System.Collections.IEnumerator.MoveNext%2A> e <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> restituisce l'elemento su cui è stata impostata, anche se l'enumeratore risulta già invalidato.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.Specialized.HybridDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente i valori in <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente i valori dell'interfaccia <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori nel <xref:System.Collections.ICollection> non è specificato, ma è stesso ordine delle chiavi associate nel <xref:System.Collections.ICollection> restituiti dal <xref:System.Collections.Specialized.HybridDictionary.Keys%2A> (metodo).  
  
 L'oggetto restituito <xref:System.Collections.ICollection> non è una copia statica; in alternativa, il <xref:System.Collections.ICollection> fa riferimento ai valori nell'originale <xref:System.Collections.Specialized.HybridDictionary>. Di conseguenza, le modifiche apportate al <xref:System.Collections.Specialized.HybridDictionary> continuano a essere riflessi nel <xref:System.Collections.ICollection>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente enumera gli elementi di un <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>