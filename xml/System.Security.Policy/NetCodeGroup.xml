<Type Name="NetCodeGroup" FullName="System.Security.Policy.NetCodeGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f65082b2a1fd707f85fa4dad68b87b15bdde5783" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36424686" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NetCodeGroup : System.Security.Policy.CodeGroup" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit NetCodeGroup extends System.Security.Policy.CodeGroup" />
  <TypeSignature Language="DocId" Value="T:System.Security.Policy.NetCodeGroup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NetCodeGroup&#xA;Inherits CodeGroup" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetCodeGroup sealed : System::Security::Policy::CodeGroup" />
  <TypeSignature Language="F#" Value="type NetCodeGroup = class&#xA;    inherit CodeGroup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Policy.CodeGroup</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Grants Web permission to the site from which the assembly was downloaded. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gruppi di codice sono i blocchi predefiniti di criteri di sicurezza di accesso di codice. Ogni livello di criteri è costituito da un gruppo di codice radice che può avere uno o più gruppi di codice figlio. Ogni gruppo di codice figlio può avere un proprio gruppi di codice figlio; Questo comportamento si estende a qualsiasi numero di livelli, che costituiscono una struttura ad albero. Ogni gruppo di codice presenta una condizione di appartenenza che determina se un assembly specificato appartiene al gruppo, in base all'evidenza per tale assembly. Solo i gruppi di codice le cui condizioni di appartenenza corrispondono a un determinato assembly, insieme ai relativi gruppi di codice figlio, applicano criteri di sicurezza di accesso di codice.  
  
 <xref:System.Security.Policy.NetCodeGroup> ha la stessa semantica di tipo merge a quella del <xref:System.Security.Policy.UnionCodeGroup>; costituisce l'unione del <xref:System.Security.Policy.PolicyStatement> oggetti dell'elemento figlio corrispondente tutti i gruppi di codice e il <xref:System.Security.Policy.PolicyStatement> viene generato dall'input <xref:System.Security.Policy.Url> evidenza. Tuttavia, <xref:System.Security.Policy.NetCodeGroup> restituisce un'autorizzazione contenente un calcolata in modo dinamico <xref:System.Net.WebPermission> che concede l'accesso per connettersi al sito da cui viene eseguito il codice. <xref:System.Security.Policy.UnionCodeGroup> restituisce semplicemente un set di autorizzazioni statico.  
  
 Quando un <xref:System.Security.Policy.NetCodeGroup> viene creato, contiene le regole predefinite di accesso alla connessione illustrate nella tabella seguente.  
  
|Schema URI|Regola|  
|----------------|----------|  
|file|È permesso alcun accesso connessione al server di origine.|  
|http|È consentito l'accesso HTTP e HTTPS tramite la porta di origine.|  
|https|È consentito l'accesso tramite HTTPS utilizzando la porta di origine.|  
  
 È possibile controllare lo schema e porta di codice è autorizzato a utilizzare quando ci si connette al proprio sito di origine passando un <xref:System.Security.Policy.CodeConnectAccess> oggetto con l'appropriato <xref:System.Security.Policy.CodeConnectAccess.Scheme%2A> e <xref:System.Security.Policy.CodeConnectAccess.Port%2A> i valori delle proprietà per il <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> (metodo). È possibile creare una regola di accesso di connessione che si applica quando lo schema di origine non è presente nell'evidenza o non è riconosciuto specificando <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> ("") come lo schema. È anche possibile creare una regola di accesso di connessione che si applica quando non vi è alcuna regola con uno schema corrispondente specificando <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> ("*") come lo schema.  
  
> [!NOTE]
>  Se il codice non presenta lo schema URI come prova, è consentito l'accesso utilizzando qualsiasi schema nel sito di origine.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un <xref:System.Security.Policy.NetCodeGroup> e l'aggiunta di <xref:System.Security.Policy.CodeConnectAccess> oggetti per il codice scaricato tramite lo schema HTTP.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetCodeGroup (System.Security.Policy.IMembershipCondition membershipCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Policy.IMembershipCondition membershipCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.#ctor(System.Security.Policy.IMembershipCondition)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (membershipCondition As IMembershipCondition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetCodeGroup(System::Security::Policy::IMembershipCondition ^ membershipCondition);" />
      <MemberSignature Language="F#" Value="new System.Security.Policy.NetCodeGroup : System.Security.Policy.IMembershipCondition -&gt; System.Security.Policy.NetCodeGroup" Usage="new System.Security.Policy.NetCodeGroup membershipCondition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="membershipCondition" Type="System.Security.Policy.IMembershipCondition" />
      </Parameters>
      <Docs>
        <param name="membershipCondition">A membership condition that tests evidence to determine whether this code group applies code access security policy.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Policy.NetCodeGroup" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Security.Policy.NetCodeGroup> viene creato, contiene le regole predefinite di accesso alla connessione illustrate nella tabella seguente.  
  
|Scheme|Regola|  
|------------|----------|  
|file|È permesso alcun accesso connessione al server di origine.|  
|http|È consentito l'accesso HTTP e HTTPS tramite la porta di origine.|  
|https|È consentito l'accesso tramite HTTPS utilizzando la porta di origine.|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un <xref:System.Security.Policy.NetCodeGroup> e l'aggiunta di <xref:System.Security.Policy.CodeConnectAccess> oggetti per il codice scaricato tramite lo schema HTTP.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="membershipCondition" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The type of the <paramref name="membershipCondition" /> parameter is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsentOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AbsentOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AbsentOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AbsentOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AbsentOriginScheme;" />
      <MemberSignature Language="F#" Value=" staticval mutable AbsentOriginScheme : string" Usage="System.Security.Policy.NetCodeGroup.AbsentOriginScheme" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains a value used to specify connection access for code with an unknown or unrecognized origin scheme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama il <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> metodo, si specifica uno schema e un oggetto associato <xref:System.Security.Policy.CodeConnectAccess> oggetto. Qualsiasi <xref:System.Security.Policy.CodeConnectAccess> oggetti che vengono aggiunti per il <xref:System.Security.Policy.NetCodeGroup> utilizzando <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> come origine dello schema vengono applicate quando dello schema di origine del codice non è presente nell'evidenza o schema non è riconosciuto dal <xref:System.Security.Policy.NetCodeGroup> oggetto.  
  
 Per specificare il <xref:System.Security.Policy.CodeConnectAccess> oggetti da utilizzare quando lo schema del codice origine corrisponde a nessuno degli schemi contenuti nel set di schemi di origine aggiunti all'oggetto corrente <xref:System.Security.Policy.NetCodeGroup> oggetto, usare il <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> valore.  
  
 Il valore di <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> campo è una stringa vuota ("").  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConnectAccess">
      <MemberSignature Language="C#" Value="public void AddConnectAccess (string originScheme, System.Security.Policy.CodeConnectAccess connectAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddConnectAccess(string originScheme, class System.Security.Policy.CodeConnectAccess connectAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.AddConnectAccess(System.String,System.Security.Policy.CodeConnectAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddConnectAccess (originScheme As String, connectAccess As CodeConnectAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddConnectAccess(System::String ^ originScheme, System::Security::Policy::CodeConnectAccess ^ connectAccess);" />
      <MemberSignature Language="F#" Value="member this.AddConnectAccess : string * System.Security.Policy.CodeConnectAccess -&gt; unit" Usage="netCodeGroup.AddConnectAccess (originScheme, connectAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originScheme" Type="System.String" />
        <Parameter Name="connectAccess" Type="System.Security.Policy.CodeConnectAccess" />
      </Parameters>
      <Docs>
        <param name="originScheme">A <see cref="T:System.String" /> containing the scheme to match against the code's scheme.</param>
        <param name="connectAccess">A <see cref="T:System.Security.Policy.CodeConnectAccess" /> that specifies the scheme and port code can use to connect back to its origin server.</param>
        <summary>Adds the specified connection access to the current code group.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile aggiungere più <xref:System.Security.Policy.CodeConnectAccess> gli oggetti per lo stesso `origin scheme`. Se un `origin scheme` dispone già di uno o più <xref:System.Security.Policy.CodeConnectAccess> oggetti, che specificano `null` per `connectAccess` non ha alcun effetto. Se lo schema di origine non sono associati <xref:System.Security.Policy.CodeConnectAccess> oggetti, specificando `null` per `connectAccess` impedisce codice con uno schema di origine che corrisponde a `originScheme` di accedere ai server di origine.  
  
   
  
## Examples  
 Esempio di codice seguente illustra la creazione e aggiunta <xref:System.Security.Policy.CodeConnectAccess> oggetti per un <xref:System.Security.Policy.NetCodeGroup>.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="originScheme" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="originScheme" /> contains characters that are not permitted in schemes.  -or-  <paramref name="originScheme" /> = <see cref="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" /> and <paramref name="connectAccess" /> specifies <see cref="F:System.Security.Policy.CodeConnectAccess.OriginScheme" /> as its scheme.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyOtherOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AnyOtherOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AnyOtherOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AnyOtherOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AnyOtherOriginScheme;" />
      <MemberSignature Language="F#" Value=" staticval mutable AnyOtherOriginScheme : string" Usage="System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains a value used to specify any other unspecified origin scheme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama il <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> metodo, si specifica uno schema e un oggetto associato <xref:System.Security.Policy.CodeConnectAccess> oggetto. È possibile utilizzare il valore di <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> campo per specificare il <xref:System.Security.Policy.CodeConnectAccess> gli oggetti che devono essere utilizzati per qualsiasi schema che non è contenuto in modo esplicito nel set di schemi di origine aggiunti all'oggetto corrente <xref:System.Security.Policy.NetCodeGroup> oggetto.  
  
 Il <xref:System.Security.Policy.CodeConnectAccess> gli oggetti specificati con il <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> campo vengono utilizzati solo se lo schema di origine del codice non corrisponde a nessuno degli schemi contenuti nel set di schemi di origine aggiunti all'oggetto corrente <xref:System.Security.Policy.NetCodeGroup> oggetto.  
  
 Per specificare il <xref:System.Security.Policy.CodeConnectAccess> oggetti da applicare quando lo schema di origine del codice non è disponibile nell'evidenza o non viene riconosciuto, utilizzare il <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> valore.  
  
 Il valore di <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> campo è "*".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeString">
      <MemberSignature Language="C#" Value="public override string AttributeString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AttributeString" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.AttributeString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AttributeString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeString : string" Usage="System.Security.Policy.NetCodeGroup.AttributeString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a string representation of the attributes of the policy statement for the code group.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As CodeGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ Copy();" />
      <MemberSignature Language="F#" Value="override this.Copy : unit -&gt; System.Security.Policy.CodeGroup" Usage="netCodeGroup.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a deep copy of the current code group.</summary>
        <returns>An equivalent copy of the current code group, including its membership conditions and child code groups.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una copia completa del gruppo di codice, vale a dire che le copie di tutti gli oggetti che contiene il gruppo di codice vengono eseguite anche.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXml">
      <MemberSignature Language="C#" Value="protected override void CreateXml (System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateXml(class System.Security.SecurityElement element, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateXml (element As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateXml(System::Security::SecurityElement ^ element, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="override this.CreateXml : System.Security.SecurityElement * System.Security.Policy.PolicyLevel -&gt; unit" Usage="netCodeGroup.CreateXml (element, level)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="netCodeGroup.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The <see cref="T:System.Security.Policy.NetCodeGroup" /> object to compare with the current code group.</param>
        <summary>Determines whether the specified code group is equivalent to the current code group.</summary>
        <returns>
          <see langword="true" /> if the specified code group is equivalent to the current code group; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I seguenti dati vengono utilizzati per determinare l'uguaglianza di due <xref:System.Security.Policy.NetCodeGroup> oggetti:  
  
-   Il <xref:System.Security.Policy.CodeGroup.Name%2A> e <xref:System.Security.Policy.CodeGroup.Description%2A> proprietà.  
  
-   La proprietà <xref:System.Security.Policy.CodeGroup.MembershipCondition%2A>.  
  
-   Il set di schemi di origine e associato <xref:System.Security.Policy.CodeConnectAccess> oggetti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConnectAccessRules">
      <MemberSignature Language="C#" Value="public System.Collections.DictionaryEntry[] GetConnectAccessRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.DictionaryEntry[] GetConnectAccessRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetConnectAccessRules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConnectAccessRules () As DictionaryEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::DictionaryEntry&gt; ^ GetConnectAccessRules();" />
      <MemberSignature Language="F#" Value="member this.GetConnectAccessRules : unit -&gt; System.Collections.DictionaryEntry[]" Usage="netCodeGroup.GetConnectAccessRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.DictionaryEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the connection access information for the current code group.</summary>
        <returns>A <see cref="T:System.Collections.DictionaryEntry" /> array containing connection access information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In ogni voce di dizionario, la <xref:System.Collections.DictionaryEntry.Key%2A> valore della proprietà è lo schema di origine e il <xref:System.Collections.DictionaryEntry.Value%2A> valore della proprietà è la matrice di associati <xref:System.Security.Policy.CodeConnectAccess> oggetti. Se non esistono alcun oggetto associato <xref:System.Security.Policy.CodeConnectAccess> oggetti, <xref:System.Collections.DictionaryEntry.Value%2A?displayProperty=nameWithType> restituisce una matrice vuota.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare le regole di accesso di connessione per un <xref:System.Security.Policy.NetCodeGroup> oggetto.  
  
 [!code-cpp[NclCodeGroup#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#8)]
 [!code-csharp[NclCodeGroup#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="netCodeGroup.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the hash code of the current code group.</summary>
        <returns>The hash code of the current code group.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Policy.CodeGroup.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="MergeLogic">
      <MemberSignature Language="C#" Value="public override string MergeLogic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MergeLogic" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.MergeLogic" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MergeLogic As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MergeLogic { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergeLogic : string" Usage="System.Security.Policy.NetCodeGroup.MergeLogic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logic to use for merging groups.</summary>
        <value>La stringa "Union".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseXml">
      <MemberSignature Language="C#" Value="protected override void ParseXml (System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ParseXml(class System.Security.SecurityElement e, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ParseXml (e As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ParseXml(System::Security::SecurityElement ^ e, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="override this.ParseXml : System.Security.SecurityElement * System.Security.Policy.PolicyLevel -&gt; unit" Usage="netCodeGroup.ParseXml (e, level)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSetName">
      <MemberSignature Language="C#" Value="public override string PermissionSetName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PermissionSetName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.PermissionSetName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PermissionSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ PermissionSetName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSetName : string" Usage="System.Security.Policy.NetCodeGroup.PermissionSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the <see cref="T:System.Security.NamedPermissionSet" /> for the code group.</summary>
        <value>Sempre la stringa "Stesso sito Web."</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetConnectAccess">
      <MemberSignature Language="C#" Value="public void ResetConnectAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetConnectAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResetConnectAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetConnectAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetConnectAccess();" />
      <MemberSignature Language="F#" Value="member this.ResetConnectAccess : unit -&gt; unit" Usage="netCodeGroup.ResetConnectAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all connection access information for the current code group.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per rimuovere le regole di accesso di connessione predefinito fornito dal sistema.  
  
 Nella tabella seguente vengono visualizzate le regole predefinite.  
  
|Scheme|Regola|  
|------------|----------|  
|file|È permesso alcun accesso connessione al server di origine.|  
|http|È consentito l'accesso HTTP e HTTPS tramite la porta di origine.|  
|https|È consentito l'accesso tramite HTTPS utilizzando la porta di origine.|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare questo metodo per rimuovere le regole di connessione accesso di codice predefinito.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.PolicyStatement Resolve (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.PolicyStatement Resolve(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Resolve(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::PolicyStatement ^ Resolve(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="override this.Resolve : System.Security.Policy.Evidence -&gt; System.Security.Policy.PolicyStatement" Usage="netCodeGroup.Resolve evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyStatement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The <see cref="T:System.Security.Policy.Evidence" /> for the assembly.</param>
        <summary>Resolves policy for the code group and its descendants for a set of evidence.</summary>
        <returns>A <see cref="T:System.Security.Policy.PolicyStatement" /> that consists of the permissions granted by the code group with optional attributes, or <see langword="null" /> if the code group does not apply (the membership condition does not match the specified evidence).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Base l'evidenza per un assembly da caricare, questo metodo restituisce il gruppo di codice controllando dapprima la condizione di appartenenza in base all'evidenza specificata. Se non esiste una corrispondenza, questo metodo restituisce un'istruzione di criteri per il gruppo di codice, inclusa la valutazione dei gruppi di codice figlio.  
  
 L'operazione di questo metodo è il seguente:  
  
 Se la condizione di appartenenza non corrisponde l'evidenza specificata, restituire `null`; in caso contrario, impostare l'autorizzazione impostata per essere restituiti (P) è uguale all'istruzione dei criteri del gruppo di codice e continuare. Per ogni gruppo di codice figlio, risolvere il gruppo di codice con la stessa prova; Se il risultato non è `null`, restituire tale istruzione dei criteri. Se nessun gruppo di codice figlio corrispondente, restituire P (istruzione dei criteri dell'elemento padre).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="evidence" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">More than one code group (including the parent code group and any child code groups) is marked <see cref="F:System.Security.Policy.PolicyStatementAttribute.Exclusive" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMatchingCodeGroups">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup ResolveMatchingCodeGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResolveMatchingCodeGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ ResolveMatchingCodeGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="override this.ResolveMatchingCodeGroups : System.Security.Policy.Evidence -&gt; System.Security.Policy.CodeGroup" Usage="netCodeGroup.ResolveMatchingCodeGroups evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">The evidence for the assembly.</param>
        <summary>Resolves matching code groups.</summary>
        <returns>The complete set of code groups that were matched by the evidence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Base l'evidenza per un assembly da caricare, questo metodo restituisce il gruppo di codice controllando dapprima la condizione di appartenenza in base all'evidenza specificata. Se non esiste una corrispondenza, questo metodo restituisce un gruppo di codice radice. Il gruppo di codice che viene restituito può contenere gruppi di codice figlio, che, a sua volta, possono anche avere gruppi di codice figlio, in modo che il valore restituito riflette il set completo dei gruppi di codice che sono stati corrispondenti all'evidenza fornita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="evidence" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>