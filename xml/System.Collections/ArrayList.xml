<Type Name="ArrayList" FullName="System.Collections.ArrayList">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a90b2ffff1dfbd123e8c16b2b7265090ddfa3aca" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36713409" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ArrayList : ICloneable, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ArrayList extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ArrayList" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayList&#xA;Implements ICloneable, IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class ArrayList : ICloneable, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ArrayList = class&#xA;    interface IList&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implements the <see cref="T:System.Collections.IList" /> interface using an array whose size is dynamically increased as required.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> classe è progettata per contenere raccolte eterogenee di oggetti. Tuttavia, non sempre offre le migliori prestazioni. In alternativa, è consigliabile quanto segue:  
  
-   Per un insieme eterogeneo di oggetti, usare il `List<Object>` (in c#) o `List(Of Object)` (in Visual Basic) digitare.  
  
-   Per una raccolta omogenea di oggetti, usare il <xref:System.Collections.Generic.List%601> classe.  
  
 Vedere la sezione "Considerazioni sulle prestazioni" nel <xref:System.Collections.Generic.List%601> argomento di riferimento per una discussione sulle prestazioni relative di queste classi.  
  
 Il <xref:System.Collections.ArrayList> non è garantito da ordinare.  È necessario ordinare il <xref:System.Collections.ArrayList> chiamando relativi <xref:System.Collections.ArrayList.Sort%2A> metodo prima di eseguire le operazioni (ad esempio <xref:System.Collections.ArrayList.BinarySearch%2A>) che richiedono il <xref:System.Collections.ArrayList> da ordinare. Per mantenere una raccolta che venga automaticamente ordinata man mano che vengono aggiunti nuovi elementi, è possibile utilizzare il <xref:System.Collections.Generic.SortedSet%601> classe.  
  
 La capacità di un <xref:System.Collections.ArrayList> è il numero di elementi di <xref:System.Collections.ArrayList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.ArrayList>, incrementata automaticamente come richiesto tramite operazioni di riallocazione. È possibile diminuire la capacità chiamando <xref:System.Collections.ArrayList.TrimToSize%2A> oppure impostando la <xref:System.Collections.ArrayList.Capacity%2A> proprietà in modo esplicito.  
  
 Per grandi <xref:System.Collections.ArrayList> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.  
  
 Elementi nella raccolta è accessibile tramite un indice integer.  Gli indici in questa raccolta sono in base zero.  
  
 Il <xref:System.Collections.ArrayList> la raccolta accetta `null` come un valore valido. Consente anche di elementi duplicati.  
  
 Utilizzo di matrici multidimensionali come elementi in un <xref:System.Collections.ArrayList> raccolta non è supportata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un <xref:System.Collections.ArrayList> e come visualizzare i relativi valori.  
  
 [!code-cpp[Classic ArrayList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Un <see cref="T:System.Collections.ArrayList" /> può supportare più lettori contemporaneamente, fino a quando la raccolta non viene modificata. Per garantire la protezione del thread dei <see cref="T:System.Collections.ArrayList" />, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /> metodo.  L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Generic.List`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.ArrayList" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.ArrayList" /> class that is empty and has the default initial capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.ArrayList> è il numero di elementi che la <xref:System.Collections.ArrayList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.ArrayList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.ArrayList>.  
  
 Questo costruttore è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : System.Collections.ICollection -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList c" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">The <see cref="T:System.Collections.ICollection" /> whose elements are copied to the new list.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.ArrayList" /> class that contains elements copied from the specified collection and that has the same initial capacity as the number of elements copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.ArrayList> è il numero di elementi che la <xref:System.Collections.ArrayList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.ArrayList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.ArrayList>.  
  
 Gli elementi vengono copiati il <xref:System.Collections.ArrayList> nello stesso ordine in cui vengono letti dal <xref:System.Collections.IEnumerator> del <xref:System.Collections.ICollection>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `c`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : int -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The number of elements that the new list can initially store.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.ArrayList" /> class that is empty and has the specified initial capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.ArrayList> è il numero di elementi che la <xref:System.Collections.ArrayList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.ArrayList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.ArrayList>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Adapter (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Adapter(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Adapter(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Adapter (list As IList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Adapter(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Adapter : System.Collections.IList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Adapter list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.IList" /> to wrap.</param>
        <summary>Creates an <see cref="T:System.Collections.ArrayList" /> wrapper for a specific <see cref="T:System.Collections.IList" />.</summary>
        <returns>The <see cref="T:System.Collections.ArrayList" /> wrapper around the <see cref="T:System.Collections.IList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Adapter%2A> non ne copia il contenuto di <xref:System.Collections.IList>. Al contrario, viene creato solo un <xref:System.Collections.ArrayList> wrapper <xref:System.Collections.IList>; pertanto, diventa il <xref:System.Collections.IList> influenzare il <xref:System.Collections.ArrayList>.  
  
 Il <xref:System.Collections.ArrayList> classe fornisce generico <xref:System.Collections.ArrayList.Reverse%2A>, <xref:System.Collections.ArrayList.BinarySearch%2A> e <xref:System.Collections.ArrayList.Sort%2A> metodi. Il wrapper può costituire un modo per utilizzare questi metodi su <xref:System.Collections.IList>; tuttavia, l'esecuzione di queste operazioni generiche tramite il wrapper potrebbe rivelarsi meno efficiente rispetto alle operazioni applicate direttamente al <xref:System.Collections.IList>.  
  
 Questo metodo è un'operazione o (1).  
  
## <a name="version-compatibility"></a>Compatibilità tra versioni  
 In .NET Framework versioni 1.0 e 1.1, chiamando il <xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29> overload del metodo nel <xref:System.Collections.ArrayList> wrapper ha restituito un enumeratore che trattato il secondo argomento un limite superiore anziché come un numero. Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] il secondo argomento correttamente viene trattato come un conteggio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
        <altmember cref="M:System.Collections.ArrayList.Reverse" />
        <altmember cref="M:System.Collections.ArrayList.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="arrayList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to be added to the end of the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <summary>Adds an object to the end of the <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>The <see cref="T:System.Collections.ArrayList" /> index at which the <paramref name="value" /> has been added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 Se <xref:System.Collections.ArrayList.Count%2A> è già pari <xref:System.Collections.ArrayList.Capacity%2A>, la capacità del <xref:System.Collections.ArrayList> viene aumentata automaticamente la riallocazione della matrice interna, e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se <xref:System.Collections.ArrayList.Count%2A> è minore di <xref:System.Collections.ArrayList.Capacity%2A>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come aggiungere elementi al <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddRange(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : System.Collections.ICollection -&gt; unit&#xA;override this.AddRange : System.Collections.ICollection -&gt; unit" Usage="arrayList.AddRange c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">The <see cref="T:System.Collections.ICollection" /> whose elements should be added to the end of the <see cref="T:System.Collections.ArrayList" />. The collection itself cannot be <see langword="null" />, but it can contain elements that are <see langword="null" />.</param>
        <summary>Adds the elements of an <see cref="T:System.Collections.ICollection" /> to the end of the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 L'ordine degli elementi nel <xref:System.Collections.ICollection> viene mantenuta nella <xref:System.Collections.ArrayList>.  
  
 Se il nuovo <xref:System.Collections.ArrayList.Count%2A> (corrente <xref:System.Collections.ArrayList.Count%2A> più le dimensioni della raccolta) sarà maggiore <xref:System.Collections.ArrayList.Capacity%2A>, la capacità del <xref:System.Collections.ArrayList> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e il gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.  
  
 Se il <xref:System.Collections.ArrayList> può contenere i nuovi elementi senza aumentare la <xref:System.Collections.ArrayList.Capacity%2A>, questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da aggiungere. Se la capacità deve essere incrementata per far posto i nuovi elementi, questo metodo diventa un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi da aggiungere e `m` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come aggiungere elementi al <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uses a binary search algorithm to locate a specific element in the sorted <see cref="T:System.Collections.ArrayList" /> or a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj -&gt; int&#xA;override this.BinarySearch : obj -&gt; int" Usage="arrayList.BinarySearch value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate. The value can be <see langword="null" />.</param>
        <summary>Searches the entire sorted <see cref="T:System.Collections.ArrayList" /> for an element using the default comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="value" /> in the sorted <see cref="T:System.Collections.ArrayList" />, if <paramref name="value" /> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro e ogni elemento del <xref:System.Collections.ArrayList> deve implementare il <xref:System.IComparable> interfaccia, che viene utilizzata per i confronti. Gli elementi del <xref:System.Collections.ArrayList> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Confronto tra `null` con qualsiasi tipo è consentita e non genera un'eccezione quando si utilizza <xref:System.IComparable>. Quando si ordinano, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.ArrayList> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente del primo di essi.  
  
 Se il <xref:System.Collections.ArrayList> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.ArrayList>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Collections.ArrayList.BinarySearch%2A> per individuare un oggetto specifico di <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Neither <paramref name="value" /> nor the elements of <see cref="T:System.Collections.ArrayList" /> implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> is not of the same type as the elements of the <see cref="T:System.Collections.ArrayList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate. The value can be <see langword="null" />.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the default comparer that is the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Searches the entire sorted <see cref="T:System.Collections.ArrayList" /> for an element using the specified comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="value" /> in the sorted <see cref="T:System.Collections.ArrayList" />, if <paramref name="value" /> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto Personalizza modalità di confronto di elementi. Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer> istanza come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.ArrayList> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione. Gli elementi del <xref:System.Collections.ArrayList> già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe essere errato.  
  
 Se `comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato. Gli elementi del <xref:System.Collections.ArrayList> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Confronto tra `null` con qualsiasi tipo è consentita e non genera un'eccezione quando si utilizza <xref:System.IComparable>. Quando si ordinano, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.ArrayList> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente del primo di essi.  
  
 Se il <xref:System.Collections.ArrayList> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.ArrayList>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Collections.ArrayList> di animali colorati. L'oggetto fornito <xref:System.Collections.IComparer> esegue il confronto tra stringhe per la ricerca binaria. Vengono visualizzati i risultati di una ricerca iterativa sia una ricerca binaria.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> is <see langword="null" /> and neither <paramref name="value" /> nor the elements of <see cref="T:System.Collections.ArrayList" /> implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" /> and <paramref name="value" /> is not of the same type as the elements of the <see cref="T:System.Collections.ArrayList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(int32 index, int32 count, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (index As Integer, count As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(int index, int count, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (index, count, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to search.</param>
        <param name="count">The length of the range to search.</param>
        <param name="value">The <see cref="T:System.Object" /> to locate. The value can be <see langword="null" />.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the default comparer that is the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Searches a range of elements in the sorted <see cref="T:System.Collections.ArrayList" /> for an element using the specified comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="value" /> in the sorted <see cref="T:System.Collections.ArrayList" />, if <paramref name="value" /> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto Personalizza modalità di confronto di elementi. Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer> istanza come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.ArrayList> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione. Gli elementi del <xref:System.Collections.ArrayList> già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe essere errato.  
  
 Se `comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato. Gli elementi del <xref:System.Collections.ArrayList> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Confronto tra `null` con qualsiasi tipo è consentita e non genera un'eccezione quando si utilizza <xref:System.IComparable>. Quando si ordinano, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.ArrayList> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente del primo di essi.  
  
 Se il <xref:System.Collections.ArrayList> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.ArrayList>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `count`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in the <see cref="T:System.Collections.ArrayList" />.  -or-  <paramref name="comparer" /> is <see langword="null" /> and neither <paramref name="value" /> nor the elements of <see cref="T:System.Collections.ArrayList" /> implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" /> and <paramref name="value" /> is not of the same type as the elements of the <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.ArrayList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of elements that the <see cref="T:System.Collections.ArrayList" /> can contain.</summary>
        <value>Numero degli elementi che <see cref="T:System.Collections.ArrayList" /> può contenere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> è il numero di elementi che la <xref:System.Collections.ArrayList> può archiviare. <xref:System.Collections.ArrayList.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.ArrayList.Count%2A>. Se <xref:System.Collections.ArrayList.Count%2A> supera <xref:System.Collections.ArrayList.Capacity%2A> durante l'aggiunta di elementi, la capacità è aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.ArrayList.TrimToSize%2A> oppure impostando la <xref:System.Collections.ArrayList.Capacity%2A> proprietà in modo esplicito. Quando il valore di <xref:System.Collections.ArrayList.Capacity%2A> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione O (`n`) operazione, in cui `n` è la nuova capacità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.ArrayList.Capacity" /> is set to a value that is less than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory available on the system.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="arrayList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all elements from the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> non subisce modifiche.  Per reimpostare la capacità del <xref:System.Collections.ArrayList>, chiamare <xref:System.Collections.ArrayList.TrimToSize%2A> o impostare il <xref:System.Collections.ArrayList.Capacity%2A> proprietà direttamente. L'eliminazione di un oggetto vuoto <xref:System.Collections.ArrayList> imposta la capacità del <xref:System.Collections.ArrayList> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere le parti inutilizzate del <xref:System.Collections.ArrayList> e su come cancellare i valori del <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.TrimToSize" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="arrayList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>A shallow copy of the <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di un insieme copia solo gli elementi della raccolta, indipendentemente che siano tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a. I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nella raccolta originale.  
  
 Al contrario, una copia completa di una raccolta copia gli elementi e tutto ciò che direttamente o indirettamente riferimento gli elementi.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="arrayList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <summary>Determines whether an element is in the <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Collections.ArrayList" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies the <see cref="T:System.Collections.ArrayList" /> or a portion of it to a one-dimensional array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array -&gt; unit&#xA;override this.CopyTo : Array -&gt; unit" Usage="arrayList.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ArrayList" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <summary>Copies the entire <see cref="T:System.Collections.ArrayList" /> to a compatible one-dimensional <see cref="T:System.Array" />, starting at the beginning of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice specificata deve essere di un tipo compatibile.  
  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Gli elementi vengono copiati per la <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.ArrayList>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come copiare un <xref:System.Collections.ArrayList> in una matrice unidimensionale <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source <see cref="T:System.Collections.ArrayList" /> is greater than the number of elements that the destination <paramref name="array" /> can contain.</exception>
        <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ArrayList" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="arrayList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ArrayList" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in <c>array</c> at which copying begins.</param>
        <summary>Copies the entire <see cref="T:System.Collections.ArrayList" /> to a compatible one-dimensional <see cref="T:System.Array" />, starting at the specified index of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice specificata deve essere di un tipo compatibile.  
  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Gli elementi vengono copiati per la <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.ArrayList>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come copiare un <xref:System.Collections.ArrayList> in una matrice unidimensionale <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source <see cref="T:System.Collections.ArrayList" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ArrayList" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (int index, Array array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int32 index, class System.Array array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(int index, Array ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int * Array * int * int -&gt; unit&#xA;override this.CopyTo : int * Array * int * int -&gt; unit" Usage="arrayList.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index in the source <see cref="T:System.Collections.ArrayList" /> at which copying begins.</param>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ArrayList" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in <c>array</c> at which copying begins.</param>
        <param name="count">The number of elements to copy.</param>
        <summary>Copies a range of elements from the <see cref="T:System.Collections.ArrayList" /> to a compatible one-dimensional <see cref="T:System.Array" />, starting at the specified index of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice specificata deve essere di un tipo compatibile.  
  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Gli elementi vengono copiati per la <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.ArrayList>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come copiare un <xref:System.Collections.ArrayList> in una matrice unidimensionale <xref:System.Array?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="arrayIndex" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  <paramref name="index" /> is equal to or greater than the <see cref="P:System.Collections.ArrayList.Count" /> of the source <see cref="T:System.Collections.ArrayList" />.  -or-  The number of elements from <paramref name="index" /> to the end of the source <see cref="T:System.Collections.ArrayList" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ArrayList" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ArrayList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements actually contained in the <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Numero di elementi effettivamente contenuti nell'oggetto <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> è il numero di elementi che la <xref:System.Collections.ArrayList> può archiviare. <xref:System.Collections.ArrayList.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.ArrayList.Count%2A>. Se <xref:System.Collections.ArrayList.Count%2A> supera <xref:System.Collections.ArrayList.Capacity%2A> durante l'aggiunta di elementi, la capacità è aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FixedSize">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a list wrapper with a fixed size, where elements are allowed to be modified, but not added or removed.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList FixedSize(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ FixedSize(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.ArrayList" /> to wrap.</param>
        <summary>Returns an <see cref="T:System.Collections.ArrayList" /> wrapper with a fixed size.</summary>
        <returns>An <see cref="T:System.Collections.ArrayList" /> wrapper with a fixed size.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo wrapper può essere utilizzato per impedire aggiunte o eliminazioni dall'originale <xref:System.Collections.ArrayList>. Gli elementi possono comunque essere modificati o sostituiti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un wrapper di dimensione fissa per un' <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.IList FixedSize (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList FixedSize(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ FixedSize(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.IList" /> to wrap.</param>
        <summary>Returns an <see cref="T:System.Collections.IList" /> wrapper with a fixed size.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> wrapper with a fixed size.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo wrapper può essere utilizzato per impedire aggiunte o eliminazioni dall'originale <xref:System.Collections.IList>. Gli elementi possono comunque essere modificati o sostituiti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.ArrayList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator for the entire <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> for the entire <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente ottiene l'enumeratore per un <xref:System.Collections.ArrayList>e l'enumeratore per un intervallo di elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator (index As Integer, count As Integer) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : int * int -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : int * int -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the <see cref="T:System.Collections.ArrayList" /> section that the enumerator should refer to.</param>
        <param name="count">The number of elements in the <see cref="T:System.Collections.ArrayList" /> section that the enumerator should refer to.</param>
        <summary>Returns an enumerator for a range of elements in the <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> for the specified range of elements in the <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in Visual C++, `For Each` Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
## <a name="version-compatibility"></a>Compatibilità tra versioni  
 In .NET Framework versioni 1.0 e 1.1, l'enumeratore per un <xref:System.Collections.ArrayList> wrapper restituito dal <xref:System.Collections.ArrayList.Adapter%2A> metodo trattato il secondo argomento un limite superiore anziché come un numero. Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] il secondo argomento correttamente viene trattato come un conteggio.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene l'enumeratore per un <xref:System.Collections.ArrayList>e l'enumeratore per un intervallo di elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ArrayList GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ArrayList GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRange (index As Integer, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ArrayList ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetRange : int * int -&gt; System.Collections.ArrayList&#xA;override this.GetRange : int * int -&gt; System.Collections.ArrayList" Usage="arrayList.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based <see cref="T:System.Collections.ArrayList" /> index at which the range starts.</param>
        <param name="count">The number of elements in the range.</param>
        <summary>Returns an <see cref="T:System.Collections.ArrayList" /> which represents a subset of the elements in the source <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>An <see cref="T:System.Collections.ArrayList" /> which represents a subset of the elements in the source <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non crea copie degli elementi. Il nuovo <xref:System.Collections.ArrayList> è solo una finestra di visualizzazione nell'origine <xref:System.Collections.ArrayList>. Tuttavia, tutte le modifiche successive all'origine <xref:System.Collections.ArrayList> devono essere eseguite tramite questa finestra di visualizzazione <xref:System.Collections.ArrayList>. Se si modifica direttamente all'origine <xref:System.Collections.ArrayList>, la finestra di visualizzazione <xref:System.Collections.ArrayList> viene invalidato e qualsiasi operazione su di essa verranno restituito un <xref:System.InvalidOperationException>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un intervallo di elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the zero-based index of the first occurrence of a value in the <see cref="T:System.Collections.ArrayList" /> or in a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="arrayList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> within the entire <see cref="T:System.Collections.ArrayList" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int -&gt; int&#xA;override this.IndexOf : obj * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that extends from the specified index to the last element.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> viene eseguita la ricerca in avanti iniziando in corrispondenza di `startIndex` fino all'ultimo elemento.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi compresi tra `startIndex` alla fine del <xref:System.Collections.ArrayList>.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int * int -&gt; int&#xA;override this.IndexOf : obj * int * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that starts at the specified index and contains the specified number of elements.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that starts at <paramref name="startIndex" /> and contains <paramref name="count" /> number of elements, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> viene eseguita la ricerca in avanti partire `startIndex` e fine `startIndex` plus `count` meno 1, se `count` è maggiore di 0.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="T:System.Collections.ArrayList" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="arrayList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which <c>value</c> should be inserted.</param>
        <param name="value">The <see cref="T:System.Object" /> to insert. The value can be <see langword="null" />.</param>
        <summary>Inserts an element into the <see cref="T:System.Collections.ArrayList" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 Se <xref:System.Collections.ArrayList.Count%2A> è già pari <xref:System.Collections.ArrayList.Capacity%2A>, la capacità del <xref:System.Collections.ArrayList> viene aumentata automaticamente la riallocazione della matrice interna, e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se `index` è uguale a <xref:System.Collections.ArrayList.Count%2A>, `value` viene aggiunto alla fine della <xref:System.Collections.ArrayList>.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come inserire elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> is greater than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public virtual void InsertRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InsertRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InsertRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member InsertRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.InsertRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.InsertRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which the new elements should be inserted.</param>
        <param name="c">The <see cref="T:System.Collections.ICollection" /> whose elements should be inserted into the <see cref="T:System.Collections.ArrayList" />. The collection itself cannot be <see langword="null" />, but it can contain elements that are <see langword="null" />.</param>
        <summary>Inserts the elements of a collection into the <see cref="T:System.Collections.ArrayList" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 Se il nuovo <xref:System.Collections.ArrayList.Count%2A> (corrente <xref:System.Collections.ArrayList.Count%2A> più le dimensioni della raccolta) sarà maggiore <xref:System.Collections.ArrayList.Capacity%2A>, la capacità del <xref:System.Collections.ArrayList> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e il gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.  
  
 Se `index` è uguale a <xref:System.Collections.ArrayList.Count%2A>, gli elementi vengono aggiunti alla fine della <xref:System.Collections.ArrayList>.  
  
 L'ordine degli elementi nel <xref:System.Collections.ICollection> viene mantenuta nella <xref:System.Collections.ArrayList>.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi da aggiungere e `m` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come inserire elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> is greater than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.ArrayList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Collections.ArrayList" /> has a fixed size.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.ArrayList" /> ha dimensioni fisse; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un wrapper di dimensione fissa per un' <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.ArrayList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Collections.ArrayList" /> is read-only.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.ArrayList" /> è di sola lettura; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un wrapper di sola lettura per un <xref:System.Collections.ArrayList> e come determinare se un <xref:System.Collections.ArrayList> è di sola lettura.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.ArrayList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ArrayList" /> is synchronized (thread safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ArrayList" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire la protezione del thread dei <xref:System.Collections.ArrayList>, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <xref:System.Collections.ArrayList.Synchronized%2A> metodo.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.ArrayList.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 Esempio di codice seguente viene illustrato come sincronizzare un <xref:System.Collections.ArrayList>, determinare se un' <xref:System.Collections.ArrayList> è sincronizzato e utilizzare un oggetto sincronizzato <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Collections.ArrayList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to get or set.</param>
        <summary>Gets or sets the element at the specified index.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Item%2A> restituisce <xref:System.Object>, pertanto potrebbe essere necessario eseguire il cast del valore restituito nel tipo originale per modificarlo. È importante notare che la <xref:System.Collections.ArrayList> non è una raccolta fortemente tipizzata. Per un'alternativa fortemente tipizzata, vedere <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[index]`.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.ArrayList.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.ArrayList.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Collections.ArrayList> e vengono aggiunti diversi elementi. Nell'esempio viene illustrato l'accesso agli elementi con il <xref:System.Collections.ArrayList.Item%2A> proprietà (l'indicizzatore in c#) e la modifica di un elemento tramite l'assegnazione di un nuovo valore per il <xref:System.Collections.ArrayList.Item%2A> proprietà per un indice specificato. L'esempio mostra anche che il <xref:System.Collections.ArrayList.Item%2A> proprietà non può essere utilizzata per accedere o aggiunta di elementi oltre le dimensioni correnti dell'elenco.  
  
 [!code-cpp[System.Collections.ArrayList.Item#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source.cs#1)]
 [!code-vb[System.Collections.ArrayList.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source.vb#1)]  
  
 L'esempio seguente usa il <xref:System.Collections.ArrayList.Item%2A> proprietà in modo esplicito per assegnare valori agli elementi nell'elenco. Nell'esempio viene definita una classe che eredita un <xref:System.Collections.ArrayList> e aggiunge un metodo per codificare gli elementi dell'elenco.  
  
 [!code-cpp[System.Collections.ArrayList.Item#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source2.cpp#2)]
 [!code-csharp[System.Collections.ArrayList.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source2.cs#2)]
 [!code-vb[System.Collections.ArrayList.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the zero-based index of the last occurrence of a value in the <see cref="T:System.Collections.ArrayList" /> or in a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj -&gt; int&#xA;override this.LastIndexOf : obj -&gt; int" Usage="arrayList.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the entire the <see cref="T:System.Collections.ArrayList" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina il primo elemento.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int -&gt; int&#xA;override this.LastIndexOf : obj * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that extends from the first element to the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` fino al primo elemento.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del <xref:System.Collections.ArrayList> a `startIndex`.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int * int -&gt; int&#xA;override this.LastIndexOf : obj * int * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified <see cref="T:System.Object" /> and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in the <see cref="T:System.Collections.ArrayList" /> that contains <paramref name="count" /> number of elements and ends at <paramref name="startIndex" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ArrayList> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e fine `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato. Si noti che `LastIndexOf` è una ricerca con le versioni precedenti, pertanto `count` deve essere minore o uguale a `startIndex` + 1.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="T:System.Collections.ArrayList" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadOnly">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a list wrapper that is read-only.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList ReadOnly(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ ReadOnly(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.ArrayList" /> to wrap.</param>
        <summary>Returns a read-only <see cref="T:System.Collections.ArrayList" /> wrapper.</summary>
        <returns>A read-only <see cref="T:System.Collections.ArrayList" /> wrapper around <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impedire eventuali modifiche apportate ai `list`, esporre `list` solo tramite il wrapper.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica della raccolta. Se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un wrapper di sola lettura per un <xref:System.Collections.ArrayList> e come determinare se un <xref:System.Collections.ArrayList> è di sola lettura.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.IList ReadOnly (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList ReadOnly(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ ReadOnly(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.IList" /> to wrap.</param>
        <summary>Returns a read-only <see cref="T:System.Collections.IList" /> wrapper.</summary>
        <returns>A read-only <see cref="T:System.Collections.IList" /> wrapper around <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impedire eventuali modifiche apportate ai `list`, esporre `list` solo tramite il wrapper.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica della raccolta. Se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="arrayList.Remove obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to remove from the <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Collections.ArrayList> non contiene l'oggetto specificato, il <xref:System.Collections.ArrayList> non subisce modifiche. Non viene generata alcuna eccezione.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 Questo metodo determina l'uguaglianza chiamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere elementi dal <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="arrayList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to remove.</param>
        <summary>Removes the element at the specified index of the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo l'elemento viene rimosso, le dimensioni della raccolta vengono modificate e il valore della <xref:System.Collections.ArrayList.Count%2A> proprietà viene ridotta di uno.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere elementi dal <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : int * int -&gt; unit&#xA;override this.RemoveRange : int * int -&gt; unit" Usage="arrayList.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range of elements to remove.</param>
        <param name="count">The number of elements to remove.</param>
        <summary>Removes a range of elements from the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere elementi dal <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <Member MemberName="Repeat">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Repeat (object value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Repeat(object value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Repeat (value As Object, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Repeat(System::Object ^ value, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : obj * int -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Repeat (value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to copy multiple times in the new <see cref="T:System.Collections.ArrayList" />. The value can be <see langword="null" />.</param>
        <param name="count">The number of times <c>value</c> should be copied.</param>
        <summary>Returns an <see cref="T:System.Collections.ArrayList" /> whose elements are copies of the specified value.</summary>
        <returns>An <see cref="T:System.Collections.ArrayList" /> with <paramref name="count" /> number of elements, all of which are copies of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un nuovo <xref:System.Collections.ArrayList> con lo stesso valore.  
  
 [!code-cpp[Classic ArrayList.Repeat Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Repeat Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Repeat Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reverses the order of the elements in the <see cref="T:System.Collections.ArrayList" /> or a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse();" />
      <MemberSignature Language="F#" Value="abstract member Reverse : unit -&gt; unit&#xA;override this.Reverse : unit -&gt; unit" Usage="arrayList.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverses the order of the elements in the entire <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi, in modo che l'elemento in corrispondenza <xref:System.Collections.ArrayList> [i], dove i è qualsiasi indice all'interno dell'intervallo viene spostato <xref:System.Collections.ArrayList> [j#], dove j è uguale a `index`  +  `index`  +  `count` - i - 1.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Reverse : int * int -&gt; unit&#xA;override this.Reverse : int * int -&gt; unit" Usage="arrayList.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to reverse.</param>
        <param name="count">The number of elements in the range to reverse.</param>
        <summary>Reverses the order of the elements in the specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi, in modo che l'elemento in corrispondenza <xref:System.Collections.ArrayList> [i], dove i è qualsiasi indice all'interno dell'intervallo viene spostato <xref:System.Collections.ArrayList> [j#], dove j è uguale a `index`  +  `index`  +  `count` - i - 1.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un intervallo di elementi in un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetRange">
      <MemberSignature Language="C#" Value="public virtual void SetRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member SetRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.SetRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.SetRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based <see cref="T:System.Collections.ArrayList" /> index at which to start copying the elements of <c>c</c>.</param>
        <param name="c">The <see cref="T:System.Collections.ICollection" /> whose elements to copy to the <see cref="T:System.Collections.ArrayList" />. The collection itself cannot be <see langword="null" />, but it can contain elements that are <see langword="null" />.</param>
        <summary>Copies the elements of a collection over a range of elements in the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> accetta `null` come un valore valido e consente elementi duplicati.  
  
 L'ordine degli elementi nel <xref:System.Collections.ICollection> viene mantenuta nella <xref:System.Collections.ArrayList>.  
  
 Questo metodo è un'operazione O (`n` + 1) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un intervallo di elementi nel <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> plus the number of elements in <paramref name="c" /> is greater than <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sorts the elements in the <see cref="T:System.Collections.ArrayList" /> or a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="arrayList.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sorts the elements in the entire <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, che utilizza l'algoritmo QuickSort. L'algoritmo QuickSort è un confronto di ordinamento (denominato anche ordinamento instabile), che significa che un "minore o uguale a" operazione di confronto determina quale dei due elementi deve trovarsi per primo nell'elenco ordinato finale. Tuttavia, se due elementi sono uguali, l'ordine originale potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali. Per eseguire un ordinamento stabile, è necessario implementare un oggetto personalizzato <xref:System.Collections.IComparer> interfaccia da utilizzare con gli altri overload di questo metodo.  
  
 In Media, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` viene <xref:System.Collections.ArrayList.Count%2A>; nel peggiore dei casi è un'operazione O (`n`^ 2) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Sort Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Sort Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Sort Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : System.Collections.IComparer -&gt; unit&#xA;override this.Sort : System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts the elements in the entire <see cref="T:System.Collections.ArrayList" /> using the specified comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il metodo <xref:System.Collections.ArrayList.Sort%2A> per ordinare un elenco di oggetti con un operatore di confronto personalizzato che implementa l'interfaccia <xref:System.Collections.IComparer>. Se si passa `null` per `comparer`, questo metodo utilizza l'implementazione <xref:System.IComparable> di ciascun elemento. In questo caso, è necessario assicurarsi che gli oggetti contenuti nell'elenco implementino l'interfaccia <xref:System.Collections.IComparer> o si verificherà un'eccezione.  
  
 Inoltre, l'utilizzo dell'implementazione <xref:System.IComparable> significa che nell'elenco viene eseguito un ordinamento di confronto, denominato anche ordinamento instabile, ossia è possibile che l'ordine di due elementi uguali non venga mantenuto. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali. Per eseguire un ordinamento stabile, è necessario implementare un oggetto personalizzato <xref:System.Collections.IComparer> interfaccia.  
  
 In Media, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` viene <xref:System.Collections.ArrayList.Count%2A>; nel peggiore dei casi è un'operazione O (`n`^ 2) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Collections.ArrayList> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CPP/arraylist_sort2.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CS/arraylist_sort2.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/VB/arraylist_sort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
        <exception cref="T:System.InvalidOperationException">An error occurred while comparing two elements.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> is passed for <paramref name="comparer" />, and the elements in the list do not implement <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (int index, int count, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(int32 index, int32 count, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (index As Integer, count As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(int index, int count, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : int * int * System.Collections.IComparer -&gt; unit&#xA;override this.Sort : int * int * System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to sort.</param>
        <param name="count">The length of the range to sort.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts the elements in a range of elements in <see cref="T:System.Collections.ArrayList" /> using the specified comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` è impostata su `null`, questo metodo esegue un ordinamento basato sul confronto (denominato anche ordinamento instabile), vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali. Per eseguire un ordinamento stabile, è necessario implementare un oggetto personalizzato <xref:System.Collections.IComparer> interfaccia.  
  
 In Media, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `count`; nel peggiore dei casi si tratta di un'operazione O(n^2).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un intervallo di elementi in un <xref:System.Collections.ArrayList> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CPP/arraylist_sort3.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CS/arraylist_sort3.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/VB/arraylist_sort3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.</exception>
        <exception cref="T:System.InvalidOperationException">An error occurred while comparing two elements.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Synchronized">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a list wrapper that is synchronized (thread safe).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Synchronized(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Synchronized(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.ArrayList" /> to synchronize.</param>
        <summary>Returns an <see cref="T:System.Collections.ArrayList" /> wrapper that is synchronized (thread safe).</summary>
        <returns>An <see cref="T:System.Collections.ArrayList" /> wrapper that is synchronized (thread safe).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire la thread-safe di <xref:System.Collections.ArrayList>, tutte le operazioni devono essere eseguite tramite questo wrapper.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.ArrayList.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Questo metodo è un'operazione o (1).  
  
 Esempio di codice seguente viene illustrato come sincronizzare un <xref:System.Collections.ArrayList>, determinare se un' <xref:System.Collections.ArrayList> è sincronizzato e utilizzare un oggetto sincronizzato <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.IList Synchronized (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList Synchronized(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ Synchronized(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.IList" /> to synchronize.</param>
        <summary>Returns an <see cref="T:System.Collections.IList" /> wrapper that is synchronized (thread safe).</summary>
        <returns>An <see cref="T:System.Collections.IList" /> wrapper that is synchronized (thread safe).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire la thread-safe di <xref:System.Collections.ArrayList>, tutte le operazioni devono essere eseguite tramite questo wrapper.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.ArrayList.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.ArrayList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare una versione sincronizzata della <xref:System.Collections.ArrayList>, utilizzare il <xref:System.Collections.ArrayList.Synchronized%2A> metodo. Tuttavia, le classi derivate possono fornire la propria versione sincronizzata della <xref:System.Collections.ArrayList> utilizzando il <xref:System.Collections.ArrayList.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni sul <xref:System.Collections.ArrayList.SyncRoot%2A> del <xref:System.Collections.ArrayList>, non direttamente sul <xref:System.Collections.ArrayList>. In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente il <xref:System.Collections.ArrayList> oggetto.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.ArrayList.SyncRoot%2A> durante l'intera enumerazione.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToArray">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies the elements of the <see cref="T:System.Collections.ArrayList" /> to a new array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="arrayList.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the elements of the <see cref="T:System.Collections.ArrayList" /> to a new <see cref="T:System.Object" /> array.</summary>
        <returns>An <see cref="T:System.Object" /> array containing copies of the elements of the <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati mediante <xref:System.Array.Copy%2A?displayProperty=nameWithType>, che è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual Array ToArray (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array ToArray(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ ToArray(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ToArray : Type -&gt; Array&#xA;override this.ToArray : Type -&gt; Array" Usage="arrayList.ToArray type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The element <see cref="T:System.Type" /> of the destination array to create and copy elements to.</param>
        <summary>Copies the elements of the <see cref="T:System.Collections.ArrayList" /> to a new array of the specified element type.</summary>
        <returns>An array of the specified element type containing copies of the elements of the <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli oggetti nel <xref:System.Collections.ArrayList> oggetto sarà possibile eseguire il cast di <xref:System.Type> specificato nel `type` parametro.  
  
 Gli elementi vengono copiati mediante <xref:System.Array.Copy%2A?displayProperty=nameWithType>, che è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 L'esempio di codice riportato di seguito viene illustrato copiare gli elementi di un <xref:System.Collections.ArrayList> a una matrice di stringhe.  
  
 [!code-cpp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CPP/arraylist_toarray.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CS/arraylist_toarray.cs#1)]
 [!code-vb[System.Collections.ArrayList.ToArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/VB/arraylist_toarray.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ArrayList" /> cannot be cast automatically to the specified type.</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="arrayList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the capacity to the actual number of elements in the <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta.  
  
 Per reimpostare un <xref:System.Collections.ArrayList> allo stato iniziale, chiamare il <xref:System.Collections.ArrayList.Clear%2A> metodo prima di chiamare <xref:System.Collections.ArrayList.TrimToSize%2A>. L'eliminazione di un oggetto vuoto <xref:System.Collections.ArrayList> imposta la capacità del <xref:System.Collections.ArrayList> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere le parti inutilizzate del <xref:System.Collections.ArrayList> e su come cancellare i valori del <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.ArrayList" /> is read-only.  -or-  The <see cref="T:System.Collections.ArrayList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.ArrayList.Clear" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
  </Members>
</Type>