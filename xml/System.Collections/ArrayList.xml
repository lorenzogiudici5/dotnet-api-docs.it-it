<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ArrayList.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a105732aa94698f5ea781b6eed29feca20656b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a105732aa94698f5ea781b6eed29feca20656b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> interface using an array whose size is dynamically increased as required.</source>
          <target state="translated">Implementa l'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>, utilizzando una matrice le cui dimensioni sono incrementate in modo dinamico in base alle esigenze.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class is designed to hold heterogeneous collections of objects.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> classe è progettata per contenere raccolte eterogenee di oggetti.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>However, it does not always offer the best performance.</source>
          <target state="translated">Tuttavia, non sempre offre le migliori prestazioni.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Instead, we recommend the following:</source>
          <target state="translated">Al contrario, si consiglia quanto segue:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a heterogeneous collection of objects, use the <ph id="ph1">`List&lt;Object&gt;`</ph> (in C#) or <ph id="ph2">`List(Of Object)`</ph> (in Visual Basic) type.</source>
          <target state="translated">Per un insieme eterogeneo di oggetti, utilizzare il <ph id="ph1">`List&lt;Object&gt;`</ph> (in c#) o <ph id="ph2">`List(Of Object)`</ph> digitare (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For a homogeneous collection of objects, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">Per una raccolta omogenea di oggetti, utilizzare la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>See the "Performance Considerations" section in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> reference topic for a discussion of the relative performance of these classes.</source>
          <target state="translated">Nella sezione "Considerazioni sulle prestazioni" il <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> argomento di riferimento per una discussione sulle prestazioni relative di queste classi.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non è garantito da ordinare.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> by calling its <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method prior to performing operations (such as <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) that require the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> to be sorted.</source>
          <target state="translated">È necessario ordinare il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> chiamando relativo <ph id="ph2">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> metodo prima di eseguire le operazioni (ad esempio <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph>) che richiedono il <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> da ordinare.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To maintain a collection that is automatically sorted as new elements are added, you can use the <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> class.</source>
          <target state="translated">Per mantenere una raccolta che verrà automaticamente ordinata come vengono aggiunti nuovi elementi, è possibile utilizzare la <ph id="ph1">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacità di un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> è il numero di elementi di <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Quando gli elementi vengono aggiunti a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, incrementata automaticamente in base alle necessità, tramite riallocazione.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">È possibile diminuire la capacità chiamando <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o impostando la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> proprietà in modo esplicito.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Per grandi <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il <ph id="ph2">`enabled`</ph> attributo dell'elemento di configurazione per <ph id="ph3">`true`</ph> nell'ambiente di runtime.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Elementi nella raccolta è accessibile tramite un indice intero.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Gli indici in questa raccolta sono in base zero.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection accepts <ph id="ph2">`null`</ph> as a valid value.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> raccolta accetta <ph id="ph2">`null`</ph> come un valore valido.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>It also allows duplicate elements.</source>
          <target state="translated">Consente, inoltre, gli elementi duplicati.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Using multidimensional arrays as elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> collection is not supported.</source>
          <target state="translated">Utilizzo di matrici multidimensionali come elementi in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> raccolta non è supportata.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>The following code example shows how to create and initialize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to display its values.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e come visualizzare i relativi valori.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Statici pubblici (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) di questo tipo sono thread-safe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">I membri di istanza non sono garantiti come thread-safe.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can support multiple readers concurrently, as long as the collection is not modified.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> può supportare più lettori contemporaneamente, fino a quando non è possibile modificare la raccolta.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> method.</source>
          <target state="translated">Per garantire la thread-safe di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <ph id="ph2">&lt;see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.ArrayList">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the default initial capacity.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> vuota e con capacità iniziale predefinita.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacità di un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> è il numero di elementi che la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Quando gli elementi vengono aggiunti a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Questo costruttore è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements are copied to the new list.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> i cui elementi vengono copiati nel nuovo elenco.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that contains elements copied from the specified collection and that has the same initial capacity as the number of elements copied.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che contiene gli elementi copiati dalla raccolta specificata e ha la stessa capacità iniziale definita dal numero degli elementi copiati.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacità di un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> è il numero di elementi che la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Quando gli elementi vengono aggiunti a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in the same order they are read by the <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> of the <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> nello stesso ordine in cui vengono letti dal <ph id="ph2">&lt;xref:System.Collections.IEnumerator&gt;</ph> del <ph id="ph3">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`c`</ph>.</source>
          <target state="translated">Questo costruttore è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi in <ph id="ph3">`c`</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The number of elements that the new list can initially store.</source>
          <target state="translated">Numero di elementi che possono essere archiviati inizialmente nel nuovo elenco.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> class that is empty and has the specified initial capacity.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> vuota e con capacità iniziale specificata.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>The capacity of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can hold.</source>
          <target state="translated">La capacità di un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> è il numero di elementi che la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>As elements are added to an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Quando gli elementi vengono aggiunti a un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Questo costruttore è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper for a specific <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Consente di creare un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> per un'interfaccia <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> specifica.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> per <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> does not copy the contents of <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> non copiare il contenuto di <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Instead, it only creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper around <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; therefore, changes to the <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> also affect the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Invece, viene creato solo un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>; pertanto, diventa il <ph id="ph3">&lt;xref:System.Collections.IList&gt;</ph> influenzare la <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> class provides generic <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> methods.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> fornisce è generica <ph id="ph2">&lt;xref:System.Collections.ArrayList.Reverse%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This wrapper can be a means to use those methods on <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; however, performing these generic operations through the wrapper might be less efficient than operations applied directly on the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Il wrapper può costituire un modo per utilizzare questi metodi su <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>; tuttavia, svolgimento di queste operazioni tramite il wrapper generiche potrebbe rivelarsi meno efficiente dell'applicazione direttamente su operazioni di <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilità tra versioni</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the .NET Framework version 1.0 and 1.1, calling the <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> method overload on the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned an enumerator that treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, la chiamata di <ph id="ph1">&lt;xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo nel <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper ha restituito un enumeratore che è considerato il secondo argomento un limite superiore anziché come un numero.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> il secondo argomento correttamente viene considerato come un numero.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Adapter(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da aggiungere alla fine della classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Aggiunge un oggetto alla fine di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> has been added.</source>
          <target state="translated">Indice <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in corrispondenza del quale è stato aggiunto <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è già uguale <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacità del <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è minore di <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come aggiungere elementi al <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> i cui elementi devono essere aggiunti alla fine di <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'insieme non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ma può contenere elementi <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>Adds the elements of an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Consente di aggiungere gli elementi di un <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> alla fine di <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">L'ordine degli elementi di <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> viene mantenuta nella <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Se il nuovo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (corrente <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> più le dimensioni della raccolta) sarà maggiore <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacità del <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> can accommodate the new elements without increasing the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, this method is an O(<ph id="ph3">`n`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> può contenere i nuovi elementi senza aumentare il <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, questo metodo è un'operazione O (<ph id="ph3">`n`</ph>) operazione, in cui <ph id="ph4">`n`</ph> è il numero di elementi da aggiungere.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>If the capacity needs to be increased to accommodate the new elements, this method becomes an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Se la capacità deve essere aumentato di conseguenza i nuovi elementi, questo metodo diventa un'operazione O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operazione, in cui <ph id="ph4">`n`</ph> è il numero di elementi da aggiungere e <ph id="ph5">`m`</ph> è <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The following code example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come aggiungere elementi al <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Uses a binary search algorithm to locate a specific element in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Viene usato un algoritmo di ricerca binario per individuare un elemento specifico nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato o in una parte di esso.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the default comparer and returns the zero-based index of the element.</source>
          <target state="translated">Cerca un elemento nell'intero <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato usando l'operatore di confronto predefinito e restituisce l'indice in base zero dell'elemento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Indice di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> a base zero nell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato, se viene rilevato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter and each element of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Il <ph id="ph1">`value`</ph> parametro e ogni elemento del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaccia, che viene utilizzata per i confronti.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Confronto tra <ph id="ph1">`null`</ph> è consentita con qualsiasi tipo e non genera un'eccezione quando si utilizza <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante l'ordinamento, <ph id="ph1">`null`</ph> viene considerato minore rispetto a qualsiasi altro oggetto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Quando si inserisce il valore nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> to locate a specific object in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come utilizzare <ph id="ph1">&lt;xref:System.Collections.ArrayList.BinarySearch%2A&gt;</ph> per individuare un oggetto specifico di <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source>Neither <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> e gli elementi di <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> non implementano l'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non è dello stesso tipo degli elementi di <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per utilizzare l'operatore di confronto predefinito che è l'implementazione  <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ogni elemento.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Cerca un elemento nell'intero <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Indice di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> a base zero nell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato, se viene rilevato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> istanza come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> viene fornito, gli elementi del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementazione fornita dall'elemento stesso o dal valore specificato.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Confronto tra <ph id="ph1">`null`</ph> è consentita con qualsiasi tipo e non genera un'eccezione quando si utilizza <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante l'ordinamento, <ph id="ph1">`null`</ph> viene considerato minore rispetto a qualsiasi altro oggetto.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Quando si inserisce il valore nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> of colored animals.</source>
          <target state="translated">Nell'esempio seguente viene creato un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> di animali colorati.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The provided <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> performs the string comparison for the binary search.</source>
          <target state="translated">L'oggetto fornito <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> esegue il confronto tra stringhe per la ricerca binaria.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source>The results of both an iterative search and a binary search are displayed.</source>
          <target state="translated">Vengono visualizzati i risultati di una ricerca iterativa sia una ricerca binaria.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> e gli elementi di <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> non implementano l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> non è dello stesso tipo degli elementi di <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to search.</source>
          <target state="translated">Indice iniziale in base zero dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Lunghezza dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer that is the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per utilizzare l'operatore di confronto predefinito che è l'implementazione  <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ogni elemento.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Cerca un elemento in un intervallo di elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">Indice di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> a base zero nell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ordinato, se viene rilevato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <ph id="ph5">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> istanza come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> viene fornito, gli elementi del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementazione fornita dall'elemento stesso o dal valore specificato.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Comparing <ph id="ph1">`null`</ph> with any type is allowed and does not generate an exception when using <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Confronto tra <ph id="ph1">`null`</ph> è consentita con qualsiasi tipo e non genera un'eccezione quando si utilizza <ph id="ph2">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Durante l'ordinamento, <ph id="ph1">`null`</ph> viene considerato minore rispetto a qualsiasi altro oggetto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Quando si inserisce il valore nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non identificano un intervallo valido in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and neither <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nor the elements of <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> e gli elementi di <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> non implementano l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not of the same type as the elements of the <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> non è dello stesso tipo degli elementi di <ph id="ph4">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>Gets or sets the number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">Ottiene o imposta il numero di elementi che <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> can contain.</source>
          <target state="translated">Numero degli elementi che <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> può contenere.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> è il numero di elementi che la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può archiviare.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è il numero di elementi effettivamente contenuti nella <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> è sempre maggiore di o uguale a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>The capacity can be decreased by calling <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or by setting the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">È possibile diminuire la capacità chiamando <ph id="ph1">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o impostando la <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> proprietà in modo esplicito.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</source>
          <target state="translated">Quando il valore di <ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the new capacity.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione o (1). l'impostazione della proprietà è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è la nuova capacità.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source><ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="P:System.Collections.ArrayList.Capacity" /&gt;</ph> è impostato su un valore minore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">La memoria disponibile nel sistema non è sufficiente.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Rimuove tutti gli elementi da <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> remains unchanged.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> rimane invariato.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, call <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> or set the <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> property directly.</source>
          <target state="translated">Per reimpostare la capacità del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, chiamare <ph id="ph2">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph> o impostare il <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> proprietà direttamente.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">L'eliminazione di un oggetto vuoto <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> imposta la capacità del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> per la capacità predefinita.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clear">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">L'esempio di codice seguente viene illustrato come le parti inutilizzate di tagliare la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e su come cancellare i valori del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Crea una copia superficiale di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Copia superficiale di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Una copia superficiale di un insieme di copia solo gli elementi della raccolta, se sono tipi di riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nella raccolta originale.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Determina se un elemento è incluso in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="item" /&gt;</ph> è presente in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it to a one-dimensional array.</source>
          <target state="translated">Copia <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o una parte di esso in una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">L'indicizzazione di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve essere in base zero.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the beginning of the target array.</source>
          <target state="translated">Copia l'intero oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in un oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale compatibile, a partire dall'inizio della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matrice specificata deve essere di un tipo compatibile.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Questo metodo utilizza <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> per copiare gli elementi.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati il <ph id="ph1">&lt;xref:System.Array&gt;</ph> nello stesso ordine in cui l'enumeratore scorre la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in una matrice unidimensionale <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the number of elements that the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph> can contain.</source>
          <target state="translated">Il numero di elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine è maggiore del numero di elementi che l'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione può contenere.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast automatico del tipo dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">L'indicizzazione di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve essere in base zero.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Indice in base zero in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale ha inizio la copia.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia l'intero oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in un oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matrice specificata deve essere di un tipo compatibile.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Questo metodo utilizza <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> per copiare gli elementi.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati il <ph id="ph1">&lt;xref:System.Array&gt;</ph> nello stesso ordine in cui l'enumeratore scorre la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in una matrice unidimensionale <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Il numero di elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine è maggiore dello spazio disponibile tra <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> e la fine dell'oggetto <ph id="ph3">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast automatico del tipo dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at which copying begins.</source>
          <target state="translated">Indice in base zero dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine a partire dal quale viene effettuata la copia.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">L'indicizzazione di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> deve essere in base zero.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Indice in base zero in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale ha inizio la copia.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements to copy.</source>
          <target state="translated">Numero degli elementi da copiare.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copia una serie di elementi da <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in un oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">La matrice specificata deve essere di un tipo compatibile.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Questo metodo utilizza <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> per copiare gli elementi.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati il <ph id="ph1">&lt;xref:System.Array&gt;</ph> nello stesso ordine in cui l'enumeratore scorre la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> in una matrice unidimensionale <ph id="ph2">&lt;xref:System.Array?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than the <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> of the source <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è maggiore o uguale al valore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is greater than the available space from <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Il numero di elementi da <ph id="ph1">&lt;paramref name="index" /&gt;</ph> alla fine dell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine è maggiore dello spazio disponibile da <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> alla fine dell'oggetto <ph id="ph4">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast automatico del tipo dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Count">
          <source>Gets the number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Ottiene il numero di elementi effettivamente contenuti nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>The number of elements actually contained in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Numero di elementi effettivamente contenuti nell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> è il numero di elementi che la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> può archiviare.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è il numero di elementi effettivamente contenuti nella <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> è sempre maggiore di o uguale a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper with a fixed size, where elements are allowed to be modified, but not added or removed.</source>
          <target state="translated">Restituisce un wrapper di elenco di dimensioni fisse, dove gli elementi possono essere modificati, ma non aggiunti o rimossi.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Restituisce un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Questo wrapper può essere utilizzato per evitare di aggiunte o eliminazioni dall'originale <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Gli elementi possono comunque essere modificati o sostituiti.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come creare un wrapper di dimensioni fisse per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Restituisce un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper with a fixed size.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This wrapper can be used to prevent additions to and deletions from the original <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</source>
          <target state="translated">Questo wrapper può essere utilizzato per evitare di aggiunte o eliminazioni dall'originale <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>The elements can still be modified or replaced.</source>
          <target state="translated">Gli elementi possono comunque essere modificati o sostituiti.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Restituisce un enumeratore che esegue l'iterazione di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Returns an enumerator for the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Viene restituito un enumeratore per l'intero <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per l'intera <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">L'istruzione <ph id="ph1">`foreach`</ph> del linguaggio C# (<ph id="ph2">`for each`</ph> in Visual Basic) nasconde la complessità degli enumeratori.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Pertanto, si consiglia l'utilizzo di <ph id="ph1">`foreach`</ph>, anziché la modifica diretta dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated">Anche il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> riporta l'enumeratore in questa posizione.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">In questa posizione, la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è indefinita.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Pertanto, è necessario chiamare il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> restituisce lo stesso oggetto finché non viene chiamato il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> imposta <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sull'elemento successivo.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituisce <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituire anche <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Se l'ultima chiamata a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituito <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è definito.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Per impostare nuovamente la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sul primo elemento della raccolta, è possibile chiamare il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguito da <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente ottiene l'enumeratore per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, l'enumeratore per un intervallo di elementi e il <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The zero-based starting index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">Indice iniziale a base zero della sezione di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cui l'enumeratore deve fare riferimento.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> section that the enumerator should refer to.</source>
          <target state="translated">Numero di elementi nella sezione di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cui l'enumeratore deve fare riferimento.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Returns an enumerator for a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Restituisce un enumeratore per uno specifico intervallo di elementi nella classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the specified range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per l'intervallo di elementi specificato nella classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Il <ph id="ph1">`foreach`</ph> istruzione del linguaggio c# (<ph id="ph2">`for each`</ph> in Visual C++, <ph id="ph3">`For Each`</ph> Visual Basic) nasconde la complessità degli enumeratori.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Pertanto, si consiglia l'utilizzo di <ph id="ph1">`foreach`</ph>, anziché la modifica diretta dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated">Anche il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> riporta l'enumeratore in questa posizione.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">In questa posizione, la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è indefinita.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Pertanto, è necessario chiamare il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> restituisce lo stesso oggetto finché non viene chiamato il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> imposta <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sull'elemento successivo.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituisce <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituire anche <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Se l'ultima chiamata a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituito <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è definito.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Per impostare nuovamente la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sul primo elemento della raccolta, è possibile chiamare il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguito da <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilità tra versioni</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the .NET Framework versions 1.0 and 1.1, the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> method treated the second argument as an upper bound rather than as a count.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, l'enumeratore per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> wrapper restituito dal <ph id="ph2">&lt;xref:System.Collections.ArrayList.Adapter%2A&gt;</ph> metodo trattato il secondo argomento un limite superiore anziché come un numero.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> the second argument is correctly treated as a count.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> il secondo argomento correttamente viene considerato come un numero.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>The following example gets the enumerator for an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, and the enumerator for a range of elements in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente ottiene l'enumeratore per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, l'enumeratore per un intervallo di elementi e il <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which the range starts.</source>
          <target state="translated">Indice in base zero di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in corrispondenza del quale inizia la serie.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The number of elements in the range.</source>
          <target state="translated">Numero di elementi nell'intervallo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Viene restituito un <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che rappresenta un sottoinsieme degli elementi del <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> which represents a subset of the elements in the source <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che rappresenta un sottoinsieme degli elementi del <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method does not create copies of the elements.</source>
          <target state="translated">Questo metodo non crea copie degli elementi.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is only a view window into the source <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Il nuovo <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> è solo una finestra di visualizzazione nell'origine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>However, all subsequent changes to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> must be done through this view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Tuttavia, tutte le modifiche successive all'origine <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> devono essere eseguite tramite questa finestra di visualizzazione <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>If changes are made directly to the source <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, the view window <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is invalidated and any operations on it will return an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Se vengono apportate modifiche direttamente all'origine <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, la finestra di visualizzazione <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> viene invalidato e qualsiasi operazione su di essa verranno restituito un <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come impostare e ottenere un intervallo di elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non identificano un intervallo valido di elementi in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the first occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Restituisce l'indice in base zero della prima occorrenza di un valore in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o in una parte di esso.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cerca l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intero insieme <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intero oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (zero) è valido in un elenco vuoto.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Consente di cercare l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi della classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> compreso tra l'indice specificato e l'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi dell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> compreso tra <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultimo elemento, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> viene eseguita la ricerca in avanti a partire da <ph id="ph2">`startIndex`</ph> e termina con l'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi da <ph id="ph3">`startIndex`</ph> alla fine del <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (zero) è valido in un elenco vuoto.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Ricerca l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi della classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che inizia dall'indice specificato e contiene il numero specificato di elementi.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains <ph id="ph4">&lt;paramref name="count" /&gt;</ph> number of elements, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi dell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che inizia da <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e contiene il numero di elementi corrispondente a <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> viene eseguita la ricerca in avanti a partire da <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> più <ph id="ph4">`count`</ph> -1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the first occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice della prima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Indice in base zero in corrispondenza del quale deve essere inserito <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to insert.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da inserire.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>Inserts an element into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserisce un elemento in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> è già uguale <ph id="ph2">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacità del <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`index`</ph> è uguale a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> viene aggiunto alla fine di <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come inserire elementi nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è maggiore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based index at which the new elements should be inserted.</source>
          <target state="translated">Indice in base zero in corrispondenza del quale devono essere inseriti i nuovi elementi.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements should be inserted into the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> i cui elementi devono essere inseriti in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'insieme non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ma può contenere elementi <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>Inserts the elements of a collection into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserisce gli elementi di una raccolta in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Se il nuovo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> (corrente <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> più le dimensioni della raccolta) sarà maggiore <ph id="ph3">&lt;xref:System.Collections.ArrayList.Capacity%2A&gt;</ph>, la capacità del <ph id="ph4">&lt;xref:System.Collections.ArrayList&gt;</ph> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, the elements are added to the end of <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`index`</ph> è uguale a <ph id="ph2">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>, gli elementi vengono aggiunti alla fine di <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">L'ordine degli elementi di <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> viene mantenuta nella <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements to be added and <ph id="ph5">`m`</ph> is <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operazione, in cui <ph id="ph4">`n`</ph> è il numero di elementi da aggiungere e <ph id="ph5">`m`</ph> è <ph id="ph6">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to insert elements into the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come inserire elementi nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è maggiore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Ottiene un valore che indica se <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> ha dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di dimensioni fisse; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsFixedSize">
          <source>The following code example shows how to create a fixed-size wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come creare un wrapper di dimensioni fisse per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">Ottiene un valore che indica se <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsReadOnly">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare un wrapper di sola lettura per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e come determinare se un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Ottiene un valore che indica se l'accesso a <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è sincronizzato (thread-safe).</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'accesso a <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è sincronizzato (thread-safe); in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through the wrapper returned by the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Per garantire la thread-safe di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.IsSynchronized">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come sincronizzare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinare se un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> è sincronizzato e utilizzare un oggetto sincronizzato <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">Indice in base zero dell'elemento da ottenere o impostare.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Elemento in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> returns an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, so you may need to cast the returned value to the original type in order to manipulate it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> restituisce <ph id="ph2">&lt;xref:System.Object&gt;</ph>, pertanto potrebbe essere necessario eseguire il cast del valore restituito nel tipo originale per modificarlo.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>It is important to note that <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is not a strongly-typed collection.</source>
          <target state="translated">È importante notare che la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non è una raccolta fortemente tipizzata.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>For a strongly-typed alternative, see <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Per un'alternativa fortemente tipizzata, vedere <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property.</source>
          <target state="translated">Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">In Visual Basic la proprietà <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione o (1). l'impostazione della proprietà è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following code example creates an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds several items.</source>
          <target state="translated">L'esempio di codice seguente crea un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e vengono aggiunti diversi elementi.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example demonstrates accessing elements with the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property (the indexer in C#), and changing an element by assigning a new value to the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property for a specified index.</source>
          <target state="translated">Nell'esempio viene illustrato l'accesso agli elementi con il <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> proprietà (l'indicizzatore in c#) e la modifica di un elemento tramite l'assegnazione di un nuovo valore per il <ph id="ph2">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> proprietà per un indice specificato.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example also shows that the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property cannot be used to access or add elements outside the current size of the list.</source>
          <target state="translated">L'esempio mostra anche che il <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> proprietà non può essere utilizzata per l'accesso o l'aggiunta di elementi oltre le dimensioni dell'elenco corrente.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> property explicitly to assign values to items in the list.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Collections.ArrayList.Item%2A&gt;</ph> proprietà in modo esplicito per assegnare valori agli elementi nell'elenco.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>The example defines a class that inherits an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and adds a method to scramble the list items.</source>
          <target state="translated">Nell'esempio viene definita una classe che eredita un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e aggiunge un metodo per codificare gli elementi dell'elenco.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns the zero-based index of the last occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Restituisce l'indice in base zero dell'ultima occorrenza di un valore in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o in una parte di esso.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Consente di cercare l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'insieme <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intero oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>, se presente; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Consente di cercare l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi della classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> compreso tra il primo elemento e l'indice specificato.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi dell'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> compreso tra il primo elemento e <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, se presente; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi dall'inizio del <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> a <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da individuare in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Consente di cercare l'oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi della classe <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> that contains <ph id="ph3">&lt;paramref name="count" /&gt;</ph> number of elements and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> che contiene un numero di elementi corrispondente a <ph id="ph3">&lt;paramref name="count" /&gt;</ph> e termina in corrispondenza di <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> meno <ph id="ph4">`count`</ph> + 1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">A partire da .NET Framework 2.0, questo metodo utilizza degli oggetti della raccolta <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi su <ph id="ph3">`item`</ph> per determinare se esiste un elemento.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`LastIndexOf`</ph> is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to <ph id="ph3">`startIndex`</ph> + 1.</source>
          <target state="translated">Si noti che <ph id="ph1">`LastIndexOf`</ph> è una ricerca con le versioni precedenti, pertanto, <ph id="ph2">`count`</ph> deve essere minore o uguale a <ph id="ph3">`startIndex`</ph> + 1.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is read-only.</source>
          <target state="translated">Restituisce un wrapper di elenco di sola lettura.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper.</source>
          <target state="translated">Restituisce un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di sola lettura.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di sola lettura di <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Per evitare che venga <ph id="ph1">`list`</ph>, esporre <ph id="ph2">`list`</ph> solo tramite il wrapper.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che ne impedisce la modifica della raccolta.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source>The following code example shows how to create a read-only wrapper around an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is read-only.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare un wrapper di sola lettura per un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e come determinare se un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to wrap.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper.</source>
          <target state="translated">Restituisce un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di sola lettura.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper around <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> di sola lettura di <ph id="ph2">&lt;paramref name="list" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>To prevent any modifications to <ph id="ph1">`list`</ph>, expose <ph id="ph2">`list`</ph> only through this wrapper.</source>
          <target state="translated">Per evitare che venga <ph id="ph1">`list`</ph>, esporre <ph id="ph2">`list`</ph> solo tramite il wrapper.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection.</source>
          <target state="translated">Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che ne impedisce la modifica della raccolta.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>If changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to remove from the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da rimuovere da <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Rimuove la prima occorrenza di un oggetto specifico da <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> does not contain the specified object, the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> remains unchanged.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> non contiene l'oggetto specificato, il <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> rimane invariato.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo determina l'uguaglianza chiamando <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come rimuovere elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">Indice in base zero dell'elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Rimuove l'elemento in corrispondenza dell'indice specificato di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>After the element is removed, the size of the collection is adjusted and the value of the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> property is decreased by one.</source>
          <target state="translated">Dopo l'elemento viene rimosso, le dimensioni della raccolta vengono modificate e il valore della <ph id="ph1">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph> proprietà viene ridotta di uno.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come rimuovere elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range of elements to remove.</source>
          <target state="translated">Indice iniziale in base zero dell'intervallo di elementi da rimuovere.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The number of elements to remove.</source>
          <target state="translated">Numero di elementi da rimuovere.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>Removes a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Rimuove un intervallo di elementi da <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The following code example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come rimuovere elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non identificano un intervallo valido di elementi in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to copy multiple times in the new <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> da copiare più volte nel nuovo <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be copied.</source>
          <target state="translated">Numero di volte che <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> deve essere copiato.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> whose elements are copies of the specified value.</source>
          <target state="translated">Viene restituito un <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> i cui elementi sono copie del valore specificato.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> with <ph id="ph2">&lt;paramref name="count" /&gt;</ph> number of elements, all of which are copies of <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> con un numero di elementi pari a <ph id="ph2">&lt;paramref name="count" /&gt;</ph>, dei quali tutti sono copie di <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source>The following code example shows how to create and initialize a new <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> with the same value.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare una nuova <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> con lo stesso valore.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Reverses the order of the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Inverte l'ordine degli elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o di una parte di esso.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>Reverses the order of the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Inverte l'ordine degli elementi nell'intero <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Questo metodo Usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> per invertire l'ordine degli elementi, in modo che l'elemento in corrispondenza <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], dove i è un indice all'interno dell'intervallo, viene spostato <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j#], dove j equivale <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse">
          <source>The following code example shows how to reverse the sort order of the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range to reverse.</source>
          <target state="translated">Indice iniziale in base zero dell'intervallo da invertire.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The number of elements in the range to reverse.</source>
          <target state="translated">Numero di elementi nell'intervallo da invertire.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>Reverses the order of the elements in the specified range.</source>
          <target state="translated">Inverte l'ordine degli elementi nell'intervallo specificato.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements, such that the element at <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], where i is any index within the range, moves to <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j], where j equals <ph id="ph4">`index`</ph><ph id="ph5"> + </ph><ph id="ph6">`index`</ph><ph id="ph7"> + </ph><ph id="ph8">`count`</ph> - i - 1.</source>
          <target state="translated">Questo metodo Usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> per invertire l'ordine degli elementi, in modo che l'elemento in corrispondenza <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> [i], dove i è un indice all'interno dell'intervallo, viene spostato <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> [j#], dove j equivale <ph id="ph4">`index`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`index`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`count`</ph> - i - 1.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort order of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un intervallo di elementi in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non identificano un intervallo valido di elementi in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> index at which to start copying the elements of <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Indice in base zero di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in corrispondenza del quale iniziare a copiare gli elementi di <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> whose elements to copy to the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> i cui elementi vengono copiati in <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'insieme non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ma può contenere elementi <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>Copies the elements of a collection over a range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Consente di copiare gli elementi di un insieme su un intervallo di elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> accetta <ph id="ph2">`null`</ph> come un valore valido e consente elementi duplicati.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The order of the elements in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is preserved in the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">L'ordine degli elementi di <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> viene mantenuta nella <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>This method is an O(<ph id="ph1">`n`</ph> + 1) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph> + 1) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The following code example shows how to set and get a range of elements in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come impostare e ottenere un intervallo di elementi di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> plus the number of elements in <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is greater than <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> più il numero di elementi in <ph id="ph2">&lt;paramref name="c" /&gt;</ph> è maggiore di <ph id="ph3">&lt;see cref="P:System.Collections.ArrayList.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Sorts the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Ordina gli elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> o di una parte di esso.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Ordina gli elementi dell'intero oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, which uses the QuickSort algorithm.</source>
          <target state="translated">Questo metodo utilizza <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, che utilizza l'algoritmo QuickSort.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The QuickSort algorithm is a comparison sort (also called an unstable sort), which means that a "less than or equal to" comparison operation determines which of two elements should occur first in the final sorted list.</source>
          <target state="translated">L'algoritmo QuickSort è un confronto di ordinamento (denominato anche ordinamento instabile), il che significa che un "minore o uguale a" operazione di confronto determina quale dei due elementi deve trovarsi per primo nell'elenco ordinato finale.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>However, if two elements are equal, their original order might not be preserved.</source>
          <target state="translated">Tuttavia, se due elementi sono uguali, l'ordine originale potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface to use with the other overloads of this method.</source>
          <target state="translated">Per eseguire un ordinamento stabile, è necessario implementare una classe personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaccia da utilizzare con gli altri overload di questo metodo.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">In Media, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; nel peggiore dei casi si tratta di un'operazione O (<ph id="ph5">`n`</ph>^ 2) operazione.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Riferimento Null (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) per utilizzare l'implementazione di <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ogni elemento.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordina gli elementi dell'intero <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> usando l'operatore di confronto specificato.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> method to  sort a list of objects with a custom comparer that implements the <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Utilizzare il metodo <ph id="ph1">&lt;xref:System.Collections.ArrayList.Sort%2A&gt;</ph> per ordinare un elenco di oggetti con un operatore di confronto personalizzato che implementa l'interfaccia <ph id="ph2">&lt;xref:System.Collections.IComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`comparer`</ph>, this method uses the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation of each element.</source>
          <target state="translated">Se si passa <ph id="ph1">`null`</ph> per <ph id="ph2">`comparer`</ph>, questo metodo utilizza l'implementazione <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In this case, you must make sure that the objects contained in the list implement the <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface or an exception will occur.</source>
          <target state="translated">In questo caso, è necessario assicurarsi che gli oggetti contenuti nell'elenco implementino l'interfaccia <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> o si verificherà un'eccezione.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In addition, using the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation means the list performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Inoltre, l'utilizzo dell'implementazione <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> significa che nell'elenco viene eseguito un ordinamento di confronto, denominato anche ordinamento instabile, ossia è possibile che l'ordine di due elementi uguali non venga mantenuto.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Per eseguire un ordinamento stabile, è necessario implementare una classe personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; in the worst case it is an O(<ph id="ph5">`n`</ph>^2) operation.</source>
          <target state="translated">In Media, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>; nel peggiore dei casi si tratta di un'operazione O (<ph id="ph5">`n`</ph>^ 2) operazione.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Si è verificato un errore durante il confronto tra due elementi.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is passed for <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph>, and the elements in the list do not implement <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> viene specificato per <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> e gli elementi nell'elenco non implementano <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The zero-based starting index of the range to sort.</source>
          <target state="translated">Indice iniziale in base zero dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The length of the range to sort.</source>
          <target state="translated">Lunghezza dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">Riferimento Null (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) per utilizzare l'implementazione di <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ogni elemento.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordina gli elementi di un intervallo di elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> usando l'operatore di confronto specificato.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is set to <ph id="ph2">`null`</ph>, this method performs a comparison sort (also called an unstable sort); that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è impostato su <ph id="ph2">`null`</ph>, questo metodo esegue un ordinamento basato sul confronto (denominato anche ordinamento instabile), vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>To perform a stable sort, you must implement a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interface.</source>
          <target state="translated">Per eseguire un ordinamento stabile, è necessario implementare una classe personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>On average, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`count`</ph>; in the worst case it is an O(n^2) operation.</source>
          <target state="translated">In Media, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`count`</ph>; nel peggiore dei casi si tratta di un'operazione O(n^2).</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in a range of elements in an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un intervallo di elementi in un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
          <source>An error occurred while comparing two elements.</source>
          <target state="translated">Si è verificato un errore durante il confronto tra due elementi.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Returns a list wrapper that is synchronized (thread safe).</source>
          <target state="translated">Restituisce un wrapper sincronizzato (thread-safe).</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to synchronize.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> da sincronizzare.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Restituisce un wrapper sincronizzato (thread-safe) per la classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Wrapper sincronizzato (thread-safe) per la classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Per garantire la thread-safe di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, tutte le operazioni devono essere eseguite tramite questo wrapper.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source>The following code example shows how to synchronize an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determine if an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> is synchronized and use a synchronized <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come sincronizzare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, determinare se un <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> è sincronizzato e utilizzare un oggetto sincronizzato <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> to synchronize.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> da sincronizzare.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Restituisce un wrapper sincronizzato (thread-safe) per la classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> wrapper that is synchronized (thread safe).</source>
          <target state="translated">Wrapper sincronizzato (thread-safe) per la classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee the thread safety of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, all operations must be done through this wrapper.</source>
          <target state="translated">Per garantire la thread-safe di <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, tutte le operazioni devono essere eseguite tramite questo wrapper.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)">
          <source><ph id="ph1">&lt;paramref name="list" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="list" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Oggetto che può essere usato per sincronizzare l'accesso a <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Per creare una versione sincronizzata del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph>, utilizzare il <ph id="ph2">&lt;xref:System.Collections.ArrayList.Synchronized%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Tuttavia, le classi derivate possono fornire una propria versione sincronizzata del <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> utilizzando il <ph id="ph2">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">Il codice di sincronizzazione è necessario eseguire operazioni sul <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, non direttamente sul <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object.</source>
          <target state="translated">In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente il <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <ph id="ph1">&lt;xref:System.Collections.ArrayList.SyncRoot%2A&gt;</ph> durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.ArrayList.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="T:System.Collections.ArrayList">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array.</source>
          <target state="translated">Copia gli elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in una nuova matrice.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Consente di copiare gli elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in una nuova matrice <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array containing copies of the elements of the <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Matrice <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> contenente le copie degli elementi di <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati mediante <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, che è un'operazione O (<ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The element <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the destination array to create and copy elements to.</source>
          <target state="translated">Elemento <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> della matrice di destinazione da creare e in cui copiare gli elementi.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> to a new array of the specified element type.</source>
          <target state="translated">Consente di copiare gli elementi di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> in una nuova matrice del tipo di elemento specificato.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>An array of the specified element type containing copies of the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Matrice del tipo di elemento specificato, contenente copie degli elementi della classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>All of the objects in the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> object will be cast to the <ph id="ph2">&lt;xref:System.Type&gt;</ph> specified in the <ph id="ph3">`type`</ph> parameter.</source>
          <target state="translated">Tutti gli oggetti nel <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> oggetto sarà possibile eseguire il cast di <ph id="ph2">&lt;xref:System.Type&gt;</ph> specificato nella <ph id="ph3">`type`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Gli elementi vengono copiati mediante <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, che è un'operazione O (<ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The following copy example shows how to copy the elements of an <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to a string array.</source>
          <target state="translated">L'esempio di codice riportato di seguito viene illustrato copiare gli elementi di un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> a una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.ToArray(System.Type)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> cannot be cast automatically to the specified type.</source>
          <target state="translated">Il tipo di <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> di origine non può essere convertito automaticamente nel tipo specificato.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Imposta la capacità sul numero effettivo di elementi contenuti in <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
          <target state="translated">Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> method before calling <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</source>
          <target state="translated">Per reimpostare un <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> lo stato iniziale, chiamare il metodo di <ph id="ph2">&lt;xref:System.Collections.ArrayList.Clear%2A&gt;</ph> metodo prima di chiamare <ph id="ph3">&lt;xref:System.Collections.ArrayList.TrimToSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> to the default capacity.</source>
          <target state="translated">L'eliminazione di un oggetto vuoto <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> imposta la capacità del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> per la capacità predefinita.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Collections.ArrayList.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The following code example shows how to trim the unused portions of the <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> and how to clear the values of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</source>
          <target state="translated">L'esempio di codice seguente viene illustrato come le parti inutilizzate di tagliare la <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> e su come cancellare i valori del <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Collections.ArrayList.TrimToSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> sono fisse.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>