<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="42109135fc2d9f48f4adb8b7cbe1020e6ae9cdde" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51311640" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Hashtable = class&#xA;    interface IDictionary&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una raccolta di coppie chiave/valore organizzate in base al codice hash della chiave.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

Ogni elemento è una coppia chiave/valore archiviata in un <xref:System.Collections.DictionaryEntry> oggetto. Non può essere una chiave `null`, ma può essere un valore.  

>  [!IMPORTANT]
>  Non è consigliabile usare il `Hashtable` classe per i nuovi sviluppi. È invece consigliabile usare il tipo generico <xref:System.Collections.Generic.HashSet%601> classe. Per altre informazioni, vedere [raccolte Non generiche non devono essere usate](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) su GitHub.
  
 Gli oggetti utilizzati come chiavi da un <xref:System.Collections.Hashtable> sono necessari per eseguire l'override la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo (o il <xref:System.Collections.IHashCodeProvider> interfaccia) e il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo) (o il <xref:System.Collections.IComparer> interfaccia). L'implementazione di metodi e interfacce deve gestire distinzione maiuscole/minuscole allo stesso modo; in caso contrario, il <xref:System.Collections.Hashtable> potrebbe comportarsi in modo non corretto. Ad esempio, quando si crea una <xref:System.Collections.Hashtable>, è necessario usare il <xref:System.Collections.CaseInsensitiveHashCodeProvider> classe (o qualsiasi tra maiuscole e minuscole <xref:System.Collections.IHashCodeProvider> implementazione) con il <xref:System.Collections.CaseInsensitiveComparer> classe (o qualsiasi tra maiuscole e minuscole <xref:System.Collections.IComparer> implementazione).  
  
 Inoltre, questi metodi devono produrre gli stessi risultati quando viene chiamato con gli stessi parametri, mentre la chiave esiste nella <xref:System.Collections.Hashtable>. Un'alternativa consiste nell'usare un <xref:System.Collections.Hashtable> costruttore con un <xref:System.Collections.IEqualityComparer> parametro. Se l'uguaglianza delle chiavi è semplicemente l'uguaglianza di riferimento, l'implementazione ereditata di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> dovrebbe essere sufficiente.  
  
 Gli oggetti principali devono essere non modificabili, purché vengono utilizzati come chiavi nel <xref:System.Collections.Hashtable>.  
  
 Quando un elemento viene aggiunto al <xref:System.Collections.Hashtable>, l'elemento viene inserito in un bucket in base al codice hash della chiave. Le ricerche successive della chiave usano il codice hash della chiave per la ricerca in un solo determinato bucket, riducendo notevolmente il numero dei confronti chiave necessari per trovare un elemento.  
  
 Il fattore di caricamento di un <xref:System.Collections.Hashtable> determina il rapporto massimo di elementi per bucket. Minore carico fattori causano tempi di tempi di ricerca medi aumentando tuttavia il consumo di memoria maggiore. In genere, il fattore di carico predefinito pari a 1,0 fornisce il miglior rapporto tra velocità e dimensioni. Un fattore di carico diversi può anche essere specificato quando il <xref:System.Collections.Hashtable> viene creato.  
  
 Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Hashtable>, il fattore di carico effettivo del <xref:System.Collections.Hashtable> aumenta. Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket nel <xref:System.Collections.Hashtable> viene automaticamente aumentato il numero primo più piccolo maggiore di due volte il numero corrente di <xref:System.Collections.Hashtable> bucket.  
  
 Ogni oggetto nella chiave di <xref:System.Collections.Hashtable> deve fornire la propria funzione hash, che è possibile accedere chiamando <xref:System.Collections.Hashtable.GetHash%2A>. Tuttavia, qualsiasi oggetto che implementa <xref:System.Collections.IHashCodeProvider> può essere passato a un <xref:System.Collections.Hashtable> costruttore e funzione hash viene utilizzato per tutti gli oggetti nella tabella.  
  
 La capacità di un <xref:System.Collections.Hashtable> è il numero di elementi di <xref:System.Collections.Hashtable> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Hashtable>, automaticamente aumentato la capacità in base alle necessità tramite la riallocazione.  
  
 Per grandi <xref:System.Collections.Hashtable> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione da `true` nell'ambiente di runtime.  
  
 Il `foreach` istruzione del linguaggio c# (`For Each` in Visual Basic) restituisce un oggetto del tipo degli elementi nella raccolta. Poiché ogni elemento del <xref:System.Collections.Hashtable> è una coppia chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è <xref:System.Collections.DictionaryEntry>. Ad esempio:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere da, non la scrittura, la raccolta.  
  
 Poiché la serializzazione e deserializzazione di un enumeratore per un <xref:System.Collections.Hashtable> può causare i riordinamento degli elementi, non è possibile continuare l'enumerazione senza chiamare il <xref:System.Collections.IEnumerator.Reset%2A> (metodo).  
  
> [!NOTE]
>  Poiché le chiavi possono essere ereditate e relativo comportamento modificato, non può essere garantirne l'univocità assoluta da confronti con i <xref:System.Type.Equals%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare, inizializzare ed eseguire varie funzioni per un <xref:System.Collections.Hashtable> e come stampare i relativi valori e chiavi.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Collections.Hashtable" /> è thread-safe per l'uso da più thread di lettura e un singolo thread di scrittura. È thread-safe per utilizzare multi-thread quando solo uno dei thread di eseguire operazioni di scrittura (aggiornamenti), che consente di letture senza blocco purché vengano serializzati i writer per il <see cref="T:System.Collections.Hashtable" />. Per supportare tutte le operazioni di più processi di scrittura nel <see cref="T:System.Collections.Hashtable" /> deve essere eseguita tramite il wrapper restituito dal <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> metodo, fornito che non sono disponibili thread di lettura di <see cref="T:System.Collections.Hashtable" /> oggetto.  
  
Enumerare una raccolta di per sé non è una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale, il fattore di carico, il provider di codice hash e l'operatore di confronto predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacità di una tabella hash viene utilizzata per calcolare il numero ottimale di bucket nella tabella hash in base al fattore di carico. Viene incrementata automaticamente in base alle necessità.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato nel nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico, il provider di codice hash e l'operatore di confronto predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable equalityComparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che definisce il provider di codice hash e l'operatore di confronto da usare con l'oggetto <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per utilizzare il provider predefinito di codice hash e l'operatore di confronto predefinito. Il provider di codice hash predefinito è l'implementazione di <see cref="M:System.Object.GetHashCode" /> di ogni chiave e l'operatore di confronto predefinito è l'implementazione di <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale e il fattore di carico predefiniti e l'oggetto <see cref="T:System.Collections.IEqualityComparer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacità di una tabella hash viene utilizzata per calcolare il numero ottimale di bucket nella tabella hash in base al fattore di carico. Viene incrementata automaticamente in base alle necessità.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il <xref:System.Collections.IEqualityComparer> oggetto include sia il provider di codice hash e l'operatore di confronto. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> oggetto non è necessario eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Collections.IEqualityComparer> rende possibili scenari quali eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale specificata e il fattore di carico, il provider di codice hash e l'operatore di confronto predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="equalityComparer">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che definisce il provider di codice hash e l'operatore di confronto da usare con <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per utilizzare il provider predefinito di codice hash e l'operatore di confronto predefinito. Il provider di codice hash predefinito è l'implementazione di <see cref="M:System.Object.GetHashCode" /> di ogni chiave e l'operatore di confronto predefinito è l'implementazione di <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico predefinito e l'oggetto <see cref="T:System.Collections.IEqualityComparer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il <xref:System.Collections.IEqualityComparer> oggetto include sia il provider di codice hash e l'operatore di confronto. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> oggetto non è necessario eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Collections.IEqualityComparer> rende possibili scenari quali eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato nel nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico specificato e il provider di codice hash e l'operatore di confronto predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hcp">Oggetto <see cref="T:System.Collections.IHashCodeProvider" /> che fornisce i codici hash per tutte le chiavi dell'oggetto <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per usare il provider predefinito di codice hash, che rappresenta l'implementazione di ogni chiave di <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.IComparer" /> da usare per determinare se due chiavi sono uguali.  
  
oppure 
 <see langword="null" /> per usare l'operatore di confronto predefinito, che rappresenta l'implementazione del metodo <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale e il fattore di carico predefiniti e il provider di codice hash e l'operatore di confronto specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacità di una tabella hash viene utilizzata per calcolare il numero ottimale di bucket nella tabella hash in base al fattore di carico. Viene incrementata automaticamente in base alle necessità.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il provider di codice hash e l'operatore di confronto personalizzato abilita scenari come eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <param name="equalityComparer">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che definisce il provider di codice hash e l'operatore di confronto da usare con <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per utilizzare il provider predefinito di codice hash e l'operatore di confronto predefinito. Il provider di codice hash predefinito è l'implementazione di <see cref="M:System.Object.GetHashCode" /> di ogni chiave e l'operatore di confronto predefinito è l'implementazione di <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale e l'interfaccia <see cref="T:System.Collections.IEqualityComparer" /> specificate e il fattore di carico predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il <xref:System.Collections.IEqualityComparer> oggetto include sia il provider di codice hash e l'operatore di confronto. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> non sono necessarie per eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Collections.IEqualityComparer> rende possibili scenari quali eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il `capacity` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale e il fattore di carico specificati e il provider di codice hash e l'operatore di confronto predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il `capacity` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="capacity" /> sta causando un overflow.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> che è serializzabile tramite gli oggetti <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacità di una tabella hash viene utilizzata per calcolare il numero ottimale di bucket nella tabella hash in base al fattore di carico. Viene incrementata automaticamente in base alle necessità.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
 Poiché la serializzazione e deserializzazione di un enumeratore per un <xref:System.Collections.Hashtable> può causare i riordinamento degli elementi, non è possibile continuare l'enumerazione senza chiamare il <xref:System.Collections.IEnumerator.Reset%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="hcp">Oggetto <see cref="T:System.Collections.IHashCodeProvider" /> che fornisce i codici hash per tutte le chiavi in <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per usare il provider predefinito di codice hash, che rappresenta l'implementazione di ogni chiave di <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.IComparer" /> da usare per determinare se due chiavi sono uguali.  
  
oppure 
 <see langword="null" /> per usare l'operatore di confronto predefinito, che rappresenta l'implementazione del metodo <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato nel nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico predefinito e il provider di codice hash e l'operatore di confronto specificati. Questo API è obsoleto. Per un'alternativa, vedere <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il provider di codice hash e l'operatore di confronto personalizzato abilita scenari come eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <param name="equalityComparer">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che definisce il provider di codice hash e l'operatore di confronto da usare con <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per utilizzare il provider predefinito di codice hash e l'operatore di confronto predefinito. Il provider di codice hash predefinito è l'implementazione di <see cref="M:System.Object.GetHashCode" /> di ogni chiave e l'operatore di confronto predefinito è l'implementazione di <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato nel nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico e l'oggetto <see cref="T:System.Collections.IEqualityComparer" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il <xref:System.Collections.IEqualityComparer> oggetto include sia il provider di codice hash e l'operatore di confronto. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> oggetto non è necessario eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Collections.IEqualityComparer> rende possibili scenari quali eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <param name="hcp">Oggetto <see cref="T:System.Collections.IHashCodeProvider" /> che fornisce i codici hash per tutte le chiavi in <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per usare il provider predefinito di codice hash, che rappresenta l'implementazione di ogni chiave di <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.IComparer" /> da usare per determinare se due chiavi sono uguali.  
  
oppure 
 <see langword="null" /> per usare l'operatore di confronto predefinito, che rappresenta l'implementazione del metodo <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale, il provider di codice hash e l'operatore di confronto specificati e il fattore di carico predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il provider di codice hash e l'operatore di confronto personalizzato abilita scenari come eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il `capacity` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <param name="equalityComparer">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che definisce il provider di codice hash e l'operatore di confronto da usare con <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per utilizzare il provider predefinito di codice hash e l'operatore di confronto predefinito. Il provider di codice hash predefinito è l'implementazione di <see cref="M:System.Object.GetHashCode" /> di ogni chiave e l'operatore di confronto predefinito è l'implementazione di <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale, il fattore di carico e l'oggetto <see cref="T:System.Collections.IEqualityComparer" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il <xref:System.Collections.IEqualityComparer> oggetto include sia il provider di codice hash e l'operatore di confronto. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> non sono necessarie per eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Collections.IEqualityComparer> rende possibili scenari quali eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il `capacity` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Oggetto <see cref="T:System.Collections.IDictionary" /> da copiare in un nuovo oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <param name="hcp">Oggetto <see cref="T:System.Collections.IHashCodeProvider" /> che fornisce i codici hash per tutte le chiavi in <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per usare il provider predefinito di codice hash, che rappresenta l'implementazione di ogni chiave di <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.IComparer" /> da usare per determinare se due chiavi sono uguali.  
  
oppure 
 <see langword="null" /> per usare l'operatore di confronto predefinito, che rappresenta l'implementazione del metodo <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Hashtable" /> copiando gli elementi dal dizionario specificato nel nuovo oggetto <see cref="T:System.Collections.Hashtable" />. Il nuovo oggetto <see cref="T:System.Collections.Hashtable" /> ha una capacità iniziale uguale al numero di elementi copiati e usa il fattore di carico, il provider di codice hash e l'operatore di confronto specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità iniziale è impostata sul numero di elementi nel dizionario di origine. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable> oggetto. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il provider di codice hash e l'operatore di confronto personalizzato abilita scenari come eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Gli elementi della nuova <xref:System.Collections.Hashtable> disposti nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.IDictionary> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nel `d` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero approssimativo di elementi che l'oggetto <see cref="T:System.Collections.Hashtable" /> può contenere inizialmente.</param>
        <param name="loadFactor">Un numero nell'intervallo da 0,1 a 1,0 moltiplicato per il valore predefinito che garantisce le prestazioni migliori. Il risultato è il rapporto massimo tra elementi e bucket.</param>
        <param name="hcp">Oggetto <see cref="T:System.Collections.IHashCodeProvider" /> che fornisce i codici hash per tutte le chiavi in <see cref="T:System.Collections.Hashtable" />.  
  
oppure 
 <see langword="null" /> per usare il provider predefinito di codice hash, che rappresenta l'implementazione di ogni chiave di <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.IComparer" /> da usare per determinare se due chiavi sono uguali.  
  
oppure 
 <see langword="null" /> per usare l'operatore di confronto predefinito, che rappresenta l'implementazione del metodo <see cref="M:System.Object.Equals(System.Object)" /> di ogni chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Hashtable" /> usando la capacità iniziale, il fattore di carico, il provider di codice hash e l'operatore di confronto specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Hashtable> oggetto. La capacità viene automaticamente aumentata in base alle esigenze in base al fattore di carico.  
  
 Il fattore di carico è il rapporto massimo di elementi per bucket. Un fattore di carico inferiore determina tempi di ricerca al costo di maggior utilizzo di memoria. Un fattore di carico pari a 1,0 è il miglior rapporto tra velocità e dimensioni.  
  
 Quando il fattore di carico effettivo raggiunge il fattore di carico, il numero di bucket viene aumentato automaticamente per il numero primo più piccolo maggiore di due volte il numero corrente di bucket.  
  
 Il provider di codice hash fornisce i codici hash per le chiavi di <xref:System.Collections.Hashtable>. Il provider di codice hash predefinito è l'implementazione della chiave di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 L'operatore di confronto determina se due chiavi sono uguali. Ogni chiave in un <xref:System.Collections.Hashtable> devono essere univoci. L'operatore di confronto predefinito è l'implementazione della chiave di <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Il provider di codice hash e l'operatore di confronto personalizzato abilita scenari come eseguendo ricerche con distinzione tra maiuscole e stringhe.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il `capacity` parametro.  
  
   
  
## Examples  
 Il codice seguente crea le tabelle hash usando diversi <xref:System.Collections.Hashtable> costruttori e vengono illustrate le differenze nel comportamento delle tabelle hash, anche se ognuno di essi contiene gli stessi elementi.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="loadFactor" /> è minore di 0,1.  
  
oppure 
 <paramref name="loadFactor" /> è maggiore di 1,0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="hashtable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da aggiungere.</param>
        <param name="value">Valore dell'elemento da aggiungere. Il valore può essere <see langword="null" />.</param>
        <summary>Aggiunge un elemento con la chiave e il valore specificati al metodo <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non può essere una chiave `null`, ma può essere un valore.  
  
 Oggetto che non ha alcuna correlazione tra il proprio stato e il relativo valore di codice hash deve in genere non utilizzabile come chiave. Ad esempio, gli oggetti stringa sono migliori rispetto agli oggetti di StringBuilder per l'uso come chiavi.  
  
 È anche possibile usare la <xref:System.Collections.Hashtable.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel <xref:System.Collections.Hashtable>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel <xref:System.Collections.Hashtable>, impostando il <xref:System.Collections.Hashtable.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Hashtable.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Se <xref:System.Collections.Hashtable.Count%2A> è minore rispetto alla capacità del <xref:System.Collections.Hashtable>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere elementi per il <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Hashtable" /> è già presente un elemento con la stessa chiave.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.Hashtable" /> è di sola lettura.  
  
oppure 
Le dimensioni dell'oggetto <see cref="T:System.Collections.Hashtable" /> sono fisse.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashtable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta. La capacità rimane invariata.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente illustra come cancellare i valori del <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.Hashtable" /> è di sola lettura.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="hashtable.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficiale di <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Copia superficiale di <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di un insieme di copia solo gli elementi della raccolta, se sono tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti. I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nell'oggetto collection originale.  
  
 Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Il <xref:System.Collections.Hashtable> duplicato ha lo stesso numero, la stessa capacità, lo stesso <xref:System.Collections.IHashCodeProvider> implementazione e la stessa <xref:System.Collections.IComparer> implementazione dell'originale <xref:System.Collections.Hashtable>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.comparer : System.Collections.IComparer with get, set" Usage="System.Collections.Hashtable.comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Collections.IComparer" /> da usare per <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Oggetto <see cref="T:System.Collections.IComparer" /> da usare per <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà è impostata su un valore ma la tabella hash è stata creata mediante un'interfaccia <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="hashtable.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Collections.Hashtable" /> contiene una chiave specifica.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Hashtable" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A> implementa <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Si comporta esattamente come <xref:System.Collections.Hashtable.ContainsKey%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se l'elemento esiste. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come determinare se il <xref:System.Collections.Hashtable> contiene un elemento specifico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="hashtable.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Collections.Hashtable" /> contiene una chiave specifica.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Hashtable" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si comporta esattamente come <xref:System.Collections.Hashtable.Contains%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se l'elemento esiste. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come determinare se il <xref:System.Collections.Hashtable> contiene un elemento specifico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="hashtable.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Hashtable" />. Il valore può essere <see langword="null" />.</param>
        <summary>Stabilisce se <see cref="T:System.Collections.Hashtable" /> contiene un valore specifico.</summary>
        <returns>
          <see langword="true" /> se la classe <see cref="T:System.Collections.Hashtable" /> contiene un elemento con l'oggetto <paramref name="value" /> specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori degli elementi del <xref:System.Collections.Hashtable> vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo).  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se l'elemento esiste. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come determinare se il <xref:System.Collections.Hashtable> contiene un elemento specifico.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="hashtable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che corrisponde alla destinazione degli oggetti <see cref="T:System.Collections.DictionaryEntry" /> copiati da <see cref="T:System.Collections.Hashtable" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi della classe <see cref="T:System.Collections.Hashtable" /> gli elementi della classe <see cref="T:System.Array" /> unidimensionale in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Hashtable>.  
  
 Per copiare solo le chiavi di <xref:System.Collections.Hashtable>, usare `Hashtable.Keys.CopyTo`.  
  
 Per copiare solo i valori di <xref:System.Collections.Hashtable>, usare `Hashtable.Values.CopyTo`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente illustra come copiare l'elenco di chiavi o l'elenco di valori in una <xref:System.Collections.Hashtable> in una matrice unidimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
Il numero di elementi nell'oggetto <see cref="T:System.Collections.Hashtable" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.Hashtable" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Hashtable.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Collections.IEqualityComparer" Usage="System.Collections.Hashtable.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'interfaccia <see cref="T:System.Collections.IEqualityComparer" /> da usare per la classe <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Oggetto <see cref="T:System.Collections.IEqualityComparer" /> da usare per <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.IEqualityComparer> include l'operatore di confronto e il provider di codice hash. Se un' <xref:System.Collections.IEqualityComparer> viene utilizzata per il <xref:System.Collections.Hashtable> costruttore, gli oggetti usati come chiavi nel <xref:System.Collections.Hashtable> non sono necessarie per eseguire l'override di <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà è impostata su un valore ma la tabella hash è stata creata mediante un'interfaccia <see cref="T:System.Collections.IHashCodeProvider" /> e un'interfaccia <see cref="T:System.Collections.IComparer" />.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="hashtable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Collections.IDictionaryEnumerator" /> che esegue l'iterazione di <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> per l'oggetto <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
 Poiché la serializzazione e deserializzazione di un enumeratore per un <xref:System.Collections.Hashtable> può causare i riordinamento degli elementi, non è possibile continuare l'enumerazione senza chiamare il <xref:System.Collections.IEnumerator.Reset%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente vengono confrontati l'utilizzo di <xref:System.Collections.Hashtable.GetEnumerator%2A> e `foreach` enumerare il contenuto di un <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member GetHash : obj -&gt; int&#xA;override this.GetHash : obj -&gt; int" Usage="hashtable.GetHash key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Oggetto <see cref="T:System.Object" /> per cui è necessario che sia restituito un codice hash.</param>
        <summary>Restituisce il codice hash per la chiave specificata.</summary>
        <returns>Codice hash per <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la tabella hash è stata creata con uno specifico <xref:System.Collections.IHashCodeProvider> implementazione, questo metodo usa tale provider di codice hash; in caso contrario, utilizza il <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> implementazione di `key`.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashtable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> restituendo i dati necessari per serializzare la <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'insieme è stato modificato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.hcp : System.Collections.IHashCodeProvider with get, set" Usage="System.Collections.Hashtable.hcp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto dal quale verranno distribuiti i codici hash.</summary>
        <value>Oggetto dal quale possono essere distribuiti i codici hash.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà è impostata su un valore ma la tabella hash è stata creata mediante un'interfaccia <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.Hashtable.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Hashtable" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.Hashtable" /> ha dimensioni fisse; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.Hashtable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Hashtable" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.Hashtable" /> è di sola lettura; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta che è di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Hashtable.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.Hashtable" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.Hashtable" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Collections.Hashtable> può supportare un writer e più lettori simultaneamente. Per supportare più processi di scrittura, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <xref:System.Collections.Hashtable.Synchronized%2A> (metodo).  
  
 Enumerare una raccolta di per sé non è una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Esempio di codice seguente viene illustrato come bloccare la raccolta usando il <xref:System.Collections.Hashtable.SyncRoot%2A> durante l'intera enumerazione:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come sincronizzare una <xref:System.Collections.Hashtable>, determinare se un <xref:System.Collections.Hashtable> è sincronizzato e usare un oggetto sincronizzato <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.Hashtable.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave di cui si deve ottenere o impostare il valore.</param>
        <summary>Ottiene o imposta il valore associato alla chiave specificata.</summary>
        <value>Valore associato alla chiave specificata. Se la chiave specificata non viene trovata, tentando di ottenerla viene restituito <see langword="null" /> mentre tentando di impostarla viene creato un nuovo elemento con la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[key]`.  
  
 È anche possibile usare la <xref:System.Collections.Hashtable.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel <xref:System.Collections.Hashtable>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel <xref:System.Collections.Hashtable>, impostando il <xref:System.Collections.Hashtable.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Hashtable.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Non può essere una chiave `null`, ma può essere un valore. Per distinguere tra `null` che viene restituito perché la chiave specificata non è stata trovata e `null` che viene restituito perché il valore della chiave specificata `null`, usare il <xref:System.Collections.Hashtable.Contains%2A> metodo o il <xref:System.Collections.Hashtable.ContainsKey%2A> metodo per determinare se la chiave presente nell'elenco.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è anche un'operazione o (1).  
  
 Il linguaggio c# usa la parola chiave per definire gli indicizzatori anziché implementare il <xref:System.Collections.IList.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Hashtable.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La proprietà è stata impostata e l'interfaccia <see cref="T:System.Collections.Hashtable" /> è in sola lettura.  
  
oppure 
La proprietà è impostata, <paramref name="key" /> non esiste nella raccolta e <see cref="T:System.Collections.Hashtable" /> è di dimensioni fisse.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member KeyEquals : obj * obj -&gt; bool&#xA;override this.KeyEquals : obj * obj -&gt; bool" Usage="hashtable.KeyEquals (item, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Elemento <see cref="T:System.Object" /> da confrontare con il parametro <c>key</c>.</param>
        <param name="key">Chiave dell'elemento <see cref="T:System.Collections.Hashtable" /> da confrontare con il parametro <c>item</c>.</param>
        <summary>Confronta un <see cref="T:System.Object" /> specifico con una chiave specifica nella <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> e <paramref name="key" /> sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la tabella hash è stata creata con uno specifico <xref:System.Collections.IComparer> implementazione, questo metodo usa tale operatore di confronto; ovvero, <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). In caso contrario, Usa `item.Equals(key)`.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> è <see langword="null" />.  
  
oppure 
 <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.Hashtable.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Collections.ICollection" /> contenente le chiavi presenti nell'oggetto <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Oggetto <see cref="T:System.Collections.ICollection" /> contenente le chiavi presenti in <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi nel <xref:System.Collections.ICollection> non è specificato, ma è stesso ordine dei valori associati nel <xref:System.Collections.ICollection> restituiti dal <xref:System.Collections.Hashtable.Values%2A> (metodo).  
  
 L'oggetto restituito <xref:System.Collections.ICollection> non è una copia statica; in alternativa, il <xref:System.Collections.ICollection> fa riferimento alle chiavi nel originale <xref:System.Collections.Hashtable>. Di conseguenza, le modifiche apportate al <xref:System.Collections.Hashtable> continuano a essere riflessi nel <xref:System.Collections.ICollection>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashtable.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Origine dell'evento di deserializzazione.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e genera l'evento di deserializzazione quando la deserializzazione è completa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Hashtable.Count%2A>.  
  
 Poiché la serializzazione e deserializzazione di un enumeratore per un <xref:System.Collections.Hashtable> può causare i riordinamento degli elementi, non è possibile continuare l'enumerazione senza chiamare il <xref:System.Collections.IEnumerator.Reset%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">L'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associato alla <see cref="T:System.Collections.Hashtable" /> corrente non è valido.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="hashtable.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Collections.Hashtable> non contiene un elemento con la chiave specificata, il <xref:System.Collections.Hashtable> rimane invariato. Non viene generata alcuna eccezione.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come rimuovere gli elementi dal <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.Hashtable" /> è di sola lettura.  
  
oppure 
Le dimensioni dell'oggetto <see cref="T:System.Collections.Hashtable" /> sono fisse.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Hashtable -&gt; System.Collections.Hashtable" Usage="System.Collections.Hashtable.Synchronized table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">Oggetto <see cref="T:System.Collections.Hashtable" /> da sincronizzare.</param>
        <summary>Restituisce un wrapper sincronizzato (thread-safe) per la classe <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Wrapper sincronizzato (thread-safe) per la classe <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Hashtable.Synchronized%2A> metodo è thread-safe per più lettori e writer. Inoltre, il wrapper sincronizzato garantisce che vi sia un solo agente di scrittura la scrittura in un momento.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Esempio di codice seguente viene illustrato come bloccare la raccolta usando il <xref:System.Collections.Hashtable.SyncRoot%2A> durante l'intera enumerazione:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come sincronizzare una <xref:System.Collections.Hashtable>, determinare se un <xref:System.Collections.Hashtable> è sincronizzato e usare un oggetto sincronizzato <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Hashtable.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare una versione sincronizzata della <xref:System.Collections.Hashtable>, usare il <xref:System.Collections.Hashtable.Synchronized%2A> (metodo). Tuttavia, le classi derivate possono fornire la propria versione sincronizzata del <xref:System.Collections.Hashtable> utilizzando il <xref:System.Collections.Hashtable.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni sul <xref:System.Collections.Hashtable.SyncRoot%2A> del <xref:System.Collections.Hashtable>, non direttamente sul <xref:System.Collections.Hashtable> . In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente i <xref:System.Collections.Hashtable> oggetto.  
  
 Enumerare una raccolta di per sé non è una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Esempio di codice seguente viene illustrato come bloccare la raccolta usando il <xref:System.Collections.Hashtable.SyncRoot%2A> durante l'intera enumerazione:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione. In questa posizione, la chiamata a <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, la chiamata <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore può essere invalidato e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>. Se la raccolta viene modificata tra <xref:System.Collections.IEnumerator.MoveNext%2A> e <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> restituisce l'elemento su cui è stata impostata, anche se l'enumeratore risulta già invalidato.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.Hashtable.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente i valori in <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente i valori dell'interfaccia <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori nel <xref:System.Collections.ICollection> non è specificato, ma è stesso ordine delle chiavi associate nel <xref:System.Collections.ICollection> restituiti dal <xref:System.Collections.Hashtable.Keys%2A> (metodo).  
  
 L'oggetto restituito <xref:System.Collections.ICollection> non è una copia statica; in alternativa, il <xref:System.Collections.ICollection> fa riferimento ai valori nell'originale <xref:System.Collections.Hashtable>. Di conseguenza, le modifiche apportate al <xref:System.Collections.Hashtable> continuano a essere riflessi nel <xref:System.Collections.ICollection>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>