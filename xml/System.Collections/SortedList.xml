<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e66558bdc698f370e66b85bb6de8f74d6987d633" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36713552" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a collection of key/value pairs that are sorted by the keys and are accessible by key and by index.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per la versione generica di questa raccolta, vedere <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType>.  
  
 Un <xref:System.Collections.SortedList> elemento è possibile accedere tramite la relativa chiave, ad esempio un elemento in qualsiasi <xref:System.Collections.IDictionary> implementazione, o al rispettivo indice, come per un elemento in qualsiasi <xref:System.Collections.IList> implementazione.  
  
 Oggetto <xref:System.Collections.SortedList> oggetto gestisce internamente due matrici per archiviare gli elementi dell'elenco, vale a dire una singola matrice per le chiavi e un'altra matrice per i valori associati. Ogni elemento è una coppia chiave/valore che può essere eseguita come un <xref:System.Collections.DictionaryEntry> oggetto. Non può essere una chiave `null`, ma può essere un valore.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi di <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto tramite operazioni di riallocazione. È possibile diminuire la capacità chiamando <xref:System.Collections.SortedList.TrimToSize%2A> oppure impostando la <xref:System.Collections.SortedList.Capacity%2A> proprietà in modo esplicito.  
  
 Per grandi <xref:System.Collections.SortedList> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.  
  
 Gli elementi di un <xref:System.Collections.SortedList> oggetto vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse. In entrambi i casi, un <xref:System.Collections.SortedList> non consentono chiavi duplicate.  
  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 Operazioni su un <xref:System.Collections.SortedList> oggetto tendono a essere più lento rispetto alle operazioni su un <xref:System.Collections.Hashtable> oggetto a causa dell'ordinamento. Tuttavia, il <xref:System.Collections.SortedList> offre una maggiore flessibilità, consentendo l'accesso ai valori delle chiavi associate o mediante gli indici.  
  
 Elementi nella raccolta è accessibile tramite un indice integer.  Gli indici in questa raccolta sono in base zero.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in Visual Basic) restituisce un oggetto di tipo degli elementi nella raccolta. Poiché ogni elemento del <xref:System.Collections.SortedList> oggetto è una coppia chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Piuttosto, l'elemento è <xref:System.Collections.DictionaryEntry>. Ad esempio:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere, non la scrittura da alla raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un <xref:System.Collections.SortedList> oggetto e come stampare i relativi valori e chiavi.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Oggetto <see cref="T:System.Collections.SortedList" /> oggetto può supportare più lettori contemporaneamente, fino a quando la raccolta non viene modificata. Per garantire la protezione del thread dei <see cref="T:System.Collections.SortedList" />, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> metodo.  L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that is empty, has the default initial capacity, and is sorted according to the <see cref="T:System.IComparable" /> interface implemented by each key added to the <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto. Gli elementi vengono ordinati in base al <xref:System.IComparable> implementazione di ciascuna chiave aggiunta al <xref:System.Collections.SortedList>.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing keys.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that is empty, has the default initial capacity, and is sorted according to the specified <see cref="T:System.Collections.IComparer" /> interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono ordinati in base all'oggetto specificato <xref:System.Collections.IComparer> implementazione. Se il `comparer` parametro `null`, il <xref:System.IComparable> l'implementazione di ogni chiave è utilizzato; pertanto, ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">The <see cref="T:System.Collections.IDictionary" /> implementation to copy to a new <see cref="T:System.Collections.SortedList" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that contains elements copied from the specified dictionary, has the same initial capacity as the number of elements copied, and is sorted according to the <see cref="T:System.IComparable" /> interface implemented by each key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto. Gli elementi vengono ordinati in base al <xref:System.IComparable> implementazione di ciascuna chiave aggiunta al <xref:System.Collections.SortedList>.  
  
 Un <xref:System.Collections.Hashtable> oggetto è un esempio di un <xref:System.Collections.IDictionary> implementazione che può essere passato al costruttore. Il nuovo <xref:System.Collections.SortedList> oggetto contiene una copia delle chiavi e valori archiviati nel <xref:System.Collections.Hashtable>.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `d`.  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">One or more elements in <paramref name="d" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">The initial number of elements that the <see cref="T:System.Collections.SortedList" /> object can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that is empty, has the specified initial capacity, and is sorted according to the <see cref="T:System.IComparable" /> interface implemented by each key added to the <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto. Gli elementi vengono ordinati in base al <xref:System.IComparable> implementazione di ciascuna chiave aggiunta al <xref:System.Collections.SortedList>.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `initialCapacity`.  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCapacity" /> is less than zero.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough available memory to create a <see cref="T:System.Collections.SortedList" /> object with the specified <paramref name="initialCapacity" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing keys.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each key.</param>
        <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.SortedList" /> object can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that is empty, has the specified initial capacity, and is sorted according to the specified <see cref="T:System.Collections.IComparer" /> interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono ordinati in base all'oggetto specificato <xref:System.Collections.IComparer> implementazione. Se il `comparer` parametro `null`, il <xref:System.IComparable> l'implementazione di ogni chiave è utilizzato; pertanto, ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than zero.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough available memory to create a <see cref="T:System.Collections.SortedList" /> object with the specified <paramref name="capacity" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">The <see cref="T:System.Collections.IDictionary" /> implementation to copy to a new <see cref="T:System.Collections.SortedList" /> object.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing keys.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Collections.SortedList" /> class that contains elements copied from the specified dictionary, has the same initial capacity as the number of elements copied, and is sorted according to the specified <see cref="T:System.Collections.IComparer" /> interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono ordinati in base all'oggetto specificato <xref:System.Collections.IComparer> implementazione. Se il `comparer` parametro `null`, il <xref:System.IComparable> l'implementazione di ogni chiave è utilizzato; pertanto, ogni chiave deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave il <xref:System.Collections.SortedList> oggetto.  
  
 Un <xref:System.Collections.Hashtable> oggetto è un esempio di un <xref:System.Collections.IDictionary> implementazione che può essere passato al costruttore. Il nuovo <xref:System.Collections.SortedList> oggetto contiene una copia delle chiavi e valori archiviati nel <xref:System.Collections.Hashtable>.  
  
 La capacità di un <xref:System.Collections.SortedList> oggetto è il numero di elementi che la <xref:System.Collections.SortedList> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.SortedList>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.SortedList> oggetto.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `d`.  
  
   
  
## Examples  
 Esempio di codice seguente crea diverse raccolte utilizzando <xref:System.Collections.SortedList> costruttori e vengono illustrate le differenze nel comportamento delle raccolte.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="d" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key of the element to add.</param>
        <param name="value">The value of the element to add. The value can be <see langword="null" />.</param>
        <summary>Adds an element with the specified key and value to a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il punto di inserimento viene determinato in base all'operatore di confronto selezionato, in modo esplicito o per impostazione predefinita, quando il <xref:System.Collections.SortedList> oggetto è stato creato.  
  
 Se <xref:System.Collections.SortedList.Count%2A> è già pari <xref:System.Collections.SortedList.Capacity%2A>, la capacità del <xref:System.Collections.SortedList> oggetto viene incrementato automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 È anche possibile usare il <xref:System.Collections.SortedList.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.SortedList> oggetto (ad esempio, `myCollection["myNonexistentKey"] = myValue`). Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.SortedList>, impostando il <xref:System.Collections.SortedList.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.SortedList.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Gli elementi di un <xref:System.Collections.SortedList> oggetto vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse.  
  
 Non può essere una chiave `null`, ma può essere un valore.  
  
 Questo metodo è un'operazione O (`n`) per dati non ordinati, dove `n` è <xref:System.Collections.SortedList.Count%2A>. È un'operazione O (log `n`) operazione se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come aggiungere elementi a un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">An element with the specified <paramref name="key" /> already exists in the <see cref="T:System.Collections.SortedList" /> object.  -or-  The <see cref="T:System.Collections.SortedList" /> is set to use the <see cref="T:System.IComparable" /> interface, and <paramref name="key" /> does not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.SortedList" /> is read-only.  -or-  The <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough available memory to add the element to the <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">The comparer throws an exception.</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the capacity of a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Numero degli elementi che l'oggetto <see cref="T:System.Collections.SortedList" /> può contenere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> è il numero di elementi che la <xref:System.Collections.SortedList> può archiviare l'oggetto. <xref:System.Collections.SortedList.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.SortedList.Count%2A>. Se <xref:System.Collections.SortedList.Count%2A> supera <xref:System.Collections.SortedList.Capacity%2A> durante l'aggiunta di elementi, la capacità è aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.SortedList.TrimToSize%2A> oppure impostando la <xref:System.Collections.SortedList.Capacity%2A> proprietà in modo esplicito. Quando il valore di <xref:System.Collections.SortedList.Capacity%2A> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione O (`n`) operazione, in cui `n` è la nuova capacità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value assigned is less than the current number of elements in the <see cref="T:System.Collections.SortedList" /> object.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory available on the system.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all elements from a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 <xref:System.Collections.SortedList.Capacity%2A> non subisce modifiche. Per reimpostare la capacità del <xref:System.Collections.SortedList> dell'oggetto, chiamare <xref:System.Collections.SortedList.TrimToSize%2A> o impostare il <xref:System.Collections.SortedList.Capacity%2A> proprietà direttamente. L'eliminazione di un oggetto vuoto <xref:System.Collections.SortedList> imposta la capacità del <xref:System.Collections.SortedList> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere le parti inutilizzate di un' <xref:System.Collections.SortedList> oggetto e viene illustrato come cancellare i valori del <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.SortedList" /> object is read-only.  -or-  The <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>A shallow copy of the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di un insieme di copia solo gli elementi della raccolta, se sono tipi di riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a. I riferimenti nella nuova raccolta puntano agli stessi oggetti che puntano i riferimenti nella raccolta originale.  
  
 Al contrario, una copia completa di una raccolta copia gli elementi e tutto ciò che direttamente o indirettamente riferimento gli elementi.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key to locate in the <see cref="T:System.Collections.SortedList" /> object.</param>
        <summary>Determines whether a <see cref="T:System.Collections.SortedList" /> object contains a specific key.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Collections.SortedList" /> object contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi di un <xref:System.Collections.SortedList> oggetto vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse.  
  
 <xref:System.Collections.SortedList.Contains%2A> implementa <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Si comporta esattamente come <xref:System.Collections.SortedList.ContainsKey%2A>.  
  
 Questo metodo Usa un algoritmo di ricerca binario; Pertanto, questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare se un <xref:System.Collections.SortedList> oggetto contiene un elemento specifico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The comparer throws an exception.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key to locate in the <see cref="T:System.Collections.SortedList" /> object.</param>
        <summary>Determines whether a <see cref="T:System.Collections.SortedList" /> object contains a specific key.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Collections.SortedList" /> object contains an element with the specified <paramref name="key" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi di un <xref:System.Collections.SortedList> oggetto vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse.  
  
 Questo metodo funziona esattamente come il <xref:System.Collections.SortedList.Contains%2A> metodo.  
  
 Questo metodo Usa un algoritmo di ricerca binario; Pertanto, questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare se un <xref:System.Collections.SortedList> oggetto contiene un elemento specifico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The comparer throws an exception.</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to locate in the <see cref="T:System.Collections.SortedList" /> object. The value can be <see langword="null" />.</param>
        <summary>Determines whether a <see cref="T:System.Collections.SortedList" /> object contains a specific value.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Collections.SortedList" /> object contains an element with the specified <paramref name="value" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori degli elementi della <xref:System.Collections.SortedList> oggetto vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A> metodo.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, è proporzionale al tempo di esecuzione medio <xref:System.Collections.SortedList.Count%2A>. Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare se un <xref:System.Collections.SortedList> oggetto contiene un elemento specifico.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> object that is the destination of the <see cref="T:System.Collections.DictionaryEntry" /> objects copied from <see cref="T:System.Collections.SortedList" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in <c>array</c> at which copying begins.</param>
        <summary>Copies <see cref="T:System.Collections.SortedList" /> elements to a one-dimensional <see cref="T:System.Array" /> object, starting at the specified index in the array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le coppie chiave/valore vengono copiate i <xref:System.Array> oggetto nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.SortedList> oggetto.  
  
 Per copiare solo le chiavi di <xref:System.Collections.SortedList>, utilizzare `SortedList.Keys.CopyTo`.  
  
 Per copiare solo i valori di <xref:System.Collections.SortedList>, utilizzare `SortedList.Values.CopyTo`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come copiare i valori in una <xref:System.Collections.SortedList> oggetto in una matrice unidimensionale <xref:System.Array> oggetto.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source <see cref="T:System.Collections.SortedList" /> object is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.SortedList" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Numero degli elementi contenuti nell'oggetto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento è una coppia chiave/valore che può essere eseguita come un <xref:System.Collections.DictionaryEntry> oggetto.  
  
 <xref:System.Collections.SortedList.Capacity%2A> è il numero di elementi che la <xref:System.Collections.SortedList> può archiviare l'oggetto. <xref:System.Collections.SortedList.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.SortedList.Count%2A>. Se <xref:System.Collections.SortedList.Count%2A> supera <xref:System.Collections.SortedList.Capacity%2A> durante l'aggiunta di elementi, la capacità è aumentata automaticamente tramite la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the value to get.</param>
        <summary>Gets the value at the specified index of a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>The value at the specified index of the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere una o tutte le chiavi o i valori in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="T:System.Collections.SortedList" /> object.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object that iterates through a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the key to get.</param>
        <summary>Gets the key at the specified index of a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>The key at the specified index of the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere una o tutte le chiavi o i valori in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="T:System.Collections.SortedList" /> object.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the keys in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> object containing the keys in the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Collections.IList> è una visualizzazione di sola lettura delle chiavi del <xref:System.Collections.SortedList> oggetto. Le modifiche apportate alle sottostante <xref:System.Collections.SortedList> vengono applicate immediatamente il <xref:System.Collections.IList>.  
  
 Gli elementi dell'oggetto restituito <xref:System.Collections.IList> ordinate nello stesso ordine delle chiavi del <xref:System.Collections.SortedList>.  
  
 Questo metodo è simile ai <xref:System.Collections.SortedList.Keys%2A> proprietà, ma restituisce un <xref:System.Collections.IList> dell'oggetto anziché un <xref:System.Collections.ICollection> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere una o tutte le chiavi o i valori in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the values in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> object containing the values in the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Collections.IList> è una visualizzazione di sola lettura dei valori del <xref:System.Collections.SortedList> oggetto. Le modifiche apportate alle sottostante <xref:System.Collections.SortedList> vengono applicate immediatamente il <xref:System.Collections.IList>.  
  
 Gli elementi dell'oggetto restituito <xref:System.Collections.IList> ordinate nello stesso ordine dei valori del <xref:System.Collections.SortedList>.  
  
 Questo metodo è simile ai <xref:System.Collections.SortedList.Values%2A> proprietà, ma restituisce un <xref:System.Collections.IList> dell'oggetto anziché un <xref:System.Collections.ICollection> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere una o tutte le chiavi o i valori in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key to locate in the <see cref="T:System.Collections.SortedList" /> object.</param>
        <summary>Returns the zero-based index of the specified key in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>The zero-based index of the <paramref name="key" /> parameter, if <paramref name="key" /> is found in the <see cref="T:System.Collections.SortedList" /> object; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi di un <xref:System.Collections.SortedList> oggetto vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse.  
  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList>.  
  
 Questo metodo Usa un algoritmo di ricerca binario; Pertanto, questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice di una chiave o un valore in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The comparer throws an exception.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to locate in the <see cref="T:System.Collections.SortedList" /> object. The value can be <see langword="null" />.</param>
        <summary>Returns the zero-based index of the first occurrence of the specified value in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>The zero-based index of the first occurrence of the <paramref name="value" /> parameter, if <paramref name="value" /> is found in the <see cref="T:System.Collections.SortedList" /> object; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 I valori degli elementi della <xref:System.Collections.SortedList> vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A> metodo.  
  
 Questo metodo utilizza una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
 A partire da .NET Framework 2.0, questo metodo Usa gli oggetti della raccolta <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi su `item` per determinare se esiste un elemento. Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice di una chiave o un valore in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a <see cref="T:System.Collections.SortedList" /> object has a fixed size.</summary>
        <value>
          <see langword="true" /> Se il <see cref="T:System.Collections.SortedList" /> oggetto è fisse dimensioni; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la raccolta viene creata, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a <see cref="T:System.Collections.SortedList" /> object is read-only.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Collections.SortedList" /> è di sola lettura; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to a <see cref="T:System.Collections.SortedList" /> object is synchronized (thread safe).</summary>
        <value>
          <see langword="true" /> se l'accesso all'oggetto <see cref="T:System.Collections.SortedList" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire la protezione del thread di un <xref:System.Collections.SortedList> dell'oggetto, tutte le operazioni devono essere eseguite tramite il wrapper restituito dal <xref:System.Collections.SortedList.Synchronized%2A> metodo.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare un insieme utilizzando la <xref:System.Collections.SortedList.SyncRoot%2A> proprietà durante l'intera enumerazione.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 Esempio di codice seguente viene illustrato come sincronizzare una <xref:System.Collections.SortedList> dell'oggetto, determinare se un <xref:System.Collections.SortedList> è sincronizzato e utilizzare un oggetto sincronizzato <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key associated with the value to get or set.</param>
        <summary>Gets and sets the value associated with a specific key in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Valore associato al parametro <paramref name="key" /> nell'oggetto <see cref="T:System.Collections.SortedList" />, se il parametro <paramref name="key" /> è presente; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Collections.SortedList.Item%2A> proprietà accedere a un elemento specifico in una raccolta, specificando la sintassi seguente: `myCollection[key]`.  
  
 È inoltre possibile utilizzare questa proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel <xref:System.Collections.SortedList> oggetto (ad esempio, `myCollection["myNonexistentKey"] = myValue)`. Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.SortedList>, impostando il <xref:System.Collections.SortedList.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.SortedList.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Non può essere una chiave `null`, ma può essere un valore. Per distinguere tra `null` che viene restituita la chiave specificata non è stato trovato e `null` che viene restituito perché il valore della chiave specificata `null`, usare il <xref:System.Collections.SortedList.Contains%2A> metodo o la <xref:System.Collections.SortedList.ContainsKey%2A> metodo per determinare se la chiave presente nell'elenco.  
  
 Gli elementi di un <xref:System.Collections.SortedList> vengono ordinati in base alle chiavi uno in base a uno specifico <xref:System.Collections.IComparer> implementazione specificato quando il <xref:System.Collections.SortedList> viene creato o in base al parametro il <xref:System.IComparable> implementazione fornita dalle chiavi stesse.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.SortedList.Keys%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.SortedList.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>. Impostazione della proprietà è un'operazione O (log `n`) se la chiave è già nel <xref:System.Collections.SortedList>. Se la chiave non è presente nell'elenco, impostare la proprietà è un'operazione O (`n`) l'operazione per i dati non ordinati o O (log `n`) se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.SortedList" /> object is read-only.  -or-  The property is set, <paramref name="key" /> does not exist in the collection, and the <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough available memory to add the element to the <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">The comparer throws an exception.</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the keys in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Ottiene un oggetto <see cref="T:System.Collections.ICollection" /> contenente le chiavi dell'oggetto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ICollection> è una visualizzazione di sola lettura delle chiavi del <xref:System.Collections.SortedList> oggetto. Le modifiche apportate alle sottostante <xref:System.Collections.SortedList> vengono applicate immediatamente il <xref:System.Collections.ICollection>.  
  
 Gli elementi del <xref:System.Collections.ICollection> ordinate nello stesso ordine delle chiavi del <xref:System.Collections.SortedList>.  
  
 Questa proprietà è simile ai <xref:System.Collections.SortedList.GetKeyList%2A> del metodo, ma restituisce un <xref:System.Collections.ICollection> dell'oggetto anziché un <xref:System.Collections.IList> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The key of the element to remove.</param>
        <summary>Removes the element with the specified key from a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto <xref:System.Collections.SortedList> non contiene alcun elemento con la chiave specificata, <xref:System.Collections.SortedList> rimarrà invariato. Non viene generata alcuna eccezione.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere elementi da un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.SortedList" /> object is read-only.  -or-  The <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to remove.</param>
        <summary>Removes the element at the specified index of a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 In raccolte di elementi adiacenti, quali gli elenchi, gli elementi successivi al punto di inserimento vengono spostati verso il basso per consentire l'inserimento del nuovo elemento. Se la raccolta è indicizzata, vengono aggiornati anche gli indici degli elementi spostati. Questo comportamento non viene applicato alle raccolte in cui gli elementi sono raggruppati concettualmente in bucket, come accade ad esempio per le tabelle hash.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere elementi da un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="T:System.Collections.SortedList" /> object.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.SortedList" /> is read-only.  -or-  The <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which to save <c>value</c>.</param>
        <param name="value">The <see cref="T:System.Object" /> to save into the <see cref="T:System.Collections.SortedList" /> object. The value can be <see langword="null" />.</param>
        <summary>Replaces the value at a specific index in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sequenza di indice si basa sulla sequenza di ordinamento. Quando viene aggiunto un elemento, viene inserito nella <xref:System.Collections.SortedList> nell'ordinamento corretto ordine e l'indicizzazione si adegua di conseguenza. Quando un elemento viene rimosso, l'indicizzazione anche si adegua di conseguenza. Pertanto, l'indice di una coppia chiave/valore specifica potrebbe cambiare quando gli elementi vengono aggiunti o rimossi dal <xref:System.Collections.SortedList> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come sostituire il valore di un elemento esistente in un <xref:System.Collections.SortedList> oggetto.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="T:System.Collections.SortedList" /> object.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">The <see cref="T:System.Collections.SortedList" /> object to synchronize.</param>
        <summary>Returns a synchronized (thread-safe) wrapper for a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <returns>A synchronized (thread-safe) wrapper for the <see cref="T:System.Collections.SortedList" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire la protezione del thread di un <xref:System.Collections.SortedList> dell'oggetto, tutte le operazioni devono essere eseguite solo tramite questo wrapper.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.SortedList.SyncRoot%2A> proprietà durante l'intera enumerazione.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Questo metodo è un'operazione o (1).  
  
 Esempio di codice seguente viene illustrato come sincronizzare una <xref:System.Collections.SortedList> dell'oggetto, determinare se un <xref:System.Collections.SortedList> è sincronizzato e utilizzare un oggetto sincronizzato <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso all'oggetto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare una versione sincronizzata della <xref:System.Collections.SortedList> dell'oggetto, utilizzare il <xref:System.Collections.SortedList.Synchronized%2A> metodo. Tuttavia, le classi derivate possono fornire la propria versione sincronizzata della <xref:System.Collections.SortedList> utilizzando il <xref:System.Collections.SortedList.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni sul <xref:System.Collections.SortedList.SyncRoot%2A> del <xref:System.Collections.SortedList>, non direttamente sul <xref:System.Collections.SortedList>. In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, viene mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente il <xref:System.Collections.SortedList> oggetto.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la raccolta utilizzando la <xref:System.Collections.SortedList.SyncRoot%2A> proprietà durante l'intera enumerazione.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, c#]  
  
 L'istruzione `foreach` del linguaggio C# (`for each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione. In questa posizione, la chiamata <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, la chiamata <xref:System.Collections.IEnumerator.Current%2A> genera un'eccezione. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>. Se la raccolta viene modificata tra <xref:System.Collections.IEnumerator.MoveNext%2A> e <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> restituisce l'elemento su cui è stata impostata, anche se l'enumeratore risulta già invalidato.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the capacity to the actual number of elements in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta.  
  
 Per reimpostare un <xref:System.Collections.SortedList> oggetto sul relativo stato iniziale, chiamata di <xref:System.Collections.SortedList.Clear%2A> metodo prima di chiamare <xref:System.Collections.SortedList.TrimToSize%2A>. L'eliminazione di un oggetto vuoto <xref:System.Collections.SortedList> imposta la capacità del <xref:System.Collections.SortedList> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere le parti inutilizzate di un <xref:System.Collections.SortedList> oggetto e su come cancellare i relativi valori.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.SortedList" /> object is read-only.  -or-  The <see cref="T:System.Collections.SortedList" /> has a fixed size.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the values in a <see cref="T:System.Collections.SortedList" /> object.</summary>
        <value>Oggetto <see cref="T:System.Collections.ICollection" /> contenente i valori dell'oggetto <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.ICollection> è una visualizzazione di sola lettura dei valori del <xref:System.Collections.SortedList> oggetto. Le modifiche apportate alle sottostante <xref:System.Collections.SortedList> vengono applicate immediatamente il <xref:System.Collections.ICollection>.  
  
 Gli elementi del <xref:System.Collections.ICollection> ordinate nello stesso ordine dei valori del <xref:System.Collections.SortedList>.  
  
 Questa proprietà è simile ai <xref:System.Collections.SortedList.GetValueList%2A> del metodo, ma restituisce un <xref:System.Collections.ICollection> dell'oggetto anziché un <xref:System.Collections.IList> oggetto.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
      </Docs>
    </Member>
  </Members>
</Type>