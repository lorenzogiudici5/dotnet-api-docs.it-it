<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="806523a2ac4e7853023da7afc4c04b405f3fafaf" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37710629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <TypeSignature Language="VB.NET" Value="Public Class TextFieldParser&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextFieldParser : IDisposable" />
  <TypeSignature Language="F#" Value="type TextFieldParser = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce i metodi e le proprietà per l'analisi dei file di testo strutturati.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `TextFieldParser` oggetto fornisce metodi e proprietà per l'analisi del file di testo strutturati. L'analisi di un file di testo con il `TextFieldParser` è simile a l'iterazione su un file di testo, mentre il `ReadFields` metodo per estrarre campi di testo è simile a suddivisione delle stringhe.  
  
 Il `TextFieldParser` può analizzare due tipi di file: delimitato o a larghezza fissa. Alcune proprietà, ad esempio `Delimiters` e `HasFieldsEnclosedInQuotes` sono significativi solo se si utilizzano file delimitati, quando si utilizza il `FieldWidths` proprietà è significativa solo quando si lavora con i file a larghezza fissa.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `Microsoft.VisualBasic.FileIO.TextFieldParser` oggetto.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Questo esempio analizza tramite un file di testo delimitato da tabulazione `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flusso da analizzare.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` oggetto per analizzare il file o un flusso che è rappresentato dal `stream` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Non è possibile leggere da <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.TextReader -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser reader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" />. Flusso <see cref="T:System.IO.TextReader" /> da analizzare.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` oggetto per analizzare il file o un flusso che è rappresentato dal `reader` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> è <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Percorso completo del file da analizzare.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` analizzare il file specificato dall'oggetto di `path` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> è una stringa vuota.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flusso da analizzare.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Codifica dei caratteri da utilizzare se la codifica non è determinata dal file. Il valore predefinito è <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` oggetto per analizzare il file o un flusso che è rappresentato dal `stream` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="defaultEncoding" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Non è possibile leggere da <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Percorso completo del file da analizzare.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Codifica dei caratteri da utilizzare se la codifica non è determinata dal file. Il valore predefinito è <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` analizzare il file specificato dall'oggetto di `path` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è una stringa vuota o <paramref name="defaultEncoding" /> è <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flusso da analizzare.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Codifica dei caratteri da utilizzare se la codifica non è determinata dal file. Il valore predefinito è <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se cercare i byte order mark all'inizio del file. Il valore predefinito è <see langword="True" />.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` oggetto per analizzare il file o un flusso che è rappresentato dal `stream` parametro.  
  
 Se il `detectEncoding` parametro è `True`, questo costruttore tenta di rilevare la codifica, esaminando i primi tre byte del file o flusso. Riconosce automaticamente UTF-8, little-endian Unicode e big endian Unicode testo se il file inizia con il BOM appropriato. In caso contrario, la codifica specificata dal parametro `defaultEncoding` viene usato.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="defaultEncoding" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Non è possibile leggere da <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding, detectEncoding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Percorso completo del file da analizzare.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Codifica dei caratteri da utilizzare se la codifica non è determinata dal file. Il valore predefinito è <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se cercare i byte order mark all'inizio del file. Il valore predefinito è <see langword="True" />.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` analizzare il file specificato dall'oggetto di `path` parametro.  
  
 Se il `detectEncoding` parametro è `True`, questo costruttore tenta di rilevare la codifica, esaminando i primi tre byte del file o flusso. Riconosce automaticamente UTF-8, little-endian Unicode e big endian Unicode testo se il file inizia con il BOM appropriato. In caso contrario, la codifica specificata dal parametro `defaultEncoding` viene usato.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è una stringa vuota o <paramref name="defaultEncoding" /> è <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Flusso da analizzare.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Codifica dei caratteri da utilizzare se la codifica non è determinata dal file. Il valore predefinito è <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Indica se cercare i byte order mark all'inizio del file. Il valore predefinito è <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" />. Indica se lasciare <c>stream</c> aperto quando l'oggetto <see langword="TextFieldParser" /> viene chiuso. Il valore predefinito è <see langword="False" />.</param>
        <summary>Inizializza una nuova istanza della classe <see langword="TextFieldParser" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo `TextFieldParser` oggetto per analizzare il file o un flusso che è rappresentato dal `stream` parametro.  
  
 Se il `detectEncoding` parametro è `True`, questo costruttore tenta di rilevare la codifica, esaminando i primi tre byte del file o flusso. Riconosce automaticamente UTF-8, little-endian Unicode e big endian Unicode testo se il file inizia con il BOM appropriato. In caso contrario, la codifica specificata dal parametro `defaultEncoding` viene usato.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="defaultEncoding" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">Non è possibile leggere da <paramref name="stream" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="textFieldParser.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude l'oggetto <see langword="TextFieldParser" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene chiusa la `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property CommentTokens As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ CommentTokens { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommentTokens : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definisce i token di commento. Un token di commento è una stringa che, se posizionata all'inizio di una riga, indica che la riga è un commento e deve essere ignorata dal parser.</summary>
        <value>Matrice di stringhe che contiene tutti i token di commento per l'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un membro avanzato. non è visibile in IntelliSense a meno che non si fa clic sul **tutti** scheda.  
  
 I token di commento di lunghezza zero vengono ignorati.  
  
   
  
## Examples  
 In questo esempio specifica che per il `TextFieldParser`, `FileReader` righe che iniziano con una virgoletta singola (') devono essere ignorate.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un token di commento contiene spazi vuoti.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiters As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Delimiters { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiters : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definisce i delimitatori per un file di testo.</summary>
        <value>Matrice di stringhe che contiene tutti i delimitatori di campo per l'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è significativa solo se il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> è impostata su `FieldType.Delimited`.  
  
 Definire i delimitatori per un file di testo può essere eseguito anche con il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> (metodo).  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `Delimiters` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 In questo esempio specifica che il delimitatore per i `TextFieldParser` oggetto `FileReader`, è la virgola (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore di un delimitatore è impostato su un carattere di nuova riga, una stringa vuota o <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate dall'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textFieldParser.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse usate dall'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textFieldParser.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Proprietà di tipo Boolean. <see langword="True" /> rilascia sia le risorse gestite che quelle non gestite; <see langword="False" /> rilascia solo le risorse non gestite.</param>
        <summary>Rilascia le risorse usate dall'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfData : bool" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce <see langword="True" /> se non sono presenti righe non vuote o righe non di commento tra la posizione del cursore corrente e la fine del file.</summary>
        <value>
          <see langword="True" /> se non vi sono più dati da leggere. In caso contrario, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata durante la lettura dai file per determinare la fine dei dati da leggere.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `EndOfData` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file delimitato da virgole|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Questo esempio Usa la `EndofData` proprietà per eseguire il ciclo attraverso tutti i campi nel file con il `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLine : string" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce la riga che ha provocato la generazione dell'eccezione <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> più recente.</summary>
        <value>Riga che ha provocato l'eccezione <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> più recente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nessun <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> sono state generate eccezioni, viene restituita una stringa vuota.  
  
 Il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> proprietà può essere utilizzata per visualizzare il numero della riga che ha causato l'eccezione.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `ErrorLine` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file delimitato da virgole|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Questo esempio Usa la `ErrorLine` proprietà per visualizzare la riga che ha generato l'oggetto corrente <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> eccezione.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ErrorLineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il numero della riga che ha provocato la generazione dell'eccezione <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> più recente.</summary>
        <value>Numero della riga che ha provocato l'eccezione <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> più recente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nessun <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> sono state generate eccezioni, viene restituito -1.  
  
 Il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> proprietà può essere utilizzata per visualizzare il numero della riga che ha causato l'eccezione. I commenti e le righe vuote non vengono ignorati quando si determina il numero di riga.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `ErrorLineNumber` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file delimitato da virgole|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Questo esempio Usa la `ErrorLineNumber` proprietà per visualizzare la posizione di riga che ha causato l'oggetto corrente <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> eccezione.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberSignature Language="VB.NET" Value="Public Property FieldWidths As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ FieldWidths { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FieldWidths : int[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la larghezza di ogni colonna nel file di testo da analizzare.</summary>
        <value>Matrice di interi che contiene la larghezza di ogni colonna nel file di testo da analizzare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è significativa solo se il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> è impostata su `FieldType.FixedWidth`. Se l'ultima voce nella matrice è minore o uguale a zero, si presuppone che il campo sia di larghezza variabile.  
  
 Il <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> metodo può essere utilizzato anche per impostare la larghezza dei campi.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `FieldWidths` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 In questo esempio legge il file `ParserText.txt`, specificando le larghezze; la prima colonna è di 5 caratteri wide, il secondo è 10, la terza di 11 e la quarta ha una larghezza variabile  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un valore di larghezza in qualsiasi percorso diverso dall'ultima voce della matrice è inferiore o uguale a zero.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TextFieldParser ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="textFieldParser.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente all'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> di provare a liberare risorse ed eseguire altre operazioni di pulitura prima che l'oggetto stesso venga recuperato dalla procedura di Garbage Collection.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="VB.NET" Value="Public Property HasFieldsEnclosedInQuotes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasFieldsEnclosedInQuotes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HasFieldsEnclosedInQuotes : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se i campi sono racchiusi tra virgolette quando un file delimitato viene analizzato.</summary>
        <value>
          <see langword="True" /> se i campi sono racchiusi tra virgolette. In caso contrario, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un membro avanzato. non è visibile in IntelliSense a meno che non si fa clic sul **tutti** scheda.  
  
 Se la proprietà è `True`, il parser si presuppone che i campi sono racchiusi tra virgolette ("") e può contenere le terminazioni di riga.  
  
 Se un campo è racchiuso tra virgolette singole, ad esempio, `abc, "field2a,field2b", field3` e questa proprietà è `True`, quindi viene restituito tutto il testo racchiuso tra virgolette è; in questo esempio restituirebbe `abc|field2a,field2b|field3`. Impostando questa proprietà su `False` renderebbe in questo esempio viene restituito `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 Questo esempio viene impostato il `HasFieldsEnclosedInQuotes` proprietà `True` per `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il numero di riga corrente oppure -1 se non sono disponibili ulteriori caratteri all'interno del flusso.</summary>
        <value>Numero di riga corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un membro avanzato. non è visibile in IntelliSense a meno che non si fa clic sul **tutti** scheda.  
  
 I commenti e le righe vuote non vengono ignorati quando si determina il numero di riga.  
  
   
  
## Examples  
 Questo esempio cerca il nome "Jones" nel file di testo e segnala le righe in cui compare.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekChars (numberOfChars As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PeekChars(int numberOfChars);" />
      <MemberSignature Language="F#" Value="member this.PeekChars : int -&gt; string" Usage="textFieldParser.PeekChars numberOfChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" />. Numero di caratteri da leggere. Obbligatorio.</param>
        <summary>Legge il numero di caratteri specificato senza spostare in avanti il cursore.</summary>
        <returns>Stringa che contiene il numero di caratteri letti specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `numberOfChars` valore deve essere inferiore al numero totale di caratteri nella riga. In caso contrario, la stringa restituita da `PeekChars` verrà troncata alla lunghezza della riga.  
  
 Le righe vuote vengono ignorate.  
  
 Non vengono restituiti i caratteri di fine riga.  
  
 Il `PeekChars` metodo non esegue alcuna analisi; un carattere di fine della riga all'interno di un campo delimitato viene interpretato come fine effettiva della riga.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `PeekChars` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Determinare il formato di un campo prima dell'analisi|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Questo esempio Usa `PeekChars` per trovare la fine dei dati e arrestare l'analisi del file a quel punto.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> è minore di 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadFields () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ ReadFields();" />
      <MemberSignature Language="F#" Value="member this.ReadFields : unit -&gt; string[]" Usage="textFieldParser.ReadFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i campi nella riga corrente, li restituisce come una matrice di stringhe e sposta il cursore alla riga successiva contenente dati.</summary>
        <returns>Matrice di stringhe che contiene i valori dei campi della riga corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per consentire agli utenti di analizzare i file di testo in più formati, il `ReadFields` metodo esamina i valori delle `TextFieldType`, `Delimiters`, e `FieldWidths`, se vengono specificati, ogni volta che viene chiamato. Gli utenti devono configurare correttamente il `TextFieldType` e `FieldWidths` o `Delimiters` proprietà, come appropriato. Se `TextFieldType` è impostata su `Delimited`, e `Delimiters` non è impostata, oppure se `TextFieldType` è impostata su `FixedWidth` e `FieldWidths`, viene generata un'eccezione.  
  
 Se `ReadFields` rileva righe vuote, queste ultime vengono ignorate e viene restituita la riga non vuota successiva.  
  
 Se il `ReadFields` (metodo) non è possibile analizzare la riga corrente, viene generata un'eccezione e non si sposta alla riga successiva. In questo modo l'applicazione tentare di analizzare nuovamente la riga.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `ReadFields` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file delimitato da virgole|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Questo esempio Usa la `ReadFields` metodo per leggere dal file delimitato da virgole `ParserText.txt`. L'esempio scrive i campi in `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Non è possibile analizzare il campo utilizzando il formato specificato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="textFieldParser.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la riga corrente come stringa e sposta il cursore alla riga successiva.</summary>
        <returns>Riga corrente dal file o dal flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ReadLine` metodo non esegue alcuna analisi; un carattere di fine della riga all'interno di un campo delimitato viene interpretato come fine effettiva della riga.  
  
 `Nothing` viene restituito se viene raggiunta la fine del file.  
  
   
  
## Examples  
 In questo esempio legge il file `ParserText.txt` e lo scrive in `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Se `Testfile.txt` non esiste, viene creato dal `WriteAllText` (metodo).  
  
 In questo esempio scrive i campi come una singola stringa. Per visualizzare ogni riga su una riga nel file di destinazione, un `VbCrLf` carattere deve essere aggiunto alla fine di ogni riga.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="member this.ReadToEnd : unit -&gt; string" Usage="textFieldParser.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge il resto del file di testo e lo restituisce come stringa.</summary>
        <returns>Testo rimanente dal file o dal flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un membro avanzato. non è visibile in IntelliSense a meno che non si fa clic sul **tutti** scheda.  
  
 Se non è nient'altro da leggere, poiché è stata raggiunta la fine del file, `Nothing` viene restituito.  
  
 Il `ReadToEnd` righe vuote e i commenti (metodo) non vengono ignorati.  
  
   
  
## Examples  
 Questo esempio Usa la `ReadToEnd` metodo per leggere l'intero file `ParserText.txt` e scriverli nel file `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Se `Testfile.txt` non esiste, viene creato dal `WriteAllText` (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDelimiters (ParamArray delimiters As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDelimiters(... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.SetDelimiters : string[] -&gt; unit" Usage="textFieldParser.SetDelimiters delimiters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Matrice di tipo <see langword="String" />.</param>
        <summary>Imposta i delimitatori per il lettore sui valori specificati e imposta il tipo di campo su <see langword="Delimited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il contenuto esistente del `Delimiters` proprietà vengono cancellate quando questo metodo è impostato.  
  
 Questo metodo fornisce un modo per impostare i delimitatori senza creare una matrice.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `SetDelimiters` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Analizzare un file di testo|[Analisi dei file di testo con l'oggetto TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In questo esempio viene aperto un parser di campo di testo e definisce il delimitatore come `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Sostituire il percorso `C:\logs\test.log` con il percorso e nome del file che si desidera analizzare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il delimitatore è di lunghezza zero.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFieldWidths (ParamArray fieldWidths As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFieldWidths(... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.SetFieldWidths : int[] -&gt; unit" Usage="textFieldParser.SetFieldWidths fieldWidths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Matrice di valori <see langword="Integer" />.</param>
        <summary>Imposta i delimitatori per il lettore sui valori specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il contenuto esistente del `Delimiters` proprietà vengono cancellate quando questa opzione è impostata.  
  
 Questo metodo fornisce un modo per impostare i delimitatori senza creare una matrice.  
  
 La tabella seguente elenca esempi di attività che implica il `SetFieldWidths` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Analizzare un file di testo.|[Analisi dei file di testo con l'oggetto TextFieldParser](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In questo esempio viene aperto un parser di campo di testo e definisce la larghezza del campo come `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Sostituire il percorso `C:\logs\test.log` con il percorso e nome del file che si desidera analizzare.  
  
 Nell'esempio seguente viene aperto un parser di campo di testo e definisce le larghezze di campo come `5`, `10`e la variabile.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Sostituire il percorso `C:\logs\test.log` con il percorso e nome del file che si desidera analizzare.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberSignature Language="VB.NET" Value="Public Property TextFieldType As FieldType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::FileIO::FieldType TextFieldType { Microsoft::VisualBasic::FileIO::FieldType get(); void set(Microsoft::VisualBasic::FileIO::FieldType value); };" />
      <MemberSignature Language="F#" Value="member this.TextFieldType : Microsoft.VisualBasic.FileIO.FieldType with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il file da analizzare è delimitato o a larghezza fissa.</summary>
        <value>Valore <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" /> che indica se il file da analizzare è delimitato o a larghezza fissa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito di questa proprietà è delimitato.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `TextFieldType` proprietà.  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Questo esempio viene creato un `TextFieldParser`, `FileReader`e specifica che è delimitata.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 Questo esempio viene creato un `TextFieldParser`, `FileReader`e specifica che è a larghezza fissa.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property TrimWhiteSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimWhiteSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrimWhiteSpace : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se gli spazi vuoti iniziale e finale devono essere tagliati dai valori dei campi.</summary>
        <value>
          <see langword="True" /> se gli spazi vuoti iniziale e finale devono essere tagliati dai valori dei campi. In caso contrario, <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito di questa proprietà è `True`.  
  
   
  
## Examples  
 Questo esempio viene creato un `TextFieldParser`, `FileReader`e imposta la `TrimWhiteSpace` proprietà `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>