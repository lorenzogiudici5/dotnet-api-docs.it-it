<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7f1000a03db6561863951b1ac502852bf4a051f0" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39873203" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un insieme di metodi che facilitano la gestione della compilazione di un'applicazione ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.Compilation.BuildManager> classe gestisce il processo di compilazione di assembly e le pagine per un'applicazione. È una classe sealed e non può essere ereditata.  
  
 <xref:System.Web.Compilation.BuildManager> contiene i membri statici che forniscono informazioni sugli assembly compilati.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dependency">Stringa che rappresenta una dipendenza.</param>
        <summary>Specifica una stringa che rappresenta una dipendenza utilizzata dal gestore di compilazione per determinare se è richiesta una compilazione pulita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo deve essere chiamato durante la `Application_PreStartInit` fase dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="dependency" /> è <see langword="null" /> oppure una stringa vuota.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo è stato chiamato dopo la fase <see langword="Application_PreStartInit" /> dell'applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">L'assembly da aggiungere.</param>
        <summary>Aggiunge un assembly al set degli assembly a cui si fa riferimento dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente all'aggiunta dell'assembly nel file Web. config a livello di applicazione. Il metodo deve essere chiamato durante la `Application_PreStartInit` fase dell'applicazione.  
  
 Il <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> metodo restituirà il set di assembly che dipendono dai file di configurazione e tutti gli assembly che sono stati aggiunti con questo metodo.  
  
 Se viene effettuato un tentativo di aggiungere un assembly che è già stato aggiunto, la voce duplicata viene ignorata.  
  
 Questo metodo deve essere chiamato prima di `Application_Start` si verifica l'evento nel file Global. asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="assembly" /> è <see langword="null" /> o vuoto.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo non era stato chiamato prima che si verificasse l'evento <see langword="Application_Start" /> nel file Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la compilazione batch è abilitata.</summary>
        <value>
          <see langword="true" /> se la compilazione batch è sempre abilitata, <see langword="false" /> se la compilazione batch non è mai abilitata o <see langword="null" /> se l'impostazione di compilazione è determinata dal file di configurazione. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di attivare o disattivare la compilazione in batch a livello di codice. Corrisponde alla `batch` attributo del `compilation` elemento nel file Web. config. Per altre informazioni, vedere [compilation Element (Schema delle impostazioni ASP.NET)](http://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12).  
  
 La proprietà può essere impostata solo nel `PreApplicationStart` (metodo). Per ulteriori informazioni sul metodo `PreApplicationStart`, vedere <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nel metodo <see langword="PreApplicationStart" /> la proprietà non è stata impostata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un elenco di assembly compilati dalla directory App_Code.</summary>
        <value>Insieme <see cref="T:System.Collections.IList" /> contenente gli assembly compilati dalla directory App_Code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file da creare.</param>
        <summary>Crea un file di cache.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> per il nuovo file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo e il <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> metodo consentono di eseguire la memorizzazione nella cache che rende persistenti nei riavvii del dominio applicazione in ambienti ad attendibilità parziale. Viene utilizzato dal framework MVC per nella cache i risultati della ricerca del controller.  
  
 Per memorizzare i dati, scrivere il <xref:System.IO.Stream> oggetto restituito da questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale del file di cui creare un'istanza.</param>
        <param name="requiredBaseType">Tipo base che definisce l'oggetto da creare.</param>
        <summary>Elabora un file a partire dal suo percorso virtuale e crea un'istanza del risultato.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'istanza del file elaborato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A> metodo funziona per le pagine compilate e senza compilazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un set di dipendenze di compilazione dalla cache ASP.NET.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">Contesto della richiesta.</param>
        <param name="virtualPath">Percorso virtuale da cui determinare l'insieme di dipendenze di compilazione.</param>
        <summary>Restituisce un insieme di dipendenze di compilazione per un percorso virtuale se questo è presente nella cache di ASP.NET.</summary>
        <returns>Oggetto <see cref="T:System.Web.Compilation.BuildDependencySet" /> memorizzato nella cache, oppure <see langword="null" /> se non è possibile recuperare l'oggetto <see cref="T:System.Web.Compilation.BuildDependencySet" /> dalla cache.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">Contesto della richiesta.</param>
        <param name="virtualPath">Percorso virtuale da cui determinare l'insieme di dipendenze di compilazione.</param>
        <param name="ensureIsUpToDate">
          <see langword="true" /> per specificare che deve essere restituito solo un set di dipendenze di compilazione corrente, oppure <see langword="false" /> per indicare che deve essere restituito qualsiasi set di dipendenze di compilazione disponibile, anche se non è corrente. Il valore predefinito è <see langword="true" />.</param>
        <summary>Restituisce un set di dipendenze di compilazione di un percorso virtuale se quest'ultimo è presente nella cache ASP.NET, anche se il contenuto non è corrente.</summary>
        <returns>Oggetto <see cref="T:System.Web.Compilation.BuildDependencySet" /> memorizzato nella cache, oppure <see langword="null" /> se non è possibile recuperare l'oggetto <see cref="T:System.Web.Compilation.BuildDependencySet" /> dalla cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `ensureIsUpToDate` valore del parametro è impostato su `true`, il <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> overload del metodo si comporta come la <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> overload del metodo. Entrambi gli overload restituiscono una dipendenza di compilazione corrente impostata se presente, in caso contrario restituiscono `null`.  
  
 Tuttavia, il <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> overload del metodo include la possibilità di restituire qualsiasi set di dipendenze di compilazione che è disponibile, anche uno obsoleto. Se il `ensureIsUpToDate` valore del parametro è impostato su `false`, il metodo restituisce qualsiasi set di dipendenze di compilazione disponibili.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale da compilare in un assembly.</param>
        <summary>Compila un file in un assembly utilizzando il percorso virtuale specificato.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Assembly" /> compilato dal percorso virtuale specificato e archiviato in memoria o su disco.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale del file da compilare.</param>
        <summary>Compila un file a partire dal suo percorso virtuale e restituisce una stringa personalizzata che il provider di compilazione mantiene nella cache.</summary>
        <returns>Stringa restituita dal metodo <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" /> e memorizzata su disco o in memoria.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale da compilare in un tipo.</param>
        <summary>Compila un file a partire dal suo percorso virtuale e restituisce il tipo compilato.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo generato dalla compilazione del percorso virtuale.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Si è verificato un errore durante la compilazione del percorso virtuale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto che rappresenta il tipo compilato per il file Global.asax.</summary>
        <returns>Oggetto che rappresenta il tipo compilato per il file Global.asax.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo viene chiamato prima che il file Global. asax è stato compilato, viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stato eseguito un tentativo di chiamare questo metodo prima che la pagina Global.asax compilata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale.</param>
        <param name="throwIfNotFound">
          <see langword="true" /> per generare un errore se il percorso virtuale non esiste. In caso contrario, <see langword="false" />. Se il percorso virtuale non esiste e <c>throwIfNotFound</c> è <see langword="false" />, questo metodo restituisce <see langword="null" />.</param>
        <summary>Ottiene una factory di oggetto per il percorso virtuale specificato.</summary>
        <returns>Factory di oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce un oggetto che consente di generare un tipo di compilazione del percorso virtuale. Restituisce un oggetto indipendentemente dal fatto che il sito Web precompilato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il percorso virtuale non esiste.  
  
oppure 
Quando è stato chiamato questo metodo esisteva già un'eccezione di livello superiore.  
  
oppure 
Questo metodo è stato chiamato durante la compilazione dei file di livello superiore da parte del processo di compilazione.  
  
oppure 
Si tratta di un'applicazione precompilata e il percorso virtuale non è stato trovato nella cache.  
  
oppure 
È stato rilevato un riferimento circolare.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un elenco di riferimenti agli assembly a cui tutte le compilazioni delle pagine devono fare riferimento.</summary>
        <returns>Insieme <see cref="T:System.Collections.ICollection" /> di riferimenti agli assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La raccolta di assembly che viene restituito dal <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> metodo include gli assembly specificati nell'elemento del file Web. config, gli assembly compilati dal codice personalizzato nella directory App_Code e gli assembly in altre cartelle di primo livello.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze di .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trova un tipo negli assembly di primo livello o negli assembly definiti nella configurazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly di primo livello fa riferimento al file Global. asax, o in un file che si trova nella directory App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se non è possibile generare un oggetto <see cref="T:System.Type" /> per il nome del tipo; in caso contrario <see langword="false" />.</param>
        <summary>Trova un tipo negli assembly di primo livello o negli assembly definiti nella configurazione e, facoltativamente, genera un'eccezione in caso di errore.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il parametro <paramref name="typeName" /> richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly di primo livello fa riferimento al file Global. asax, o in un file che si trova nella directory App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="typeName" /> non è valido.  
  
\- oppure - 
 <paramref name="typeName" /> è ambiguo.  
  
\- oppure - 
 Non è possibile trovare <paramref name="typeName" /> e <paramref name="throwOnError" /> è <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se non è possibile generare un oggetto <see cref="T:System.Type" /> per il nome del tipo; in caso contrario <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> se a <c>typeName</c> viene applicata la distinzione tra maiuscole e minuscole; in caso contrario, <see langword="false" />.</param>
        <summary>Trova un tipo negli assembly di primo livello o negli assembly definiti nella configurazione utilizzando una ricerca senza distinzione tra maiuscole e minuscole e generando, facoltativamente, un'eccezione in caso di errore.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il parametro <paramref name="typeName" /> richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly di primo livello fa riferimento al file Global. asax, o in un file che si trova nella directory App_GlobalResources, App_WebReferences, App_Code o App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="typeName" /> non è valido.  
  
\- oppure - 
 <paramref name="typeName" /> è ambiguo.  
  
\- oppure - 
 Non è possibile trovare <paramref name="typeName" /> e <paramref name="throwOnError" /> è <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale utilizzato per determinare le dipendenze.</param>
        <summary>Fornisce un insieme di dipendenze del percorso virtuale per un percorso virtuale specificato.</summary>
        <returns>Insieme <see cref="T:System.Collections.ICollection" /> di file rappresentati dai percorsi virtuali che memorizzano dipendenze per il percorso virtuale.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se l'applicazione è precompilata.</summary>
        <value>
          <see langword="true" /> se l'applicazione viene precompilata; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'applicazione corrente è precompilata come aggiornabile.</summary>
        <value>
          <see langword="true" /> se l'applicazione viene precompilata come aggiornabile. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file da leggere.</param>
        <summary>Legge un file memorizzato nella cache.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> per il file o <see langword="null" /> se il file non esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo e il <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> metodo consentono di eseguire la memorizzazione nella cache che rende persistenti nei riavvii del dominio applicazione in ambienti ad attendibilità parziale. Viene utilizzato dal framework MVC per nella cache i risultati della ricerca del controller.  
  
 Per recuperare i dati memorizzati nella cache, si leggono le <xref:System.IO.Stream> oggetto restituito da questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la versione di destinazione di .NET Framework per il sito Web corrente.</summary>
        <value>Versione di destinazione di .NET Framework per il sito Web corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà supporta la funzionalità di multitargeting ASP.NET, che consente di usare la versione più recente di Visual Studio per sviluppare applicazioni che verranno eseguiti con le versioni precedenti di .NET Framework. Un provider di compilazione è possibile usare questa proprietà per assicurarsi che il provider genera codice che è appropriato per la versione di destinazione di .NET Framework. Potrebbe, ad esempio, si desidera generare un codice diverso a seconda se un sito Web fa riferimento il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] o il [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. Per altre informazioni sulle destinazioni, vedere [.NET Framework Multi-Targeting for ASP.NET Web Projects](http://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76).  
  
 Se il sito Web non dispone di un file Web. config, ASP.NET presuppone che la versione di framework di destinazione è la versione che è associata il pool di applicazioni IIS in esecuzione con il sito. Per un sito Web di file system in cui è in esecuzione in Visual Studio, la versione di framework predefinito è la versione corrente di .NET Framework.  
  
 Se il sito Web dispone di un file Web. config, ASP.NET determina il framework di destinazione, esaminare il file Web. config.  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Siti Web destinati a .NET Framework 2.0  
 Le applicazioni Web che hanno come destinazione il [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] vengono compilate come se fosse la destinazione di [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]. Il processo di compilazione non viene fatta distinzione tra i [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] e il [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] perché il file Web. config non indica il framework di destinazione o versione del compilatore una di queste versioni di destinazione. (Per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)], il file Web. config consente di specificare la versione del compilatore e per il [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il file Web. config consente di specificare il framework di destinazione.) Pertanto, per le applicazioni Web che hanno come destinazione il [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], questa proprietà restituisce un moniker framework di destinazione che indica il [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)].  
  
 Ciò in genere non costituisce eventuali problemi. Visual Studio impedisce la creazione di riferimenti a [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] le funzionalità in un progetto di cui è destinato il [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]. Ad esempio, Visual Studio non fornisce i modelli di elemento per i servizi WCF in un progetto di cui è destinato [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], dal momento che WCF è stato introdotto con la [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] e non è compatibile con il [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 Se si prevede di distribuire un sito Web in un [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] ambiente run-time e si utilizza uno strumento diverso da Visual Studio per fare riferimento a funzionalità che sono compatibili solo con [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], il progetto venga compilato senza la generazione di errori o avvisi. Tuttavia, l'applicazione potrebbe generare errori quando il sito Web in esecuzione su di [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>