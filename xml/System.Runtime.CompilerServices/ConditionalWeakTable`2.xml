<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dbf347a600196f6012ffdb19e1733f7b6934173d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36541728" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <typeparam name="TKey">
      <span data-ttu-id="250dc-101">Tipo di riferimento al quale è associato il campo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-101">The reference type to which the field is attached.</span>
      </span>
    </typeparam>
    <typeparam name="TValue">
      <span data-ttu-id="250dc-102">Il tipo del campo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-102">The field's type.</span>
      </span>
      <span data-ttu-id="250dc-103">Deve essere un tipo di riferimento.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-103">This must be a reference type.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="250dc-104">Consente ai compilatori di allegare dinamicamente campi dell'oggetto agli oggetti gestiti.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-104">Enables compilers to dynamically attach object fields to managed objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-105">Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe consente ai compilatori di linguaggio di allegare proprietà arbitrarie agli oggetti gestiti in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="250dc-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="250dc-106">Oggetto <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> oggetto è un dizionario che associa un oggetto gestito, è rappresentato da una chiave, alla proprietà associata è rappresentato da un valore.</span><span class="sxs-lookup"><span data-stu-id="250dc-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="250dc-107">Le chiavi dell'oggetto sono le singole istanze di `TKey` (classe) a cui è associata la proprietà e i relativi valori sono i valori delle proprietà che vengono assegnati agli oggetti corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="250dc-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="250dc-108">Le chiavi devono essere univoche. in altre parole, il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe supporta un solo valore associato per ogni oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="250dc-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="250dc-109">Due chiavi sono uguali se passandoli al <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo `true`.</span><span class="sxs-lookup"><span data-stu-id="250dc-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="250dc-110">Non è possibile controllare i confronti di uguaglianza eseguendo l'override <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> impostare in modo esplicito il codice hash per una chiave.</span><span class="sxs-lookup"><span data-stu-id="250dc-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="250dc-111">Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe non utilizza il <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo per calcolare i codici hash e pertanto non vengono richiamate in <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> esegue l'override.</span><span class="sxs-lookup"><span data-stu-id="250dc-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="250dc-112">Sebbene il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe contiene una raccolta di coppie chiave/valore, viene considerata come una tabella anziché un oggetto dizionario.</span><span class="sxs-lookup"><span data-stu-id="250dc-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="250dc-113">Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe differisce da un dizionario in diversi modi:</span><span class="sxs-lookup"><span data-stu-id="250dc-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="250dc-114">Non vengono mantenute le chiavi.</span><span class="sxs-lookup"><span data-stu-id="250dc-114">It does not persist keys.</span></span> <span data-ttu-id="250dc-115">Vale a dire, una chiave non viene mantenuta attiva solo perché è un membro della raccolta.</span><span class="sxs-lookup"><span data-stu-id="250dc-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="250dc-116">Non include tutti i metodi (ad esempio `GetEnumerator` o `Contains`) che ha in genere un dizionario.</span><span class="sxs-lookup"><span data-stu-id="250dc-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="250dc-117">Non implementa il <xref:System.Collections.Generic.IDictionary%602> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="250dc-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="250dc-118">Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe differisce da altri oggetti della raccolta nella gestione della durata degli oggetti di chiavi archiviate nell'insieme.</span><span class="sxs-lookup"><span data-stu-id="250dc-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="250dc-119">In genere, quando un oggetto viene archiviato in una raccolta, la sua durata dura fino a quando non viene rimosso (e non sono presenti riferimenti aggiuntivi per l'oggetto) o fino a quando non viene eliminato definitivamente l'oggetto raccolta stesso.</span><span class="sxs-lookup"><span data-stu-id="250dc-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="250dc-120">Tuttavia, nel <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> (classe), aggiunta di una coppia chiave/valore per la tabella non garantisce che la chiave verrà mantenuti, anche se può essere raggiunta direttamente da un valore archiviato nella tabella (ad esempio, se la tabella contiene una chiave, con un valore V1 e una seconda chiave, B, con un valore di P2 che contiene un riferimento ad A).</span><span class="sxs-lookup"><span data-stu-id="250dc-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="250dc-121">Al contrario, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automaticamente rimuove la voce di chiave/valore, non appena non esistono altri riferimenti a una chiave esterna alla tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="250dc-122">Nell'esempio viene illustrata una situazione di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="250dc-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="250dc-123">Nell'esempio seguente viene illustrato che una chiave archiviata nel <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella non vengono mantenute dopo i riferimenti a esso all'esterno della tabella vengono eliminati definitivamente.</span><span class="sxs-lookup"><span data-stu-id="250dc-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="250dc-124">L'esempio definisce due classi: `ManagedClass`, che rappresenta la chiave nella tabella, e `ClassData`, che rappresenta il valore della chiave.</span><span class="sxs-lookup"><span data-stu-id="250dc-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="250dc-125">Nell'esempio viene creata un'istanza di tre oggetti di ogni tipo.</span><span class="sxs-lookup"><span data-stu-id="250dc-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="250dc-126">Crea inoltre un <xref:System.WeakReference> oggetto che rappresenta il secondo `ManagedClass`, quindi Elimina il secondo `ManagedClass` istanza.</span><span class="sxs-lookup"><span data-stu-id="250dc-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="250dc-127">Il tentativo di recuperare il secondo `ManagedClass` dell'oggetto dal <xref:System.WeakReference.Target%2A> proprietà indica che non rimangono riferimenti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="250dc-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="250dc-128">Le istanze del <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> classe sono thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span>
      </span>
      <span data-ttu-id="250dc-129">Non richiedono che ai chiamanti di alcun blocco aggiuntivo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="250dc-129">They do not require callers to do any additional locking.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="250dc-130">Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-131">Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> costruttore crea un'istanza vuota <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella; vale a dire, la tabella non contiene nessun coppie chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="250dc-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="250dc-132">È possibile aggiungere coppie chiave/valore chiamando il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="250dc-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="250dc-133">Ogni chiave in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> l'oggetto deve essere univoco.</span><span class="sxs-lookup"><span data-stu-id="250dc-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="250dc-134">Le chiavi non sono univoche se fanno riferimento allo stesso oggetto (vale a dire, se essere passate come argomenti per il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> restituisce `true`).</span><span class="sxs-lookup"><span data-stu-id="250dc-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="250dc-135">Chiave da aggiungere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-135">The key to add.</span>
          </span>
          <span data-ttu-id="250dc-136">
            <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-136">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="250dc-137">Valore della proprietà della chiave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-137">The key's property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="250dc-138">Aggiunge una chiave alla tabella.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-138">Adds a key to the table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-139">Ogni chiave in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> l'oggetto deve essere univoco.</span><span class="sxs-lookup"><span data-stu-id="250dc-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="250dc-140">Le chiavi non sono univoche se fanno riferimento allo stesso oggetto (vale a dire, se essere passate come argomenti per il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> restituisce `true`).</span><span class="sxs-lookup"><span data-stu-id="250dc-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="250dc-141">Se la chiave è sottoposto a Garbage Collection durante l'operazione di addizione, la coppia chiave/valore esistente viene rimosso e viene aggiunta la nuova coppia chiave/valore senza che venga generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="250dc-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="250dc-142">L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza.</span><span class="sxs-lookup"><span data-stu-id="250dc-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="250dc-143">Nell'esempio viene quindi chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> metodo per aggiungere un `MainClass` oggetto e il relativo collegate `MainInfo` l'oggetto in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="250dc-144">L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.</span><span class="sxs-lookup"><span data-stu-id="250dc-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="250dc-145">
            <paramref name="key" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-145">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="250dc-146">
            <paramref name="key" /> esiste già.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-146">
              <paramref name="key" /> already exists.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="250dc-147">richiede attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-147">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="250dc-148">L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-148">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="250dc-149">Garantisce che le risorse vengano liberate e che vengano eseguite le altre operazioni di pulizia quando l'oggetto <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> viene recuperato da Garbage Collector.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-149">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-150">Il garbage collector chiama <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> quando l'oggetto corrente è pronto per essere completato.</span><span class="sxs-lookup"><span data-stu-id="250dc-150">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="250dc-151">Chiave da ricercare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-151">The key to search for.</span>
          </span>
          <span data-ttu-id="250dc-152">
            <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-152">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="250dc-153">Ricerca atomicamente una chiave specificata nella tabella e restituisce il valore corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-153">Atomically searches for a specified key in the table and returns the corresponding value.</span>
          </span>
          <span data-ttu-id="250dc-154">Se la chiave non esiste nella tabella, il metodo richiama il costruttore predefinito della classe che rappresenta il valore della tabella per creare un valore che viene associato alla chiave specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-154">If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="250dc-155">Valore che corrisponde a <paramref name="key" />, se <paramref name="key" /> esiste già nella tabella; in caso contrario, nuovo valore creato dal costruttore predefinito della classe definita dal parametro di tipo generico <paramref name="TValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-155">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-156">Se `key` non esiste nella tabella, il metodo aggiunge, insieme all'oggetto che viene creata un'istanza chiamando il costruttore predefinito della classe definita per il `TValue` parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="250dc-156">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="250dc-157">Se il `TValue` classe non dispone di alcun costruttore predefinito, un <xref:System.MissingMethodException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="250dc-157">If the `TValue` class has no default constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="250dc-158">Questo è il metodo consigliato per il recupero di un valore esistente o aggiungendo un nuovo valore per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella se la classe di valore della tabella definisce un costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="250dc-158">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a default constructor.</span></span> <span data-ttu-id="250dc-159">Se non definisce un costruttore predefinito, è possibile chiamare invece il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> (metodo), che si basa su un metodo di callback fornita per creare un'istanza di oggetto che rappresenta il valore della tabella</span><span class="sxs-lookup"><span data-stu-id="250dc-159">If it does not define a default constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="250dc-160">Per recuperare il valore di una chiave esistente senza aggiungere la coppia chiave/valore se la chiave non viene trovata nella tabella, chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="250dc-160">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="250dc-161">L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza.</span><span class="sxs-lookup"><span data-stu-id="250dc-161">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="250dc-162">Nell'esempio viene chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodo per aggiungere un `MainClass` oggetto e il relativo collegate `MainInfo` l'oggetto in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-162">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="250dc-163">L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.</span><span class="sxs-lookup"><span data-stu-id="250dc-163">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="250dc-164">
            <paramref name="key" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-164">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="250dc-165">
            <block subset="none" type="note">
              <para> In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.MissingMemberException" />.  </para>
            </block> La classe che rappresenta il valore della tabella non definisce un costruttore predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-165">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.  </para>
              </block>  The class that represents the table's value does not define a default constructor.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="250dc-166">Chiave da ricercare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-166">The key to search for.</span>
          </span>
          <span data-ttu-id="250dc-167">
            <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-167">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <param name="createValueCallback">
          <span data-ttu-id="250dc-168">Delegato a un metodo che può creare un valore per l'oggetto <c>key</c> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-168">A delegate to a method that can create a value for the given <c>key</c>.</span>
          </span>
          <span data-ttu-id="250dc-169">Dispone di un solo parametro di tipo <c>TKey</c> e restituisce un valore di tipo <c>TValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-169">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="250dc-170">Ricerca atomicamente una chiave specificata nella tabella e restituisce il valore corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-170">Atomically searches for a specified key in the table and returns the corresponding value.</span>
          </span>
          <span data-ttu-id="250dc-171">Se la chiave non esiste nella tabella, il metodo richiama un metodo di callback per creare un valore che viene associato alla chiave specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-171">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="250dc-172">Valore associato a <paramref name="key" />, se <paramref name="key" /> esiste già nella tabella; in caso contrario, il nuovo valore restituito dal delegato <paramref name="createValueCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-172">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-173">Se `key` non esiste nella tabella <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> richiama il metodo definito dal `createValueCallback` parametro e lo passa la chiave.</span><span class="sxs-lookup"><span data-stu-id="250dc-173">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="250dc-174">Un nuovo valore è associato alla chiave della tabella e restituito come risultato.</span><span class="sxs-lookup"><span data-stu-id="250dc-174">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="250dc-175">Utilizzare questo metodo solo quando la classe che rappresenta il valore della tabella non definisce un costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="250dc-175">Use this method only when the class that represents the table's value does not define a default constructor.</span></span> <span data-ttu-id="250dc-176">Se definisce un costruttore predefinito, usare il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="250dc-176">If it does define a default constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="250dc-177">Per recuperare il valore di una chiave esistente senza aggiungere la coppia chiave/valore se la chiave non viene trovata nella tabella, chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="250dc-177">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="250dc-178">Se più thread tentano di creare la stessa chiave, `createValueCallback` può essere richiamato più volte con la stessa chiave.</span><span class="sxs-lookup"><span data-stu-id="250dc-178">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="250dc-179">Solo una di queste chiamate avrà esito positivo e il relativo valore restituito verrà aggiunto alla tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-179">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="250dc-180">Il thread può creare il valore è indeterminato.</span><span class="sxs-lookup"><span data-stu-id="250dc-180">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="250dc-181">Questa regola consente alla tabella di richiamare `createValueCallback` all'esterno del blocco di tabella interna per impedire i deadlock.</span><span class="sxs-lookup"><span data-stu-id="250dc-181">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="250dc-182">L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza.</span><span class="sxs-lookup"><span data-stu-id="250dc-182">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="250dc-183">Definisce inoltre un valore statico (`Shared` in Visual Basic) `CreateAttachedValue` metodo che può essere assegnato al <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegato e passare il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="250dc-183">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="250dc-184">Nell'esempio viene chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodo per aggiungere un `MainClass` oggetto e il relativo collegate `MainInfo` l'oggetto in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-184">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="250dc-185">L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.</span><span class="sxs-lookup"><span data-stu-id="250dc-185">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="250dc-186">
            <paramref name="key" /> o <paramref name="createValueCallback" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-186">
              <paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="250dc-187">richiede attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-187">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="250dc-188">L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-188">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="250dc-189">Chiave da rimuovere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-189">The key to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="250dc-190">Rimuove una chiave e il relativo valore dalla tabella.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-190">Removes a key and its value from the table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="250dc-191">
            <see langword="true" /> se la chiave viene trovata e rimossa; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-191">
              <see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-192">Se la chiave è sottoposto a Garbage Collection durante l'operazione, il metodo non genera un'eccezione e il valore restituito è indefinito.</span><span class="sxs-lookup"><span data-stu-id="250dc-192">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="250dc-193">
            <paramref name="key" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-193">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="250dc-194">richiede attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-194">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="250dc-195">L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-195">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="250dc-196">La chiave che rappresenta un oggetto con una proprietà associata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-196">The key that represents an object with an attached property.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="250dc-197">Quando questo metodo viene restituito, contiene il valore della proprietà associata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-197">When this method returns, contains the attached property value.</span>
          </span>
          <span data-ttu-id="250dc-198">Se <c>key</c> non viene trovato, <c>value</c> contiene il valore predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-198">If <c>key</c> is not found, <c>value</c> contains the default value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="250dc-199">Ottiene il valore della chiave specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-199">Gets the value of the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="250dc-200">
            <see langword="true" /> se viene trovato l'oggetto <paramref name="key" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-200">
              <see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="250dc-201">Se la chiave è sottoposto a Garbage Collection durante l'operazione, il metodo può restituire `false` e impostare `value` sul valore predefinito valore (come se la chiave non erano presente).</span><span class="sxs-lookup"><span data-stu-id="250dc-201">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="250dc-202">L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza.</span><span class="sxs-lookup"><span data-stu-id="250dc-202">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="250dc-203">Nell'esempio viene chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore da un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-203">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="250dc-204">In ogni caso, nell'esempio viene chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per confermare che la coppia chiave/valore è stato aggiunto alla tabella.</span><span class="sxs-lookup"><span data-stu-id="250dc-204">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="250dc-205">
            <paramref name="key" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-205">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="250dc-206">richiede attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-206">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="250dc-207">L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="250dc-207">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>