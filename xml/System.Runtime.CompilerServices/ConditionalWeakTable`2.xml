<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bce20f7cca9b913a61401bd35c2b545b5de16a2f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39726203" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Tipo di riferimento al quale è associato il campo.</typeparam>
    <typeparam name="TValue">Il tipo del campo. Deve essere un tipo di riferimento.</typeparam>
    <summary>Consente ai compilatori di allegare dinamicamente campi dell'oggetto agli oggetti gestiti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe consente ai compilatori di linguaggio associare proprietà arbitrarie a oggetti gestiti in fase di esecuzione. Oggetto <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> oggetto è un dizionario che associa un oggetto gestito, che è rappresentato da una chiave, alla proprietà associata, che è rappresentata da un valore. Le chiavi dell'oggetto sono le singole istanze del `TKey` classe a cui è associata la proprietà e i relativi valori sono i valori delle proprietà che vengono assegnati agli oggetti corrispondenti.  
  
 Le chiavi devono essere univoche. in altre parole, il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe supporta un solo valore associato per ogni oggetto gestito. Due chiavi sono uguali se si passa per la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> restituzione del metodo `true`.  
  
> [!NOTE]
>  Non è possibile controllare i confronti di uguaglianza eseguendo l'override <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> impostare in modo esplicito il codice hash per una chiave. Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe non usa la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo per calcolare i codici hash e pertanto non è possibile richiamare <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> esegue l'override.  
  
 Sebbene il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe contiene una raccolta di coppie chiave/valore, è più considerato come una tabella anziché un oggetto dizionario. Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe differisce da un dizionario in diversi modi:  
  
-   Non rende persistenti le chiavi. Vale a dire una chiave non viene mantenuta attiva solo perché è un membro della raccolta.  
  
-   Non include tutti i metodi (ad esempio `GetEnumerator` o `Contains`) che ha in genere un dizionario.  
  
-   Non implementa il <xref:System.Collections.Generic.IDictionary%602> interfaccia.  
  
 Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe differisce dagli altri oggetti della raccolta nella gestione della durata delle chiavi archiviate nell'insieme. In genere, quando un oggetto è archiviato in una raccolta, il ciclo di vita dura fino a quando non viene rimosso (e non sono presenti altri riferimenti all'oggetto) o fino a quando non viene eliminato definitivamente l'oggetto raccolta stesso. Tuttavia, nel <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> (classe), aggiunta di una coppia chiave/valore per la tabella non garantisce che la chiave verrà mantenuti, anche se può essere raggiunta direttamente da un valore archiviato nella tabella (ad esempio, se la tabella contiene una chiave, con un valore V1 e una seconda chiave, B, con un valore di P2 che contiene un riferimento all'oggetto). Al contrario, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automaticamente rimuove la voce di chiave/valore, non appena non altri riferimenti a una chiave esistano all'esterno della tabella. Nell'esempio viene illustrata una situazione di questo tipo.  
  
   
  
## Examples  
 L'esempio seguente illustra come una chiave archiviata nel <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella non viene mantenuta dopo i riferimenti a esso all'esterno della tabella vengono eliminati definitivamente. L'esempio definisce due classi: `ManagedClass`, che rappresenta la chiave nella tabella, e `ClassData`, che rappresenta il valore della chiave. L'esempio crea tre oggetti di ogni tipo. Crea inoltre una <xref:System.WeakReference> oggetto che rappresenta il secondo `ManagedClass`e quindi distrugge la seconda `ManagedClass` istanza. Il tentativo di recuperare il secondo `ManagedClass` dall'oggetto di <xref:System.WeakReference.Target%2A> proprietà indica che nessun riferimento all'oggetto rimanga.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Le istanze del <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> classe sono thread-safe. Non richiedono ai chiamanti di alcun blocco aggiuntivo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> costruttore crea un'istanza di un oggetto vuoto <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella; vale a dire, la tabella non contiene nessun coppie chiave/valore. È possibile aggiungere coppie chiave/valore chiamando il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> (metodo).  
  
 Ogni chiave in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> oggetto deve essere univoco. Le chiavi non sono univoche se fanno riferimento allo stesso oggetto (vale a dire, se li passando come argomenti per il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> restituzione del metodo `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da aggiungere. <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</param>
        <param name="value">Valore della proprietà della chiave.</param>
        <summary>Aggiunge una chiave alla tabella.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> oggetto deve essere univoco. Le chiavi non sono univoche se fanno riferimento allo stesso oggetto (vale a dire, se li passando come argomenti per il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> restituzione del metodo `true`).  
  
 Se la chiave è sottoposto a garbage collection durante l'operazione di addizione, la coppia chiave/valore esistente viene rimossa e la nuova coppia chiave/valore viene aggiunto senza che venga generata un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza. Nell'esempio viene quindi chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> metodo per aggiungere un `MainClass` oggetto e relativo collegati `MainInfo` dell'oggetto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella. L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> esiste già.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantisce che le risorse vengano liberate e che vengano eseguite le altre operazioni di pulizia quando l'oggetto <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> viene recuperato da Garbage Collector.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il garbage collector chiama <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> quando l'oggetto corrente è pronto per essere completato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da ricercare. <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</param>
        <summary>Ricerca atomicamente una chiave specificata nella tabella e restituisce il valore corrispondente. Se la chiave non esiste nella tabella, il metodo richiama il costruttore predefinito della classe che rappresenta il valore della tabella per creare un valore che viene associato alla chiave specificata.</summary>
        <returns>Valore che corrisponde a <paramref name="key" />, se <paramref name="key" /> esiste già nella tabella; in caso contrario, nuovo valore creato dal costruttore predefinito della classe definita dal parametro di tipo generico <paramref name="TValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `key` non esiste nella tabella, il metodo aggiunge, insieme all'oggetto che viene creata un'istanza chiamando il costruttore predefinito della classe definita per il `TValue` parametro di tipo generico. Se il `TValue` classe non dispone di alcun costruttore predefinito, un <xref:System.MissingMethodException> viene generata un'eccezione.  
  
 Questo è il metodo consigliato per il recupero di un valore esistente o aggiungendo un nuovo valore per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella se la classe di valore della tabella definisce un costruttore predefinito. Se non definisce un costruttore predefinito, è possibile chiamare invece il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodo, che si basa su un metodo di callback fornite per creare un'istanza dell'oggetto che rappresenta il valore della tabella  
  
 Per recuperare il valore di una chiave esistente senza aggiungere la coppia chiave/valore se la chiave non viene trovata nella tabella, chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza. L'esempio chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodo per aggiungere un `MainClass` oggetto e relativo collegati `MainInfo` dell'oggetto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella. L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.MissingMemberException" />. </para>
          </block>  
  
La classe che rappresenta il valore della tabella non definisce un costruttore predefinito.</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da ricercare. <c>key</c> rappresenta l'oggetto a cui è associata la proprietà.</param>
        <param name="createValueCallback">Delegato a un metodo che può creare un valore per l'oggetto <c>key</c> specificato. Dispone di un solo parametro di tipo <c>TKey</c> e restituisce un valore di tipo <c>TValue</c>.</param>
        <summary>Ricerca atomicamente una chiave specificata nella tabella e restituisce il valore corrispondente. Se la chiave non esiste nella tabella, il metodo richiama un metodo di callback per creare un valore che viene associato alla chiave specificata.</summary>
        <returns>Valore associato a <paramref name="key" />, se <paramref name="key" /> esiste già nella tabella; in caso contrario, il nuovo valore restituito dal delegato <paramref name="createValueCallback" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `key` non esiste nella tabella <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> richiama il metodo definito dal `createValueCallback` parametro e lo passa la chiave. Un nuovo valore è associato alla chiave della tabella e restituito come risultato.  
  
 Usare questo metodo solo quando la classe che rappresenta il valore della tabella non definisce un costruttore predefinito. Se definisce un costruttore predefinito, usare il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodo invece. Per recuperare il valore di una chiave esistente senza aggiungere la coppia chiave/valore se la chiave non viene trovata nella tabella, chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> (metodo).  
  
 Se più thread tentano di creare la stessa chiave, `createValueCallback` può essere richiamato più volte con la stessa chiave. Solo una di queste chiamate avrà esito positivo e il relativo valore restituito verrà aggiunto alla tabella. Quale thread ha esito positivo in creando il valore è indeterminata. Questa regola consente alla tabella di richiamare `createValueCallback` di fuori del blocco di tabella interna per impedire i deadlock.  
  
   
  
## Examples  
 L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza. Definisce anche un valore statico (`Shared` in Visual Basic) `CreateAttachedValue` metodo che può essere assegnato alle <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegare e passato al <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> (metodo). L'esempio chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodo per aggiungere un `MainClass` oggetto e relativo collegati `MainInfo` dell'oggetto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella. L'esempio illustra anche le chiamate per il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metodi per aggiungere coppie chiave/valore per la tabella e il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per recuperare il valore di una chiave esistente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> o <paramref name="createValueCallback" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da rimuovere.</param>
        <summary>Rimuove una chiave e il relativo valore dalla tabella.</summary>
        <returns>
          <see langword="true" /> se la chiave viene trovata e rimossa; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la chiave è sottoposto a garbage collection durante questa operazione, il metodo non genera un'eccezione e il valore restituito è indefinito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">La chiave che rappresenta un oggetto con una proprietà associata.</param>
        <param name="value">Quando questo metodo viene restituito, contiene il valore della proprietà associata. Se <c>key</c> non viene trovato, <c>value</c> contiene il valore predefinito.</param>
        <summary>Ottiene il valore della chiave specificata.</summary>
        <returns>
          <see langword="true" /> se viene trovato l'oggetto <paramref name="key" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la chiave è sottoposto a garbage collection durante questa operazione, il metodo può restituire `false` e impostare `value` sul valore predefinito valore (come se la chiave non erano presente).  
  
   
  
## Examples  
 L'esempio seguente definisce una `MainClass` classe e un `MainInfo` (classe), che fornisce informazioni sul `MainClass` istanza. L'esempio chiama il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodi per aggiungere coppie chiave/valore da un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabella. In ogni caso, nell'esempio viene chiamato il <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodo per confermare che la coppia chiave/valore è stato aggiunto alla tabella.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>