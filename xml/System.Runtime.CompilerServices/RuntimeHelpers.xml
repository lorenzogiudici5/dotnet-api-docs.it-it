<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RuntimeHelpers.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c39d8180904c9260ec3b7f679f09d3791b94ac31.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c39d8180904c9260ec3b7f679f09d3791b94ac31</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
          <target state="translated">Fornisce un set di proprietà e metodi statici che forniscono il supporto per i compilatori.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>This class cannot be inherited.</source>
          <target state="translated">Questa classe non può essere ereditata.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come impostare in modo affidabile l'handle utilizzando il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Per impostare in modo affidabile un handle a un handle preesistente specificato, è necessario assicurarsi che l'allocazione di handle nativo e la successiva registrazione di questo handle all'interno di un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> oggetto è di tipo atomico.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Qualsiasi errore tra queste operazioni (ad esempio un'interruzione del thread o l'eccezione di memoria esaurita) comporterà l'handle nativo perdita.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> per verificare che l'handle non viene perso.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
          <target state="translated">Assicura che lo spazio dello stack restante sia sufficiente per eseguire la funzione di .NET Framework media.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> fornisce informazioni su un stack artificialmente limitato che mantiene sufficiente spazio per un'eccezione da generare e azione di ripristino da eseguire.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
          <target state="translated">Il limite dello stack artificiale viene scelto da common language runtime per garantire che spazio sufficiente per generare un'eccezione in modo sicuro.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
          <target state="translated">Questo metodo è utile in situazioni in cui potrebbe verificarsi un overflow dello stack come risultato una ricorsione illimitata.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
          <target state="translated">Serve da usare in scenari di servizi del compilatore, anche se può anche essere utilizzato in modo sicuro in altri scenari di sviluppo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
          <target state="translated">Se lo spazio dello stack è sufficiente, non viene generata l'eccezione e la maggior parte dei tipi .NET Framework e i membri possono comunque essere chiamati.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo non fa parte del supporto di area a esecuzione vincolata e non deve essere confuso con il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
          <target state="translated">Lo spazio dello stack disponibile è insufficiente per eseguire la funzione di .NET Framework media.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Primo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">Secondo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are considered equal.</source>
          <target state="translated">Determina se le istanze di <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> specificate sono considerate uguali.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parameter is the same instance as the <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> parameter, or if both are <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or if <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> è la stessa istanza del parametro <ph id="ph3">&lt;paramref name="o2" /&gt;</ph>, se entrambi sono <ph id="ph4">&lt;see langword="null" /&gt;</ph> o se <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> restituisce <ph id="ph5">&lt;see langword="true" /&gt;</ph>; in caso contrario, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The following example demonstrates how to compare two objects by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come confrontare due oggetti utilizzando il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to try.</source>
          <target state="translated">Delegato per il codice da provare.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to run if an exception occurs.</source>
          <target state="translated">Delegato per il codice da eseguire in caso di eccezione.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>The data to pass to <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Dati da passare a <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> e <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>Executes code using a <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> while using another <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to execute additional code in case of an exception.</source>
          <target state="translated">Esegue il codice utilizzando <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph>, mentre si utilizza un altro oggetto <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> per eseguire ulteriore codice in caso di eccezione.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>An object to retrieve the hash code for.</source>
          <target state="translated">Oggetto per cui recuperare il codice hash.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
          <target state="translated">Viene utilizzato come funzione hash per un oggetto particolare ed è adatto per l'utilizzo in algoritmi e in strutture di dati che utilizzano i codici hash, quali una tabella hash.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A hash code for the object identified by the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Codice hash per l'oggetto identificato dal parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> metodo chiama sempre il <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> metodo non virtuale, anche se il tipo dell'oggetto ha eseguito l'override di <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pertanto, l'utilizzo <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> potrebbero essere diversi da chiamare <ph id="ph2">`GetHashCode`</ph> direttamente sull'oggetto con il <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
          <target state="translated">Sebbene il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> restituisce codici hash identici per i riferimenti all'oggetto identico, non utilizzare questo metodo per verificare l'identità dell'oggetto, in quanto il codice hash non identifica in modo univoco un riferimento all'oggetto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per eseguire il test per identificare oggetti (ovvero, per verificare che due oggetti riferimento lo stesso oggetto in memoria), chiamare il <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
          <target state="translated">Non è necessario utilizzare <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> per verificare se due stringhe rappresentano riferimenti a oggetti uguali, in quanto la stringa è inserita.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per verificare l'inserimento di stringhe, chiamare il <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods differ as follows:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> metodi differiscono nel modo seguente:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Restituisce un codice hash basato sulla definizione dell'oggetto di uguaglianza.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ad esempio, due stringhe con contenuto identico restituirà lo stesso valore per <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that indicates object identity.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Restituisce un codice hash che indica l'identità dell'oggetto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
          <target state="translated">Ovvero, due stringhe variabili il cui contenuto è identico e che rappresentano una stringa che viene inserita (vedere il <bpt id="p1">[</bpt>inserimento di stringhe<ept id="p1">](#interning)</ept> sezione) o i codici hash che rappresentano una singola stringa in memoria restituire identici.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
          <target state="translated">Si noti che <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> restituisce sempre i codici hash identici per i riferimenti agli oggetti uguali.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
          <target state="translated">Tuttavia, non è vero il contrario: i codici hash uguale non indicano i riferimenti agli oggetti uguali.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
          <target state="translated">Un valore del codice hash particolare non è univoco per un riferimento di oggetto specifico. riferimenti a oggetti diversi possono generare codici hash identici.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>String Interning</source>
          <target state="translated">Inserimento di stringhe</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
          <target state="translated">Common language runtime (CLR) gestisce un pool interno di stringhe e archivia i valori letterali nel pool.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
          <target state="translated">Se due stringhe (ad esempio, <ph id="ph1">`str1`</ph> e <ph id="ph2">`str2`</ph>) sono costituite da un identico valore letterale stringa, Common Language Runtime imposterà <ph id="ph3">`str1`</ph> e <ph id="ph4">`str2`</ph> in modo da puntare alla stessa posizione nell'heap gestito per risparmiare memoria.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> nella stringa di questi due oggetti produce lo stesso codice hash, diversamente il secondo elemento puntato nella sezione precedente.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The CLR adds only literals to the pool.</source>
          <target state="translated">CLR aggiunge solo valori letterali al pool.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
          <target state="translated">Risultati delle operazioni di stringa, ad esempio concatenazione non vengono aggiunti al pool, a meno che il compilatore risolve la concatenazione di stringhe come un singolo valore letterale di stringa.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will not produce the same hash code.</source>
          <target state="translated">Pertanto, se <ph id="ph1">`str2`</ph> è stato creato come risultato di un'operazione di concatenazione e <ph id="ph2">`str2`</ph> è identico a <ph id="ph3">`str1`</ph>tramite <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> stringa questi due oggetti non verranno generato lo stesso codice hash.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se si desidera aggiungere una stringa concatenata al pool in modo esplicito, utilizzare il <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method to check whether a string has an interned reference.</source>
          <target state="translated">È inoltre possibile utilizzare il <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> metodo per verificare se una stringa è stato inserito un riferimento.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The following example demonstrates the difference between the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la differenza tra il <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The output from the example illustrates the following:</source>
          <target state="translated">L'output dell'esempio viene illustrato quanto segue:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Both sets of hash codes for the first set of strings passed to the <ph id="ph1">`ShowHashCodes`</ph> method are different, because the strings are completely different.</source>
          <target state="translated">Entrambi i set di codici hash per il primo set di stringhe passato per il <ph id="ph1">`ShowHashCodes`</ph> metodo sono diversi, perché le stringhe sono completamente diverse.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> generates the same hash code for the second set of strings passed to the <ph id="ph2">`ShowHashCodes`</ph> method, because the strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> genera lo stesso codice hash per il secondo set di stringhe passato per il <ph id="ph2">`ShowHashCodes`</ph> metodo, perché le stringhe sono uguali.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method does not.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> non dal metodo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The first string is defined by using a string literal and so is interned.</source>
          <target state="translated">La prima stringa viene definita mediante un valore letterale stringa e pertanto è stata inserita.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the value of the second string is the same, it is not interned, because it is returned by a call to the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Anche se il valore della seconda stringa è lo stesso, questo non è inserito, poiché viene restituito da una chiamata al <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>In the case of the third string, the hash codes produced by <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> for both strings are identical, as are the hash codes produced by <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Nel caso della terza stringa, i codici hash generati da <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> per entrambe le stringhe sono identiche, così come sono i codici hash generati da <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</source>
          <target state="translated">Ciò accade perché il compilatore ha considerato il valore assegnato a entrambe le stringhe come un singolo valore letterale di stringa, e in modo da fare riferimento le variabili di stringa per la stessa stringa centralizzata.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The value type to be boxed.</source>
          <target state="translated">Tipo di valore di cui eseguire la conversione boxing.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxes a value type.</source>
          <target state="translated">Esegue la conversione boxing di un tipo di valore.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>A boxed copy of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> if it is a value class; otherwise, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> itself.</source>
          <target state="translated">Copia boxed di <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> se è una classe di valori. In caso contrario, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
          <target state="translated">Conversione boxing di un tipo di valore, crea un oggetto ed esegue una copia superficiale dei campi del tipo di valore specificato nel nuovo oggetto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
          <target state="translated">Questo metodo consente a una classe di valore deve essere modificato come oggetto pur mantenendo il comportamento di alias di una classe di valore.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
          <target state="translated">Il valore restituito varia a seconda se la classe di valori sia modificabile o non modificabile:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
          <target state="translated">Se il valore assegnato è una classe di valore modificabile, il metodo restituisce una copia superficiale della classe, perché le classi di valore hanno una semantica di copia.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
          <target state="translated">Se il valore assegnato è una classe di valore non modificabile, il metodo restituisce l'oggetto stesso, anziché una copia della classe.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
          <target state="translated">I compilatori di linguaggi tipizzati in modo dinamico è possono utilizzare questo metodo per assicurarsi che vengano utilizzati tipi di valore boxed in modo identico ai tipi di valore unboxed.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
          <target state="translated">Tipi di valore boxed, ovvero ottengano duplicati quando si passa a, e vengono sempre passati per valore.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
          <target state="translated">Il compilatore può chiamare <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> per assegnare un tipo di valore a un oggetto o per passare un tipo di valore come parametro di un oggetto di tipo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The following example demonstrates how to box a value class by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente illustra come eseguire il boxing di una classe di valori utilizzando il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>The array to be initialized.</source>
          <target state="translated">Matrice da inizializzare.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
          <target state="translated">Handle di campo che specifica il percorso dei dati utilizzati per inizializzare la matrice.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
          <target state="translated">Fornisce un modo rapido per inizializzare una matrice dai dati memorizzati in un modulo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
          <target state="translated">Ottiene l'offset, in byte, per i dati nella stringa specificata.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object to the first character in the string.</source>
          <target state="translated">Offset dei byte, dall'inizio dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> al primo carattere nella stringa.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
          <target state="translated">I compilatori utilizzano questa proprietà per le operazioni non sicure, ma maggiore efficienza, puntatore ai caratteri in una stringa gestita.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
          <target state="translated">I compilatori devono impedire lo spostamento dal garbage collector prima dell'uso della stringa.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
          <target state="translated">Si noti che le stringhe di common language runtime sono immutabili. vale a dire il relativo contenuto può leggere ma non è stato modificato.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Designates a body of code as a constrained execution region (CER).</source>
          <target state="translated">Indica un corpo di codice come area a esecuzione limitata (CER).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
          <target state="translated">I compilatori utilizzano questo metodo per contrassegnare <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, e <ph id="ph3">`fault`</ph> blocchi come aree a esecuzione vincolata (CER).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
          <target state="translated">Codice che è contrassegnato come area limitata deve chiamare solo altro codice con contratti di affidabilità sicuri.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
          <target state="translated">Non deve allocare o effettuare chiamate virtuali ai metodi non preparate o non affidabile, a meno che non è stato preparato per gestire gli errori.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Si noti che non intermedia codici operativi del linguaggio, ad eccezione di <ph id="ph1">`NOP`</ph>, sono consentite tra una chiamata al <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> (metodo) e <ph id="ph3">`try`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
          <target state="translated">Per ulteriori informazioni su CER, vedere le classi di <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> dello spazio dei nomi.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">CER che sono contrassegnate con il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> (metodo) non funzionano perfettamente quando un <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> viene generato dal <ph id="ph3">`try`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
          <target state="translated">Il metodo <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> chiama il metodo <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come impostare in modo affidabile l'handle utilizzando il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Per impostare in modo affidabile un handle a un handle preesistente specificato, è necessario assicurarsi che l'allocazione di handle nativo e la successiva registrazione di questo handle all'interno di un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> oggetto è di tipo atomico.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Qualsiasi errore tra queste operazioni (ad esempio un'interruzione del thread o l'eccezione di memoria esaurita) comporterà l'handle nativo perdita.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> per verificare che l'handle non viene perso.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
          <target state="translated">Indica un corpo di codice come area a esecuzione limitata (CER) senza eseguire alcun probe.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Compilers should not call this method directly.</source>
          <target state="translated">I compilatori non devono chiamare questo metodo direttamente.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Definire invece un CER chiamando il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>The event delegate to prepare.</source>
          <target state="translated">Delegato dell'evento da preparare.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> event delegates.</source>
          <target state="translated">Consente alle applicazioni di preparare in modo dinamico i delegati dell'evento <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> delegato dell'evento, ad esempio <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, e <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> non vengono preparati automaticamente all'avvio.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>You can use the following methods to prepare them:</source>
          <target state="translated">Per la preparazione, è possibile utilizzare i metodi seguenti:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
          <target state="translated">Attributo del metodo usando il <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
          <target state="translated">Attributo del metodo usando il <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> metodo per preparare il delegato dinamicamente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
          <target state="translated">Per ulteriori informazioni, vedere l'articolo <bpt id="p1">[</bpt>mantenere il codice in esecuzione con le funzionalità di affidabilità di .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in MSDN Magazine.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>The delegate type to prepare.</source>
          <target state="translated">Tipo di delegato da preparare.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Indica che è necessario preparare il delegato specificato da includere in un'area a esecuzione vincolata (CER).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
          <target state="translated">I compilatori utilizzano questo metodo per preparare la chiamata al metodo di un delegato e la destinazione di tale chiamata (e il grafico del delegato chiamata determinare staticamente) come un'area a esecuzione vincolata (CER).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prepara un metodo da includere in un'area a esecuzione limitata (CER).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Handle del metodo da preparare.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prepara un metodo da includere in un'area a esecuzione limitata (CER).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
          <target state="translated">Utilizzano i compilatori di <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> metodo per gestire chiamate virtuali che vengono eseguite all'interno di un'area a esecuzione vincolata (CER).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
          <target state="translated">In fase di compilazione JIT, common language runtime non dispone in genere informazioni sufficienti sulla destinazione di una chiamata virtuale.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
          <target state="translated">Pertanto, il runtime non viene preparato inizialmente un segmento del grafico delle chiamate.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
          <target state="translated">Se il codice che utilizza CER è disponibili informazioni sufficienti per determinare la destinazione in qualsiasi punto nel tempo prima di CER effettivamente immessi, è possibile chiamare <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> per eseguire la stessa preparazione di runtime in genere effettuata per una CER indirizzata al metodo specificato come argomento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Handle del metodo da preparare.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The instantiation to pass to the method.</source>
          <target state="translated">Creazione di istanza da passare al metodo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
          <target state="translated">Prepara un metodo da includere in un'area a esecuzione limitata (CER) con la creazione dell'istanza specificata.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">È possibile fornire supportano per i compilatori di generics con la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
          <target state="translated">Common language runtime non è possibile preparare aree a esecuzione vincolata (CER) con radice in un metodo che dispone di parametri di tipo generico (un parametro di tipo nella classe che contiene il metodo o uno sul metodo stesso) quando vengono creata un'istanza di tali parametri di tipo come tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
          <target state="translated">È possibile utilizzare questo overload per passare un'istanza specifica (ad esempio, una matrice di tipi), specificando i parametri di tipo classe innanzitutto (se presente), seguito dai parametri di tipo di metodo (se presente).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The runtime prepares that instantiation of the method.</source>
          <target state="translated">Il runtime consente di preparare la creazione dell'istanza del metodo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
          <target state="translated">(Questo è necessario solo se si utilizza le creazioni di istanze contiene almeno un parametro di tipo riferimento). Di conseguenza, è possibile utilizzare un formato CER <ph id="ph1">`try`</ph> clausola in un metodo generico (o un metodo non generico in una classe generica) e funzionerà in modo affidabile con creazioni di istanza di <ph id="ph2">&lt;xref:System.Int32&gt;</ph> o altri tipi di valore.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
          <target state="translated">Per creare un'istanza di riferimento, tipi, ad esempio <ph id="ph1">&lt;xref:System.String&gt;</ph>, è necessario utilizzare esplicita <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> metodo CER metodo radice.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
          <target state="translated">Sonda una determinata quantità di spazio dello stack per garantire che non possa verificarsi un overflow dello stack all'interno di un blocco successivo di codice, presupponendo che il codice utilizzi una quantità limitata e moderata di spazio dello stack.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
          <target state="translated">Si consiglia di utilizzare un'area a esecuzione vincolata (CER) anziché questo metodo.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
          <target state="translated">Questo metodo viene utilizzato dall'infrastruttura di area a esecuzione vincolata in esecuzione in host resilienti all'overflow dello stack, ad esempio Microsoft SQL Server e Microsoft Exchange Server.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
          <target state="translated">Questo metodo attualmente le ricerche per 48 KB di spazio dello stack su x86 piattaforma, ma la quantità esatta potrebbe cambiare nel tempo e possono variare in altre piattaforme.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is also used by compilers.</source>
          <target state="translated">Questo metodo viene inoltre utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
          <target state="translated">Anziché utilizzare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> (metodo), è necessario utilizzare un CER standard.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
          <target state="translated">Ovvero, se si intende utilizzare una quantità di spazio dello stack moderata, chiamare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> metodo immediatamente prima il <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> o <ph id="ph5">`try`</ph> <ph id="ph6">/</ph> <ph id="ph7">`catch`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se si chiama un metodo ricorsivo o un piano per una grande quantità di spazio dello stack, è necessario utilizzare il <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>A type handle that specifies the class constructor method to run.</source>
          <target state="translated">Handle di tipo che specifica il metodo del costruttore di classi da eseguire.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>Runs a specified class constructor method.</source>
          <target state="translated">Esegue un metodo del costruttore di classi specificato.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>The class initializer throws an exception.</source>
          <target state="translated">L'inizializzatore della classe genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>A handle that specifies the module constructor method to run.</source>
          <target state="translated">Handle che specifica il metodo del costruttore di moduli da eseguire.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>Runs a specified module constructor method.</source>
          <target state="translated">Esegue il metodo del costruttore di moduli specificato.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Questo metodo viene utilizzato dai compilatori.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>The module constructor throws an exception.</source>
          <target state="translated">Il costruttore di moduli ha generato un'eccezione.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>