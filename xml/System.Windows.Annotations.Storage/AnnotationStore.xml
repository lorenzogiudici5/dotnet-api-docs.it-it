<Type Name="AnnotationStore" FullName="System.Windows.Annotations.Storage.AnnotationStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="082826d0f8122981f184a3439980c9651a61ea37" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40449623" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class AnnotationStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AnnotationStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Annotations.Storage.AnnotationStore" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AnnotationStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class AnnotationStore abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type AnnotationStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Quando sottoposta a override in una classe derivata, rappresenta un archivio dati per scrivere e leggere le annotazioni dell'utente.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AnnotationStore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AnnotationStore();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Annotations.Storage.AnnotationStore" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAnnotation">
      <MemberSignature Language="C#" Value="public abstract void AddAnnotation (System.Windows.Annotations.Annotation newAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddAnnotation(class System.Windows.Annotations.Annotation newAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.AddAnnotation(System.Windows.Annotations.Annotation)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub AddAnnotation (newAnnotation As Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void AddAnnotation(System::Windows::Annotations::Annotation ^ newAnnotation);" />
      <MemberSignature Language="F#" Value="abstract member AddAnnotation : System.Windows.Annotations.Annotation -&gt; unit" Usage="annotationStore.AddAnnotation newAnnotation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newAnnotation" Type="System.Windows.Annotations.Annotation" />
      </Parameters>
      <Docs>
        <param name="newAnnotation">Annotazione da aggiungere all'archivio.</param>
        <summary>Aggiunge un nuovo oggetto <see cref="T:System.Windows.Annotations.Annotation" /> all'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un nuovo <xref:System.Windows.Annotations.Annotation> viene aggiunto all'archivio relativo identificatore univoco globale (GUID) <xref:System.Windows.Annotations.Annotation.Id%2A> proprietà è impostata su un nuovo valore.  Quando <xref:System.Windows.Annotations.Storage.AnnotationStore.AddAnnotation%2A> viene chiamato, relativi <xref:System.Windows.Annotations.Annotation.Id%2A> proprietà viene controllata per verificare se il <xref:System.Windows.Annotations.Annotation> è già stato aggiunto all'archivio.  Se il <xref:System.Windows.Annotations.Annotation> già è stato aggiunto ed è presente nell'archivio (come determinato dalla relativa <xref:System.Windows.Annotations.Annotation.Id%2A> proprietà) un <xref:System.ArgumentException> viene generato l'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newAnnotation" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nell'archivio esiste già un oggetto <see cref="T:System.Windows.Annotations.Annotation" /> con lo stesso valore di proprietà <see cref="P:System.Windows.Annotations.Annotation.Id" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato nell'archivio.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.DeleteAnnotation(System.Guid)" />
      </Docs>
    </Member>
    <Member MemberName="AnchorChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Annotations.AnnotationResourceChangedEventHandler AnchorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Annotations.AnnotationResourceChangedEventHandler AnchorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event AnchorChanged As AnnotationResourceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Annotations::AnnotationResourceChangedEventHandler ^ AnchorChanged;" />
      <MemberSignature Language="F#" Value="member this.AnchorChanged : System.Windows.Annotations.AnnotationResourceChangedEventHandler " Usage="member this.AnchorChanged : System.Windows.Annotations.AnnotationResourceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.AnnotationResourceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando cambia un ancoraggio su qualsiasi <see cref="T:System.Windows.Annotations.Annotation" /> nell'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged> evento può essere utilizzato per monitorare le modifiche per l'annotazione <xref:System.Windows.Annotations.Annotation.Anchors%2A> contenute nell'archivio senza la necessità di registrare in ogni <xref:System.Windows.Annotations.Annotation> singolarmente.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Annotations.AnnotationAuthorChangedEventHandler AuthorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Annotations.AnnotationAuthorChangedEventHandler AuthorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event AuthorChanged As AnnotationAuthorChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Annotations::AnnotationAuthorChangedEventHandler ^ AuthorChanged;" />
      <MemberSignature Language="F#" Value="member this.AuthorChanged : System.Windows.Annotations.AnnotationAuthorChangedEventHandler " Usage="member this.AuthorChanged : System.Windows.Annotations.AnnotationAuthorChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.AnnotationAuthorChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando cambia un autore su qualsiasi <see cref="T:System.Windows.Annotations.Annotation" /> nell'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged> evento può essere utilizzato per monitorare le modifiche per l'annotazione <xref:System.Windows.Annotations.Annotation.Authors%2A> contenute nell'archivio senza la necessità di registrare in ogni <xref:System.Windows.Annotations.Annotation> singolarmente.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public abstract bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="System.Windows.Annotations.Storage.AnnotationStore.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se i dati nei buffer di annotazione devono essere scritti immediatamente nell'archivio dati fisico.</summary>
        <value>
          <see langword="true" /> se i dati nei buffer di annotazione devono essere scritti immediatamente all'archivio dati fisico per ogni operazione; in caso contrario, <see langword="false" /> se i dati nei buffer di annotazione devono essere scritti quando l'applicazione chiama in modo esplicito <see cref="M:System.Windows.Annotations.Storage.AnnotationStore.Flush" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le applicazioni che usano un modello di salvataggio espliciti impostabile <xref:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush%2A> al `false` e chiamare <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> direttamente quando appropriato.  
  
 Le applicazioni che usano un modello di salvataggio implicito impostabile <xref:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush%2A> al `true` per fare in modo <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> venga chiamato automaticamente dopo ogni operazione di ripristino (aggiungere, eliminare o modificare).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.Flush" />
      </Docs>
    </Member>
    <Member MemberName="CargoChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Annotations.AnnotationResourceChangedEventHandler CargoChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Annotations.AnnotationResourceChangedEventHandler CargoChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event CargoChanged As AnnotationResourceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Annotations::AnnotationResourceChangedEventHandler ^ CargoChanged;" />
      <MemberSignature Language="F#" Value="member this.CargoChanged : System.Windows.Annotations.AnnotationResourceChangedEventHandler " Usage="member this.CargoChanged : System.Windows.Annotations.AnnotationResourceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.AnnotationResourceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando cambia un cargo su qualsiasi <see cref="T:System.Windows.Annotations.Annotation" /> nell'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged> evento può essere utilizzato per monitorare le modifiche per l'annotazione <xref:System.Windows.Annotations.Annotation.Cargos%2A> contenute nell'archivio senza la necessità di registrare in ogni <xref:System.Windows.Annotations.Annotation> singolarmente.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteAnnotation">
      <MemberSignature Language="C#" Value="public abstract System.Windows.Annotations.Annotation DeleteAnnotation (Guid annotationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Annotations.Annotation DeleteAnnotation(valuetype System.Guid annotationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.DeleteAnnotation(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function DeleteAnnotation (annotationId As Guid) As Annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Windows::Annotations::Annotation ^ DeleteAnnotation(Guid annotationId);" />
      <MemberSignature Language="F#" Value="abstract member DeleteAnnotation : Guid -&gt; System.Windows.Annotations.Annotation" Usage="annotationStore.DeleteAnnotation annotationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="annotationId">Proprietà <see cref="P:System.Windows.Annotations.Annotation.Id" /> del GUID dell'annotazione da eliminare.</param>
        <summary>Elimina dall'archivio l'annotazione con l'<see cref="P:System.Windows.Annotations.Annotation.Id" /> specificato.</summary>
        <returns>Annotazione eliminata; in caso contrario, <see langword="null" /> se un'annotazione con l'oggetto <paramref name="annotationId" /> specificato non è presente nell'archivio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Windows.Annotations.Storage.AnnotationStore.DeleteAnnotation%2A> e <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> metodi.  
  
 [!code-csharp[DocumentSerialize#DocSerDelete](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserdelete)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato nell'archivio.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.AddAnnotation(System.Windows.Annotations.Annotation)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotation(System.Guid)" />
        <altmember cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate dall'archivio.</summary>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.Finalize" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="annotationStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse gestite e non gestite usate dall'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le applicazioni devono chiamare <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> dopo aver utilizzato la <xref:System.Windows.Annotations.Storage.AnnotationStore>.  Dopo la chiamata <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> l'applicazione può rilasciare tutti i riferimenti per il <xref:System.Windows.Annotations.Storage.AnnotationStore> per consentire al garbage collector di recuperare la memoria che il <xref:System.Windows.Annotations.Storage.AnnotationStore> occupata.  Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementa un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pubblico <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> metodo chiama il metodo protetto <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> `(Boolean)` metodo con il `disposing` parametro di `true` per rilasciare tutte le risorse gestite e non gestite.  
  
> [!NOTE]
>  Chiamare <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> prima dell'ultimo riferimento il <xref:System.Windows.Annotations.Storage.AnnotationStore> viene rilasciato.  Se <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> non viene chiamato <xref:System.Windows.Annotations.Storage.AnnotationStore> risorse non verranno liberate finché il garbage collector chiama l'archivio <xref:System.Windows.Annotations.Storage.AnnotationStore.Finalize%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IDisposable.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="annotationStore.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dall'archivio e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò protetta <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> viene chiamato da parte del pubblico <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> e <xref:System.Object.Finalize%2A> metodi.  Pubblico <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> richiama il metodo protetto <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> `(Boolean)` metodo con il `disposing` parametro impostato su `true`.  <xref:System.Object.Finalize%2A> richiama <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> con `disposing` impostato su `false`.  
  
 Quando la `disposing` parametro è `true`, <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> rilascia tutte le risorse utilizzate da qualsiasi gestiti gli oggetti che il <xref:System.Windows.Annotations.Storage.AnnotationStore> riferimenti.  <xref:System.Windows.Annotations.Storage.AnnotationStore.Dispose%2A> richiama anche il `Dispose()` metodo per ogni oggetto di riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose(System.Boolean)" /> può essere chiamato più volte da altri oggetti.  Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see cref="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose(System.Boolean)" />. Per altre informazioni su come implementare <see cref="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Per altre informazioni sulle <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~AnnotationStore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!AnnotationStore ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="annotationStore.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantisce la chiamata finale di <see cref="M:System.Windows.Annotations.Storage.AnnotationStore.Dispose(System.Boolean)" /> per questo archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override della base <xref:System.Object.Finalize%2A> (metodo).  Il programma dell'applicazione non deve chiamare <xref:System.Windows.Annotations.Storage.AnnotationStore.Finalize%2A> direttamente.  <xref:System.Windows.Annotations.Storage.AnnotationStore.Finalize%2A> viene richiamata automaticamente durante l'operazione di garbage collection tranne se disabilitati da una chiamata al <xref:System.GC.SuppressFinalize%2A> (metodo).  
  
 Per altre informazioni, vedere [metodi Finalize e distruttori](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md), e [override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="annotationStore.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forza la scrittura nel dispositivo di archiviazione sottostante dei dati di annotazione mantenuti nei buffer interni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le applicazioni che usano un modello di salvataggio espliciti impostabile <xref:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush%2A> al `false` e chiamare <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> direttamente quando appropriato.  
  
 Le applicazioni che usano un modello di salvataggio implicita possono impostare il <xref:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush%2A> al `true` per fare in modo <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> venga chiamato automaticamente dopo ogni operazione di ripristino (aggiungere, eliminare o modificare).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> metodo quando l'applicazione viene chiusa la <xref:System.Windows.Annotations.AnnotationService>.  
  
 [!code-csharp[DocViewerAnnotationsXps#StopAnnotations](~/samples/snippets/csharp/VS_Snippets_Wpf/DocViewerAnnotationsXps/CSharp/AnnotationsHelperXps.cs#stopannotations)]
 [!code-vb[DocViewerAnnotationsXps#StopAnnotations](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DocViewerAnnotationsXps/visualbasic/annotationshelperxps.vb#stopannotations)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Windows.Annotations.Storage.AnnotationStore.DeleteAnnotation%2A> e <xref:System.Windows.Annotations.Storage.AnnotationStore.Flush%2A> metodi.  
  
 [!code-csharp[DocumentSerialize#DocSerDelete](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserdelete)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato nell'archivio.</exception>
        <altmember cref="P:System.Windows.Annotations.Storage.AnnotationStore.AutoFlush" />
      </Docs>
    </Member>
    <Member MemberName="GetAnnotation">
      <MemberSignature Language="C#" Value="public abstract System.Windows.Annotations.Annotation GetAnnotation (Guid annotationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Annotations.Annotation GetAnnotation(valuetype System.Guid annotationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotation(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAnnotation (annotationId As Guid) As Annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Windows::Annotations::Annotation ^ GetAnnotation(Guid annotationId);" />
      <MemberSignature Language="F#" Value="abstract member GetAnnotation : Guid -&gt; System.Windows.Annotations.Annotation" Usage="annotationStore.GetAnnotation annotationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.Annotation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="annotationId">Proprietà <see cref="P:System.Windows.Annotations.Annotation.Id" /> del GUID dell'annotazione da restituire.</param>
        <summary>Restituisce dall'archivio l'annotazione con l'oggetto <see cref="P:System.Windows.Annotations.Annotation.Id" /> specificato.</summary>
        <returns>Annotazione con l'<paramref name="annotationId" /> specificato; in caso contrario, <see langword="null" /> se un'annotazione con l'oggetto <paramref name="annotationId" /> specificato non è presente nell'archivio.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato nell'archivio.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.DeleteAnnotation(System.Guid)" />
        <altmember cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAnnotations">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un elenco delle annotazioni contenute nell'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations%2A> metodo per determinare se sono presenti tutte le annotazioni contenute nell'archivio.  
  
 [!code-csharp[DocumentSerialize#DocSerCloseFile](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserclosefile)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotation(System.Guid)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt; GetAnnotations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Windows.Annotations.Annotation&gt; GetAnnotations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAnnotations () As IList(Of Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;System::Windows::Annotations::Annotation ^&gt; ^ GetAnnotations();" />
      <MemberSignature Language="F#" Value="abstract member GetAnnotations : unit -&gt; System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;" Usage="annotationStore.GetAnnotations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un elenco di tutte le annotazioni nell'archivio.</summary>
        <returns>Elenco di tutte le annotazioni che sono attualmente nell'archivio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations%2A> metodo per determinare se sono presenti tutte le annotazioni contenute nell'archivio.  
  
 [!code-csharp[DocumentSerialize#DocSerCloseFile](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserclosefile)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato nell'archivio.</exception>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotation(System.Guid)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations(System.Windows.Annotations.ContentLocator)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt; GetAnnotations (System.Windows.Annotations.ContentLocator anchorLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Windows.Annotations.Annotation&gt; GetAnnotations(class System.Windows.Annotations.ContentLocator anchorLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations(System.Windows.Annotations.ContentLocator)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAnnotations (anchorLocator As ContentLocator) As IList(Of Annotation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;System::Windows::Annotations::Annotation ^&gt; ^ GetAnnotations(System::Windows::Annotations::ContentLocator ^ anchorLocator);" />
      <MemberSignature Language="F#" Value="abstract member GetAnnotations : System.Windows.Annotations.ContentLocator -&gt; System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;" Usage="annotationStore.GetAnnotations anchorLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Windows.Annotations.Annotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anchorLocator" Type="System.Windows.Annotations.ContentLocator" />
      </Parameters>
      <Docs>
        <param name="anchorLocator">Sequenza <see cref="T:System.Windows.Annotations.ContentLocatorPart" /> iniziale per la quale restituire le annotazioni corrispondenti.</param>
        <summary>Restituisce un elenco di annotazioni che hanno <see cref="P:System.Windows.Annotations.Annotation.Anchors" /> con localizzatori che iniziano con una sequenza <see cref="T:System.Windows.Annotations.ContentLocatorPart" /> corrispondente.</summary>
        <returns>Elenco di annotazioni che hanno <see cref="P:System.Windows.Annotations.Annotation.Anchors" /> con localizzatori che avviano l'oggetto <paramref name="anchorLocator" /> specificato e vi corrispondono; in caso contrario, <see langword="null" /> se non vengono trovate annotazioni corrispondenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò <xref:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotations%2A> metodo Usa internamente il <xref:System.Windows.Annotations.ContentLocator.StartsWith%2A> metodo del <xref:System.Windows.Annotations.ContentLocator> classe per eseguire la ricerca e far corrispondere le annotazioni da restituire.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.GetAnnotation(System.Guid)" />
        <altmember cref="M:System.Windows.Annotations.ContentLocator.StartsWith(System.Windows.Annotations.ContentLocator)" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="protected bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.AnnotationStore.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Annotations.Storage.AnnotationStore.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato.</summary>
        <value>
          <see langword="true" /> se <see cref="Overload:System.Windows.Annotations.Storage.AnnotationStore.Dispose" /> è stato chiamato; in caso contrario, <see langword="false" />.  Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAnchorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAnchorChanged (System.Windows.Annotations.AnnotationResourceChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAnchorChanged(class System.Windows.Annotations.AnnotationResourceChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAnchorChanged (args As AnnotationResourceChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAnchorChanged(System::Windows::Annotations::AnnotationResourceChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnAnchorChanged : System.Windows.Annotations.AnnotationResourceChangedEventArgs -&gt; unit&#xA;override this.OnAnchorChanged : System.Windows.Annotations.AnnotationResourceChangedEventArgs -&gt; unit" Usage="annotationStore.OnAnchorChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Windows.Annotations.AnnotationResourceChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorChanged (System.Windows.Annotations.AnnotationAuthorChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorChanged(class System.Windows.Annotations.AnnotationAuthorChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorChanged (args As AnnotationAuthorChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorChanged(System::Windows::Annotations::AnnotationAuthorChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorChanged : System.Windows.Annotations.AnnotationAuthorChangedEventArgs -&gt; unit&#xA;override this.OnAuthorChanged : System.Windows.Annotations.AnnotationAuthorChangedEventArgs -&gt; unit" Usage="annotationStore.OnAuthorChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Windows.Annotations.AnnotationAuthorChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCargoChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCargoChanged (System.Windows.Annotations.AnnotationResourceChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCargoChanged(class System.Windows.Annotations.AnnotationResourceChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCargoChanged (args As AnnotationResourceChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCargoChanged(System::Windows::Annotations::AnnotationResourceChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnCargoChanged : System.Windows.Annotations.AnnotationResourceChangedEventArgs -&gt; unit&#xA;override this.OnCargoChanged : System.Windows.Annotations.AnnotationResourceChangedEventArgs -&gt; unit" Usage="annotationStore.OnCargoChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Windows.Annotations.AnnotationResourceChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStoreContentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStoreContentChanged (System.Windows.Annotations.Storage.StoreContentChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStoreContentChanged(class System.Windows.Annotations.Storage.StoreContentChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStoreContentChanged (e As StoreContentChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStoreContentChanged(System::Windows::Annotations::Storage::StoreContentChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStoreContentChanged : System.Windows.Annotations.Storage.StoreContentChangedEventArgs -&gt; unit&#xA;override this.OnStoreContentChanged : System.Windows.Annotations.Storage.StoreContentChangedEventArgs -&gt; unit" Usage="annotationStore.OnStoreContentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Annotations.Storage.StoreContentChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="StoreContentChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Annotations.Storage.StoreContentChangedEventHandler StoreContentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Annotations.Storage.StoreContentChangedEventHandler StoreContentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event StoreContentChanged As StoreContentChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Annotations::Storage::StoreContentChangedEventHandler ^ StoreContentChanged;" />
      <MemberSignature Language="F#" Value="member this.StoreContentChanged : System.Windows.Annotations.Storage.StoreContentChangedEventHandler " Usage="member this.StoreContentChanged : System.Windows.Annotations.Storage.StoreContentChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Annotations.Storage.StoreContentChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto <see cref="T:System.Windows.Annotations.Annotation" /> viene aggiunto o eliminato dall'archivio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere un delegato per il <xref:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged> evento.  
  
 [!code-csharp[DocumentSerialize#DocSerEnableAnn](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docserenableann)]  
  
 Nell'esempio seguente viene illustrata l'operazione del <xref:System.Windows.Annotations.Storage.AnnotationStore.StoreContentChanged> delegato dell'evento.  
  
 [!code-csharp[DocumentSerialize#DocSerContentChanged](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentSerialize/CSharp/ThumbViewer.cs#docsercontentchanged)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnStoreContentChanged(System.Windows.Annotations.Storage.StoreContentChangedEventArgs)" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AnchorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.AuthorChanged" />
        <altmember cref="E:System.Windows.Annotations.Storage.AnnotationStore.CargoChanged" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAnchorChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnAuthorChanged(System.Windows.Annotations.AnnotationAuthorChangedEventArgs)" />
        <altmember cref="M:System.Windows.Annotations.Storage.AnnotationStore.OnCargoChanged(System.Windows.Annotations.AnnotationResourceChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="protected object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Annotations.Storage.AnnotationStore.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Annotations.Storage.AnnotationStore.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto da usare come blocco di sincronizzazione per le sezioni critiche di <see cref="T:System.Windows.Annotations.Storage.AnnotationStore" />.</summary>
        <value>Oggetto da usare come blocco di sincronizzazione per le sezioni critiche di <see cref="T:System.Windows.Annotations.Storage.AnnotationStore" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>