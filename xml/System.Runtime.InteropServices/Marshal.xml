<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Marshal.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b582e89d8a536a45d26354652aab5d4e97b21f0f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b582e89d8a536a45d26354652aab5d4e97b21f0f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</source>
          <target state="translated">Fornisce una raccolta di metodi per l'allocazione della memoria non gestita, la copia di blocchi di memoria non gestita e la conversione di tipi gestiti in tipi non gestiti, oltre ad altri metodi usati durante l'interazione con codice non gestito.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The <ph id="ph1">`static`</ph> methods defined on the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class are essential to working with unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">`static`</ph> metodi definiti nella <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe sono essenziali per l'utilizzo con codice non gestito.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</source>
          <target state="translated">La maggior parte dei metodi definiti in questa classe vengono in genere utilizzati dagli sviluppatori che desiderano offrire un ponte tra il gestito e modelli di programmazione.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>For example, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> metodo copia i caratteri ANSI da una stringa specificata (nell'heap gestito) in un buffer nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>It also allocates the target heap of the right size.</source>
          <target state="translated">Inoltre, alloca heap di destinazione della dimensione giusta.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The common language runtime provides specific marshaling capabilities.</source>
          <target state="translated">Common language runtime fornisce le funzionalità specifiche di marshalling.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>For details on marshaling behavior, see <bpt id="p1">[</bpt>Interop Marshaling<ept id="p1">](~/docs/framework/interop/interop-marshaling.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate sul comportamento di marshalling, vedere <bpt id="p1">[</bpt>marshalling di interoperabilità<ept id="p1">](~/docs/framework/interop/interop-marshaling.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The <ph id="ph1">`Read`</ph> and <ph id="ph2">`Write`</ph> methods in the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class support both aligned and unaligned access.</source>
          <target state="translated">Il <ph id="ph1">`Read`</ph> e <ph id="ph2">`Write`</ph> metodi di <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe supporta l'accesso allineato e non allineato.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The following example shows how to use various methods defined by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare diversi metodi definiti per il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The interface reference count to increment.</source>
          <target state="translated">Numero di riferimenti nell'interfaccia da incrementare.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>Increments the reference count on the specified interface.</source>
          <target state="translated">Incrementa il numero di riferimenti nell'interfaccia specificata.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The new value of the reference count on the <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> parameter.</source>
          <target state="translated">Nuovo valore del conteggio dei riferimenti sul parametro <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
          <target state="translated">Common language runtime gestisce il conteggio dei riferimenti di un oggetto COM per l'utente, rendendo non è necessario utilizzare questo metodo direttamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
          <target state="translated">In rari casi, ad esempio test di un gestore di marshalling personalizzato, potrebbe essere necessario modificare manualmente la durata dell'oggetto.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>After calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, you must decrement the reference count by using a method such as <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dopo la chiamata <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, è necessario diminuire il conteggio dei riferimenti utilizzando un metodo, ad esempio <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>Do not rely on the return value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, as it can sometimes be unstable.</source>
          <target state="translated">Non fare affidamento sul valore restituito di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, come può talvolta essere instabile.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer.</source>
          <target state="translated">È possibile chiamare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> per ottenere un <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> valore che rappresenta un <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore a interfaccia.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</source>
          <target state="translated">È inoltre possibile utilizzare questi metodi e <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph> metodo su oggetti gestiti per ottenere le interfacce COM rappresentate da COM callable wrapper dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>If you are not familiar with the details of this wrapper type, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">Se non si ha familiarità con i dettagli di questo tipo di wrapper, vedere <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>The size of the block of memory to be allocated.</source>
          <target state="translated">Dimensioni del blocco di memoria da allocare.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>Allocates a block of memory of specified size from the COM task memory allocator.</source>
          <target state="translated">Alloca un blocco di memoria delle dimensioni specificate dall'allocatore di memoria delle attività COM.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>An integer representing the address of the block of memory allocated.</source>
          <target state="translated">Intero che rappresenta l'indirizzo del blocco di memoria allocato.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This memory must be released with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Questa memoria deve essere liberata con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> is one of two memory allocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> è uno di allocazione della memoria due metodi API di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> è l'altro.) Il contenuto di memoria iniziale restituito non è definito e la memoria allocata può essere maggiore del numero di byte richiesto.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148626)</ept> function, which is referred to as the COM task memory allocator.</source>
          <target state="translated">Questo metodo espone il COM <bpt id="p1">[</bpt>CoTaskMemAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148626)</ept> funzione, viene considerato l'allocatore di memoria delle attività COM.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">Memoria insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates memory from the unmanaged memory of the process.</source>
          <target state="translated">Alloca memoria dalla memoria non gestita del processo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>The required number of bytes in memory.</source>
          <target state="translated">Numero di byte necessari nella memoria.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</source>
          <target state="translated">Alloca memoria dalla memoria non gestita del processo tramite il numero specificato di byte.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>A pointer to the newly allocated memory.</source>
          <target state="translated">Puntatore alla memoria appena allocata.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This memory must be released using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> method.</source>
          <target state="translated">Questa memoria deve essere liberata usando il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> è uno dei due metodi di allocazione di memoria nel <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148628)</ept> function from Kernel32.dll.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> è l'altro.) Questo metodo espone Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148628)</ept> funzione da Kernel32.dll.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> chiamate <ph id="ph2">`LocalAlloc`</ph>, passa un <ph id="ph3">`LMEM_FIXED`</ph> flag che determina la memoria allocata da bloccare sul posto.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>Also, the allocated memory is not zero-filled.</source>
          <target state="translated">Inoltre, la memoria allocata non è riempiti con zero.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> method.</source>
          <target state="translated">Nel codice riportato di seguito viene illustrata la chiamata al metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">Memoria insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>The required number of bytes in memory.</source>
          <target state="translated">Numero di byte necessari nella memoria.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</source>
          <target state="translated">Alloca memoria dalla memoria non gestita del processo tramite il puntatore al numero specificato di byte.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>A pointer to the newly allocated memory.</source>
          <target state="translated">Puntatore alla memoria appena allocata.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>This memory must be released using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> method.</source>
          <target state="translated">Questa memoria deve essere liberata usando il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> è uno dei due metodi di allocazione di memoria nel <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148628)</ept> function from Kernel32.dll.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> è l'altro.) Questo metodo espone Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148628)</ept> funzione da Kernel32.dll.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> chiamate <ph id="ph2">`LocalAlloc`</ph>, passa un <ph id="ph3">`LMEM_FIXED`</ph> flag che determina la memoria allocata da bloccare sul posto.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>Also, the allocated memory is not zero-filled.</source>
          <target state="translated">Inoltre, la memoria allocata non è riempiti con zero.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>For example code, see <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Per vedere un codice di esempio, vedere <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">Memoria insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</source>
          <target state="translated">Indica se Runtime Callable Wrapper (RCW) provenienti da qualsiasi contesto sono disponibili per la pulizia.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if there are any RCWs available for cleanup; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se sono disponibili RCW per la pulizia. In caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</source>
          <target state="translated">Se sono presenti molti riferimenti tra codice gestito e nativo con grafici delle dipendenze completa che può richiedere molto tempo per tutti gli oggetti per la pulitura.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</source>
          <target state="translated">Ogni volta che viene eseguito un catalogo globale consente di liberare un certo numero di RCW che a sua volta causerà il rilascio di oggetti COM sottostanti.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</source>
          <target state="translated">Gli oggetti COM verranno quindi i riferimenti gestiti e rendere più oggetti disponibili per la pulizia alla successiva esecuzione di un catalogo globale, che avvia il processo di nuovo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A&gt;</ph> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A&gt;</ph> metodo fornisce un modo per l'applicazione determinare il numero di cicli di Garbage Collection. Raccolta e catalogo globale. WaitForPendingFinalizers devono verificarsi per tutte le operazioni di pulizia.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>The moniker corresponding to the desired interface pointer.</source>
          <target state="translated">Moniker corrispondente al puntatore a interfaccia desiderato.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>Gets an interface pointer identified by the specified moniker.</source>
          <target state="translated">Ottiene un puntatore a interfaccia identificato dal moniker specificato.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>An object containing a reference to the interface pointer identified by the <ph id="ph1">&lt;paramref name="monikerName" /&gt;</ph> parameter.</source>
          <target state="translated">Oggetto contenente un riferimento al puntatore a interfaccia identificato dal parametro <ph id="ph1">&lt;paramref name="monikerName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>A moniker is a name, and in this case, the moniker is defined by an interface.</source>
          <target state="translated">Un moniker è rappresentato da un nome; in questo caso il moniker è definito da un'interfaccia.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A&gt;</ph> exposes the COM <ph id="ph2">`BindToMoniker`</ph> method, which produces an object that you can cast to any COM interface you require.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A&gt;</ph> espone il COM <ph id="ph2">`BindToMoniker`</ph> (metodo), che genera un oggetto che è possibile eseguire il cast a qualsiasi interfaccia COM necessaria.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>This method provides the same functionality as the <ph id="ph1">`GetObject`</ph> method in Visual Basic 6.0 and <ph id="ph2">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>.</source>
          <target state="translated">Questo metodo fornisce la stessa funzionalità come il <ph id="ph1">`GetObject`</ph> metodo in Visual Basic 6.0 e <ph id="ph2">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>An unrecognized HRESULT was returned by the unmanaged <ph id="ph1">&lt;see langword="BindToMoniker" /&gt;</ph> method.</source>
          <target state="translated">Un HRESULT non riconosciuto è stato restituito dal metodo <ph id="ph1">&lt;see langword="BindToMoniker" /&gt;</ph> non gestito.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>The object whose CCW holds a reference counted handle.</source>
          <target state="translated">Oggetto il cui CCW contiene un handle con conteggio dei riferimenti.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</source>
          <target state="translated">L'handle è forte se il conteggio dei riferimenti su CCW è maggiore di zero; in caso contrario, è debole.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to change the strength of the handle on the <bpt id="p1">&lt;c&gt;</bpt>otp<ept id="p1">&lt;/c&gt;</ept> parameter to weak, regardless of its reference count; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to reset the handle strength on <bpt id="p2">&lt;c&gt;</bpt>otp<ept id="p2">&lt;/c&gt;</ept> to be reference counted.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per impostare come debole l'handle sul parametro <bpt id="p1">&lt;c&gt;</bpt>otp<ept id="p1">&lt;/c&gt;</ept>, indipendentemente dal conteggio dei riferimenti, <ph id="ph2">&lt;see langword="false" /&gt;</ph> per reimpostare la forza dell'handle su <bpt id="p2">&lt;c&gt;</bpt>otp<ept id="p2">&lt;/c&gt;</ept> per ottenere il conteggio dei riferimenti.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>Changes the strength of an object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> (CCW) handle.</source>
          <target state="translated">Modifica la forza dell'handle <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> (CCW) di un oggetto.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A&gt;</ph> is used for object pooling functionality and should never be called by user code directly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A&gt;</ph> viene utilizzato per la funzionalità del pool di oggetti e non deve essere chiamato direttamente dal codice utente.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Notifies the runtime to clean up all <bpt id="p1">[</bpt>Runtime Callable Wrappers<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCWs) allocated in the current context.</source>
          <target state="translated">Notifica al runtime di eseguire la pulizia di tutti i <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) allocati nel contesto corrente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>The interop system pumps messages while it attempts to clean up RCWs.</source>
          <target state="translated">Il sistema di interoperabilità immette i messaggi durante il tentativo di pulizia di RCW.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</source>
          <target state="translated">Ciò garantisce che la pulizia per tutte le applicazioni, incluse le applicazioni che non distribuiscono abbastanza spesso accade RCW apartment a thread singolo (STA).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>However, some applications that do pump appropriately are very sensitive to where pumping occurs.</source>
          <target state="translated">Tuttavia, alcune applicazioni che distribuiscono in modo appropriato sono molto sensibili per cui si verifica la distribuzione.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</source>
          <target state="translated">Quando il sistema di interoperabilità immette i messaggi in posizioni che sono impreviste, queste applicazioni, l'applicazione può verificarsi problemi di reentrancy difficili da diagnosticare.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</source>
          <target state="translated">Pertanto, le applicazioni debbano essere in grado di controllare la propria distribuzione per un particolare STA e per controllare la pulizia di RCW.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</source>
          <target state="translated">Tuttavia, gli sviluppatori controllano spesso solo un sottoinsieme dei thread nella propria applicazione e pertanto non è possibile assicurarsi che tutti i thread stiano eseguendo in modo appropriato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>To solve this problem:</source>
          <target state="translated">Per risolvere il problema:</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType&gt;</ph> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType&gt;</ph> metodo per disattivare la pulizia automatica di RCW e la distribuzione di messaggi che si verifica, in base al thread.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</source>
          <target state="translated">Questo consente agli sviluppatori escludere la pulizia automatica e la corrispondente distribuzione di messaggi.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A&gt;</ph> method to notify the runtime to clean up all RCWs that are allocated in the current context.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A&gt;</ph> metodo per notificare al runtime di pulizia di RCW tutti allocati nel contesto corrente.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</source>
          <target state="translated">Questo metodo complementare consente agli sviluppatori di controllare con precisione quando il runtime esegue operazioni di pulitura nel contesto corrente.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</source>
          <target state="translated">Copia i dati da una matrice gestita a un puntatore di memoria non gestita o viceversa.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di interi senza segno a 8 bit gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29&gt;</ph> overload, and then copies the unmanaged array back to managed memory by using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Nell'esempio seguente copia una matrice di memoria non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29&gt;</ph> overload e quindi la matrice non gestita viene copiata nella memoria gestita tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> rapporto di overload.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di caratteri gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph3">&lt;paramref name="length" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di numeri a virgola mobile a precisione doppia gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di interi con segno a 16 bit gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di interi con segno a 32 bit gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di interi con segno a 64 bit gestita e unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di interi senza segno a 8 bit gestita.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed character array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di caratteri gestita.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di numeri a virgola mobile a precisione doppia gestita.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 16 bit gestita.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 32 bit gestita.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 64 bit gestita.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the<ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di<ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> gestita.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Therefore, the unmanaged data that corresponds to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti che corrisponde alla <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">È necessario inizializzare la matrice gestita in modo appropriato prima di chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">Puntatore di memoria da cui copiare.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">Matrice in cui effettuare la copia.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</source>
          <target state="translated">Copia i dati da un puntatore di memoria non gestita a una matrice di numeri a virgola mobile a precisione singola gestita.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il <ph id="ph1">`startIndex`</ph> e <ph id="ph2">`length`</ph> parametri di essere convalidati.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">Di conseguenza, i dati non gestiti corrispondenti di <ph id="ph1">`source`</ph> parametro popola la matrice gestita indipendentemente dalla sua utilità.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> unidimensionale gestita a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> matrice da una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">Matrice unidimensionale da cui copiare.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">Puntatore di memoria in cui copiare.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">Numero degli elementi di matrice da copiare.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</source>
          <target state="translated">Copia i dati da una matrice di numeri a virgola mobile a precisione singola gestita unidimensionale a un puntatore di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non sono validi.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> o <ph id="ph4">&lt;paramref name="length" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The outer <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer.</source>
          <target state="translated">Puntatore <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> esterno.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>An object to aggregate.</source>
          <target state="translated">Oggetto da aggregare.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>Aggregates a managed object with the specified COM object.</source>
          <target state="translated">Aggrega un oggetto gestito all'oggetto COM specificato.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The inner <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer of the managed object.</source>
          <target state="translated">Puntatore <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interno dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> metodo aggrega il puntatore gestito interno di un oggetto gestito con il puntatore esterno specificato e restituisce un inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è un oggetto <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The type of the managed object to aggregate.</source>
          <target state="translated">Tipo dell'oggetto gestito da aggregare.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The outer <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer.</source>
          <target state="translated">Puntatore <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> esterno.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The managed object to aggregate.</source>
          <target state="translated">Oggetto gestito da aggregare.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>Aggregates a managed object of the specified type with the specified COM object.</source>
          <target state="translated">Aggrega un oggetto gestito del tipo specificato con l'oggetto COM specificato.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated">Puntatore <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interno dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> metodo aggrega il puntatore gestito interno di un oggetto gestito di un tipo specificato con il puntatore esterno specificato e restituisce un inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è un oggetto <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The object to be wrapped.</source>
          <target state="translated">Oggetto da includere.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The type of wrapper to create.</source>
          <target state="translated">Tipo di wrapper da creare.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Wraps the specified COM object in an object of the specified type.</source>
          <target state="translated">Include l'oggetto COM specificato in un oggetto del tipo specificato.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The newly wrapped object that is an instance of the desired type.</source>
          <target state="translated">L'oggetto appena incluso che è un'istanza del tipo desiderato.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A&gt;</ph> converts one COM class type, typically the base <ph id="ph2">`__ComObject`</ph> type, to another COM class type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A&gt;</ph> Converte un tipo di classe, in genere la base <ph id="ph2">`__ComObject`</ph> tipo, a un altro tipo di classe COM.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
          <target state="translated">L'oggetto COM di input, rappresentato dal parametro <ph id="ph1">`o`</ph>, è un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Both the <ph id="ph1">`t`</ph> and <ph id="ph2">`o`</ph> parameters must be classes whose signatures are attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sia il <ph id="ph1">`t`</ph> e <ph id="ph2">`o`</ph> i parametri devono essere classi le cui firme sono attribuite con <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
          <target state="translated">Se si crea manualmente il RCW nel codice sorgente, è necessario applicare questo attributo per la firma gestita che rappresenta la coclasse originale per indicarne le origini COM.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
          <target state="translated">Tlbimp.exe importa COM <bpt id="p1">[</bpt>coclasse<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> come una classe gestita e un'interfaccia.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
          <target state="translated">L'interfaccia di coclasse ha lo stesso nome della coclasse originale e la classe gestita ha al nome coclasse originale verrà aggiunto "Class".</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
          <target state="translated">Ad esempio, una coclasse chiamato <ph id="ph1">`MyCoclass`</ph> diventa un'interfaccia di coclasse chiamata <ph id="ph2">`MyCoclass`</ph> e una classe gestita chiamata <ph id="ph3">`MyCoclassClass`</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Since <ph id="ph1">`t`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the coclass interface.</source>
          <target state="translated">Poiché <ph id="ph1">`t`</ph> deve essere una classe, non è un'interfaccia, assicurarsi di specificare la classe gestita (<ph id="ph2">`MyCoclassClass`</ph>) e non l'interfaccia della coclasse.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>You lose the identity of the input COM object because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
          <target state="translated">L'identità dell'oggetto COM esegue il wrapping di una nuova istanza RCW input viene persa la <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore esposto dal RCW originale.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> must derive from <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> deve derivare da <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> è un tipo <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be converted to the destination type because it does not support all required interfaces.</source>
          <target state="translated">Non è possibile convertire <ph id="ph1">&lt;paramref name="o" /&gt;</ph> nel tipo di destinazione perché non supporta tutte le interfacce richieste.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The type of object to wrap.</source>
          <target state="translated">Tipo di oggetto di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The type of object to return.</source>
          <target state="translated">Tipo di oggetto da restituire.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The object to be wrapped.</source>
          <target state="translated">Oggetto da includere.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Wraps the specified COM object in an object of the specified type.</source>
          <target state="translated">Include l'oggetto COM specificato in un oggetto del tipo specificato.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The newly wrapped object.</source>
          <target state="translated">Oggetto appena incluso.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29&gt;</ph> converts a COM object of type <ph id="ph2">`T`</ph> to the <ph id="ph3">`TWrapper`</ph> COM class type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29&gt;</ph> Converte un oggetto COM di tipo <ph id="ph2">`T`</ph> per il <ph id="ph3">`TWrapper`</ph> tipo di classe COM.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
          <target state="translated">L'oggetto COM di input, rappresentato dal parametro <ph id="ph1">`o`</ph>, è un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Both the <ph id="ph1">`T`</ph> generic type parameter and the <ph id="ph2">`o`</ph> parameter must be classes whose signatures are attributed with the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Sia il <ph id="ph1">`T`</ph> parametro di tipo generico e <ph id="ph2">`o`</ph> parametro deve essere classi le cui firme sono assegnati gli attributi di <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
          <target state="translated">Se si crea manualmente il RCW nel codice sorgente, è necessario applicare questo attributo per la firma gestita che rappresenta la coclasse originale per indicarne le origini COM.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
          <target state="translated">Tlbimp.exe importa COM <bpt id="p1">[</bpt>coclasse<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> come una classe gestita e un'interfaccia.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
          <target state="translated">L'interfaccia di coclasse ha lo stesso nome della coclasse originale e la classe gestita ha al nome coclasse originale verrà aggiunto "Class".</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
          <target state="translated">Ad esempio, una coclasse chiamato <ph id="ph1">`MyCoclass`</ph> diventa un'interfaccia di coclasse chiamata <ph id="ph2">`MyCoclass`</ph> e una classe gestita chiamata <ph id="ph3">`MyCoclassClass`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Because<ph id="ph1">`T`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the <ph id="ph3">`coclass`</ph> interface.</source>
          <target state="translated">Poiché<ph id="ph1">`T`</ph> deve essere una classe, non è un'interfaccia, assicurarsi di specificare la classe gestita (<ph id="ph2">`MyCoclassClass`</ph>) e non il <ph id="ph3">`coclass`</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>You lose the identity of the input COM object, because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
          <target state="translated">Si perde l'identità dell'oggetto COM di input, perché esegue il wrapping di una nuova istanza RCW il <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore esposto dal RCW originale.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> must derive from <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> deve derivare da <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è un tipo <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be converted to the <ph id="ph2">&lt;paramref name="TWrapper" /&gt;</ph> because it does not support all required interfaces.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non può essere convertito in <ph id="ph2">&lt;paramref name="TWrapper" /&gt;</ph> perché non supporta tutte le interfacce richieste.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Type of a formatted class.</source>
          <target state="translated">Tipo di una classe formattata.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>This provides the layout information necessary to delete the buffer in the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Fornisce le informazioni di layout necessarie per eliminare il buffer nel parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Frees all substructures that the specified unmanaged memory block points to.</source>
          <target state="translated">Libera tutte le sottostrutture a cui punta il blocco di memoria non gestita specificato.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</source>
          <target state="translated">È possibile utilizzare questo metodo per rilasciare i campi di tipo riferimento, ad esempio stringhe, di una struttura non gestita.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
          <target state="translated">A differenza dei relativi campi, una struttura può essere un tipo di valore o un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</source>
          <target state="translated">Strutture di tipo di valore che contengono campi di tipo valore (tutti i tipi copiabili) sono privi di riferimenti la cui memoria deve essere liberata.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> metodo utilizza questo metodo per evitare perdite di memoria quando si riutilizza la memoria occupata da una struttura.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> chiama il componente COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> (funzione), che a sua volta, libera una stringa allocata.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Oltre a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe fornisce due altri metodi di deallocazione di memoria: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> has an automatic layout.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> dispone di un layout automatico.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Use sequential or explicit instead.</source>
          <target state="translated">Utilizzare invece il layout sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>The type of the formatted structure.</source>
          <target state="translated">Tipo della struttura formattata.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>This provides the layout information necessary to delete the buffer in the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Fornisce le informazioni di layout necessarie per eliminare il buffer nel parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Frees all substructures of a specified type that the specified unmanaged memory block points to.</source>
          <target state="translated">Libera tutte le sottostrutture di un tipo specificato a cui punta il blocco di memoria non gestita specificato.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>You can use this method to free reference type fields, such as strings, of an unmanaged structure.</source>
          <target state="translated">È possibile utilizzare questo metodo per rilasciare i campi di tipo riferimento, ad esempio stringhe, di una struttura non gestita.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
          <target state="translated">A differenza dei relativi campi, una struttura può essere un tipo di valore o un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</source>
          <target state="translated">Strutture di tipo di valore che contengono campi dei tipi di valore (tutti i tipi copiabili) sono privi di riferimenti la cui memoria deve essere liberata.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> metodo utilizza questo metodo per evitare perdite di memoria quando si riutilizza la memoria occupata da una struttura.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> chiama il componente COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> (funzione), che a sua volta, libera una stringa allocata.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> has an automatic layout.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> dispone di un layout automatico.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Use sequential or explicit instead.</source>
          <target state="translated">Utilizzare invece il layout sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The RCW to be released.</source>
          <target state="translated">Wrapper RCW da rilasciare.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>Releases all references to a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) by setting its reference count to 0.</source>
          <target state="translated">Rilascia tutti i riferimenti a un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) impostando il conteggio dei riferimenti su 0.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The new value of the reference count of the RCW associated with the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter, which is 0 (zero) if the release is successful.</source>
          <target state="translated">Nuovo valore del conteggio dei riferimenti del wrapper RCW associato al parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph>, corrispondente a 0 (zero) se il rilascio è stato eseguito correttamente.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method releases the managed reference to a COM object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> metodo rilascia il riferimento a un oggetto COM gestito.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>Calling this method is equivalent to calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until it returns 0 (zero).</source>
          <target state="translated">Chiamare questo metodo è equivalente alla chiamata di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo in un ciclo fino a quando non viene restituito 0 (zero).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</source>
          <target state="translated">Quando il conteggio dei riferimenti all'oggetto COM diventa 0, l'oggetto COM in genere viene liberata, anche se ciò dipende dall'implementazione dell'oggetto COM e sotto il controllo di runtime.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>However, the RCW can still exist, waiting to be garbage-collected.</source>
          <target state="translated">Tuttavia, il RCW ancora può esistere, in attesa di essere sottoposto a garbage collection.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The COM object cannot be used after it has been separated from its underlying RCW.</source>
          <target state="translated">L'oggetto COM non può essere utilizzato dopo che è stato separato dal RCW sottostante.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>If you try to call a method on the RCW after its reference count becomes 0, a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> will be thrown.</source>
          <target state="translated">Se si tenta di chiamare un metodo su RCW dopo che il conteggio dei riferimenti arriva a 0, un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> verrà generata.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is not a valid COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non è un oggetto COM valido.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>The address of the BSTR to be freed.</source>
          <target state="translated">Indirizzo del BSTR da liberare.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>Frees a <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> using the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function.</source>
          <target state="translated">Libera un <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> usando la funzione COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>Like <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph>, you can use this method to deallocate memory.</source>
          <target state="translated">Ad esempio <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph>, è possibile utilizzare questo metodo per deallocare la memoria.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function, which frees memory allocated by any of the following unmanaged methods: <ph id="ph2">`SysAllocString`</ph>, <ph id="ph3">`SysAllocStringByteLen`</ph>, <ph id="ph4">`SysAllocStringLen`</ph>, <ph id="ph5">`SysReAllocString`</ph>, <ph id="ph6">`SysReAllocStringLen`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A&gt;</ph> chiama il componente COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> (funzione), che libera la memoria allocata da uno dei seguenti metodi non gestiti: <ph id="ph2">`SysAllocString`</ph>, <ph id="ph3">`SysAllocStringByteLen`</ph>, <ph id="ph4">`SysAllocStringLen`</ph>, <ph id="ph5">`SysReAllocString`</ph>, <ph id="ph6">`SysReAllocStringLen`</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>You can call unmanaged methods such as these with platform invoke.</source>
          <target state="translated">È possibile chiamare metodi non gestiti, ad esempio con platform invoke.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>For details, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>utilizzo di funzioni DLL non gestite<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>The address of the memory to be freed.</source>
          <target state="translated">Indirizzo della memoria da liberare.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>Frees a block of memory allocated by the unmanaged COM task memory allocator.</source>
          <target state="translated">Libera un blocco di memoria assegnato dall'allocatore di memoria non gestita delle attività COM.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> to free any memory allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph>, or any equivalent unmanaged method.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> per liberare memoria allocata da <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph>, o un equivalente di metodo non gestito.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>If the <ph id="ph1">`ptr`</ph> parameter is <ph id="ph2">`null`</ph>, the method does nothing.</source>
          <target state="translated">Se il <ph id="ph1">`ptr`</ph> parametro <ph id="ph2">`null`</ph>, il metodo non esegue alcuna operazione.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>CoTaskMemFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148638)</ept> function, which frees all bytes so that you can no longer use the memory that the <ph id="ph2">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> espone il COM <bpt id="p1">[</bpt>CoTaskMemFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148638)</ept> funzione, che libera tutti i byte in modo che non è possibile utilizzare la memoria che di <ph id="ph2">`ptr`</ph> punta al parametro.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Oltre a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe fornisce due altri metodi di deallocazione di memoria: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The handle returned by the original matching call to <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">L'handle restituito dalla chiamata di corrispondenza originale a <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>Frees memory previously allocated from the unmanaged memory of the process.</source>
          <target state="translated">Libera la memoria precedentemente allocata dalla memoria non gestita del processo.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> to free any memory from the global heap allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>, or any equivalent unmanaged API method.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> per liberare memoria dall'heap globale allocato da <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>, o metodo API non gestita qualsiasi equivalente.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>If the <ph id="ph1">`hglobal`</ph> parameter is <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> the method does nothing.</source>
          <target state="translated">Se il <ph id="ph1">`hglobal`</ph> parametro <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> il metodo non esegue alcuna operazione.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> exposes the <bpt id="p1">[</bpt>LocalFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148640)</ept> function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by <ph id="ph2">`hglobal`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> espone il <bpt id="p1">[</bpt>LocalFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148640)</ept> funzione da Kernel32.DLL, che libera tutti i byte in modo che non è possibile utilizzare la memoria a cui puntava <ph id="ph2">`hglobal`</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation API methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">Oltre a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe fornisce due deallocazione della memoria metodi API: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> method.</source>
          <target state="translated">Nel codice riportato di seguito viene illustrata la chiamata al metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <ph id="ph1">&lt;xref:System.String&gt;</ph> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>The type to generate a GUID for.</source>
          <target state="translated">Tipo per il quale generare un GUID.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</source>
          <target state="translated">Restituisce il GUID (Globally Unique Identifier) del tipo specificato o genera un GUID mediante l'algoritmo usato da Type Library Exporter (Tlbexp.exe).</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>An identifier for the specified type.</source>
          <target state="translated">Identificatore per il tipo specificato.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>If the type has a GUID in the metadata, it is returned.</source>
          <target state="translated">Se il tipo ha un GUID nei metadati, viene restituito.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Otherwise, a GUID is automatically generated.</source>
          <target state="translated">In caso contrario, viene generato automaticamente un GUID.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</source>
          <target state="translated">È possibile utilizzare questo metodo per determinare a livello di codice il GUID di COM per qualsiasi tipo gestito, inclusi i tipi COM invisibile.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Class interfaces are the only exception because they do not correspond to a managed type.</source>
          <target state="translated">Le interfacce di classe sono l'unica eccezione perché non corrispondono a un tipo gestito.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A&gt;</ph> provides the same functionality as the <ph id="ph2">&lt;xref:System.Type.GUID%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A&gt;</ph> fornisce la stessa funzionalità come la <ph id="ph2">&lt;xref:System.Type.GUID%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The type to get a ProgID for.</source>
          <target state="translated">Tipo per il quale ottenere un ProgID.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>Returns a programmatic identifier (ProgID) for the specified type.</source>
          <target state="translated">Restituisce un ProgID (Programmatic Identifier) per il tipo specificato.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The ProgID of the specified type.</source>
          <target state="translated">ProgID del tipo specificato.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>If the type has a ProgID in the metadata, that ProgID is returned.</source>
          <target state="translated">Se il tipo ha un ProgID nei metadati, viene restituito tale ProgID.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>Otherwise, a ProgID is generated based on the fully qualified name of the type.</source>
          <target state="translated">In caso contrario, viene generato un ProgID in base al nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter is not a class that can be create by COM.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="type" /&gt;</ph> non è una classe che può essere creata da COM.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The class must be public, have a public default constructor, and be COM visible.</source>
          <target state="translated">La classe deve essere pubblica, disporre di un costruttore predefinito pubblico e deve essere visibile a COM.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="type" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The programmatic identifier (ProgID) of the object that was requested.</source>
          <target state="translated">Identificatore programmatico (ProgID) dell'oggetto richiesto.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Obtains a running instance of the specified object from the running object table (ROT).</source>
          <target state="translated">Ottiene un'istanza in esecuzione dell'oggetto specificato dalla tabella ROT (Running Object Table).</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The object that was requested; otherwise <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto richiesto; in caso contrario, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>You can cast this object to any COM interface that it supports.</source>
          <target state="translated">È possibile eseguire il cast di questo oggetto a qualsiasi interfaccia COM supportata.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (<ph id="ph2">`ProgID`</ph>) expected by this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> espone il COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> da OLEAUT32 (funzione). DLL. Tuttavia, quest'ultimo prevede un identificatore di classe (CLSID) anziché l'identificatore programmatico (<ph id="ph2">`ProgID`</ph>) previsto dal metodo.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>To obtain a running instance of a COM object without a registered <ph id="ph1">`ProgID`</ph>, use platform invoke to define the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function.</source>
          <target state="translated">Per ottenere un'istanza in esecuzione di un oggetto COM senza un registrati <ph id="ph1">`ProgID`</ph>, utilizzare platform invoke per definire il modello COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> (funzione).</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>For a description of platform invoke, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
          <target state="translated">Per una descrizione di platform invoke, vedere <bpt id="p1">[</bpt>utilizzo di funzioni DLL non gestite<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>ProgID and CLSID</source>
          <target state="translated">ProgID e CLSID</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</source>
          <target state="translated">Le chiavi nel sottoalbero HKEY_CLASSES_ROOT del Registro di sistema contengono una varietà di tipi di sottochiave.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</source>
          <target state="translated">La maggior parte delle sottochiavi sono ProgID che mappano una semplice stringa su un CLSID.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Applications often use these human-readable strings instead of the numeric CLSIDs.</source>
          <target state="translated">Applicazioni usano spesso queste stringhe leggibile dall'utente anziché i CLSID numerici.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</source>
          <target state="translated">Spesso, un componente ha un ProgID indipendenti dalla versione che viene eseguito il mapping alla versione più recente del componente installata nel sistema.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</source>
          <target state="translated">Applicazioni e componenti usano principalmente ProgID per recuperare i CLSID corrispondente.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The following example was run on a computer that was configured with a running instance of Microsoft Word.</source>
          <target state="translated">Nell'esempio seguente è stato eseguito in un computer che è stato configurato con un'istanza di Microsoft Word.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>There were no instances of Microsoft Excel running.</source>
          <target state="translated">Vi sono istanze di Microsoft Excel in esecuzione.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The example calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> twice.</source>
          <target state="translated">Nell'esempio viene chiamato <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> due volte.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the <ph id="ph1">`Word.Application`</ph> object).</source>
          <target state="translated">La prima chiamata tenta di recuperare un riferimento a un'istanza di Microsoft Word (un'istanza di <ph id="ph1">`Word.Application`</ph> oggetto).</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an <ph id="ph1">`Excel.Application`</ph> object).</source>
          <target state="translated">La seconda chiamata tenta di recuperare un riferimento a un'istanza di Microsoft Excel (un'istanza di un <ph id="ph1">`Excel.Application`</ph> oggetto).</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The code retrieves a reference to an instance of Microsoft Word successfully.</source>
          <target state="translated">Il codice recupera un riferimento a un'istanza di Microsoft Word correttamente.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>.</source>
          <target state="translated">Tuttavia, poiché Microsoft Excel non è in esecuzione, il tentativo di recuperare il secondo oggetto genera un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The object was not found.</source>
          <target state="translated">L'oggetto non è stato trovato.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Returns an interface pointer that represents an interface for an object.</source>
          <target state="translated">Restituisce un puntatore a interfaccia che rappresenta un'interfaccia per un oggetto.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The object that provides the interface.</source>
          <target state="translated">Oggetto che fornisce l'interfaccia.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The type of interface that is requested.</source>
          <target state="translated">Tipo di interfaccia richiesto.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
          <target state="translated">Restituisce un puntatore a un'interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> che rappresenta l'interfaccia specificata sull'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Custom query interface access is enabled by default.</source>
          <target state="translated">L'accesso all'interfaccia di query è abilitato per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The interface pointer that represents the specified interface for the object.</source>
          <target state="translated">Puntatore a interfaccia che rappresenta l'interfaccia specificata per l'oggetto.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>This method returns an interface pointer that represents the requested interface on the specified object.</source>
          <target state="translated">Questo metodo restituisce un puntatore a interfaccia che rappresenta l'interfaccia richiesta per l'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
          <target state="translated">È necessario rispettare le regole definite da COM quando si utilizzano i puntatori a interfaccia COM non elaborati.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> tipo, o con marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</source>
          <target state="translated">Anche se meno comune, è possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore all'oggetto COM callable wrapper dell'oggetto.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>For example, you can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ad esempio, è possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> su un oggetto gestito che viene esportato in COM per ottenere un puntatore a interfaccia per <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (<ph id="ph1">`t`</ph>).</source>
          <target state="translated">Poiché il tipo corrispondente da passare al secondo parametro non dispone di un'interfaccia di classe, non è possibile ottenere un puntatore a un'interfaccia di classe (<ph id="ph1">`t`</ph>).</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Instead, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</source>
          <target state="translated">Utilizzare invece <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> per richiamare i membri sull'interfaccia predefinita di COM callable wrapper, che in genere è un'interfaccia di classe di invio automatico.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> method overload allows query interface customization by default.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> overload del metodo che consente la personalizzazione dell'interfaccia di query per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
          <target state="translated">Per specificare se applicare la personalizzazione dell'interfaccia di query, utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, e <bpt id="p3">[</bpt>Introduzione all'interfaccia di classe<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> argomenti.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The type is not visible to COM.</source>
          <target state="translated">Il tipo non è visibile a COM.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter does not support the requested interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> non supporta l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The object that provides the interface.</source>
          <target state="translated">Oggetto che fornisce l'interfaccia.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The type of interface that is requested.</source>
          <target state="translated">Tipo di interfaccia richiesto.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>One of the enumeration values that indicates whether to apply an <ph id="ph1">&lt;see langword="IUnknown::QueryInterface" /&gt;</ph> customization that is supplied by an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /&gt;</ph>.</source>
          <target state="translated">Uno dei valori di enumerazione che indica se applicare una personalizzazione <ph id="ph1">&lt;see langword="IUnknown::QueryInterface" /&gt;</ph> fornita da un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
          <target state="translated">Restituisce un puntatore a un'interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> che rappresenta l'interfaccia specificata sull'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Custom query interface access is controlled by the specified customization mode.</source>
          <target state="translated">L'accesso all'interfaccia di query personalizzato viene controllato dalla modalità della personalizzazione specificata.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The interface pointer that represents the interface for the object.</source>
          <target state="translated">Puntatore a interfaccia che rappresenta l'interfaccia per l'oggetto.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> lets you specify whether to apply query interface customization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> Consente di specificare se applicare la personalizzazione dell'interfaccia di query.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> overload to apply query interface customization by default.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> eseguire l'overload per applicare la personalizzazione dell'interfaccia di query per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The type is not visible to COM.</source>
          <target state="translated">Il tipo non è visibile a COM.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The object <ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> dell'oggetto non supporta l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type of <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo di <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type of interface to return.</source>
          <target state="translated">Tipo di interfaccia da restituire.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The object that provides the interface.</source>
          <target state="translated">Oggetto che fornisce l'interfaccia.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on an object of the specified type.</source>
          <target state="translated">Restituisce un puntatore a un'interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> che rappresenta l'interfaccia specificata sull'oggetto del tipo specificato.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Custom query interface access is enabled by default.</source>
          <target state="translated">L'accesso all'interfaccia di query è abilitato per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The interface pointer that represents the <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> interface.</source>
          <target state="translated">Puntatore a interfaccia che rappresenta l'interfaccia <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>This method returns an interface pointer that represents the <ph id="ph1">`TInterface`</ph> interface on the specified object.</source>
          <target state="translated">Questo metodo restituisce un puntatore a interfaccia che rappresenta il <ph id="ph1">`TInterface`</ph> interfaccia sull'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Always use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> method to decrement the reference count when you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> metodo per decrementare il conteggio dei riferimenti quando il puntatore è stato completato.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
          <target state="translated">È necessario rispettare le regole definite da COM quando si utilizzano i puntatori a interfaccia COM non elaborati.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> tipo, o con marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</source>
          <target state="translated">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore all'interno COM callable wrapper dell'oggetto, sebbene sia meno comune.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>For example, you can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ad esempio, è possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> su un oggetto gestito che viene esportato in COM per ottenere un puntatore a interfaccia per <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> method overload allows query interface customization by default.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> overload del metodo che consente la personalizzazione dell'interfaccia di query per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
          <target state="translated">Per specificare se applicare la personalizzazione dell'interfaccia di query, utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, e <bpt id="p3">[</bpt>Introduzione all'interfaccia di classe<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> argomenti.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type is not visible to COM.</source>
          <target state="translated">Il tipo non è visibile a COM.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is an open generic type.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter does not support the <ph id="ph2">&lt;paramref name="TInterface" /&gt;</ph> interface.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> non supporta l'interfaccia <ph id="ph2">&lt;paramref name="TInterface" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The object that provides the interface.</source>
          <target state="translated">Oggetto che fornisce l'interfaccia.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The type of interface that is requested.</source>
          <target state="translated">Tipo di interfaccia richiesto.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</source>
          <target state="translated">Restituisce un puntatore a interfaccia che rappresenta l'interfaccia specificata per un oggetto, se il chiamante appartiene allo stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The interface pointer specified by <ph id="ph1">&lt;paramref name="t" /&gt;</ph> that represents the interface for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">Puntatore a interfaccia specificato da <ph id="ph1">&lt;paramref name="t" /&gt;</ph> che rappresenta l'interfaccia per l'oggetto specificato oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se il chiamante non appartiene allo stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">Questo metodo è identico <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A&gt;</ph> ad eccezione del fatto che venga restituito <ph id="ph2">`null`</ph> se il chiamante non è presente nello stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The type is not visible to COM.</source>
          <target state="translated">Il tipo non è visibile a COM.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non supporta l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The COM object that contains the data that you want.</source>
          <target state="translated">Oggetto COM che contiene i dati desiderati.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The key in the internal hash table of <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> to retrieve the data from.</source>
          <target state="translated">Chiave nella tabella hash interna di <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> da cui recuperare i dati.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>Retrieves data that is referenced by the specified key from the specified COM object.</source>
          <target state="translated">Recupera i dati ai quali fa riferimento la chiave specificata dall'oggetto COM specificato.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The data represented by the <ph id="ph1">&lt;paramref name="key" /&gt;</ph> parameter in the internal hash table of the <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> parameter.</source>
          <target state="translated">Dati rappresentati dal parametro <ph id="ph1">&lt;paramref name="key" /&gt;</ph> nella tabella hash interna del parametro <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> have an associated hash table, which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A&gt;</ph> retrieves.</source>
          <target state="translated">Tutti gli oggetti COM di cui è stato eseguito il wrapping in un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> dispongono di un hash associato tabella cui <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A&gt;</ph> recupera.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType&gt;</ph> adds data to the hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType&gt;</ph> Aggiunge dati alla tabella hash.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>You should never have to call either method from your code.</source>
          <target state="translated">È necessario non chiamare il metodo dal codice.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is not a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> non è un oggetto COM.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è un oggetto <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>An object that represents an interface method.</source>
          <target state="translated">Oggetto che rappresenta un metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>Retrieves the virtual function table (v-table or VTBL) slot for a specified <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> type when that type is exposed to COM.</source>
          <target state="translated">Recupera lo slot della tabella della funzione virtuale (V-Table o VTBL) per un tipo <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> specificato quando quel tipo è esposto a COM.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The VTBL slot <ph id="ph1">&lt;paramref name="m" /&gt;</ph> identifier when it is exposed to COM.</source>
          <target state="translated">Identificatore <ph id="ph1">&lt;paramref name="m" /&gt;</ph> dello slot VTBL quando è esposto a COM.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The zero-based slot number returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
          <target state="translated">Il numero di slot in base zero restituito da questo metodo tiene conto di tre <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> ed eventualmente di quattro <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> metodi, impostando il valore del primo slot disponibile su 3 o 7.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> fornisce la funzionalità opposta di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</source>
          <target state="translated">È possibile utilizzare questo metodo per recuperare i numeri di slot per i membri delle interfacce che non sono visibili da COM e per i membri delle interfacce private.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</source>
          <target state="translated">I numeri di slot restituiti corrispondono ai numeri v-table che sarebbero riservati se il tipo è esposto a COM.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</source>
          <target state="translated">I membri invisibili a COM occupano effettivamente uno slot in una tabella v esposto, anche se il client COM non è possibile utilizzare lo slot.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> on a class interface by passing <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from a class.</source>
          <target state="translated">Non è possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> su un'interfaccia di classe passando <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> da una classe.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>Introduzione all'interfaccia di classe<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not an interface method.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> non è un metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The unmanaged function pointer to be converted.</source>
          <target state="translated">Puntatore alla funzione non gestita da convertire.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The type of the delegate to be returned.</source>
          <target state="translated">Tipo di delegato da restituire.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Converts an unmanaged function pointer to a delegate.</source>
          <target state="translated">Converte un puntatore a funzione non gestito in un delegato.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>A delegate instance that can be cast to the appropriate delegate type.</source>
          <target state="translated">Istanza di delegato di cui è possibile eseguire il cast al tipo di delegato appropriato.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</source>
          <target state="translated">Nelle versioni 1.0 e 1.1 di .NET Framework, è possibile passare un delegato che rappresenta un metodo gestito a codice non gestito come un puntatore a funzione, consentendo il codice non gestito di chiamare il metodo gestito tramite il puntatore a funzione.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</source>
          <target state="translated">È inoltre possibile per il codice non gestito passare il puntatore a funzione al codice gestito e il puntatore è stato risolto correttamente al metodo gestito sottostante.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>In the .NET Framework 2.0 and later versions, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> methods to marshal delegates in both directions.</source>
          <target state="translated">In .NET Framework 2.0 e versioni successive, è possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> metodi per il marshalling di delegati in entrambe le direzioni.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>With <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>, <ph id="ph2">`ptr`</ph> is imported as a <ph id="ph3">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Con <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>, <ph id="ph2">`ptr`</ph> viene importato come un <ph id="ph3">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>A <ph id="ph1">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> can be obtained for a managed delegate by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> and passed as a parameter; it can then be called from inside the unmanaged method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> può essere ottenuto per un delegato gestito chiamando <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> e passato come parametro; può quindi essere chiamato all'interno del metodo non gestito da.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</source>
          <target state="translated">Si noti che il gestore di marshalling del parametro può anche effettuare il marshalling di delegati in .NET Framework 2.0 e versioni successive i puntatori a funzione.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> method has the following restrictions:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> metodo presenta le restrizioni seguenti:</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Generics are not supported in interop scenarios.</source>
          <target state="translated">Generics non supportati in scenari di interoperabilità.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot pass an invalid function pointer to this method.</source>
          <target state="translated">A questo metodo, è possibile passare un puntatore a funzione non valido.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You can use this method only for pure unmanaged function pointers.</source>
          <target state="translated">È possibile utilizzare questo metodo solo per i puntatori a funzione non gestita pure.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
          <target state="translated">È possibile utilizzare questo metodo con puntatori a funzione ottenuti tramite C++ o dal <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
          <target state="translated">È possibile utilizzare questo metodo per creare un delegato da un puntatore a funzione a un altro delegato gestito.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is not a delegate or is generic.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è un delegato o è generico.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The type of the delegate to return.</source>
          <target state="translated">Tipo del delegato da restituire.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The unmanaged function pointer to convert.</source>
          <target state="translated">Puntatore alla funzione non gestita da convertire.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>Converts an unmanaged function pointer to a delegate of a specified type.</source>
          <target state="translated">Converte un puntatore a funzione non gestito in un delegato di un tipo specificato.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>A instance of the specified delegate type.</source>
          <target state="translated">Istanza del tipo di delegato specificato.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29&gt;</ph> methods to marshal delegates in both directions.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29&gt;</ph> metodi per il marshalling di delegati in entrambe le direzioni.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> method has the following restrictions:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> metodo presenta le restrizioni seguenti:</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot pass an invalid function pointer to this method.</source>
          <target state="translated">A questo metodo, è possibile passare un puntatore a funzione non valido.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You can use this method only for pure unmanaged function pointers.</source>
          <target state="translated">È possibile utilizzare questo metodo solo per i puntatori a funzione non gestita pure.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
          <target state="translated">È possibile utilizzare questo metodo con puntatori a funzione ottenuti tramite C++ o dal <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
          <target state="translated">È possibile utilizzare questo metodo per creare un delegato da un puntatore a funzione a un altro delegato gestito.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="TDelegate" /&gt;</ph> generic parameter is not a delegate, or it is an open generic type.</source>
          <target state="translated">Il parametro generico <ph id="ph1">&lt;paramref name="TDelegate" /&gt;</ph> non è un delegato oppure è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>A type that represents an interface or class.</source>
          <target state="translated">Tipo che rappresenta un'interfaccia o classe.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</source>
          <target state="translated">Recupera l'ultimo slot della tabella della funzione virtuale (V-Table o VTBL) di un tipo quando è esposto a COM.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>The last VTBL slot of the interface when exposed to COM.</source>
          <target state="translated">Ultimo slot VTBL dell'interfaccia quando è esposto a COM.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>If the <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</source>
          <target state="translated">Se il parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è una classe, lo slot VTBL restituito è l'ultimo slot nell'interfaccia generata dalla classe.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>This method returns the zero-based, v-table number for an interface or a class.</source>
          <target state="translated">Questo metodo restituisce il numero di v-table in base zero, per un'interfaccia o una classe.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>When used on a class, the slot number returned refers to the class interface for the class.</source>
          <target state="translated">Quando utilizzato in una classe, il numero di slot restituito fa riferimento all'interfaccia di classe per la classe.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
          <target state="translated">Se l'interfaccia della classe è auto-dual, questo metodo restituisce sempre -1 per indicare che l'interfaccia solo dispatch non espone una tabella v ai client gestiti.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in combinazione con <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> per passare gli slot all'interno di un intervallo specificato.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>Introduzione all'interfaccia di classe<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>Retrieves a code that identifies the type of the exception that occurred.</source>
          <target state="translated">Recupera un codice che identifica il tipo dell'eccezione che si è verificata.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>The type of the exception.</source>
          <target state="translated">Tipo dell'eccezione.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A&gt;</ph> viene esposta per il supporto del compilatore di strutturata (SEH) solo.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>If this method is called before an exception is thrown, it returns 0x0.</source>
          <target state="translated">Se questo metodo viene chiamato prima che venga generata un'eccezione, viene restituito 0x0.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Converts an HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object.</source>
          <target state="translated">Converte un codice errore HRESULT in un oggetto <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> corrispondente.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>The HRESULT to be converted.</source>
          <target state="translated">Codice errore HRESULT da convertire.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object.</source>
          <target state="translated">Converte il codice errore HRESULT specificato in un oggetto <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> corrispondente.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>An object that represents the converted HRESULT.</source>
          <target state="translated">Oggetto che rappresenta l'HRESULT convertito.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> metodo per ottenere un <ph id="ph2">&lt;xref:System.Exception&gt;</ph> basato su un valore HRESULT, senza necessità di chiamare il <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> metodo e rilevare l'eccezione.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>The current <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface is used to construct the exception.</source>
          <target state="translated">Corrente <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interfaccia viene utilizzata per costruire l'eccezione.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere <bpt id="p1">[</bpt>come: mappa di HRESULT ed eccezioni<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>The HRESULT to be converted.</source>
          <target state="translated">Codice errore HRESULT da convertire.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> interface that provides more information about the error.</source>
          <target state="translated">Puntatore all'interfaccia <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> che fornisce ulteriori informazioni sull'errore.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>You can specify <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> to use the current <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> interface, or <bpt id="p2">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p2">&lt;/c&gt;</ept> to ignore the current <ph id="ph2">&lt;see langword="IErrorInfo" /&gt;</ph> interface and construct the exception just from the error code.</source>
          <target state="translated">È possibile specificare <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> per usare l'interfaccia <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> corrente oppure <bpt id="p2">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p2">&lt;/c&gt;</ept> per ignorare l'interfaccia <ph id="ph2">&lt;see langword="IErrorInfo" /&gt;</ph> corrente e costruire l'eccezione unicamente dal codice di errore.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object, with additional error information passed in an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface for the exception object.</source>
          <target state="translated">Converte il codice di errore HRESULT specificato in un oggetto <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> corrispondente, con ulteriori informazioni sull'errore passate in un'interfaccia <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> per l'oggetto eccezione.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>An object that represents the converted HRESULT and information obtained from <ph id="ph1">&lt;paramref name="errorInfo" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta HRESULT convertito e le informazioni ottenute da <ph id="ph1">&lt;paramref name="errorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception (thus avoiding the corresponding performance overhead).</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> metodo per ottenere un <ph id="ph2">&lt;xref:System.Exception&gt;</ph> basato su un valore HRESULT, senza necessità di chiamare il <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> metodo e rilevare l'eccezione (evitando in tal modo il sovraccarico delle prestazioni corrispondenti).</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</source>
          <target state="translated">Il <ph id="ph1">`errorInfo`</ph> parametro fornisce informazioni aggiuntive sull'errore, ad esempio la descrizione testuale e l'identificatore univoco globale (GUID) per l'interfaccia che definisce l'errore.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Use this method overload if you have custom error information that you have to supply in the conversion.</source>
          <target state="translated">Utilizzare questo overload del metodo se si dispone di informazioni personalizzate sugli errori che è necessario fornire la conversione.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere <bpt id="p1">[</bpt>come: mappa di HRESULT ed eccezioni<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</source>
          <target state="translated">Recupera la descrizione di un'eccezione indipendente dal computer e le informazioni sullo stato esistente per il thread nel momento in cui si è verificata l'eccezione.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>A pointer to an <bpt id="p1">[</bpt>EXCEPTION_POINTERS<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148648)</ept> structure.</source>
          <target state="translated">Puntatore a una struttura <bpt id="p1">[</bpt>EXCEPTION_POINTERS<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148648)</ept>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A&gt;</ph> viene esposta per il supporto del compilatore di strutturata (SEH) solo.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The delegate to be passed to unmanaged code.</source>
          <target state="translated">Delegato da passare al codice non gestito.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>Converts a delegate into a function pointer that is callable from unmanaged code.</source>
          <target state="translated">Converte un delegato in un puntatore a funzione disponibile per la chiamata dal codice non gestito.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
          <target state="translated">Valore che può essere passato al codice non gestito, che a sua volta può usarlo per chiamare il delegato gestito sottostante.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
          <target state="translated">Il delegato <ph id="ph1">`d`</ph> viene convertito in un puntatore a funzione che può essere passato a codice non gestito utilizzando il <bpt id="p1">[</bpt>stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> convenzione di chiamata.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
          <target state="translated">È necessario impedire manualmente il delegato venga raccolto dal garbage collector da codice gestito.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The garbage collector does not track references to unmanaged code.</source>
          <target state="translated">Il garbage collector non tiene traccia dei riferimenti a codice non gestito.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="d" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="d" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The type of delegate to convert.</source>
          <target state="translated">Tipo di delegato da convertire.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The delegate to be passed to unmanaged code.</source>
          <target state="translated">Delegato da passare al codice non gestito.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</source>
          <target state="translated">Converte un delegato di un tipo specificato in un puntatore a funzione disponibile per la chiamata dal codice non gestito.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
          <target state="translated">Valore che può essere passato al codice non gestito, che a sua volta può usarlo per chiamare il delegato gestito sottostante.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code by using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
          <target state="translated">Il delegato <ph id="ph1">`d`</ph> viene convertito in un puntatore a funzione che può essere passato a codice non gestito da utilizzando il <bpt id="p1">[</bpt>stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> convenzione di chiamata.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
          <target state="translated">È necessario impedire manualmente il delegato venga raccolto dal garbage collector da codice gestito.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The garbage collector does not track references to unmanaged code.</source>
          <target state="translated">Il garbage collector non tiene traccia dei riferimenti a codice non gestito.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="d" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="d" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The module whose HINSTANCE is desired.</source>
          <target state="translated">Modulo di cui si desidera l'HINSTANCE.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>Returns the instance handle (HINSTANCE) for the specified module.</source>
          <target state="translated">Restituisce l'handle di istanza (HINSTANCE) per il modulo specificato.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The HINSTANCE for <ph id="ph1">&lt;paramref name="m" /&gt;</ph>; or -1 if the module does not have an HINSTANCE.</source>
          <target state="translated">HINSTANCE per <ph id="ph1">&lt;paramref name="m" /&gt;</ph>; o -1 se il modulo non contiene un HINSTANCE.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>When dynamic or in-memory, modules do not have an HINSTANCE.</source>
          <target state="translated">Quando i moduli dinamici o in memoria, non contiene un HINSTANCE.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>The exception to convert to an HRESULT.</source>
          <target state="translated">Eccezione da convertire in valore HRESULT.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Converts the specified exception to an HRESULT.</source>
          <target state="translated">Converte l'eccezione specificata in valore HRESULT.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>The HRESULT mapped to the supplied exception.</source>
          <target state="translated">Valore HRESULT mappato all'eccezione fornita.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> also sets up an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> Inoltre, installa un <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interfaccia per l'eccezione che può essere ottenuto chiamando la funzione COM GetErrorInfoNEEDGUID.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.PreserveSigAttribute&gt;</ph> attribute.</source>
          <target state="translated">È possibile utilizzare questa funzione per restituire un valore HRESULT sull'implementazione di una classe gestita di un'interfaccia COM in cui si applica il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.PreserveSigAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Have the attributed method catch all exceptions and use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method to return the appropriate HRESULT value.</source>
          <target state="translated">Le eccezioni catch tutti metodo con attributi e utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> per restituire il valore HRESULT appropriato.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Allowing an exception to propagate outside the method produces incorrect behavior.</source>
          <target state="translated">Consentendo un'eccezione di propagarsi all'esterno del metodo produce un comportamento non corretto.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</source>
          <target state="translated">(In realtà, common language runtime non riesce a passare un'eccezione a un client COM che chiama tale metodo tramite una v-table.)</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method sets the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread.</source>
          <target state="translated">Si noti che il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> metodo imposta la <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interfaccia del thread corrente.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>This can cause unexpected results for methods like the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> methods that default to using the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> of the current thread if it is set.</source>
          <target state="translated">Questo può causare risultati imprevisti per metodi come il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> metodi che per impostazione predefinita il <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> del thread corrente, se è impostato.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.Marshal" /&gt;</ph>.</source>
          <target state="translated">Restituisce il valore HRESULT corrispondente all'ultimo errore in cui è incorso il codice Win32 eseguito usando <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.Marshal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The HRESULT corresponding to the last Win32 error code.</source>
          <target state="translated">HRESULT corrispondente all'ultimo codice errore Win32.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The target function must have had the <ph id="ph1">`setLastError`</ph> metadata flag set.</source>
          <target state="translated">La funzione di destinazione deve essere stato il <ph id="ph1">`setLastError`</ph> impostato flag di metadati.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>For example, the <ph id="ph1">`SetLastError`</ph> field of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> must be <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">`SetLastError`</ph> campo il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> deve essere <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The process for setting this flag depends on the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Il processo per l'impostazione di questo flag dipende dal linguaggio di origine utilizzato: c# e C++ sono <ph id="ph1">`false`</ph> per impostazione predefinita, ma la <ph id="ph2">`Declare`</ph> istruzione in Visual Basic è <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come recuperare un valore HRESULT corrispondente a un codice di errore Win32 usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface is requested.</source>
          <target state="translated">Oggetto di cui è richiesta l'interfaccia <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface from a managed object.</source>
          <target state="translated">Restituisce un'interfaccia <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> da un oggetto gestito.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> pointer for the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Puntatore <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> per il parametro <ph id="ph2">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IDispatch`</ph> interface.</source>
          <target state="translated">Nel codice gestito, raramente si lavora direttamente con il <ph id="ph1">`IDispatch`</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated">Tuttavia, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> tipo, o con marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</source>
          <target state="translated">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore a interfaccia a COM callable wrapper per l'oggetto.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>For additional information, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non supporta l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface is requested.</source>
          <target state="translated">Oggetto di cui è richiesta l'interfaccia <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface pointer from a managed object, if the caller is in the same context as that object.</source>
          <target state="translated">Restituisce un puntatore a interfaccia <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> da un oggetto gestito se il chiamante appartiene allo stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface pointer for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the specified object.</source>
          <target state="translated">Puntatore a interfaccia <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> per l'oggetto specificato, oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se il chiamante non appartiene allo stesso contesto dell'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">Questo metodo è identico <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> ad eccezione del fatto che venga restituito <ph id="ph2">`null`</ph> se il chiamante non è presente nello stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non supporta l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>The type whose <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface is being requested.</source>
          <target state="translated">Tipo di cui è richiesta l'interfaccia <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /&gt;</ph> interface from a managed type.</source>
          <target state="translated">Restituisce un'interfaccia <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /&gt;</ph> da un tipo gestito.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface for the <ph id="ph2">&lt;paramref name="t" /&gt;</ph> parameter.</source>
          <target state="translated">Puntatore all'interfaccia <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> per il parametro <ph id="ph2">&lt;paramref name="t" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>This method returns a pointer to an <ph id="ph1">`ITypeInfo`</ph> implementation that is based on the original type.</source>
          <target state="translated">Questo metodo restituisce un puntatore a un <ph id="ph1">`ITypeInfo`</ph> implementazione che è in base al tipo originale.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Calling an object with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata a un oggetto con <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> fa sì che il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
          <target state="translated">È possibile applicare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> per sostituire il comportamento di marshalling di interoperabilità standard con il gestore di marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>The following example demonstrates how to retrieve a pointer to the <ph id="ph1">`ITypeInfo`</ph> interface for a type using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come recuperare un puntatore al <ph id="ph1">`ITypeInfo`</ph> interfaccia per un tipo usando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not a visible type to COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è un tipo visibile a COM.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> è un tipo <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>A type library is registered for the assembly that contains the type, but the type definition cannot be found.</source>
          <target state="translated">È stata registrata una libreria dei tipi per l'assembly che contiene il tipo, ma non è possibile trovare la definizione del tipo.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface is requested.</source>
          <target state="translated">Oggetto di cui è richiesta l'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object.</source>
          <target state="translated">Restituisce un'interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> da un oggetto gestito.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer for the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Puntatore <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> per il parametro <ph id="ph2">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IUnknown`</ph> interface.</source>
          <target state="translated">Nel codice gestito, raramente si lavora direttamente con il <ph id="ph1">`IUnknown`</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated">Tuttavia, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> tipo, o con marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>You can also use this method on a managed object to obtain an interface pointer to the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> for the object.</source>
          <target state="translated">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore a interfaccia per il <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> per l'oggetto.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The following example demonstrates how to retrieve an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface for a managed object using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come recuperare un <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interfaccia per un oggetto gestito utilizzando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface is requested.</source>
          <target state="translated">Oggetto di cui è richiesta l'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object, if the caller is in the same context as that object.</source>
          <target state="translated">Restituisce un'interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> da un oggetto gestito se il chiamante appartiene allo stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the specified object.</source>
          <target state="translated">Puntatore <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> per l'oggetto specificato, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> se il chiamante non appartiene allo stesso contesto dell'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">Questo metodo è identico <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> ad eccezione del fatto che venga restituito <ph id="ph2">`null`</ph> se il chiamante non è presente nello stesso contesto dell'oggetto.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The following example demonstrates how to retrieve an <ph id="ph1">`IUnknown`</ph> interface for a managed object using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come recuperare un <ph id="ph1">`IUnknown`</ph> interfaccia per un oggetto gestito utilizzando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /&gt;</ph> flag set.</source>
          <target state="translated">Restituisce il codice errore restituito dall'ultima funzione non gestita chiamata mediante una chiamata platform invoke con il flag <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /&gt;</ph> impostato.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The last error code set by a call to the Win32 <bpt id="p1">[</bpt>SetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148656)</ept> function.</source>
          <target state="translated">Ultimo codice di errore impostato da una chiamata alla funzione Win32 <bpt id="p1">[</bpt>SetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148656)</ept>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> exposes the Win32 <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148657)</ept> function from Kernel32.DLL.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> espone Win32 <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148657)</ept> funzione da Kernel32.DLL.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>This method exists because it is not safe to make a direct platform invoke call to <ph id="ph1">`GetLastError`</ph> to obtain this information.</source>
          <target state="translated">Questo metodo è disponibile perché non è possibile effettuare una piattaforma diretta chiamata a <ph id="ph1">`GetLastError`</ph> per ottenere queste informazioni.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>If you want to access this error code, you must call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> instead of writing your own platform invoke definition for <ph id="ph2">`GetLastError`</ph> and calling it.</source>
          <target state="translated">Se si desidera accedere a questo codice di errore, è necessario chiamare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> anziché scrivere la propria definizione di platform invoke per <ph id="ph2">`GetLastError`</ph> e chiamata.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The common language runtime can make internal calls to APIs that overwrite the <ph id="ph1">`GetLastError`</ph> maintained by the operating system.</source>
          <target state="translated">Common language runtime può eseguire chiamate interne alle API di sovrascriveranno il <ph id="ph1">`GetLastError`</ph> gestiti dal sistema operativo.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>You can use this method to obtain error codes only if you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> to the method signature and set the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph> field to<ph id="ph3">`true`</ph>.</source>
          <target state="translated">È possibile utilizzare questo metodo per ottenere i codici di errore solo se si applica il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> per la firma del metodo e il set di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph> campo<ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The process for this varies depending upon the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Il processo per questo varia in base al linguaggio di origine utilizzato: c# e C++ sono <ph id="ph1">`false`</ph> per impostazione predefinita, ma la <ph id="ph2">`Declare`</ph> istruzione in Visual Basic è <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> method.</source>
          <target state="translated">Nel codice riportato di seguito viene illustrata la chiamata al metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</source>
          <target state="translated">Nell'esempio viene innanzitutto illustrato il metodo senza errori presenti e quindi viene illustrata la chiamata al metodo con un errore presentano.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method to marshal.</source>
          <target state="translated">Puntatore al metodo di cui effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method signature.</source>
          <target state="translated">Puntatore alla firma del metodo.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di byte in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</source>
          <target state="translated">Ottiene un puntatore a una funzione generata a runtime che effettua il marshalling di una chiamata da codice gestito a codice non gestito.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the function that will marshal a call from the <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> parameter to unmanaged code.</source>
          <target state="translated">Puntatore alla funzione che eseguirà il marshalling di una chiamata dal parametro <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> a codice non gestito.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A&gt;</ph> viene esposta per il supporto del compilatore.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The type for which the <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is to be retrieved.</source>
          <target state="translated">Tipo per il quale recuperare <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The VTBL slot.</source>
          <target state="translated">Slot VTBL.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>On successful return, one of the enumeration values that specifies the type of the member.</source>
          <target state="translated">A corretto completamento, uno dei valori di enumerazione che specifica il tipo del membro.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>Retrieves a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object for the specified virtual function table (v-table or VTBL) slot.</source>
          <target state="translated">Recupera un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> per lo slot della tabella di funzione virtuale specificata (V-Table o VTBL).</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The object that represents the member at the specified VTBL slot.</source>
          <target state="translated">Oggetto che rappresenta il membro nello slot VTBL specificato.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The return value may be a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, or <ph id="ph3">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> object.</source>
          <target state="translated">Il valore restituito può essere un <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, o <ph id="ph3">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from which all three derive).</source>
          <target state="translated">Il valore restituito dipende dal tipo di membro gestito che esiste nello slot COM specificato (pertanto il tipo restituito generalizzato <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> dal quale derivano tutti i tre).</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The zero-based slot number that is returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
          <target state="translated">Il numero di slot in base zero che viene restituito da questo metodo tiene conto di tre <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> ed eventualmente di quattro <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> metodi, impostando il valore del primo slot disponibile su 3 o 7.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> fornisce la funzionalità opposta di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in combinazione con <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> per passare gli slot all'interno di un intervallo specificato.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The <ph id="ph1">`memberType`</ph> parameter is important only on return.</source>
          <target state="translated">Il <ph id="ph1">`memberType`</ph> parametro è importante solo in fase di restituzione.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object.</source>
          <target state="translated">Contiene il tipo di membro COM (un metodo regolare o una funzione di accesso) che corrisponde all'oggetto restituito <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not visible from COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è visibile da COM.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The object for which to get a COM VARIANT.</source>
          <target state="translated">Oggetto per il quale ottenere un tipo COM VARIANT.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>A pointer to receive the VARIANT that corresponds to the <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Puntatore per ricevere il tipo VARIANT corrispondente al parametro <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>Converts an object to a COM VARIANT.</source>
          <target state="translated">Converte un oggetto nel tipo COM VARIANT.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
          <target state="translated">Il <ph id="ph1">`pDstNativeVariant`</ph> parametro deve puntare a una memoria sufficiente per memorizzare il VARIANT risulta.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>Also, the implementation of this method calls the <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
          <target state="translated">Inoltre, l'implementazione di questo metodo chiama il <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> funzione nella memoria non elaborata che il <ph id="ph1">`pDstNativeVariant`</ph> punta al parametro.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is an instance of a generic type.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è un'istanza di un tipo generico.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The type of the object to convert.</source>
          <target state="translated">Tipo dell'oggetto da convertire.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The object for which to get a COM VARIANT.</source>
          <target state="translated">Oggetto per il quale ottenere un tipo COM VARIANT.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>A pointer to receive the VARIANT that corresponds to the <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Puntatore per ricevere il tipo VARIANT corrispondente al parametro <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>Converts an object of a specified type to a COM VARIANT.</source>
          <target state="translated">Esegue la conversione da un oggetto di tipo specificato in un oggetto COM VARIANT.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
          <target state="translated">Il <ph id="ph1">`pDstNativeVariant`</ph> parametro deve puntare a una memoria sufficiente per memorizzare il VARIANT risulta.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>Also, the implementation of this method calls <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
          <target state="translated">Inoltre, l'implementazione di questo metodo chiama <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> funzione nella memoria non elaborata che il <ph id="ph1">`pDstNativeVariant`</ph> punta al parametro.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">Puntatore all'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Returns an instance of a type that represents a COM object by a pointer to its <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
          <target state="translated">Restituisce un'istanza di un tipo che rappresenta un oggetto COM tramite un puntatore alla relativa interfaccia <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>An object that represents the specified unmanaged COM object.</source>
          <target state="translated">Oggetto che rappresenta l'oggetto COM non gestito specificato.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This method wraps <ph id="ph1">`IUnknown`</ph> in a managed object.</source>
          <target state="translated">Questo metodo esegue il wrapping <ph id="ph1">`IUnknown`</ph> in un oggetto gestito.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This has the effect of incrementing the reference count of the COM component.</source>
          <target state="translated">Questo ha l'effetto di incrementare il conteggio dei riferimenti del componente COM.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</source>
          <target state="translated">Il conteggio dei riferimenti verranno decrementato quando il runtime esegue garbage collection sull'oggetto gestito che rappresenta l'oggetto COM.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The <ph id="ph1">`pUnk`</ph> parameter represents an <ph id="ph2">`IUnknown`</ph> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph3">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
          <target state="translated">Il <ph id="ph1">`pUnk`</ph> parametro rappresenta un <ph id="ph2">`IUnknown`</ph> puntatore a interfaccia; tuttavia, poiché tutte le interfacce COM derivano direttamente o indirettamente da <ph id="ph3">`IUnknown`</ph>, è possibile passare qualsiasi interfaccia COM a questo metodo.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, which the common language runtime manages as it does any other managed object.</source>
          <target state="translated">L'oggetto restituito da <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A&gt;</ph> è un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, che common language runtime gestisce come esegue qualsiasi altro oggetto gestito.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The type of this wrapper is often a base <ph id="ph1">`System.__ComObject`</ph> type, which is a hidden type used when the wrapper type is ambiguous.</source>
          <target state="translated">Il tipo di questo wrapper è spesso una base <ph id="ph1">`System.__ComObject`</ph> tipo, ovvero un tipo nascosto utilizzato quando il tipo di wrapper è ambiguo.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>You can still make late-bound calls to such a base type as long as the COM object implements the <bpt id="p1">[</bpt>IDispatch<ept id="p1">](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85))</ept> interface.</source>
          <target state="translated">È comunque possibile apportare chiamate ad associazione tardiva a questo tipo è un tipo di base fino a quando l'oggetto COM implementa il <bpt id="p1">[</bpt>IDispatch<ept id="p1">](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85))</ept> interfaccia.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Likewise, you can cast the returned object to an appropriate COM interface.</source>
          <target state="translated">Analogamente, è possibile impostare l'oggetto restituito da un'interfaccia COM appropriata.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</source>
          <target state="translated">Per un oggetto di cui eseguire il wrapping con un tipo specifico di classe gestita e non è un tipo di wrapper generica, è necessario rispettare i requisiti seguenti:</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Implement the <bpt id="p1">[</bpt>IProvideClassInfo<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148012)</ept> interface for the COM object.</source>
          <target state="translated">Implementare il <bpt id="p1">[</bpt>IProvideClassInfo<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148012)</ept> interfaccia per l'oggetto COM.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Register the containing assembly with the <bpt id="p1">[</bpt>Regasm.exe (Assembly Registration Tool)<ept id="p1">](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>.</source>
          <target state="translated">Registrare l'assembly contenitore con il <bpt id="p1">[</bpt>Regasm.exe (strumento di registrazione di Assembly)<ept id="p1">](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">In alternativa, è possibile ignorare questi requisiti e ottenere comunque un oggetto che viene eseguito il wrapping con un tipo classe gestito specifico tramite il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>A pointer to a COM VARIANT.</source>
          <target state="translated">Puntatore a un COM VARIANT.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>Converts a COM VARIANT to an object.</source>
          <target state="translated">Converte un tipo COM VARIANT in un oggetto.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>An object that corresponds to the <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> parameter.</source>
          <target state="translated">Oggetto che corrisponde al parametro <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> Restituisce un oggetto gestito che corrisponde a un puntatore non elaborato a un tipo VARIANT non gestito.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> fornisce la funzionalità opposta di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>When the VARIANT type is VT_ERROR, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns an object of type <ph id="ph2">`Int32`</ph> instead of <ph id="ph3">`UInt32`</ph>.</source>
          <target state="translated">Quando il tipo di variante è VT_ERROR, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> restituisce un oggetto di tipo <ph id="ph2">`Int32`</ph> anziché <ph id="ph3">`UInt32`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> is not a valid VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> non è un tipo VARIANT valido.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> has an unsupported type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> presenta un tipo non supportato.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>The type to which to convert the COM VARIANT.</source>
          <target state="translated">Tipo in cui convertire COM VARIANT.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>A pointer to a COM VARIANT.</source>
          <target state="translated">Puntatore a un COM VARIANT.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>Converts a COM VARIANT to an object of a specified type.</source>
          <target state="translated">Esegue la conversione da un oggetto di tipo specificato a un oggetto COM VARIANT.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>An object of the specified type that corresponds to the <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> parameter.</source>
          <target state="translated">Oggetto del tipo specificato che corrisponde al parametro <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> returns a managed object of type <ph id="ph2">`T`</ph> that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> Restituisce un oggetto gestito di tipo <ph id="ph2">`T`</ph> che corrisponde a un puntatore non elaborato a un tipo VARIANT non gestito.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> fornisce la funzionalità opposta di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> is not a valid VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> non è un tipo VARIANT valido.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> has an unsupported type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> presenta un tipo non supportato.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
          <target state="translated">Puntatore al primo elemento di una matrice di COM VARIANT.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The count of COM VARIANTs in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di tipi COM VARIANT in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>Converts an array of COM <bpt id="p1">[</bpt>VARIANTs<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148670)</ept> to an array of objects.</source>
          <target state="translated">Converte una matrice di tipi COM <bpt id="p1">[</bpt>VARIANT<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148670)</ept> in una matrice di oggetti.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>An object array that corresponds to <ph id="ph1">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</source>
          <target state="translated">Matrice di oggetti che corrisponde a <ph id="ph1">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A&gt;</ph> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A&gt;</ph> Restituisce una matrice di oggetti gestiti che corrisponde a un puntatore non elaborato in una matrice di tipo C di tipi VARIANT non gestiti.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
          <target state="translated">Il metodo restituisce una matrice vuota quando il <ph id="ph1">`cVars`</ph> parametro è 0.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The object array (the return value) gets garbage collected as usual.</source>
          <target state="translated">La matrice di oggetti (il valore restituito) Ottiene raccolto nel garbage collector come di consueto.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
          <target state="translated">La matrice di input non gestita o varianti singole nella matrice di input non vengono liberate.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>Therefore it is your responsibility to free them as appropriate.</source>
          <target state="translated">Pertanto è responsabilità dell'utente liberarle in modo appropriato.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> is a negative number.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> è un numero negativo.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The type of the array to return.</source>
          <target state="translated">Tipo della matrice da restituire.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
          <target state="translated">Puntatore al primo elemento di una matrice di COM VARIANT.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The count of COM VARIANTs in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di tipi COM VARIANT in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>Converts an array of COM VARIANTs to an array of a specified type.</source>
          <target state="translated">Converte una matrice di tipi COM VARIANT in una matrice di un tipo specificato.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>An array of <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> objects that corresponds to <ph id="ph2">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> che corrisponde a <ph id="ph2">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29&gt;</ph> returns an array of <ph id="ph2">`T`</ph> that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29&gt;</ph> Restituisce una matrice di <ph id="ph2">`T`</ph> che corrisponde a un puntatore non elaborato in una matrice di tipo C di tipi VARIANT non gestiti.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
          <target state="translated">Il metodo restituisce una matrice vuota quando il <ph id="ph1">`cVars`</ph> parametro è 0.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The returned array is garbage-collected as usual.</source>
          <target state="translated">La matrice restituita è sottoposto a garbage collection come di consueto.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
          <target state="translated">La matrice di input non gestita o varianti singole nella matrice di input non vengono liberate.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>Therefore, it is your responsibility to free them as appropriate.</source>
          <target state="translated">Pertanto, è responsabilità dell'utente liberarle in modo appropriato.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> is a negative number.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> è un numero negativo.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>A type that represents an interface.</source>
          <target state="translated">Tipo che rappresenta un'interfaccia.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</source>
          <target state="translated">Ottiene il primo slot nella tabella di funzioni virtual (V-Table o VTBL) che contiene metodi definiti dall'utente.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>The first VTBL slot that contains user-defined methods.</source>
          <target state="translated">Primo slot VTBL che contiene metodi definiti dall'utente.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>The first slot is 3 if the interface is based on <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>, and 7 if the interface is based on <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>.</source>
          <target state="translated">Il primo slot è 3 se l'interfaccia è basata su <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> e 7 se l'interfaccia è basata su <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>This method returns the zero-based v-table number for an interface or a class.</source>
          <target state="translated">Questo metodo restituisce il numero in base zero v-table per una classe o un'interfaccia.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>When used on a class, the slot number that is returned refers to the class interface for the class.</source>
          <target state="translated">Quando utilizzato in una classe, che viene restituito il numero di slot fa riferimento all'interfaccia di classe per la classe.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
          <target state="translated">Se l'interfaccia della classe è l'invio automatico, questo metodo restituisce sempre -1 per indicare che l'interfaccia solo dispatch non espone una tabella v ai client gestiti.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> in combinazione con <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> per passare gli slot all'interno di un intervallo specificato.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>Introduzione all'interfaccia di classe<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not visible from COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è visibile da COM.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>An integer that represents a fiber cookie.</source>
          <target state="translated">Intero che rappresenta un fiber cookie.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>Converts a fiber cookie into the corresponding <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> instance.</source>
          <target state="translated">Converte un fiber cookie nella corrispondente istanza di <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>A thread that corresponds to the <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> parameter.</source>
          <target state="translated">Thread che corrisponde al parametro <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</source>
          <target state="translated">Fiber cookie sono opachi i token utilizzati dall'host durante la segnalazione di common language runtime per le decisioni di pianificazione fiber.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>They consist of a stack and register context.</source>
          <target state="translated">Sono costituiti da uno stack e registrare contesto.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> parameter is 0.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> è 0.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface of the unmanaged object.</source>
          <target state="translated">Puntatore all'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> dell'oggetto non gestito.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The type of the requested managed class.</source>
          <target state="translated">Tipo della classe gestita richiesta.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>Returns a managed object of a specified type that represents a COM object.</source>
          <target state="translated">Restituisce un oggetto gestito di un tipo specificato che rappresenta un oggetto COM.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>An instance of the class corresponding to the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the requested unmanaged COM object.</source>
          <target state="translated">Istanza della classe corrispondente all'oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta l'oggetto COM non gestito richiesto.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">`t`</ph> parameter must be either a COM-imported type or a subtype of a COM-imported type.</source>
          <target state="translated">Il <ph id="ph1">`t`</ph> parametro deve essere un tipo importato da COM o un sottotipo di un tipo importato da COM.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>In addition, <ph id="ph1">`t`</ph> must be a type whose metadata was imported by the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">Inoltre, <ph id="ph1">`t`</ph> deve essere un tipo i cui metadati sono stati importati dal <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>This type must be a class and not an associated coclass interface, which carries the name of the COM class.</source>
          <target state="translated">Questo tipo deve essere una classe e non un'interfaccia, coclasse associata che porta il nome della classe COM.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>For example, if Tlbimp.exe imports <ph id="ph1">`Myclass`</ph> as a class called <ph id="ph2">`MyclassClass`</ph> and as a coclass interface called <ph id="ph3">`Myclass`</ph>, you must use <ph id="ph4">`MyclassClass`</ph> (not <ph id="ph5">`Myclass`</ph>) with this method.</source>
          <target state="translated">Se, ad esempio, Importa Tlbimp.exe <ph id="ph1">`Myclass`</ph> come una classe denominata <ph id="ph2">`MyclassClass`</ph> e come un'interfaccia di coclasse chiamato <ph id="ph3">`Myclass`</ph>, è necessario utilizzare <ph id="ph4">`MyclassClass`</ph> (non <ph id="ph5">`Myclass`</ph>) con questo metodo.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>For additional information about imported classes and coclass interfaces, see <bpt id="p1">[</bpt>Imported Type Conversion<ept id="p1">](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle interfacce di coclasse e le classi importate, vedere <bpt id="p1">[</bpt>importati conversione del tipo<ept id="p1">](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)</ept>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>If an object has already been obtained for the <ph id="ph1">`pUnk`</ph> parameter, <ph id="ph2">`t`</ph> is ignored and the existing object is returned.</source>
          <target state="translated">Se un oggetto già ottenuto per il <ph id="ph1">`pUnk`</ph> parametro <ph id="ph2">`t`</ph> viene ignorato e viene restituito l'oggetto esistente.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">`pUnk`</ph> represents an<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph2">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
          <target state="translated"><ph id="ph1">`pUnk`</ph> rappresenta un<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore a interfaccia; tuttavia, poiché tutte le interfacce COM derivano direttamente o indirettamente da <ph id="ph2">`IUnknown`</ph>, è possibile passare qualsiasi interfaccia COM a questo metodo.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW), which the common language runtime manages as it does any other managed object.</source>
          <target state="translated">L'oggetto restituito da <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A&gt;</ph> è un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW), che common language runtime gestisce come esegue qualsiasi altro oggetto gestito.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not attributed with <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;paramref name="t" /&gt;</ph> non è applicato l'attribuito <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> è un tipo <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>The <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface to marshal.</source>
          <target state="translated">Interfaccia <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> di cui effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>Converts an unmanaged <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object into a managed <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated">Converte un oggetto <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> non gestito in un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> gestito.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>A managed type that represents the unmanaged <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> object.</source>
          <target state="translated">Tipo gestito che rappresenta l'oggetto <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> non gestito.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> instance that is based on the original type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> Restituisce un <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> istanza in cui è in base al tipo originale.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
          <target state="translated">È possibile applicare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> per sostituire il comportamento di marshalling di interoperabilità standard con il gestore di marshalling personalizzato.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool uses the custom marshaler to translate <ph id="ph1">`ITypeInfo`</ph> parameters to <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> parameters.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento utilizza il gestore di marshalling personalizzato per convertire <ph id="ph1">`ITypeInfo`</ph> parametri <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> parametri.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>However, if you obtain an <ph id="ph1">`ITypeInfo`</ph> interface by some means other than Tlbimp.exe, you can use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> to manually perform the same translation.</source>
          <target state="translated">Tuttavia, se si ottiene un <ph id="ph1">`ITypeInfo`</ph> interfaccia da alcuni significa diverso Tlbimp.exe, è possibile utilizzare <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> per eseguire manualmente la stessa conversione.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to return.</source>
          <target state="translated">CLSID del tipo da restituire.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source>Returns the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Restituisce il tipo associato all'identificatore di classe specificato (CLSID).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> indipendentemente dalla validità del CLSID.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">Recupera il nome del tipo rappresentato da un oggetto <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept>.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>An object that represents an <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> pointer.</source>
          <target state="translated">Oggetto che rappresenta un puntatore <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">Recupera il nome del tipo rappresentato da un oggetto <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>The name of the type that the <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> parameter points to.</source>
          <target state="translated">Nome del tipo a cui punta il parametro <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">È inoltre possibile recuperare il nome del tipo rappresentato da un <ph id="ph1">`ITypeInfo`</ph> chiamando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> metodo e passando -1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>The <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>An object that represents an <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> pointer.</source>
          <target state="translated">Oggetto che rappresenta un puntatore <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">Recupera il nome del tipo rappresentato da un oggetto <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>The name of the type that the <ph id="ph1">&lt;paramref name="pTI" /&gt;</ph> parameter points to.</source>
          <target state="translated">Nome del tipo a cui punta il parametro <ph id="ph1">&lt;paramref name="pTI" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> object by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">È inoltre possibile recuperare il nome del tipo rappresentato da un <ph id="ph1">`ITypeInfo`</ph> oggetto chiamando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> metodo e passando -1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose LIBID is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato LIBID.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The LIBID of the specified type library.</source>
          <target state="translated">LIBID della libreria dei tipi specificata.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> estrae il LIBID direttamente da una libreria dei tipi esistente.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
          <target state="translated">Questa azione è diverso da quello di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> metodo, che calcola il LIBID necessario in base all'assembly corrente.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sugli identificatori di libreria, vedere <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose LIBID is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato LIBID.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The LIBID of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated">LIBID della libreria dei tipi a cui punta il parametro <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> estrae il LIBID direttamente da una libreria dei tipi esistente.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
          <target state="translated">Questa azione è diverso da quello di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> metodo, che calcola il LIBID necessario in base all'assembly corrente.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sugli identificatori di libreria, vedere <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The assembly from which the type library was exported.</source>
          <target state="translated">Assembly dal quale è stata esportata la libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</source>
          <target state="translated">Recupera il LIBID assegnato a una libreria dei tipi quando viene esportato dall'assembly specificato.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The LIBID that is assigned to a type library when it is exported from the specified assembly.</source>
          <target state="translated">LIBID che viene assegnato a una libreria dei tipi quando viene esportata dall'assembly specificato.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>When assemblies are exported to type libraries, the type library is assigned a LIBID.</source>
          <target state="translated">Quando vengono esportati gli assembly di librerie dei tipi, la libreria dei tipi viene assegnata un LIBID.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>You can set the LIBID explicitly by applying the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType&gt;</ph> at the assembly level, or it can be generated automatically.</source>
          <target state="translated">È possibile impostare in modo esplicito il LIBID applicando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType&gt;</ph> di assembly livello oppure può essere generato automaticamente.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool calculates a LIBID value based on the identity of the assembly.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento consente di calcolare un valore LIBID in base all'identità dell'assembly.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> returns the LIBID that is associated with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>, if the attribute is applied.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> Restituisce il LIBID che è associato il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>, se viene applicato l'attributo.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A&gt;</ph> returns the calculated value.</source>
          <target state="translated">In caso contrario, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A&gt;</ph> restituisce il valore calcolato.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> method to extract the actual LIBID from an existing type library.</source>
          <target state="translated">In alternativa, è possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> metodo per estrarre il reale LIBID da una libreria dei tipi esistente.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>See the <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept> topic for more information about library identifiers.</source>
          <target state="translated">Vedere il <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept> per ulteriori informazioni sugli identificatori di libreria.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;paramref name="asm" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asm" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">Recupera l'LCID di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose LCID is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato LCID.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">Recupera l'LCID di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The LCID of the type library that the <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter points to.</source>
          <target state="translated">LCID della libreria dei tipi a cui punta il parametro <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose LCID is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato LCID.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">Recupera l'LCID di una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The LCID of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated">LCID della libreria dei tipi a cui punta il parametro <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">Recupera il nome di una libreria di tipi.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose name is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato il nome.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">Recupera il nome di una libreria di tipi.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name of the type library that the <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter points to.</source>
          <target state="translated">Nome della libreria dei tipi a cui punta il parametro <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
          <target state="translated">Il nome restituito da questo metodo è l'identificatore utilizzato con l'istruzione di libreria, ad esempio ADODB per la libreria dei tipi Microsoft ADO.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name is not a file name.</source>
          <target state="translated">Il nome non è un nome di file.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>You can also retrieve the type library name by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">È anche possibile recuperare il nome della libreria di tipo chiamando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> metodo e passando -1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose name is to be retrieved.</source>
          <target state="translated">Libreria dei tipi di cui deve essere recuperato il nome.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">Recupera il nome di una libreria di tipi.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated">Nome della libreria dei tipi a cui punta il parametro <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
          <target state="translated">Il nome restituito da questo metodo è l'identificatore utilizzato con l'istruzione di libreria, ad esempio ADODB per la libreria dei tipi Microsoft ADO.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name is not a file name.</source>
          <target state="translated">Il nome non è un nome di file.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>You can also retrieve the type library name by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">È anche possibile recuperare il nome della libreria di tipo chiamando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> metodo e passando -1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>A managed assembly.</source>
          <target state="translated">Assembly gestiti.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>The major version number.</source>
          <target state="translated">Numero di versione principale.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>The minor version number.</source>
          <target state="translated">Numero di versione secondario.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>Retrieves the version number of a type library that will be exported from the specified assembly.</source>
          <target state="translated">Recupera il numero di versione di una libreria dei tipi che verrà esportata dall'assembly specificato.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>Before exporting an assembly by using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibExporterFlags&gt;</ph> with the <ph id="ph2">`CallerResolvedReferences`</ph> value, you can use this method to retrieve the type library version from the assembly.</source>
          <target state="translated">Prima di esportare un assembly utilizzando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibExporterFlags&gt;</ph> con il <ph id="ph2">`CallerResolvedReferences`</ph> valore, è possibile utilizzare questo metodo per recuperare la versione della libreria dei tipi dall'assembly.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>If you do not apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibVersionAttribute&gt;</ph> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</source>
          <target state="translated">Se non si applica il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibVersionAttribute&gt;</ph> attributo a un assembly esportato per controllare in modo esplicito il numero di versione della libreria dei tipi generati, la libreria dei tipi avrà lo stesso numero di versione dell'assembly.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source><ph id="ph1">&lt;paramref name="inputAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>A managed pointer to an <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">Puntatore gestito a un'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>Creates a unique <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) object for a given <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
          <target state="translated">Crea un oggetto <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) univoco per un'interfaccia <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> specificata.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>A unique RCW for the specified <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">RCW univoco per l'interfaccia <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A&gt;</ph> method ensures that you receive a unique RCW, because it does not match an <ph id="ph2">`IUnknown`</ph> pointer to an existing object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A&gt;</ph> metodo garantisce la ricezione di un RCW univoco, perché non corrisponde un <ph id="ph2">`IUnknown`</ph> puntatore a un oggetto esistente.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>Use this method when you have to create a unique RCW that is not impacted by other code that calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method.</source>
          <target state="translated">Utilizzare questo metodo quando è necessario creare un RCW che non venga interessato da altro codice che chiama il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method to marshal.</source>
          <target state="translated">Puntatore al metodo di cui effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method signature.</source>
          <target state="translated">Puntatore alla firma del metodo.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di byte in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</source>
          <target state="translated">Ottiene un puntatore a una funzione generata a runtime che effettua il marshalling di una chiamata da codice non gestito a codice gestito.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to a function that will marshal a call from <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> to managed code.</source>
          <target state="translated">Puntatore a una funzione che eseguirà il marshalling di una chiamata da <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> al codice gestito.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A&gt;</ph> viene esposta per il supporto del compilatore.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>The object to check.</source>
          <target state="translated">Oggetto da controllare.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>Indicates whether a specified object represents a COM object.</source>
          <target state="translated">Indica se un oggetto specificato rappresenta un oggetto COM.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter is a COM type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="o" /&gt;</ph> è un tipo COM; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsComObject%2A&gt;</ph> returns <ph id="ph2">`true`</ph> if the class type of the instance is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> or if it derives directly or indirectly from a class attributed with <ph id="ph4">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsComObject%2A&gt;</ph> Restituisce <ph id="ph2">`true`</ph> se il tipo di classe dell'istanza è attribuito <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> o se deriva direttamente o indirettamente da una classe con attributi <ph id="ph4">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>Tlbimp.exe (utilità di importazione di tipo libreria)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>Two other methods also determine whether a specified object represents a COM object, but the requirements for returning <ph id="ph1">`true`</ph> differ from this method's requirements.</source>
          <target state="translated">Altri due metodi inoltre determinano se un oggetto specificato rappresenta un oggetto COM, ma i requisiti per la restituzione <ph id="ph1">`true`</ph> differiscono dai requisiti di questo metodo.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.IsImport%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">`true`</ph> if the class (or interface) is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> directly; it does not return <ph id="ph4">`true`</ph> for derived types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsImport%2A?displayProperty=nameWithType&gt;</ph> Restituisce <ph id="ph2">`true`</ph> se la classe (o l'interfaccia) è attribuito <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> direttamente; non restituisce <ph id="ph4">`true`</ph> per i tipi derivati.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">`true`</ph> if the type is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> or derives from a type with the same GUID.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType&gt;</ph> Restituisce <ph id="ph2">`true`</ph> se il tipo è attribuito <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> o deriva da un tipo con lo stesso GUID.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>The type to check for COM visibility.</source>
          <target state="translated">Tipo di cui verificare la visibilità COM.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>Indicates whether a type is visible to COM clients.</source>
          <target state="translated">Indica se un tipo è visibile ai client COM.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is visible to COM; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il tipo è visibile a COM. In caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A&gt;</ph> enables you to check for COM visibility in one step.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A&gt;</ph> Consente di controllare la visibilità COM in un unico passaggio.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>Types that are not visible cannot be used from COM.</source>
          <target state="translated">Impossibile utilizzare tipi che non sono visibili da COM.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>A type is visible if it is <ph id="ph1">`public`</ph> and not hidden with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un tipo è visibile se è <ph id="ph1">`public`</ph> e non è nascosto mediante il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The method to be checked.</source>
          <target state="translated">Metodo da controllare.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</source>
          <target state="translated">Calcola il numero di byte nella memoria non gestita necessari per contenere i parametri per il metodo specificato.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The number of bytes required to represent the method parameters in unmanaged memory.</source>
          <target state="translated">Numero di byte necessari per rappresentare i parametri del metodo nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A&gt;</ph> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A&gt;</ph> metodo restituisce la dimensione dello stack (in byte) necessaria per rappresentare i parametri di una firma del metodo nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>Note that the return value of this method is platform-dependent.</source>
          <target state="translated">Si noti che il valore restituito di questo metodo è dipendente dalla piattaforma.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</source>
          <target state="translated">Una firma con un solo parametro integer, ad esempio, restituisce un valore pari a 4 in piattaforme a 32 bit e un valore pari a 8 su piattaforme a 64 bit.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>A value type or formatted reference type that specifies the managed class.</source>
          <target state="translated">Tipo di valore o tipo di riferimento formattato che specifica la classe gestita.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> to the class.</source>
          <target state="translated">È necessario applicare <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> alla classe.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The field within the <bpt id="p1">&lt;c&gt;</bpt>t<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Campo all'interno del parametro <bpt id="p1">&lt;c&gt;</bpt>t<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Returns the field offset of the unmanaged form of the managed class.</source>
          <target state="translated">Restituisce l'offset del campo della forma non gestita della classe gestita.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
          <target state="translated">Offset, in byte, per il parametro <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> all'interno della classe specificata dichiarata tramite platform invoke.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> fornisce la differenza in termini di layout della struttura non gestita, che non corrisponde necessariamente all'offset del layout della struttura gestita.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
          <target state="translated">Il marshalling della struttura, è possibile trasformare il layout e modificare l'offset.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The <ph id="ph1">`t`</ph> parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
          <target state="translated">Il <ph id="ph1">`t`</ph> parametro può essere un tipo di valore o un tipo di riferimento formattato (con layout sequenziale o esplicito).</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">È possibile ottenere la dimensione dell'intero layout utilizzando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>di marshalling predefinito per i tipi valore<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> può esporre campi privati.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The class cannot be exported as a structure or the field is nonpublic.</source>
          <target state="translated">La classe non può essere esportata come struttura o il campo è non pubblico.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Beginning with the .NET Framework version 2.0, the field may be private.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, il campo può essere privato.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>A managed value type or formatted reference type.</source>
          <target state="translated">Tipo di valore definito o tipo di riferimento formattato.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> attribute to the class.</source>
          <target state="translated">È necessario applicare l'attributo <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> alla classe.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The name of the field in the <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> type.</source>
          <target state="translated">Nome del campo nel tipo <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Returns the field offset of the unmanaged form of a specified managed class.</source>
          <target state="translated">Restituisce l'offset del campo della forma non gestita della classe gestita specificata.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
          <target state="translated">Offset, in byte, per il parametro <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> all'interno della classe specificata dichiarata tramite platform invoke.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29&gt;</ph> fornisce la differenza in termini di layout della struttura non gestita, che non corrisponde necessariamente all'offset del layout della struttura gestita.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
          <target state="translated">Il marshalling della struttura, è possibile trasformare il layout e modificare l'offset.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The <ph id="ph1">`T`</ph> generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
          <target state="translated">Il <ph id="ph1">`T`</ph> parametro di tipo generico può essere un tipo di valore o un tipo di riferimento formattato (con layout sequenziale o esplicito).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method.</source>
          <target state="translated">È possibile ottenere la dimensione dell'intero layout utilizzando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>di marshalling predefinito per i tipi valore<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> può esporre campi privati.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The method to be checked.</source>
          <target state="translated">Metodo da controllare.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Executes one-time method setup tasks without calling the method.</source>
          <target state="translated">Esegue in un'unica operazione le attività di configurazione del metodo senza chiamarlo.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Setup tasks provide early initialization and are performed automatically when the target method is invoked.</source>
          <target state="translated">Attività di configurazione forniscono prima inizializzazione e vengono eseguite automaticamente quando viene richiamato il metodo di destinazione.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>First-time tasks include the following:</source>
          <target state="translated">Le prime attività includono:</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Verifying that the platform invoke metadata is correctly formatted.</source>
          <target state="translated">Verifica che i metadati PInvoke è formattato correttamente.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Verifying that all the managed types are valid parameters of platform invoke functions.</source>
          <target state="translated">Verifica che tutti i tipi gestiti sono parametri validi della piattaforma di richiamare le funzioni.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Locating and loading the unmanaged DLL into the process.</source>
          <target state="translated">Individuare e caricare la DLL non gestita nel processo.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Locating the entry point in the process.</source>
          <target state="translated">Individuare il punto di ingresso del processo.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> on a method outside of platform invoke has no effect.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> su un metodo all'esterno di platform invoke non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>To execute setup tasks on all platform invoke methods in a type, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per eseguire il programma di installazione nella piattaforma tutte le attività chiamare i metodi in un tipo, utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="m" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The class whose methods are to be checked.</source>
          <target state="translated">Classe di cui è necessario controllare metodi.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>Performs a pre-link check for all methods on a class.</source>
          <target state="translated">Esegue un controllo pre-collegamento per tutti i metodi di una classe.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> method invokes <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType&gt;</ph> on every method for a given type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> Richiama metodo <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType&gt;</ph> su ogni metodo per un determinato tipo.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> executes one-time method setup tasks without calling each method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> esegue attività di configurazione in un'unica operazione senza chiamare ogni metodo.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> only for platform invoke calls.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> solo per chiamate platform invoke.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="c" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="c" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged ANSI string into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia tutta o parte di una stringa ANSI non gestita.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">L'indirizzo del primo carattere della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>Copies all characters up to the first null character from an unmanaged ANSI string to a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, and widens each ANSI character to Unicode.</source>
          <target state="translated">Copia tutti i caratteri fino al primo carattere Null da una stringa ANSI non gestita a un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e trasforma ogni carattere ANSI in Unicode.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged ANSI string.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa ANSI non gestita.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>If <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns a null string.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, il metodo restituisce una stringa Null.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> method to create a managed string from an unmanaged <ph id="ph2">`char`</ph> array.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> metodo per creare una stringa gestita da una funzione non gestita <ph id="ph2">`char`</ph> matrice.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">L'indirizzo del primo carattere della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The byte count of the input string to copy.</source>
          <target state="translated">Conteggio dei byte della stringa di input da copiare.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito, vi copia un numero di caratteri specificato da una stringa ANSI non gestita e trasforma ciascun carattere ANSI nel formato Unicode.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the native ANSI string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Stringa gestita contenente una copia della stringa ANSI nativa se il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>; in caso contrario, il metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> method to create a managed string from an unmanaged<ph id="ph2">`char`</ph> array.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> metodo per creare una stringa gestita da una funzione non gestita<ph id="ph2">`char`</ph> matrice.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="len" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="len" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged string into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia tutta o parte di una stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
          <target state="translated">Per le piattaforme Unicode, l'indirizzo del primo carattere Unicode.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
          <target state="translated">Per le piattaforme ANSI, l'indirizzo del primo carattere ANSI.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia tutti i caratteri fino al primo carattere null da una stringa archiviata nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>; in caso contrario, questo metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>.</source>
          <target state="translated">Se la piattaforma corrente è Unicode, ogni carattere ANSI viene trasformato in un carattere Unicode e questo metodo chiama <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Otherwise, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
          <target state="translated">In caso contrario, questo metodo chiama <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> fornisce la funzionalità di opposto di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
          <target state="translated">Per le piattaforme Unicode, l'indirizzo del primo carattere Unicode.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
          <target state="translated">Per le piattaforme ANSI, l'indirizzo del primo carattere ANSI.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>The number of characters to copy.</source>
          <target state="translated">Numero di caratteri da copiare.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies the specified number of characters from a string stored in unmanaged memory into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia il numero di caratteri specificato da una stringa archiviata nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the native string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa nativa se il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>; in caso contrario, questo metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>On Unicode platforms, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>; on ANSI platforms, it calls <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
          <target state="translated">Su piattaforme Unicode, questo metodo chiama <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>; piattaforme ANSI, chiama <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>No transformations are done before these methods are called.</source>
          <target state="translated">Prima di questi metodi vengono chiamati, viene eseguita alcuna trasformazione.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> fornisce la funzionalità di opposto <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="len" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="len" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">L'indirizzo del primo carattere della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies a <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> stored in unmanaged memory into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia una <bpt id="p1">[</bpt>stringa binaria (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> archiviata nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Call this method only on strings that were allocated with the unmanaged <bpt id="p1">[</bpt>SysAllocString<ept id="p1">](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)</ept> and <bpt id="p2">[</bpt>SysAllocStringLen<ept id="p2">](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)</ept> functions.</source>
          <target state="translated">Chiamare questo metodo solo su stringhe allocate con le <bpt id="p1">[</bpt>SysAllocString<ept id="p1">](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)</ept> e <bpt id="p2">[</bpt>SysAllocStringLen<ept id="p2">](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)</ept> funzioni.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.IntPtr.Zero" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è uguale a <ph id="ph2">&lt;see cref="F:System.IntPtr.Zero" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged Unicode string into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia tutta o parte di una stringa Unicode non gestita.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">L'indirizzo del primo carattere della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all characters up to the first null character from an unmanaged Unicode string into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia tutti i caratteri fino al primo carattere Null da una stringa Unicode non gestita.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>; in caso contrario, questo metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">L'indirizzo del primo carattere della stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>The number of Unicode characters to copy.</source>
          <target state="translated">Numero di caratteri Unicode da copiare.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies a specified number of characters from an unmanaged Unicode string into it.</source>
          <target state="translated">Alloca un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito e vi copia un numero di caratteri specificato da una stringa Unicode non gestita.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>; in caso contrario, questo metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta rispetto di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Marshals data from an unmanaged block of memory to a managed object.</source>
          <target state="translated">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>The object to which the data is to be copied.</source>
          <target state="translated">Oggetto nel quale devono essere copiati i dati.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>This must be an instance of a formatted class.</source>
          <target state="translated">Deve essere un'istanza di una classe formattata.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Marshals data from an unmanaged block of memory to a managed object.</source>
          <target state="translated">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come un <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>You cannot use this overload method with value types.</source>
          <target state="translated">È possibile utilizzare questo metodo di overload con tipi di valore.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Structure layout is not sequential or explicit.</source>
          <target state="translated">Il layout della struttura non è sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Structure is a boxed value type.</source>
          <target state="translated">La struttura è un tipo valore boxed.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The type of object to be created.</source>
          <target state="translated">Tipo di oggetto da creare.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This object must represent a formatted class or a structure.</source>
          <target state="translated">Questo oggetto deve rappresentare una classe formattata o una struttura.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</source>
          <target state="translated">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito appena allocato del tipo specificato.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>A managed object containing the data pointed to by the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter.</source>
          <target state="translated">Oggetto gestito contenente i dati a cui punta il parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come un <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>You can pass a value type to this overload method.</source>
          <target state="translated">È possibile passare un tipo di valore a questo metodo di overload.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>In this case, the returned object is a boxed instance.</source>
          <target state="translated">In questo caso, l'oggetto restituito è un'istanza di tipo boxed.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene creata una struttura gestita, trasferirla in memoria non gestita e quindi lo trasferisce alla memoria gestita tramite il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come effettuare il marshalling di un blocco di memoria da una struttura gestita tramite non gestita di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This code assumes 32-bit compilation.</source>
          <target state="translated">Questo codice si presuppone la compilazione a 32 bit.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>Before using a 64-bit compiler, replace <ph id="ph1">&lt;xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType&gt;</ph> with <ph id="ph2">&lt;xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Prima di usare un compilatore a 64 bit, sostituire <ph id="ph1">&lt;xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType&gt;</ph> con <ph id="ph2">&lt;xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> parameter layout is not sequential or explicit.</source>
          <target state="translated">Il layout del parametro <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> non è sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The class specified by <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> does not have an accessible default constructor.</source>
          <target state="translated">La classe specificata da <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> non dispone di un costruttore predefinito accessibile.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The type of the object to which the data is to be copied.</source>
          <target state="translated">Tipo dell'oggetto nel quale devono essere copiati i dati.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>This must be a formatted class or a structure.</source>
          <target state="translated">Questo deve rappresentare una classe formattata o una struttura.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</source>
          <target state="translated">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito appena allocato del tipo specificato per un parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>A managed object that contains the data that the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter points to.</source>
          <target state="translated">Oggetto gestito che contiene i dati a cui punta il parametro <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29&gt;</ph> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>You can pass a value type to this method overload.</source>
          <target state="translated">È possibile passare un tipo di valore a questo overload di metodo.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The layout of <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> is not sequential or explicit.</source>
          <target state="translated">Il layout di <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> non è sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The class specified by <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> does not have an accessible default constructor.</source>
          <target state="translated">La classe specificata da <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> non dispone di un costruttore predefinito accessibile.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>The type of <bpt id="p1">&lt;c&gt;</bpt>structure<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo di <bpt id="p1">&lt;c&gt;</bpt>struttura<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>This must be a formatted class.</source>
          <target state="translated">Deve essere una classe formattata.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>The object to which the data is to be copied.</source>
          <target state="translated">Oggetto nel quale devono essere copiati i dati.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>Marshals data from an unmanaged block of memory to a managed object of the specified type.</source>
          <target state="translated">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito di un tipo specificato.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29&gt;</ph> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>You cannot use this method overload with value types.</source>
          <target state="translated">È possibile utilizzare questo overload del metodo con i tipi di valore.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>Structure layout is not sequential or explicit.</source>
          <target state="translated">Il layout della struttura non è sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The interface to be queried.</source>
          <target state="translated">Interfaccia su cui eseguire una query.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The interface identifier (IID) of the requested interface.</source>
          <target state="translated">Identificatore di interfaccia (IID) dell'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>When this method returns, contains a reference to the returned interface.</source>
          <target state="translated">Quando questo metodo restituisce un risultato, contiene un riferimento all'interfaccia restituita.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Requests a pointer to a specified interface from a COM object.</source>
          <target state="translated">Richiede un puntatore a un'interfaccia specificata da un oggetto COM.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>An HRESULT that indicates the success or failure of the call.</source>
          <target state="translated">HRESULT che indica l'esito positivo o negativo della chiamata.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A&gt;</ph> method exposes the <bpt id="p1">[</bpt>IUnknown::QueryInterface<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=144867)</ept> method of a COM object, which attempts to obtain a specific interface pointer.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A&gt;</ph> metodo espone il <bpt id="p1">[</bpt>IUnknown:: QueryInterface<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=144867)</ept> metodo di un oggetto COM, che tenta di ottenere un puntatore a interfaccia specifico.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Using <ph id="ph1">`QueryInterface`</ph> on a COM object is the same as performing a cast operation in managed code.</source>
          <target state="translated">Utilizzando <ph id="ph1">`QueryInterface`</ph> su una COM oggetto è uguale all'esecuzione di un'operazione cast in codice gestito.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>To obtain an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer, you can call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ottenere un <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> valore che rappresenta un <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore a interfaccia, è possibile chiamare <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, o <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a single byte from unmanaged memory.</source>
          <target state="translated">Legge un singolo byte da memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>Reads a single byte from unmanaged memory.</source>
          <target state="translated">Legge un singolo byte da memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The byte read from unmanaged memory.</source>
          <target state="translated">Byte letto da memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> dispone di un offset implicito di 0.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">Questo metodo consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</source>
          <target state="translated">Nell'esempio seguente viene creato un blocco di memoria non gestita, scrive un byte nella memoria non gestita, legge i byte da memoria non gestita e quindi elimina la memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> method to read the value of an unmanaged character.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> metodo per leggere il valore di un carattere non gestito.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
          <target state="translated">Legge un singolo byte in base a un determinato offset (o indice) dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The byte read from unmanaged memory at the given offset.</source>
          <target state="translated">Byte letto da memoria non gestita all'offset fornito.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> method to read the value of an unmanaged character.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> metodo per leggere il valore di un carattere non gestito.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
          <target state="translated">Legge un singolo byte in base a un determinato offset (o indice) dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>The byte read from unmanaged memory at the given offset.</source>
          <target state="translated">Byte letto da memoria non gestita all'offset fornito.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 16-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 16 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>Reads a 16-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 16 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The 16-bit signed integer read from unmanaged memory.</source>
          <target state="translated">Intero con segno a 16 bit letto dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> dispone di un offset implicito di 0.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int16`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">Questo metodo consente l'interazione diretta con un tipo non gestito C <ph id="ph1">`Int16`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`short`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`short`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un intero con segno a 16 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero con segno a 16 bit letto dalla memoria non gestita a un offset specificato.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`short`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`short`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un intero con segno a 16 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero con segno a 16 bit letto dalla memoria non gestita a un offset specificato.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 32-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 32 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>Reads a 32-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 32 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
          <target state="translated">Intero con segno a 32 bit letto dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> dispone di un offset implicito di 0.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int32`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">Questo metodo consente l'interazione diretta con un tipo non gestito C <ph id="ph1">`Int32`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`int`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`int`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un Intero con segno a 32 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
          <target state="translated">Intero con segno a 32 bit letto dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`int`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`int`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un Intero con segno a 32 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>The 32-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero con segno a 32 bit letto dalla memoria non gestita a un offset specificato.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 64-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 64 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>Reads a 64-bit signed integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero con segno a 64 bit dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The 64-bit signed integer read from unmanaged memory.</source>
          <target state="translated">Intero con segno a 64 bit letto dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> dispone di un offset implicito di 0.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int64`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">Questo metodo consente l'interazione diretta con un tipo non gestito C <ph id="ph1">`Int64`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`__int64`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`__int64`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un Intero con segno a 64 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero con segno a 64 bit letto dalla memoria non gestita a un offset specificato.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`__int64`</ph> variable.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> metodo per leggere il valore di una funzione non gestita <ph id="ph2">`__int64`</ph> variabile.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un Intero con segno a 64 bit a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero con segno a 64 bit letto dalla memoria non gestita a un offset specificato.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a processor native sized integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero della dimensione nativa del processore dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>Reads a processor native-sized integer from unmanaged memory.</source>
          <target state="translated">Legge un intero di dimensioni native del processore dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The integer read from unmanaged memory.</source>
          <target state="translated">Intero letto da memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</source>
          <target state="translated">In computer a 32 bit viene restituito un intero a 32 bit, mentre in computer a 64 bit viene restituito un intero a 64 bit.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> dispone di un offset implicito di 0.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">Questo metodo consente l'interazione diretta con un tipo non gestito C <ph id="ph1">`IntPtr`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da cui leggere.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Reads a processor native sized integer at a given offset from unmanaged memory.</source>
          <target state="translated">Legge un intero di dimensioni native del processore a un offset specificato dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero letto da memoria non gestita all'offset fornito.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> Consente l'interazione diretta con un tipo non gestito C <ph id="ph2">`IntPtr`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della lettura.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Reads a processor native sized integer from unmanaged memory.</source>
          <target state="translated">Legge un valore intero della dimensione nativa del processore dalla memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>The integer read from unmanaged memory at the given offset.</source>
          <target state="translated">Intero letto da memoria non gestita all'offset fornito.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> Consente l'interazione diretta con un tipo non gestito C <ph id="ph2">`IntPtr`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di leggere i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">La lettura da posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Puntatore alla memoria allocata con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>The new size of the allocated block.</source>
          <target state="translated">Nuova dimensione del blocco allocato.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Ridimensiona un blocco di memoria allocato in precedenza con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>An integer representing the address of the reallocated block of memory.</source>
          <target state="translated">Intero che rappresenta l'indirizzo del blocco di memoria riallocato.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This memory must be released with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Questa memoria deve essere liberata con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph> is one of two memory reallocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph> è uno dei due metodi di riallocazione della memoria nella <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> è l'altro.) Inizio del contenuto della memoria riallocata corrisponde al contenuto originale. Tuttavia, è possibile l'intero blocco di memoria in un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemRealloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148778)</ept> function, which is referred to as the COM task memory allocator.</source>
          <target state="translated">Questo metodo espone il COM <bpt id="p1">[</bpt>CoTaskMemRealloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148778)</ept> funzione, viene considerato l'allocatore di memoria delle attività COM.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">Memoria insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Puntatore alla memoria allocata con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>The new size of the allocated block.</source>
          <target state="translated">Nuova dimensione del blocco allocato.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This is not a pointer; it is the byte count you are requesting, cast to type <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">Non si tratta di un puntatore; corrisponde al conteggio dei byte richiesti, di cui è stato eseguito il cast al tipo <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>If you pass a pointer, it is treated as a size.</source>
          <target state="translated">Se si passa un puntatore, viene trattato come una dimensione.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Ridimensiona un blocco di memoria allocato in precedenza con <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>A pointer to the reallocated memory.</source>
          <target state="translated">Puntatore alla memoria riallocata.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This memory must be released using <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Questa memoria deve essere liberata usando <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is one of two memory reallocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> è una delle operazioni di riallocazione della memoria due metodi API di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.)</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> è l'altro.)</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This method exposes the Win32 <bpt id="p1">[</bpt>GlobalReAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148780)</ept> function from Kernel32.dll.</source>
          <target state="translated">Questo metodo espone Win32 <bpt id="p1">[</bpt>GlobalReAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148780)</ept> funzione da Kernel32.dll.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>The returned pointer can differ from the original.</source>
          <target state="translated">Il puntatore restituito può essere diverso dall'originale.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</source>
          <target state="translated">Se è diverso, il contenuto del blocco di memoria originale è stato copiato nel nuovo blocco e il blocco di memoria originale è stato liberato.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">Memoria insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The interface to release.</source>
          <target state="translated">Interfaccia da liberare.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Decrements the reference count on the specified interface.</source>
          <target state="translated">Riduce il numero di riferimenti nell'interfaccia specificata.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The new value of the reference count on the interface specified by the <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> parameter.</source>
          <target state="translated">Nuovo valore del numero di riferimenti nell'interfaccia specificata dal parametro <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
          <target state="translated">Common language runtime gestisce il conteggio dei riferimenti di un oggetto COM per l'utente, rendendo non è necessario utilizzare questo metodo direttamente.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Use this value only for testing purposes.</source>
          <target state="translated">Utilizzare questo valore solo a scopo di test.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
          <target state="translated">In rari casi, ad esempio test di un gestore di marshalling personalizzato, potrebbe essere necessario modificare manualmente la durata dell'oggetto.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Only programs that call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType&gt;</ph> should call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>.</source>
          <target state="translated">Solo i programmi che chiamano <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType&gt;</ph> deve chiamare <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> after the reference count has reached zero causes undefined behavior.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> il conteggio dei riferimenti raggiunge zero causa un comportamento indefinito.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer to release.</source>
          <target state="translated">È possibile chiamare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> per ottenere un <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> valore che rappresenta un <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> puntatore a interfaccia da liberare.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> method on managed objects to release the COM interfaces represented by the managed object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">È inoltre possibile utilizzare questi metodi e <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> metodo su oggetti gestiti per rilasciare le interfacce COM rappresentate dall'oggetto gestito <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The following example demonstrates how to retrieve an <ph id="ph1">`IUnknown`</ph> interface for a managed object using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come recuperare un <ph id="ph1">`IUnknown`</ph> interfaccia per un oggetto gestito utilizzando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The example then releases the interface pointer by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene quindi rilascia il puntatore a interfaccia chiamando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The COM object to release.</source>
          <target state="translated">Oggetto COM da rilasciare.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Decrements the reference count of the <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) associated with the specified COM object.</source>
          <target state="translated">Decrementa il conteggio dei riferimenti del <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) associato all'oggetto COM specificato.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The new value of the reference count of the RCW associated with <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</source>
          <target state="translated">Nuovo valore del conteggio dei riferimenti dell'RCW associato a <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</source>
          <target state="translated">Questo valore in genere è zero poiché RCW conserva solo un riferimento all'oggetto COM incluso indipendentemente dal numero dei client gestiti che lo chiamano.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This method is used to explicitly control the lifetime of a COM object used from managed code.</source>
          <target state="translated">Questo metodo viene utilizzato per controllare in modo esplicito la durata di un oggetto COM dal codice gestito.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</source>
          <target state="translated">Utilizzare questo metodo per liberare l'oggetto COM sottostante che contiene i riferimenti alle risorse in modo tempestivo o quando gli oggetti devono essere liberati in un ordine specifico.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</source>
          <target state="translated">Ogni volta che un puntatore a interfaccia COM entra in common language runtime (CLR), viene eseguito il wrapping in un RCW.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</source>
          <target state="translated">Il wrapper RCW presenta un conteggio di riferimenti viene incrementato ogni volta che viene eseguito il mapping di un puntatore a interfaccia COM a esso.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method decrements the reference count of an RCW.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo decrementa il conteggio dei riferimenti di un RCW.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <ph id="ph1">&lt;xref:System.NullReferenceException?displayProperty=nameWithType&gt;</ph> if you attempt to use the object further.</source>
          <target state="translated">Quando il conteggio dei riferimenti arriva a zero, il runtime rilascia tutti i relativi riferimenti all'oggetto COM non gestito e genera un <ph id="ph1">&lt;xref:System.NullReferenceException?displayProperty=nameWithType&gt;</ph> se si tenta di utilizzare ulteriormente l'oggetto.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> returns the number of remaining references.</source>
          <target state="translated">Se la stessa interfaccia COM viene passata più volte da non gestito al codice gestito, il conteggio dei riferimenti sul wrapper viene incrementato ogni volta e la chiamata <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> restituisce il numero di riferimenti rimanenti.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</source>
          <target state="translated">Questo metodo consente di forzare una versione di conteggio di riferimento RCW in modo che si verifica con precisione quando si desidera.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>However, improper use of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> may cause your application to fail, or may cause an access violation.</source>
          <target state="translated">Tuttavia, l'uso improprio di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> potrebbe rallentare l'applicazione non riesce, o potrebbe causare una violazione di accesso.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</source>
          <target state="translated">Si consideri uno scenario in cui il codice gestito in un dominio applicazione è mantiene un RCW che rappresenta un componente COM.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the RCW, the managed code will be unable to access the RCW and will raise an <ph id="ph2">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> exception.</source>
          <target state="translated">Se si chiama il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo sul RCW, il codice gestito, sarà in grado di accedere a RCW e genererà un <ph id="ph2">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>A more serious error may occur if a call to the RCW is executing when the RCW is released.</source>
          <target state="translated">Se una chiamata a RCW è in esecuzione quando viene rilasciato il RCW, potrebbe verificarsi un errore più grave.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>In this case, there is a good chance that the thread making the call will cause an access violation.</source>
          <target state="translated">In questo caso, è probabile che il thread che effettua la chiamata causerà una violazione di accesso.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</source>
          <target state="translated">Tuttavia, potrebbe venire danneggiata memoria del processo e il processo può continuare per l'esecuzione fino a quando non riesce per motivi molto difficili da eseguire il debug.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM <bpt id="p1">[</bpt>CoCreateInstance<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=142894)</ept> function, which returns the same interface pointer every time it is called for singleton COM components.</source>
          <target state="translated">Questo rischio è maggiore di quando il componente COM che è in uso è un singleton, per il motivo seguente: CLR attiva componenti COM chiamando il componente COM <bpt id="p1">[</bpt>CoCreateInstance<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=142894)</ept> funzione che restituisce lo stesso puntatore di interfaccia ogni ora che viene chiamato per i componenti COM singleton.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the COM component, the other will be broken.</source>
          <target state="translated">Pertanto, separati e indipendente parti del codice gestito in un dominio applicazione possono utilizzare lo stesso RCW per un componente COM singleton e se uno chiama il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo sul componente COM, l'altro verrà interrotto.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Therefore, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> only if it is absolutely required.</source>
          <target state="translated">Pertanto, utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> solo se è assolutamente necessario.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If you want to call this method to ensure that a COM component is released at a determined time, consider using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method instead.</source>
          <target state="translated">Se si desidera chiamare questo metodo per garantire che un componente COM viene rilasciato in un determinato momento, è consigliabile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> will release the underlying COM component regardless of how many times it has re-entered the CLR.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> rilascerà il componente COM sottostante indipendentemente da quante volte è stato immesso nuovamente CLR.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</source>
          <target state="translated">Il conteggio dei riferimenti interni del RCW viene incrementato di uno ogni volta che il componente COM immette nuovamente il CLR.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Therefore, you could call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until the value returned is zero.</source>
          <target state="translated">Pertanto, è possibile chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> metodo in un ciclo fino a quando il valore restituito è zero.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This achieves the same result as the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method.</source>
          <target state="translated">Lo stesso risultato viene ottenuto il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is not a valid COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> non è un oggetto COM valido.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>Releases the thread cache.</source>
          <target state="translated">Rilascia la cache del thread.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">Oggetto gestito da copiare.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>Allocates an unmanaged <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object into it.</source>
          <target state="translated">Alloca una <bpt id="p1">[</bpt>stringa binaria (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> non gestita e vi copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> gestito.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se è stato fornito un oggetto Null.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A&gt;</ph> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la <ph id="ph1">`BSTR`</ph> termine chiamando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">Oggetto gestito da copiare.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se è stato fornito un oggetto Null.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The characters of the string are copied as ANSI characters.</source>
          <target state="translated">I caratteri della stringa vengono copiati come caratteri ANSI.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> metodo per effettuare il marshalling e decrittografare il contenuto di un <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> oggetto in un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> metodo per azzerare ed eliminare il blocco non gestito.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">Oggetto gestito da copiare.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se è stato fornito un oggetto Null.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The characters of the string are copied as Unicode characters.</source>
          <target state="translated">I caratteri della stringa vengono copiati come caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> metodo per effettuare il marshalling e decrittografare il contenuto di un <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> oggetto in un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> metodo per azzerare ed eliminare il blocco non gestito.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">Oggetto gestito da copiare.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> gestito nella memoria non gestita, effettuando contemporaneamente la conversione nel formato ANSI.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied, or 0 if a null object was supplied.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se è stato fornito un oggetto Null.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> metodo per effettuare il marshalling e decrittografare il contenuto di un <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> oggetto in un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> metodo per azzerare ed eliminare il blocco non gestito.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">Oggetto gestito da copiare.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object into unmanaged memory.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> gestito nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object whose length is 0.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato <ph id="ph1">&lt;paramref name="s" /&gt;</ph> oppure 0 se <ph id="ph2">&lt;paramref name="s" /&gt;</ph> è un oggetto <ph id="ph3">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> con lunghezza 0.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> metodo è utile per il marshalling personalizzato o per l'utilizzo quando la combinazione di codice gestito e.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method with the unmanaged <ph id="ph2">`LogonUser`</ph> function to perform impersonation with the <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> class.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> metodo con tipo non gestito <ph id="ph2">`LogonUser`</ph> funzione per eseguire la rappresentazione con la <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method to zero out and free the unmanaged string reference.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> per azzerare e liberare il riferimento alla stringa non gestita.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The COM object in which to store the data.</source>
          <target state="translated">Oggetto COM in cui archiviare i dati.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The key in the internal hash table of the COM object in which to store the data.</source>
          <target state="translated">Chiave nella tabella hash interna dell'oggetto COM in cui archiviare i dati.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The data to set.</source>
          <target state="translated">Dati da impostare.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>Sets data referenced by the specified key in the specified COM object.</source>
          <target state="translated">Imposta i dati ai quali fa riferimento la chiave specificata nell'oggetto COM specificato.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the data was set successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se i dati sono stati impostati correttamente; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) have an associated hash table, to which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A&gt;</ph> adds data.</source>
          <target state="translated">Tutti gli oggetti COM di cui è stato eseguito il wrapping in un <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) dispone di una tabella hash associata, a cui <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A&gt;</ph> aggiunge i dati.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType&gt;</ph> retrieves data from the hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType&gt;</ph> Recupera i dati dalla tabella hash.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>You should never have to call either method from your code.</source>
          <target state="translated">È necessario non chiamare il metodo dal codice.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is not a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> non è un oggetto COM.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è un oggetto <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Returns the unmanaged size, in bytes, of a class.</source>
          <target state="translated">Restituisce in byte la dimensione non gestita di una classe.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The object whose size is to be returned.</source>
          <target state="translated">Oggetto di cui verrà restituita la dimensione.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>Returns the unmanaged size of an object in bytes.</source>
          <target state="translated">Restituisce la dimensione non gestita di un oggetto, espressa in byte.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The size of the specified object in unmanaged code.</source>
          <target state="translated">Dimensione dell'oggetto specificato nel codice non gestito.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
          <target state="translated">Questo metodo accetta un'istanza di una struttura, che può essere un tipo riferimento o un tipo di valore boxed.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">Il layout deve essere sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The size returned is the size of the unmanaged object.</source>
          <target state="translated">La dimensione restituita è la dimensione dell'oggetto non gestito.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">Le dimensioni gestite e non di un oggetto può essere diverso.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">Per i tipi di carattere, la dimensione dipende dal <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> valore applicato a tale classe.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method to determine how much unmanaged memory to allocate using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> metodo per determinare la quantità di memoria non gestita da allocare utilizzando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</source>
          <target state="translated">Nell'esempio seguente viene creata una struttura gestita, trasferirla in memoria non gestita e quindi lo trasferisce alla memoria gestita.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method to determine how much unmanaged memory to allocate.</source>
          <target state="translated">Questo esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> metodo per determinare la quantità di memoria non gestita da allocare.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The type whose size is to be returned.</source>
          <target state="translated">Tipo di cui verrà restituita la dimensione.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>Returns the size of an unmanaged type in bytes.</source>
          <target state="translated">Restituisce la dimensione di un tipo non gestito espressa in byte.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The size of the specified type in unmanaged code.</source>
          <target state="translated">Dimensione del tipo specificato nel codice non gestito.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>You can use this method when you do not have a structure.</source>
          <target state="translated">È possibile utilizzare questo metodo quando non si dispone di una struttura.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">Il layout deve essere sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The size returned is the size of the unmanaged type.</source>
          <target state="translated">La dimensione restituita è la dimensione di tipo non gestito.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">Le dimensioni gestite e non di un oggetto può essere diverso.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">Per i tipi di carattere, la dimensione dipende dal <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> valore applicato a tale classe.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method.</source>
          <target state="translated">Nel codice riportato di seguito viene illustrata la chiamata al metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="t" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The type whose size is to be returned.</source>
          <target state="translated">Tipo di cui verrà restituita la dimensione.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>Returns the size of an unmanaged type in bytes.</source>
          <target state="translated">Restituisce la dimensione di un tipo non gestito espressa in byte.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The size, in bytes, of the type that is specified by the <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> generic type parameter.</source>
          <target state="translated">Dimensione, in byte, del tipo specificato dal parametro di tipo generico <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>You can use this method when you do not have a structure.</source>
          <target state="translated">È possibile utilizzare questo metodo quando non si dispone di una struttura.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">Il layout deve essere sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The size returned is the size of the unmanaged type.</source>
          <target state="translated">La dimensione restituita è la dimensione di tipo non gestito.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">Le dimensioni gestite e non di un oggetto può essere diverso.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">Per i tipi di carattere, la dimensione dipende dal <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> valore applicato a tale classe.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The type of the <bpt id="p1">&lt;c&gt;</bpt>structure<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Il tipo di <bpt id="p1">&lt;c&gt;</bpt>struttura<ept id="p1">&lt;/c&gt;</ept> parametro.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The object whose size is to be returned.</source>
          <target state="translated">Oggetto di cui verrà restituita la dimensione.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>Returns the unmanaged size of an object of a specified type in bytes.</source>
          <target state="translated">Restituisce la dimensione non gestita di un oggetto di un tipo specifico in byte.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The size, in bytes, of the specified object in unmanaged code.</source>
          <target state="translated">Dimensione, in byte, dell'oggetto specificato nel codice non gestito.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
          <target state="translated">Questo metodo accetta un'istanza di una struttura, che può essere un tipo riferimento o un tipo di valore boxed.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">Il layout deve essere sequenziale o esplicito.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The size returned is the size of the unmanaged object.</source>
          <target state="translated">La dimensione restituita è la dimensione dell'oggetto non gestito.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">Le dimensioni gestite e non di un oggetto può essere diverso.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">Per i tipi di carattere, la dimensione dipende dal <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> valore applicato a tale classe.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method to determine how much unmanaged memory to allocate by using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> metodo per determinare la quantità di memoria non gestita per allocare usando il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>The managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>Allocates a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into it.</source>
          <target state="translated">Alloca un elemento <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> e vi copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>An unmanaged pointer to the <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph>, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is null.</source>
          <target state="translated">Puntatore non gestito a <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> o 0 se <ph id="ph2">&lt;paramref name="s" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la <ph id="ph1">`BSTR`</ph> termine chiamando <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>The length for <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is out of range.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="s" /&gt;</ph>non è compresa nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Intero che rappresenta un puntatore al blocco di memoria allocato per la stringa oppure 0 se <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>The characters of the string are copied as ANSI characters.</source>
          <target state="translated">I caratteri della stringa vengono copiati come caratteri ANSI.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> supera la lunghezza massima consentita dal sistema operativo.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The allocated memory block, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Blocco di memoria allocato o 0 se <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A&gt;</ph> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</source>
          <target state="translated">I caratteri della stringa vengono copiati come caratteri ANSI o Unicode, a seconda del sistema operativo in cui è in esecuzione il codice.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>On Windows 98, the characters are copied as ANSI characters.</source>
          <target state="translated">In Windows 98, i caratteri vengono copiati come caratteri ANSI.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</source>
          <target state="translated">In Windows NT 4.0, Windows 2000, Windows XP e in Windows Server 2003, i caratteri vengono copiati come caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The length for <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is out of range.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="s" /&gt;</ph>non è compresa nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Intero che rappresenta un puntatore al blocco di memoria allocato per la stringa oppure 0 se s è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A&gt;</ph> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>The characters of the string are copied as Unicode characters.</source>
          <target state="translated">I caratteri della stringa vengono copiati come caratteri Unicode.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> supera la lunghezza massima consentita dal sistema operativo.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito nella memoria non gestita, effettuando contemporaneamente la conversione nel formato ANSI.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The address, in unmanaged memory, to where <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se <ph id="ph2">&lt;paramref name="s" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> fornisce la funzionalità opposta di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <ph id="ph1">&lt;xref:System.String&gt;</ph> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> supera la lunghezza massima consentita dal sistema operativo.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory, converting into ANSI format if required.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito nella memoria non gestita, effettuando, se necessario, la conversione nel formato ANSI.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>The address, in unmanaged memory, to where the string was copied, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stata copiata la stringa, oppure 0 se <ph id="ph1">&lt;paramref name="s" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A&gt;</ph> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <ph id="ph1">&lt;xref:System.String&gt;</ph> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">La memoria disponibile è insufficiente.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">Stringa gestita da copiare.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory.</source>
          <target state="translated">Copia il contenuto di un oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> gestito nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Indirizzo, nella memoria non gestita, in cui è stato copiato <ph id="ph1">&lt;paramref name="s" /&gt;</ph>, oppure 0 se <ph id="ph2">&lt;paramref name="s" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A&gt;</ph> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo fornisce la funzionalità opposta di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The method could not allocate enough native heap memory.</source>
          <target state="translated">Il metodo non è riuscito ad allocare memoria dell'heap nativo sufficiente.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="s" /&gt;</ph> supera la lunghezza massima consentita dal sistema operativo.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A managed object that holds the data to be marshaled.</source>
          <target state="translated">Oggetto gestito che contiene i dati di cui effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>This object must be a structure or an instance of a formatted class.</source>
          <target state="translated">L'oggetto deve essere una struttura o un'istanza di una classe formattata.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestito che deve essere allocato prima della chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to call the <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /&gt;</ph> method on the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before this method copies the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per chiamare il metodo <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /&gt;</ph> sul parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima che il metodo esegua la copia dei dati.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The block must contain valid data.</source>
          <target state="translated">Il blocco deve contenere dati validi.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Note that passing <ph id="ph1">&lt;see langword="false" /&gt;</ph> when the memory block already contains data can lead to a memory leak.</source>
          <target state="translated">Si noti che passare il valore <ph id="ph1">&lt;see langword="false" /&gt;</ph> quando il blocco di memoria contiene già dei dati può causare una perdita di memoria.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Marshals data from a managed object to an unmanaged block of memory.</source>
          <target state="translated">Effettua il marshalling di dati da un oggetto gestito a un blocco di memoria non gestito.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> is a value type, it can be boxed or unboxed.</source>
          <target state="translated">Se <ph id="ph1">`structure`</ph> è un tipo di valore, può essere sottoposto a boxing o alla conversione unboxing.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If it is boxed, it is unboxed before copying.</source>
          <target state="translated">Se viene sottoposto a boxing, è unboxed prima della copia.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Una classe formattata è un tipo di riferimento il cui layout viene specificato per il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attributo, come <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> Copia il contenuto di <ph id="ph2">`structure`</ph> preallocati blocco di memoria che di <ph id="ph3">`ptr`</ph> punta al parametro.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), the managed objects are kept alive with reference counts.</source>
          <target state="translated">Se <ph id="ph1">`structure`</ph> contiene i tipi di riferimento che il marshalling di puntatori a interfaccia COM (interfacce, classi senza layout, e <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), gli oggetti gestiti vengono mantenuti attivi con i conteggi dei riferimenti.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
          <target state="translated">Tutti gli altri tipi di riferimento (ad esempio, stringhe e matrici) vengono eseguito il marshalling per le copie.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType&gt;</ph> method before you free the memory block.</source>
          <target state="translated">Per rilasciare gli oggetti gestiti o non gestiti, è necessario chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType&gt;</ph> metodo prima liberare il blocco di memoria.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
          <target state="translated">Se si utilizza il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> metodo per copiare un'istanza diversa per il blocco di memoria in un secondo momento, specificare <ph id="ph2">`true`</ph> per <ph id="ph3">`fDeleteOld`</ph> per rimuovere un riferimento i conteggi per i tipi di riferimento nell'istanza precedente.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</source>
          <target state="translated">In caso contrario, le copie di riferimenti gestiti typesand non gestita in modo efficace vengono comunicate.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The overall pattern for using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> is as follows:</source>
          <target state="translated">Lo schema generale per l'utilizzo di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> è indicato di seguito:</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>On the first call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
          <target state="translated">La prima chiamata al <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> dopo che è stato allocato un blocco di memoria, <ph id="ph2">`fDeleteOld`</ph> deve essere <ph id="ph3">`false`</ph>, in quanto nessun contenuto da cancellare.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
          <target state="translated">Specificare <ph id="ph1">`true`</ph> per <ph id="ph2">`fDeleteOld`</ph> solo se il blocco contiene dati validi.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
          <target state="translated">Se si copia un'istanza diversa per il blocco di memoria e l'oggetto contiene i tipi di riferimento, <ph id="ph1">`fDeleteOld`</ph> deve essere <ph id="ph2">`true`</ph> per liberare i tipi di riferimento del contenuto precedente.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
          <target state="translated">Se l'oggetto contiene i tipi di riferimento, è necessario chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> metodo prima liberare il blocco di memoria.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> type to create a pinned handle for the structure.</source>
          <target state="translated">Per aggiungere una struttura esistente anziché copiarlo, usare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> tipo per creare un handle bloccato per la struttura.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate su come aggiungere, vedere <bpt id="p1">[</bpt>copia e blocco<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method, and then transfers it back to managed memory using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene creata una struttura gestita che viene trasferita all'utilizzo di memoria non gestita di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> (metodo) e quindi trasferita alla memoria gestita tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is a reference type that is not a formatted class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> è un tipo di riferimento che non corrisponde a una classe formattata.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> è un'istanza di un tipo generico (in .NET Framework 4.5 e versioni precedenti).</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The type of the managed object.</source>
          <target state="translated">Tipo dell'oggetto gestito.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A managed object that holds the data to be marshaled.</source>
          <target state="translated">Oggetto gestito che contiene i dati di cui effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The object must be a structure or an instance of a formatted class.</source>
          <target state="translated">L'oggetto deve essere una struttura o un'istanza di una classe formattata.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
          <target state="translated">Puntatore a un blocco di memoria non gestito che deve essere allocato prima della chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to call the <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /&gt;</ph> method on the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before this method copies the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per chiamare il metodo <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /&gt;</ph> sul parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima che il metodo esegua la copia dei dati.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The block must contain valid data.</source>
          <target state="translated">Il blocco deve contenere dati validi.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Note that passing <ph id="ph1">&lt;see langword="false" /&gt;</ph> when the memory block already contains data can lead to a memory leak.</source>
          <target state="translated">Si noti che passare il valore <ph id="ph1">&lt;see langword="false" /&gt;</ph> quando il blocco di memoria contiene già dei dati può causare una perdita di memoria.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Marshals data from a managed object of a specified type to an unmanaged block of memory.</source>
          <target state="translated">Effettua il marshalling di dati da un oggetto gestito di un tipo specificato a un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Una classe formattata è un tipo di riferimento il cui layout viene specificato per il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attributo, come <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> Copia il contenuto di <ph id="ph2">`structure`</ph> preallocati blocco di memoria che di <ph id="ph3">`ptr`</ph> punta al parametro.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), the managed objects are kept alive with reference counts.</source>
          <target state="translated">Se <ph id="ph1">`structure`</ph> contiene i tipi di riferimento che il marshalling di puntatori a interfaccia COM (interfacce, classi senza layout, e <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), gli oggetti gestiti vengono mantenuti attivi con i conteggi dei riferimenti.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
          <target state="translated">Tutti gli altri tipi di riferimento (ad esempio, stringhe e matrici) vengono eseguito il marshalling per le copie.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29&gt;</ph> method before you free the memory block.</source>
          <target state="translated">Per rilasciare gli oggetti gestiti o non gestiti, è necessario chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29&gt;</ph> metodo prima liberare il blocco di memoria.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
          <target state="translated">Se si utilizza il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> metodo per copiare un'istanza diversa per il blocco di memoria in un secondo momento, specificare <ph id="ph2">`true`</ph> per <ph id="ph3">`fDeleteOld`</ph> per rimuovere un riferimento i conteggi per i tipi di riferimento nell'istanza precedente.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Otherwise, the managed reference types and unmanaged copies are effectively leaked.</source>
          <target state="translated">In caso contrario, i tipi di riferimenti gestiti e una copia non gestita in modo efficace viene comunicati.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The overall pattern for using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> is as follows:</source>
          <target state="translated">Lo schema generale per l'utilizzo di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> è indicato di seguito:</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>On the first call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
          <target state="translated">La prima chiamata al <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> dopo che è stato allocato un blocco di memoria, <ph id="ph2">`fDeleteOld`</ph> deve essere <ph id="ph3">`false`</ph>, in quanto nessun contenuto da cancellare.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
          <target state="translated">Specificare <ph id="ph1">`true`</ph> per <ph id="ph2">`fDeleteOld`</ph> solo se il blocco contiene dati validi.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
          <target state="translated">Se si copia un'istanza diversa per il blocco di memoria e l'oggetto contiene i tipi di riferimento, <ph id="ph1">`fDeleteOld`</ph> deve essere <ph id="ph2">`true`</ph> per liberare i tipi di riferimento del contenuto precedente.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
          <target state="translated">Se l'oggetto contiene i tipi di riferimento, è necessario chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> metodo prima liberare il blocco di memoria.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> type to create a pinned handle for the structure.</source>
          <target state="translated">Per aggiungere una struttura esistente anziché copiarlo, usare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> tipo per creare un handle bloccato per la struttura.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate su come aggiungere, vedere <bpt id="p1">[</bpt>copia e blocco<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is a reference type that is not a formatted class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> è un tipo di riferimento che non corrisponde a una classe formattata.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</source>
          <target state="translated">Rappresenta la dimensione predefinita del carattere nel sistema. Il valore predefinito è 2 per i sistemi Unicode e 1 per i sistemi ANSI.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>This field is read-only.</source>
          <target state="translated">Questo campo è di sola lettura.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> field.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> campo.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</source>
          <target state="translated">Rappresenta la dimensione massima di un set di caratteri a doppio byte (DBCS, double-byte character set), in byte, per il sistema operativo corrente.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>This field is read-only.</source>
          <target state="translated">Questo campo è di sola lettura.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> field.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> campo.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Throws an exception with a specific failure HRESULT value.</source>
          <target state="translated">Genera un'eccezione con un valore HRESULT di un errore specifico.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>The HRESULT corresponding to the desired exception.</source>
          <target state="translated">Valore HRESULT corrispondente all'eccezione desiderata.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Throws an exception with a specific failure HRESULT value.</source>
          <target state="translated">Genera un'eccezione con un valore HRESULT di un errore specifico.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
          <target state="translated">Questo metodo crea un oggetto di eccezione per il valore HRESULT specificato.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
          <target state="translated">Se il valore HRESULT è 0 o positivo (codice di esito positivo), il metodo restituisce senza creare o generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
          <target state="translated">Si noti che il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29&gt;</ph> metodo restituisce un'eccezione in base il <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interfaccia del thread corrente, se impostata.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
          <target state="translated">In questo caso, il <ph id="ph1">`errorCode`</ph> parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
          <target state="translated">Alcuni HRESULT di errore il mapping a eccezioni definite, mentre altri no.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
          <target state="translated">Se il valore HRESULT mappato a un'eccezione definita, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> crea un'istanza dell'eccezione e genera.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
          <target state="translated">In caso contrario, crea un'istanza di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>, inizializza il campo di codice di errore con il valore HRESULT e genera l'eccezione.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged <bpt id="p1">[</bpt>GetErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)</ept> function.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> viene richiamato, tenta di recuperare informazioni aggiuntive relative all'errore tramite non gestito <bpt id="p1">[</bpt>GetErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)</ept> (funzione).</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere <bpt id="p1">[</bpt>come: mappa di HRESULT ed eccezioni<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Occasionally, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> might return an exception from a previous COM call.</source>
          <target state="translated">In alcuni casi, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> potrebbe restituire un'eccezione da una precedente chiamata COM.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>In this case, you can use the following workaround and pass <ph id="ph1">`IntPtr(-1)`</ph> as the second parameter (<ph id="ph2">`errorInfo`</ph>):</source>
          <target state="translated">In questo caso, è possibile utilizzare la soluzione seguente e passare <ph id="ph1">`IntPtr(-1)`</ph> come secondo parametro (<ph id="ph2">`errorInfo`</ph>):</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The HRESULT corresponding to the desired exception.</source>
          <target state="translated">Valore HRESULT corrispondente all'eccezione desiderata.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>A pointer to the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface that provides more information about the error.</source>
          <target state="translated">Puntatore all'interfaccia <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> che fornisce informazioni aggiuntive sull'errore.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>You can specify <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> to use the current <bpt id="p2">[</bpt>IErrorInfo<ept id="p2">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface, or <bpt id="p3">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p3">&lt;/c&gt;</ept> to ignore the current <bpt id="p4">[</bpt>IErrorInfo<ept id="p4">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface and construct the exception just from the error code.</source>
          <target state="translated">È possibile specificare <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> per usare l'interfaccia <bpt id="p2">[</bpt>IErrorInfo<ept id="p2">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> corrente oppure <bpt id="p3">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p3">&lt;/c&gt;</ept> per ignorare l'interfaccia <bpt id="p4">[</bpt>IErrorInfo<ept id="p4">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> corrente e costruire l'eccezione unicamente dal codice di errore.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Throws an exception with a specific failure HRESULT, based on the specified <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
          <target state="translated">Genera un'eccezione con un valore HRESULT di errore specifico, basato sull'interfaccia <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> specificata.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
          <target state="translated">Questo metodo crea un oggetto di eccezione per il valore HRESULT specificato.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
          <target state="translated">Se il valore HRESULT è 0 o positivo (codice di esito positivo), il metodo restituisce senza creare o generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method releases the <ph id="ph2">`errorInfo`</ph> parameter, decreasing the COM reference count of the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> metodo rilascia il <ph id="ph2">`errorInfo`</ph> conteggio di parametro, diminuendo il COM dei riferimenti di <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interfaccia.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
          <target state="translated">Si noti che il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> metodo restituisce un'eccezione in base il <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interfaccia del thread corrente, se impostata.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
          <target state="translated">In questo caso, il <ph id="ph1">`errorCode`</ph> parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
          <target state="translated">Alcuni HRESULT di errore il mapping a eccezioni definite, mentre altri no.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
          <target state="translated">Se il valore HRESULT mappato a un'eccezione definita, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> crea un'istanza dell'eccezione e genera.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
          <target state="translated">In caso contrario, crea un'istanza di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType&gt;</ph>, inizializza il campo di codice di errore con il valore HRESULT e genera l'eccezione.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter is used to retrieve extra information regarding the error.</source>
          <target state="translated">Il <ph id="ph1">`errorInfo`</ph> parametro viene utilizzato per recuperare informazioni aggiuntive relative all'errore.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere <bpt id="p1">[</bpt>come: mappa di HRESULT ed eccezioni<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The array that contains the desired element.</source>
          <target state="translated">Matrice che contiene l'elemento desiderato.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The index in the <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> parameter of the desired element.</source>
          <target state="translated">Indice nel parametro <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> dell'elemento desiderato.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>Gets the address of the element at the specified index inside the specified array.</source>
          <target state="translated">Ottiene l'indirizzo dell'elemento in corrispondenza dell'indice specificato all'interno della matrice specificata.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> inside <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</source>
          <target state="translated">Indirizzo di <ph id="ph1">&lt;paramref name="index" /&gt;</ph> all'interno di <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The array must be pinned using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
          <target state="translated">La matrice deve essere bloccata utilizzando un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> prima di essere passato a questo metodo.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
          <target state="translated">Per ottenere prestazioni ottimali, questo metodo non convalida la matrice passata. Questo può causare comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The type of the array.</source>
          <target state="translated">Tipo della matrice</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The array that contains the desired element.</source>
          <target state="translated">Matrice che contiene l'elemento desiderato.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The index of the desired element in the <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Indice dell'elemento desiderato nella matrice <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[Supportato in .NET Framework 4.5.1 e versioni successive]</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>Gets the address of the element at the specified index in an array of a specified type.</source>
          <target state="translated">Ottiene l'indirizzo dell'elemento in corrispondenza dell'indice specificato in una matrice del tipo specificato.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> in <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</source>
          <target state="translated">Indirizzo di <ph id="ph1">&lt;paramref name="index" /&gt;</ph> all'interno di <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The array must be pinned by using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
          <target state="translated">La matrice deve essere bloccata utilizzando un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> prima di essere passato a questo metodo.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
          <target state="translated">Per ottenere prestazioni ottimali, questo metodo non convalida la matrice passata. Questo può causare comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a single byte value to unmanaged memory.</source>
          <target state="translated">Scrive un valore a singolo byte nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>Writes a single byte value to unmanaged memory.</source>
          <target state="translated">Scrive un valore a singolo byte nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</source>
          <target state="translated">Nell'esempio seguente viene creato un blocco di memoria non gestita, scrive un byte nella memoria non gestita, legge i byte da memoria non gestita e quindi elimina la memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita su cui scrivere.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un valore a singolo byte nella memoria non gestita a un offset specifico.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un valore a singolo byte nella memoria non gestita a un offset specifico.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 16-bit signed integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero con segno a 16 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>Writes a character as a 16-bit integer value to unmanaged memory.</source>
          <target state="translated">Scrive un carattere sotto forma di intero a 16 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>Writes a 16-bit integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero a 16 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The base address in the native heap to write to.</source>
          <target state="translated">L'indirizzo di base nell'heap nativo su cui scrivere.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita su cui scrivere.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 32-bit signed integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero con segno a 32 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>Writes a 32-bit signed integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero con segno a 32 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita su cui scrivere.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un Intero con segno a 32 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un Intero con segno a 32 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 64-bit signed integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero con segno a 64 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero con segno a 64 bit nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The base address in unmanaged memory to write.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita da scrivere.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un Intero con segno a 64 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un Intero con segno a 64 bit nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a processor native-sized integer value to unmanaged memory.</source>
          <target state="translated">Scrive un intero di dimensioni native del processore nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</source>
          <target state="translated">Gli interi a 32 bit vengono scritti in sistemi a 32 bit e gli interi a 64 bit vengono scritti in sistemi a 64 bit.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo nella memoria non gestita sul quale scrivere.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>Writes a processor native sized integer value into unmanaged memory.</source>
          <target state="translated">Scrive un valore intero della dimensione nativa del processore nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> Consente l'interazione diretta con un tipo non gestito C <ph id="ph2">`IntPtr`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è un formato riconosciuto.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">Indirizzo di base nella memoria non gestita su cui scrivere.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Writes a processor native-sized integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">Scrive un intero di dimensioni native del processore nella memoria non gestita in corrispondenza di un offset specificato.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</source>
          <target state="translated">Questo metodo scrive un intero a 32 bit su sistemi a 32 bit e un valore integer a 64 bit su sistemi a 64 bit.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> Consente l'interazione diretta con un tipo non gestito C <ph id="ph2">`IntPtr`</ph> matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">Offset di byte supplementare, aggiunto al parametro <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> prima della scrittura.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">Valore da scrivere.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Writes a processor native sized integer value to unmanaged memory.</source>
          <target state="translated">Scrive un valore intero della dimensione nativa del processore nella memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) in una matrice gestita separata prima di impostare i valori degli elementi.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">La scrittura in posizioni di memoria non allineate è supportata.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">L'indirizzo di base (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) più il byte di offset (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produce un indirizzo Null o non valido.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> è un oggetto <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">Questo metodo non accetta parametri <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>The address of the <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> to free.</source>
          <target state="translated">Indirizzo dell'elemento <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> da liberare.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>Frees a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">Libera un puntatore <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> allocato usando il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method first sets the contents of the BSTR to zero, and then frees the BSTR.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> metodo imposta prima di tutto il contenuto di BSTR su zero e quindi libera BSTR.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">Indirizzo della stringa non gestita da liberare.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">Libera un puntatore a una stringa non gestita allocato tramite il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> metodo per effettuare il marshalling e decrittografare il contenuto di un <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> oggetto in un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> metodo per azzerare ed eliminare il blocco non gestito.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">Indirizzo della stringa non gestita da liberare.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">Libera un puntatore a una stringa non gestita allocato tramite il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">Indirizzo della stringa non gestita da liberare.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">Libera un puntatore a una stringa non gestita allocato tramite il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> metodo per effettuare il marshalling e decrittografare il contenuto di un <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> oggetto in un blocco di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">Viene quindi utilizzato il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> metodo per azzerare ed eliminare il blocco non gestito.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">Indirizzo della stringa non gestita da liberare.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">Libera un puntatore a una stringa non gestita allocato tramite il metodo <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method with the unmanaged <ph id="ph2">`LogonUser`</ph> function to perform impersonation with the <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> class.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> metodo con tipo non gestito <ph id="ph2">`LogonUser`</ph> funzione per eseguire la rappresentazione con la <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method to zero out and free the unmanaged string reference.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> per azzerare e liberare il riferimento alla stringa non gestita.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>