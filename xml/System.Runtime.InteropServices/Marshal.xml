<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="95bcb-101">Fornisce una raccolta di metodi per l'allocazione della memoria non gestita, la copia di blocchi di memoria non gestita e la conversione di tipi gestiti in tipi non gestiti, oltre ad altri metodi usati durante l'interazione con codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-101">Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-102">Il `static` metodi definiti nella <xref:System.Runtime.InteropServices.Marshal> classe sono essenziali per l'utilizzo con codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-102">The `static` methods defined on the <xref:System.Runtime.InteropServices.Marshal> class are essential to working with unmanaged code.</span></span> <span data-ttu-id="95bcb-103">La maggior parte dei metodi definiti in questa classe vengono in genere utilizzati dagli sviluppatori che desiderano offrire un ponte tra il gestito e modelli di programmazione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-103">Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</span></span> <span data-ttu-id="95bcb-104">Ad esempio, il <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> metodo copia i caratteri ANSI da una stringa specificata (nell'heap gestito) in un buffer nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-104">For example, the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</span></span> <span data-ttu-id="95bcb-105">Inoltre, alloca heap di destinazione della dimensione giusta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-105">It also allocates the target heap of the right size.</span></span>  
  
 <span data-ttu-id="95bcb-106">Common language runtime fornisce le funzionalità specifiche di marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-106">The common language runtime provides specific marshaling capabilities.</span></span> <span data-ttu-id="95bcb-107">Per informazioni dettagliate sul comportamento di marshalling, vedere [marshalling di interoperabilità](~/docs/framework/interop/interop-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-107">For details on marshaling behavior, see [Interop Marshaling](~/docs/framework/interop/interop-marshaling.md).</span></span>  
  
 <span data-ttu-id="95bcb-108">Il `Read` e `Write` metodi di <xref:System.Runtime.InteropServices.Marshal> classe supporta l'accesso allineato e non allineato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-108">The `Read` and `Write` methods in the <xref:System.Runtime.InteropServices.Marshal> class support both aligned and unaligned access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-109">Nell'esempio seguente viene illustrato come utilizzare diversi metodi definiti per il <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-109">The following example shows how to use various methods defined by the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="95bcb-110">Numero di riferimenti nell'interfaccia da incrementare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-110">The interface reference count to increment.</span></span></param>
        <summary><span data-ttu-id="95bcb-111">Incrementa il numero di riferimenti nell'interfaccia specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-111">Increments the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="95bcb-112">Nuovo valore del conteggio dei riferimenti sul parametro <paramref name="pUnk" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-112">The new value of the reference count on the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-113">Common language runtime gestisce il conteggio dei riferimenti di un oggetto COM per l'utente, rendendo non è necessario utilizzare questo metodo direttamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-113">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="95bcb-114">In rari casi, ad esempio test di un gestore di marshalling personalizzato, potrebbe essere necessario modificare manualmente la durata dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-114">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="95bcb-115">Dopo la chiamata <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, è necessario diminuire il conteggio dei riferimenti utilizzando un metodo, ad esempio <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-115">After calling <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, you must decrement the reference count by using a method such as <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-116">Non fare affidamento sul valore restituito di <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, come può talvolta essere instabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-116">Do not rely on the return value of <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, as it can sometimes be unstable.</span></span>  
  
 <span data-ttu-id="95bcb-117">È possibile chiamare <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, o <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> per ottenere un <xref:System.IntPtr> valore che rappresenta un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-117">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer.</span></span> <span data-ttu-id="95bcb-118">È inoltre possibile utilizzare questi metodi e <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> metodo su oggetti gestiti per ottenere le interfacce COM rappresentate da COM callable wrapper dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-118">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</span></span> <span data-ttu-id="95bcb-119">Se non si ha familiarità con i dettagli di questo tipo di wrapper, vedere [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-119">If you are not familiar with the details of this wrapper type, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-120">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-120">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-121">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-121">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="95bcb-122">Dimensioni del blocco di memoria da allocare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-122">The size of the block of memory to be allocated.</span></span></param>
        <summary><span data-ttu-id="95bcb-123">Alloca un blocco di memoria delle dimensioni specificate dall'allocatore di memoria delle attività COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-123">Allocates a block of memory of specified size from the COM task memory allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-124">Intero che rappresenta l'indirizzo del blocco di memoria allocato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-124">An integer representing the address of the block of memory allocated.</span></span> <span data-ttu-id="95bcb-125">Questa memoria deve essere liberata con <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-125">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> è uno di allocazione della memoria due metodi API di <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> is one of two memory allocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="95bcb-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> è l'altro.) Il contenuto di memoria iniziale restituito non è definito e la memoria allocata può essere maggiore del numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</span></span> <span data-ttu-id="95bcb-128">Questo metodo espone il COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) funzione, viene considerato l'allocatore di memoria delle attività COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-128">This method exposes the COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-129">Memoria insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-129">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-130">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-130">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-131">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-131">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-132">Alloca memoria dalla memoria non gestita del processo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-132">Allocates memory from the unmanaged memory of the process.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="95bcb-133">Numero di byte necessari nella memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-133">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="95bcb-134">Alloca memoria dalla memoria non gestita del processo tramite il numero specificato di byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-134">Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-135">Puntatore alla memoria appena allocata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-135">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="95bcb-136">Questa memoria deve essere liberata usando il metodo <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-136">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> è uno dei due metodi di allocazione di memoria nel <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="95bcb-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> è l'altro.) Questo metodo espone Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) funzione da Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="95bcb-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="95bcb-139">Quando <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> chiamate `LocalAlloc`, passa un `LMEM_FIXED` flag che determina la memoria allocata da bloccare sul posto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-139">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="95bcb-140">Inoltre, la memoria allocata non è riempiti con zero.</span><span class="sxs-lookup"><span data-stu-id="95bcb-140">Also, the allocated memory is not zero-filled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-141">Nel codice riportato di seguito viene illustrata la chiamata al metodo <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-141">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> method.</span></span> <span data-ttu-id="95bcb-142">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-142">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-143">Memoria insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-143">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-144">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-144">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-145">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-145">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="95bcb-146">Numero di byte necessari nella memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-146">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="95bcb-147">Alloca memoria dalla memoria non gestita del processo tramite il puntatore al numero specificato di byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-147">Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-148">Puntatore alla memoria appena allocata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-148">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="95bcb-149">Questa memoria deve essere liberata usando il metodo <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-149">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> è uno dei due metodi di allocazione di memoria nel <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="95bcb-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> è l'altro.) Questo metodo espone Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) funzione da Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="95bcb-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="95bcb-152">Quando <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> chiamate `LocalAlloc`, passa un `LMEM_FIXED` flag che determina la memoria allocata da bloccare sul posto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-152">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="95bcb-153">Inoltre, la memoria allocata non è riempiti con zero.</span><span class="sxs-lookup"><span data-stu-id="95bcb-153">Also, the allocated memory is not zero-filled.</span></span>  
  
 <span data-ttu-id="95bcb-154">Per vedere un codice di esempio, vedere <xref:System.Runtime.InteropServices.Marshal> e <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-154">For example code, see <xref:System.Runtime.InteropServices.Marshal> and <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-155">Memoria insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-155">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-156">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-156">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-157">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-157">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-158">Indica se Runtime Callable Wrapper (RCW) provenienti da qualsiasi contesto sono disponibili per la pulizia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-158">Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</span></span></summary>
        <returns>
          <span data-ttu-id="95bcb-159"><see langword="true" /> se sono disponibili RCW per la pulizia. In caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-159"><see langword="true" /> if there are any RCWs available for cleanup; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-160">Se sono presenti molti riferimenti tra codice gestito e nativo con grafici delle dipendenze completa che può richiedere molto tempo per tutti gli oggetti per la pulitura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-160">If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</span></span> <span data-ttu-id="95bcb-161">Ogni volta che viene eseguito un catalogo globale consente di liberare un certo numero di RCW che a sua volta causerà il rilascio di oggetti COM sottostanti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-161">Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</span></span> <span data-ttu-id="95bcb-162">Gli oggetti COM verranno quindi i riferimenti gestiti e rendere più oggetti disponibili per la pulizia alla successiva esecuzione di un catalogo globale, che avvia il processo di nuovo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-162">Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</span></span>  
  
 <span data-ttu-id="95bcb-163">Il <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> metodo fornisce un modo per l'applicazione determinare il numero di cicli di Garbage Collection. Raccolta e catalogo globale. WaitForPendingFinalizers devono verificarsi per tutte le operazioni di pulizia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-163">The <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-164">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-164">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-165">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-165">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName"><span data-ttu-id="95bcb-166">Moniker corrispondente al puntatore a interfaccia desiderato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-166">The moniker corresponding to the desired interface pointer.</span></span></param>
        <summary><span data-ttu-id="95bcb-167">Ottiene un puntatore a interfaccia identificato dal moniker specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-167">Gets an interface pointer identified by the specified moniker.</span></span></summary>
        <returns><span data-ttu-id="95bcb-168">Oggetto contenente un riferimento al puntatore a interfaccia identificato dal parametro <paramref name="monikerName" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-168">An object containing a reference to the interface pointer identified by the <paramref name="monikerName" /> parameter.</span></span> <span data-ttu-id="95bcb-169">Un moniker è rappresentato da un nome; in questo caso il moniker è definito da un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-169">A moniker is a name, and in this case, the moniker is defined by an interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> espone il COM `BindToMoniker` (metodo), che genera un oggetto che è possibile eseguire il cast a qualsiasi interfaccia COM necessaria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> exposes the COM `BindToMoniker` method, which produces an object that you can cast to any COM interface you require.</span></span> <span data-ttu-id="95bcb-171">Questo metodo fornisce la stessa funzionalità come il `GetObject` metodo in Visual Basic 6.0 e [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-171">This method provides the same functionality as the `GetObject` method in Visual Basic 6.0 and [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="95bcb-172">Un HRESULT non riconosciuto è stato restituito dal metodo <see langword="BindToMoniker" /> non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-172">An unrecognized HRESULT was returned by the unmanaged <see langword="BindToMoniker" /> method.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-173">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-173">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-174">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-174">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp"><span data-ttu-id="95bcb-175">Oggetto il cui CCW contiene un handle con conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-175">The object whose CCW holds a reference counted handle.</span></span> <span data-ttu-id="95bcb-176">L'handle è forte se il conteggio dei riferimenti su CCW è maggiore di zero; in caso contrario, è debole.</span><span class="sxs-lookup"><span data-stu-id="95bcb-176">The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</span></span></param>
        <param name="fIsWeak">
          <span data-ttu-id="95bcb-177"><see langword="true" /> per impostare come debole l'handle sul parametro <c>otp</c>, indipendentemente dal conteggio dei riferimenti, <see langword="false" /> per reimpostare la forza dell'handle su <c>otp</c> per ottenere il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-177"><see langword="true" /> to change the strength of the handle on the <c>otp</c> parameter to weak, regardless of its reference count; <see langword="false" /> to reset the handle strength on <c>otp</c> to be reference counted.</span></span></param>
        <summary><span data-ttu-id="95bcb-178">Modifica la forza dell'handle [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) (CCW) di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-178">Changes the strength of an object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) (CCW) handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> viene utilizzato per la funzionalità del pool di oggetti e non deve essere chiamato direttamente dal codice utente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> is used for object pooling functionality and should never be called by user code directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-180">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-180">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-181">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-181">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-182">Notifica al runtime di eseguire la pulizia di tutti i [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) allocati nel contesto corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-182">Notifies the runtime to clean up all [Runtime Callable Wrappers](~/docs/framework/interop/runtime-callable-wrapper.md) (RCWs) allocated in the current context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-183">Il sistema di interoperabilità immette i messaggi durante il tentativo di pulizia di RCW.</span><span class="sxs-lookup"><span data-stu-id="95bcb-183">The interop system pumps messages while it attempts to clean up RCWs.</span></span> <span data-ttu-id="95bcb-184">Ciò garantisce che la pulizia per tutte le applicazioni, incluse le applicazioni che non distribuiscono abbastanza spesso accade RCW apartment a thread singolo (STA).</span><span class="sxs-lookup"><span data-stu-id="95bcb-184">This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</span></span> <span data-ttu-id="95bcb-185">Tuttavia, alcune applicazioni che distribuiscono in modo appropriato sono molto sensibili per cui si verifica la distribuzione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-185">However, some applications that do pump appropriately are very sensitive to where pumping occurs.</span></span> <span data-ttu-id="95bcb-186">Quando il sistema di interoperabilità immette i messaggi in posizioni che sono impreviste, queste applicazioni, l'applicazione può verificarsi problemi di reentrancy difficili da diagnosticare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-186">When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</span></span> <span data-ttu-id="95bcb-187">Pertanto, le applicazioni debbano essere in grado di controllare la propria distribuzione per un particolare STA e per controllare la pulizia di RCW.</span><span class="sxs-lookup"><span data-stu-id="95bcb-187">Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</span></span>  
  
 <span data-ttu-id="95bcb-188">Tuttavia, gli sviluppatori controllano spesso solo un sottoinsieme dei thread nella propria applicazione e pertanto non è possibile assicurarsi che tutti i thread stiano eseguendo in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-188">However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</span></span>  
  
 <span data-ttu-id="95bcb-189">Per risolvere il problema:</span><span class="sxs-lookup"><span data-stu-id="95bcb-189">To solve this problem:</span></span>  
  
1.  <span data-ttu-id="95bcb-190">Utilizzare il <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> metodo per disattivare la pulizia automatica di RCW e la distribuzione di messaggi che si verifica, in base al thread.</span><span class="sxs-lookup"><span data-stu-id="95bcb-190">Use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</span></span> <span data-ttu-id="95bcb-191">Questo consente agli sviluppatori escludere la pulizia automatica e la corrispondente distribuzione di messaggi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-191">This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</span></span>  
  
2.  <span data-ttu-id="95bcb-192">Utilizzare il <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> metodo per notificare al runtime di pulizia di RCW tutti allocati nel contesto corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-192">Use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> method to notify the runtime to clean up all RCWs that are allocated in the current context.</span></span> <span data-ttu-id="95bcb-193">Questo metodo complementare consente agli sviluppatori di controllare con precisione quando il runtime esegue operazioni di pulitura nel contesto corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-193">This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-194">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-194">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-195">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-195">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-196">Copia i dati da una matrice gestita a un puntatore di memoria non gestita o viceversa.</span><span class="sxs-lookup"><span data-stu-id="95bcb-196">Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-197">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-197">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-198">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-198">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-199">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-199">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-200">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-200">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-201">Copia i dati da una matrice di interi senza segno a 8 bit gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-201">Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-202">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-202">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-203">Nell'esempio seguente copia una matrice di memoria non gestita usando il <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> overload e quindi la matrice non gestita viene copiata nella memoria gestita tramite il <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.</span><span class="sxs-lookup"><span data-stu-id="95bcb-203">The following example copies an array to unmanaged memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> overload, and then copies the unmanaged array back to managed memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-204"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-204"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-205"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-205"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-206">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-206">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-207">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-208">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-208">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-209">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-209">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-210">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-210">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-211">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-211">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-212">Copia i dati da una matrice di caratteri gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-212">Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-213">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-213">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-214">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-214">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-215"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-215"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-216"><paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-216"><paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-217">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-217">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-218">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-218">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-219">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-219">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-220">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-220">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-221">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-221">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-222">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-222">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-223">Copia i dati da una matrice di numeri a virgola mobile a precisione doppia gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-223">Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-224">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-224">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-225">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-225">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-226"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-226"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-227"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-227"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-228">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-229">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-230">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-230">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-231">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-231">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-232">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-232">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-233">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-233">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-234">Copia i dati da una matrice di interi con segno a 16 bit gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-234">Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-235">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-235">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-236">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-236">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-237"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-237"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-238"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-238"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-239">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-240">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-241">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-241">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-242">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-242">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-243">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-243">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-244">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-244">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-245">Copia i dati da una matrice di interi con segno a 32 bit gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-245">Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-246">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-246">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-247">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-247">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-248"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-248"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-249"><paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-249"><paramref name="startIndex" /> or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-250">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-250">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-251">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-251">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-252">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-252">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-253">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-253">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-254">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-254">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-255">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-255">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-256">Copia i dati da una matrice di interi con segno a 64 bit gestita e unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-256">Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-257">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-257">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-258">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-258">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-259"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-259"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-260"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-260"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-261">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-261">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-262">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-262">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-263">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-263">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-264">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-264">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-265">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-265">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-266">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-266">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-267">Copia i dati da un puntatore di memoria non gestita a una matrice di interi senza segno a 8 bit gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-267">Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-268">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-268">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-269">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-269">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-270">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-270">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-271">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-271">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-272"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-272"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-273">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-273">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-274">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-274">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-275">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-275">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-276">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-276">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-277">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-277">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-278">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-278">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-279">Copia i dati da un puntatore di memoria non gestita a una matrice di caratteri gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-279">Copies data from an unmanaged memory pointer to a managed character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-280">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-280">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-281">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-281">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-282">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-282">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-283">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-283">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-284"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-284"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-285">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-285">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-286">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-286">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-287">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-287">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-288">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-288">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-289">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-289">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-290">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-290">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-291">Copia i dati da un puntatore di memoria non gestita a una matrice di numeri a virgola mobile a precisione doppia gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-291">Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-292">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-292">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-293">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-293">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-294">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-294">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-295">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-295">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-296"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-296"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-297">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-297">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-298">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-298">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-299">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-299">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-300">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-300">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-301">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-301">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-302">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-302">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-303">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 16 bit gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-303">Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-304">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-304">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-305">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-305">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-306">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-306">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-307">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-307">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-308"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-308"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-309">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-309">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-310">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-310">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-311">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-311">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-312">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-312">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-313">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-313">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-314">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-314">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-315">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 32 bit gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-315">Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-316">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-316">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-317">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-317">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-318">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-318">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-319">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-319">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-320"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-320"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-321">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-321">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-322">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-322">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-323">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-323">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-324">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-324">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-325">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-325">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-326">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-326">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-327">Copia i dati da un puntatore di memoria non gestita a una matrice di interi con segno a 64 bit gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-327">Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-328">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-328">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-329">Di conseguenza, i dati non gestiti corrispondenti di`source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-329">Thus, the unmanaged data corresponding to the`source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-330">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-330">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-331">Nell'esempio seguente viene copiata una matrice nella memoria non gestita, quindi la matrice non gestita viene copiata nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-331">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-332"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-332"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-333">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-333">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-334">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-334">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-335">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-335">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-336">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-336">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-337">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-337">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-338">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-338">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-339">Copia i dati da un puntatore di memoria non gestita a una matrice <see cref="T:System.IntPtr" /> gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-339">Copies data from an unmanaged memory pointer to a managed <see cref="T:System.IntPtr" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-340">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-340">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-341">Di conseguenza, i dati non gestiti che corrisponde alla `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-341">Therefore, the unmanaged data that corresponds to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-342">È necessario inizializzare la matrice gestita in modo appropriato prima di chiamare il <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-342">You must initialize the managed array with the appropriate size before calling the <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-343"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-343"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-344">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-344">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-345">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-345">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-346">Puntatore di memoria da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-346">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-347">Matrice in cui effettuare la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-347">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-348">Indice in base zero nella matrice di destinazione in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-348">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-349">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-349">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-350">Copia i dati da un puntatore di memoria non gestita a una matrice di numeri a virgola mobile a precisione singola gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-350">Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-351">Matrici di tipo C non gestite non contengono informazioni sui limiti che impediscono il `startIndex` e `length` parametri di essere convalidati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-351">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="95bcb-352">Di conseguenza, i dati non gestiti corrispondenti di `source` parametro popola la matrice gestita indipendentemente dalla sua utilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-352">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="95bcb-353">Prima di chiamare questo metodo, è necessario inizializzare la matrice gestita con le dimensioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-353">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-354"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-354"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-355">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-355">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-356">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-356">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-357">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-357">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-358">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-358">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-359">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-359">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-360">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-360">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-361">Copia i dati da una matrice <see cref="T:System.IntPtr" /> unidimensionale gestita a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-361">Copies data from a one-dimensional, managed <see cref="T:System.IntPtr" /> array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-362">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita <xref:System.IntPtr> matrice da una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-362">You can use this method to copy a subset of a one-dimensional managed <xref:System.IntPtr> array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-363"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-363"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-364">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-364">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-365">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-365">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="95bcb-366">Matrice unidimensionale da cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-366">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="95bcb-367">Indice in base zero nella matrice di origine in corrispondenza del quale inizia la copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-367">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="95bcb-368">Puntatore di memoria in cui copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-368">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="95bcb-369">Numero degli elementi di matrice da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-369">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-370">Copia i dati da una matrice di numeri a virgola mobile a precisione singola gestita unidimensionale a un puntatore di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-370">Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-371">È possibile utilizzare questo metodo per copiare un sottoinsieme di una matrice unidimensionale gestita a una matrice di tipo C non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-371">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-372"><paramref name="startIndex" /> e <paramref name="length" /> non sono validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-372"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-373"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> o <paramref name="length" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-373"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-374">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-374">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-375">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-375">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter"><span data-ttu-id="95bcb-376">Puntatore <see langword="IUnknown" /> esterno.</span><span class="sxs-lookup"><span data-stu-id="95bcb-376">The outer <see langword="IUnknown" /> pointer.</span></span></param>
        <param name="o"><span data-ttu-id="95bcb-377">Oggetto da aggregare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-377">An object to aggregate.</span></span></param>
        <summary><span data-ttu-id="95bcb-378">Aggrega un oggetto gestito all'oggetto COM specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-378">Aggregates a managed object with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-379">Puntatore <see langword="IUnknown" /> interno dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-379">The inner <see langword="IUnknown" /> pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-380">Il <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> metodo aggrega il puntatore gestito interno di un oggetto gestito con il puntatore esterno specificato e restituisce un inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-380">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-381"><paramref name="o" /> è un oggetto [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-381"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-382">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-382">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-383">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-383">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-384">Tipo dell'oggetto gestito da aggregare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-384">The type of the managed object to aggregate.</span></span></typeparam>
        <param name="pOuter"><span data-ttu-id="95bcb-385">Puntatore [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) esterno.</span><span class="sxs-lookup"><span data-stu-id="95bcb-385">The outer [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer.</span></span></param>
        <param name="o"><span data-ttu-id="95bcb-386">Oggetto gestito da aggregare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-386">The managed object to aggregate.</span></span></param>
        <summary><span data-ttu-id="95bcb-387">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-387">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-388">Aggrega un oggetto gestito del tipo specificato con l'oggetto COM specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-388">Aggregates a managed object of the specified type with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-389">Puntatore [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interno dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-389">The inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-390">Il <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> metodo aggrega il puntatore gestito interno di un oggetto gestito di un tipo specificato con il puntatore esterno specificato e restituisce un inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-390">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-391"><paramref name="o" /> è un oggetto [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-391"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-392">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-392">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-393">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-393">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-394">Oggetto da includere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-394">The object to be wrapped.</span></span></param>
        <param name="t"><span data-ttu-id="95bcb-395">Tipo di wrapper da creare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-395">The type of wrapper to create.</span></span></param>
        <summary><span data-ttu-id="95bcb-396">Include l'oggetto COM specificato in un oggetto del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-396">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-397">L'oggetto appena incluso che è un'istanza del tipo desiderato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-397">The newly wrapped object that is an instance of the desired type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> Converte un tipo di classe, in genere la base `__ComObject` tipo, a un altro tipo di classe COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> converts one COM class type, typically the base `__ComObject` type, to another COM class type.</span></span> <span data-ttu-id="95bcb-399">L'oggetto COM di input, rappresentato dal parametro `o`, è un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="95bcb-399">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="95bcb-400">Sia il `t` e `o` i parametri devono essere classi le cui firme sono attribuite con <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-400">Both the `t` and `o` parameters must be classes whose signatures are attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-401">Il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-401">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="95bcb-402">Se si crea manualmente il RCW nel codice sorgente, è necessario applicare questo attributo per la firma gestita che rappresenta la coclasse originale per indicarne le origini COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-402">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="95bcb-403">Tlbimp.exe importa COM [coclasse](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) come una classe gestita e un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-403">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="95bcb-404">L'interfaccia di coclasse ha lo stesso nome della coclasse originale e la classe gestita ha al nome coclasse originale verrà aggiunto "Class".</span><span class="sxs-lookup"><span data-stu-id="95bcb-404">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="95bcb-405">Ad esempio, una coclasse chiamato `MyCoclass` diventa un'interfaccia di coclasse chiamata `MyCoclass` e una classe gestita chiamata `MyCoclassClass`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-405">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="95bcb-406">Poiché `t` deve essere una classe, non è un'interfaccia, assicurarsi di specificare la classe gestita (`MyCoclassClass`) e non l'interfaccia della coclasse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-406">Since `t` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the coclass interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-407">L'identità dell'oggetto COM esegue il wrapping di una nuova istanza RCW input viene persa la [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore esposto dal RCW originale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-407">You lose the identity of the input COM object because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-408"><paramref name="t" /> deve derivare da <see langword="__ComObject" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-408"><paramref name="t" /> must derive from <see langword="__ComObject" />.</span></span>  
  
 <span data-ttu-id="95bcb-409">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-409">-or-</span></span>  
  
 <span data-ttu-id="95bcb-410"><paramref name="t" /> è un tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-410"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-411">Il valore del parametro <paramref name="t" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-411">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="95bcb-412">Non è possibile convertire <paramref name="o" /> nel tipo di destinazione perché non supporta tutte le interfacce richieste.</span><span class="sxs-lookup"><span data-stu-id="95bcb-412"><paramref name="o" /> cannot be converted to the destination type because it does not support all required interfaces.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-413">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-413">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-414">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-414">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-415">Tipo di oggetto di cui eseguire il wrapping.</span><span class="sxs-lookup"><span data-stu-id="95bcb-415">The type of object to wrap.</span></span></typeparam>
        <typeparam name="TWrapper"><span data-ttu-id="95bcb-416">Tipo di oggetto da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-416">The type of object to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="95bcb-417">Oggetto da includere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-417">The object to be wrapped.</span></span></param>
        <summary><span data-ttu-id="95bcb-418">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-418">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-419">Include l'oggetto COM specificato in un oggetto del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-419">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-420">Oggetto appena incluso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-420">The newly wrapped object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> Converte un oggetto COM di tipo `T` per il `TWrapper` tipo di classe COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> converts a COM object of type `T` to the `TWrapper` COM class type.</span></span> <span data-ttu-id="95bcb-422">L'oggetto COM di input, rappresentato dal parametro `o`, è un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="95bcb-422">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="95bcb-423">Sia il `T` parametro di tipo generico e `o` parametro deve essere classi le cui firme sono assegnati gli attributi di <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-423">Both the `T` generic type parameter and the `o` parameter must be classes whose signatures are attributed with the <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="95bcb-424">Il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-424">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="95bcb-425">Se si crea manualmente il RCW nel codice sorgente, è necessario applicare questo attributo per la firma gestita che rappresenta la coclasse originale per indicarne le origini COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-425">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="95bcb-426">Tlbimp.exe importa COM [coclasse](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) come una classe gestita e un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-426">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="95bcb-427">L'interfaccia di coclasse ha lo stesso nome della coclasse originale e la classe gestita ha al nome coclasse originale verrà aggiunto "Class".</span><span class="sxs-lookup"><span data-stu-id="95bcb-427">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="95bcb-428">Ad esempio, una coclasse chiamato `MyCoclass` diventa un'interfaccia di coclasse chiamata `MyCoclass` e una classe gestita chiamata `MyCoclassClass`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-428">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="95bcb-429">Poiché`T` deve essere una classe, non è un'interfaccia, assicurarsi di specificare la classe gestita (`MyCoclassClass`) e non il `coclass` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-429">Because`T` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the `coclass` interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-430">Si perde l'identità dell'oggetto COM di input, perché esegue il wrapping di una nuova istanza RCW il [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore esposto dal RCW originale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-430">You lose the identity of the input COM object, because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-431"><typeparamref name="T" /> deve derivare da <see langword="__ComObject" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-431"><typeparamref name="T" /> must derive from <see langword="__ComObject" />.</span></span>  
  
 <span data-ttu-id="95bcb-432">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-432">-or-</span></span>  
  
 <span data-ttu-id="95bcb-433"><typeparamref name="T" /> è un tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-433"><typeparamref name="T" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="95bcb-434"><paramref name="o" /> non può essere convertito in <paramref name="TWrapper" /> perché non supporta tutte le interfacce richieste.</span><span class="sxs-lookup"><span data-stu-id="95bcb-434"><paramref name="o" /> cannot be converted to the <paramref name="TWrapper" /> because it does not support all required interfaces.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-435">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-435">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-436">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-437">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-437">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structuretype"><span data-ttu-id="95bcb-438">Tipo di una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-438">Type of a formatted class.</span></span> <span data-ttu-id="95bcb-439">Fornisce le informazioni di layout necessarie per eliminare il buffer nel parametro <c>ptr</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-439">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span></span></param>
        <summary><span data-ttu-id="95bcb-440">Libera tutte le sottostrutture a cui punta il blocco di memoria non gestita specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-440">Frees all substructures that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-441">È possibile utilizzare questo metodo per rilasciare i campi di tipo riferimento, ad esempio stringhe, di una struttura non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-441">You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="95bcb-442">A differenza dei relativi campi, una struttura può essere un tipo di valore o un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="95bcb-442">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="95bcb-443">Strutture di tipo di valore che contengono campi di tipo valore (tutti i tipi copiabili) sono privi di riferimenti la cui memoria deve essere liberata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-443">Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="95bcb-444">Il <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> metodo utilizza questo metodo per evitare perdite di memoria quando si riutilizza la memoria occupata da una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-444">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="95bcb-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> chiama il componente COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) (funzione), che a sua volta, libera una stringa allocata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 <span data-ttu-id="95bcb-446">Oltre a <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, <xref:System.Runtime.InteropServices.Marshal> classe fornisce due altri metodi di deallocazione di memoria: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-446">In addition to <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-447"><paramref name="structureType" /> dispone di un layout automatico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-447"><paramref name="structureType" /> has an automatic layout.</span></span> <span data-ttu-id="95bcb-448">Utilizzare invece il layout sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-448">Use sequential or explicit instead.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-449">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-449">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-450">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-450">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-451">Tipo della struttura formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-451">The type of the formatted structure.</span></span> <span data-ttu-id="95bcb-452">Fornisce le informazioni di layout necessarie per eliminare il buffer nel parametro <c>ptr</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-452">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="95bcb-453">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-453">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="95bcb-454">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-454">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-455">Libera tutte le sottostrutture di un tipo specificato a cui punta il blocco di memoria non gestita specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-455">Frees all substructures of a specified type that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-456">È possibile utilizzare questo metodo per rilasciare i campi di tipo riferimento, ad esempio stringhe, di una struttura non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-456">You can use this method to free reference type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="95bcb-457">A differenza dei relativi campi, una struttura può essere un tipo di valore o un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="95bcb-457">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="95bcb-458">Strutture di tipo di valore che contengono campi dei tipi di valore (tutti i tipi copiabili) sono privi di riferimenti la cui memoria deve essere liberata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-458">Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="95bcb-459">Il <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> metodo utilizza questo metodo per evitare perdite di memoria quando si riutilizza la memoria occupata da una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-459">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="95bcb-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> chiama il componente COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) (funzione), che a sua volta, libera una stringa allocata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-461"><typeparamref name="T" /> dispone di un layout automatico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-461"><typeparamref name="T" /> has an automatic layout.</span></span> <span data-ttu-id="95bcb-462">Utilizzare invece il layout sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-462">Use sequential or explicit instead.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-463">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-463">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-464">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-464">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-465">Wrapper RCW da rilasciare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-465">The RCW to be released.</span></span></param>
        <summary><span data-ttu-id="95bcb-466">Rilascia tutti i riferimenti a un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) impostando il conteggio dei riferimenti su 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-466">Releases all references to a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) by setting its reference count to 0.</span></span></summary>
        <returns><span data-ttu-id="95bcb-467">Nuovo valore del conteggio dei riferimenti del wrapper RCW associato al parametro <paramref name="o" />, corrispondente a 0 (zero) se il rilascio è stato eseguito correttamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-467">The new value of the reference count of the RCW associated with the <paramref name="o" /> parameter, which is 0 (zero) if the release is successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-468">Il <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> metodo rilascia il riferimento a un oggetto COM gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-468">The <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method releases the managed reference to a COM object.</span></span> <span data-ttu-id="95bcb-469">Chiamare questo metodo è equivalente alla chiamata di <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo in un ciclo fino a quando non viene restituito 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="95bcb-469">Calling this method is equivalent to calling the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="95bcb-470">Quando il conteggio dei riferimenti all'oggetto COM diventa 0, l'oggetto COM in genere viene liberata, anche se ciò dipende dall'implementazione dell'oggetto COM e sotto il controllo di runtime.</span><span class="sxs-lookup"><span data-stu-id="95bcb-470">When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</span></span> <span data-ttu-id="95bcb-471">Tuttavia, il RCW ancora può esistere, in attesa di essere sottoposto a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="95bcb-471">However, the RCW can still exist, waiting to be garbage-collected.</span></span>  
  
 <span data-ttu-id="95bcb-472">L'oggetto COM non può essere utilizzato dopo che è stato separato dal RCW sottostante.</span><span class="sxs-lookup"><span data-stu-id="95bcb-472">The COM object cannot be used after it has been separated from its underlying RCW.</span></span> <span data-ttu-id="95bcb-473">Se si tenta di chiamare un metodo su RCW dopo che il conteggio dei riferimenti arriva a 0, un <xref:System.Runtime.InteropServices.InvalidComObjectException> verrà generata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-473">If you try to call a method on the RCW after its reference count becomes 0, a <xref:System.Runtime.InteropServices.InvalidComObjectException> will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-474"><paramref name="o" /> non è un oggetto COM valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-474"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-475"><paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-475"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-476">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-476">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-477">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-477">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-478">Indirizzo del BSTR da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-478">The address of the BSTR to be freed.</span></span></param>
        <summary><span data-ttu-id="95bcb-479">Libera un <see langword="BSTR" /> usando la funzione COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633).</span><span class="sxs-lookup"><span data-stu-id="95bcb-479">Frees a <see langword="BSTR" /> using the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-480">Ad esempio <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, è possibile utilizzare questo metodo per deallocare la memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-480">Like <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, you can use this method to deallocate memory.</span></span> <span data-ttu-id="95bcb-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> chiama il componente COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) (funzione), che libera la memoria allocata da uno dei seguenti metodi non gestiti: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function, which frees memory allocated by any of the following unmanaged methods: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span></span> <span data-ttu-id="95bcb-482">È possibile chiamare metodi non gestiti, ad esempio con platform invoke.</span><span class="sxs-lookup"><span data-stu-id="95bcb-482">You can call unmanaged methods such as these with platform invoke.</span></span> <span data-ttu-id="95bcb-483">Per informazioni dettagliate, vedere [utilizzo di funzioni DLL non gestite](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-483">For details, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-484">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-484">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-485">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-485">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-486">Indirizzo della memoria da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-486">The address of the memory to be freed.</span></span></param>
        <summary><span data-ttu-id="95bcb-487">Libera un blocco di memoria assegnato dall'allocatore di memoria non gestita delle attività COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-487">Frees a block of memory allocated by the unmanaged COM task memory allocator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-488">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> per liberare memoria allocata da <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, o un equivalente di metodo non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-488">You can use <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> to free any memory allocated by <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, or any equivalent unmanaged method.</span></span> <span data-ttu-id="95bcb-489">Se il `ptr` parametro `null`, il metodo non esegue alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-489">If the `ptr` parameter is `null`, the method does nothing.</span></span>  
  
 <span data-ttu-id="95bcb-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> espone il COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) funzione, che libera tutti i byte in modo che non è possibile utilizzare la memoria che di `ptr` punta al parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> exposes the COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) function, which frees all bytes so that you can no longer use the memory that the `ptr` parameter points to.</span></span>  
  
 <span data-ttu-id="95bcb-491">Oltre a <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal> classe fornisce due altri metodi di deallocazione di memoria: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-491">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-492">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-492">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-493">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-493">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal"><span data-ttu-id="95bcb-494">L'handle restituito dalla chiamata di corrispondenza originale a <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-494">The handle returned by the original matching call to <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <summary><span data-ttu-id="95bcb-495">Libera la memoria precedentemente allocata dalla memoria non gestita del processo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-495">Frees memory previously allocated from the unmanaged memory of the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-496">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> per liberare memoria dall'heap globale allocato da <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, o metodo API non gestita qualsiasi equivalente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-496">You can use <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> to free any memory from the global heap allocated by <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, or any equivalent unmanaged API method.</span></span> <span data-ttu-id="95bcb-497">Se il `hglobal` parametro <xref:System.IntPtr.Zero?displayProperty=nameWithType> il metodo non esegue alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-497">If the `hglobal` parameter is <xref:System.IntPtr.Zero?displayProperty=nameWithType> the method does nothing.</span></span>  
  
 <span data-ttu-id="95bcb-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> espone il [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) funzione da Kernel32.DLL, che libera tutti i byte in modo che non è possibile utilizzare la memoria a cui puntava `hglobal`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> exposes the [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by `hglobal`.</span></span>  
  
 <span data-ttu-id="95bcb-499">Oltre a <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal> classe fornisce due deallocazione della memoria metodi API: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-499">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation API methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-500">Nel codice riportato di seguito viene illustrata la chiamata al metodo <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-500">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method.</span></span> <span data-ttu-id="95bcb-501">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-501">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 <span data-ttu-id="95bcb-502">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <xref:System.String> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</span><span class="sxs-lookup"><span data-stu-id="95bcb-502">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-503">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-503">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-504">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-504">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="95bcb-505">Tipo per il quale generare un GUID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-505">The type to generate a GUID for.</span></span></param>
        <summary><span data-ttu-id="95bcb-506">Restituisce il GUID (Globally Unique Identifier) del tipo specificato o genera un GUID mediante l'algoritmo usato da Type Library Exporter (Tlbexp.exe).</span><span class="sxs-lookup"><span data-stu-id="95bcb-506">Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</span></span></summary>
        <returns><span data-ttu-id="95bcb-507">Identificatore per il tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-507">An identifier for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-508">Se il tipo ha un GUID nei metadati, viene restituito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-508">If the type has a GUID in the metadata, it is returned.</span></span> <span data-ttu-id="95bcb-509">In caso contrario, viene generato automaticamente un GUID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-509">Otherwise, a GUID is automatically generated.</span></span> <span data-ttu-id="95bcb-510">È possibile utilizzare questo metodo per determinare a livello di codice il GUID di COM per qualsiasi tipo gestito, inclusi i tipi COM invisibile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-510">You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</span></span> <span data-ttu-id="95bcb-511">Le interfacce di classe sono l'unica eccezione perché non corrispondono a un tipo gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-511">Class interfaces are the only exception because they do not correspond to a managed type.</span></span> <span data-ttu-id="95bcb-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> fornisce la stessa funzionalità come la <xref:System.Type.GUID%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="95bcb-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> provides the same functionality as the <xref:System.Type.GUID%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-513">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-513">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-514">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-514">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="95bcb-515">Tipo per il quale ottenere un ProgID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-515">The type to get a ProgID for.</span></span></param>
        <summary><span data-ttu-id="95bcb-516">Restituisce un ProgID (Programmatic Identifier) per il tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-516">Returns a programmatic identifier (ProgID) for the specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-517">ProgID del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-517">The ProgID of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-518">Se il tipo ha un ProgID nei metadati, viene restituito tale ProgID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-518">If the type has a ProgID in the metadata, that ProgID is returned.</span></span> <span data-ttu-id="95bcb-519">In caso contrario, viene generato un ProgID in base al nome completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-519">Otherwise, a ProgID is generated based on the fully qualified name of the type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-520">Il parametro <paramref name="type" /> non è una classe che può essere creata da COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-520">The <paramref name="type" /> parameter is not a class that can be create by COM.</span></span> <span data-ttu-id="95bcb-521">La classe deve essere pubblica, disporre di un costruttore predefinito pubblico e deve essere visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-521">The class must be public, have a public default constructor, and be COM visible.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-522">Il valore del parametro <paramref name="type" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-522">The <paramref name="type" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-523">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-523">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-524">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-524">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="95bcb-525">Identificatore programmatico (ProgID) dell'oggetto richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-525">The programmatic identifier (ProgID) of the object that was requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-526">Ottiene un'istanza in esecuzione dell'oggetto specificato dalla tabella ROT (Running Object Table).</span><span class="sxs-lookup"><span data-stu-id="95bcb-526">Obtains a running instance of the specified object from the running object table (ROT).</span></span></summary>
        <returns><span data-ttu-id="95bcb-527">Oggetto richiesto; in caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-527">The object that was requested; otherwise <see langword="null" />.</span></span> <span data-ttu-id="95bcb-528">È possibile eseguire il cast di questo oggetto a qualsiasi interfaccia COM supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-528">You can cast this object to any COM interface that it supports.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> espone il COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) da OLEAUT32 (funzione). DLL. Tuttavia, quest'ultimo prevede un identificatore di classe (CLSID) anziché l'identificatore programmatico (`ProgID`) previsto dal metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> exposes the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (`ProgID`) expected by this method.</span></span> <span data-ttu-id="95bcb-530">Per ottenere un'istanza in esecuzione di un oggetto COM senza un registrati `ProgID`, utilizzare platform invoke per definire il modello COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) (funzione).</span><span class="sxs-lookup"><span data-stu-id="95bcb-530">To obtain a running instance of a COM object without a registered `ProgID`, use platform invoke to define the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function.</span></span> <span data-ttu-id="95bcb-531">Per una descrizione di platform invoke, vedere [utilizzo di funzioni DLL non gestite](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-531">For a description of platform invoke, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
## <a name="progid-and-clsid"></a><span data-ttu-id="95bcb-532">ProgID e CLSID</span><span class="sxs-lookup"><span data-stu-id="95bcb-532">ProgID and CLSID</span></span>  
 <span data-ttu-id="95bcb-533">Le chiavi nel sottoalbero HKEY_CLASSES_ROOT del Registro di sistema contengono una varietà di tipi di sottochiave.</span><span class="sxs-lookup"><span data-stu-id="95bcb-533">Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</span></span> <span data-ttu-id="95bcb-534">La maggior parte delle sottochiavi sono ProgID che mappano una semplice stringa su un CLSID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-534">Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</span></span> <span data-ttu-id="95bcb-535">Applicazioni usano spesso queste stringhe leggibile dall'utente anziché i CLSID numerici.</span><span class="sxs-lookup"><span data-stu-id="95bcb-535">Applications often use these human-readable strings instead of the numeric CLSIDs.</span></span> <span data-ttu-id="95bcb-536">Spesso, un componente ha un ProgID indipendenti dalla versione che viene eseguito il mapping alla versione più recente del componente installata nel sistema.</span><span class="sxs-lookup"><span data-stu-id="95bcb-536">Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</span></span>  
  
 <span data-ttu-id="95bcb-537">Applicazioni e componenti usano principalmente ProgID per recuperare i CLSID corrispondente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-537">Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-538">Nell'esempio seguente è stato eseguito in un computer che è stato configurato con un'istanza di Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="95bcb-538">The following example was run on a computer that was configured with a running instance of Microsoft Word.</span></span> <span data-ttu-id="95bcb-539">Vi sono istanze di Microsoft Excel in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-539">There were no instances of Microsoft Excel running.</span></span>  
  
 <span data-ttu-id="95bcb-540">Nell'esempio viene chiamato <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> due volte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-540">The example calls <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> twice.</span></span> <span data-ttu-id="95bcb-541">La prima chiamata tenta di recuperare un riferimento a un'istanza di Microsoft Word (un'istanza di `Word.Application` oggetto).</span><span class="sxs-lookup"><span data-stu-id="95bcb-541">The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the `Word.Application` object).</span></span> <span data-ttu-id="95bcb-542">La seconda chiamata tenta di recuperare un riferimento a un'istanza di Microsoft Excel (un'istanza di un `Excel.Application` oggetto).</span><span class="sxs-lookup"><span data-stu-id="95bcb-542">The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an `Excel.Application` object).</span></span>  
  
 <span data-ttu-id="95bcb-543">Il codice recupera un riferimento a un'istanza di Microsoft Word correttamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-543">The code retrieves a reference to an instance of Microsoft Word successfully.</span></span> <span data-ttu-id="95bcb-544">Tuttavia, poiché Microsoft Excel non è in esecuzione, il tentativo di recuperare il secondo oggetto genera un <xref:System.Runtime.InteropServices.COMException>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-544">However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <xref:System.Runtime.InteropServices.COMException>.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="95bcb-545">L'oggetto non è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-545">The object was not found.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-546">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-546">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-547">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-547">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-548">Restituisce un puntatore a interfaccia che rappresenta un'interfaccia per un oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-548">Returns an interface pointer that represents an interface for an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-549">Oggetto che fornisce l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-549">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="95bcb-550">Tipo di interfaccia richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-550">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-551">Restituisce un puntatore a un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) che rappresenta l'interfaccia specificata sull'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-551">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="95bcb-552">L'accesso all'interfaccia di query è abilitato per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-552">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="95bcb-553">Puntatore a interfaccia che rappresenta l'interfaccia specificata per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-553">The interface pointer that represents the specified interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-554">Questo metodo restituisce un puntatore a interfaccia che rappresenta l'interfaccia richiesta per l'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-554">This method returns an interface pointer that represents the requested interface on the specified object.</span></span> <span data-ttu-id="95bcb-555">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-555">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="95bcb-556">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-556">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-557">Utilizzare sempre <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-557">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="95bcb-558">È necessario rispettare le regole definite da COM quando si utilizzano i puntatori a interfaccia COM non elaborati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-558">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="95bcb-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <xref:System.IntPtr> tipo, o con marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="95bcb-560">Anche se meno comune, è possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore all'oggetto COM callable wrapper dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-560">Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</span></span> <span data-ttu-id="95bcb-561">Ad esempio, è possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> su un oggetto gestito che viene esportato in COM per ottenere un puntatore a interfaccia per <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-561">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-562">Poiché il tipo corrispondente da passare al secondo parametro non dispone di un'interfaccia di classe, non è possibile ottenere un puntatore a un'interfaccia di classe (`t`).</span><span class="sxs-lookup"><span data-stu-id="95bcb-562">You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (`t`).</span></span> <span data-ttu-id="95bcb-563">Utilizzare invece <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> per richiamare i membri sull'interfaccia predefinita di COM callable wrapper, che in genere è un'interfaccia di classe di invio automatico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-563">Instead, use <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</span></span>  
  
 <span data-ttu-id="95bcb-564">Il <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> overload del metodo che consente la personalizzazione dell'interfaccia di query per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-564">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="95bcb-565">Per specificare se applicare la personalizzazione dell'interfaccia di query, utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-565">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="95bcb-566">Per ulteriori informazioni, vedere il [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), e [Introduzione all'interfaccia di classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) argomenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-566">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-567">Il parametro <typeparamref name="T" /> non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-567">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="95bcb-568">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-568">-or-</span></span>  
  
 <span data-ttu-id="95bcb-569">Il tipo non è visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-569">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="95bcb-570">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-570">-or-</span></span>  
  
 <span data-ttu-id="95bcb-571">Il parametro <typeparamref name="T" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-571">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="95bcb-572">Il parametro <paramref name="o" /> non supporta l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-572">The <paramref name="o" /> parameter does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-573">Il valore del parametro <paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-573">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-574">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-574">-or-</span></span>  
  
 <span data-ttu-id="95bcb-575">Il valore del parametro <typeparamref name="T" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-575">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-576">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-576">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-577">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-577">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-578">Oggetto che fornisce l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-578">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="95bcb-579">Tipo di interfaccia richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-579">The type of interface that is requested.</span></span></param>
        <param name="mode"><span data-ttu-id="95bcb-580">Uno dei valori di enumerazione che indica se applicare una personalizzazione <see langword="IUnknown::QueryInterface" /> fornita da un oggetto <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-580">One of the enumeration values that indicates whether to apply an <see langword="IUnknown::QueryInterface" /> customization that is supplied by an <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span></span></param>
        <summary><span data-ttu-id="95bcb-581">Restituisce un puntatore a un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) che rappresenta l'interfaccia specificata sull'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-581">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="95bcb-582">L'accesso all'interfaccia di query personalizzato viene controllato dalla modalità della personalizzazione specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-582">Custom query interface access is controlled by the specified customization mode.</span></span></summary>
        <returns><span data-ttu-id="95bcb-583">Puntatore a interfaccia che rappresenta l'interfaccia per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-583">The interface pointer that represents the interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> Consente di specificare se applicare la personalizzazione dell'interfaccia di query.</span><span class="sxs-lookup"><span data-stu-id="95bcb-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> lets you specify whether to apply query interface customization.</span></span> <span data-ttu-id="95bcb-585">Utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> eseguire l'overload per applicare la personalizzazione dell'interfaccia di query per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-585">Use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> overload to apply query interface customization by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-586">Il parametro <typeparamref name="T" /> non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-586">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="95bcb-587">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-587">-or-</span></span>  
  
 <span data-ttu-id="95bcb-588">Il tipo non è visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-588">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="95bcb-589">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-589">-or-</span></span>  
  
 <span data-ttu-id="95bcb-590">Il parametro <typeparamref name="T" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-590">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="95bcb-591">Il parametro <paramref name="o" /> dell'oggetto non supporta l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-591">The object <paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-592">Il valore del parametro <paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-592">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-593">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-593">-or-</span></span>  
  
 <span data-ttu-id="95bcb-594">Il valore del parametro <typeparamref name="T" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-594">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-595">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-595">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-596">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-596">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-597">Il tipo di <c>o</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-597">The type of <c>o</c>.</span></span></typeparam>
        <typeparam name="TInterface"><span data-ttu-id="95bcb-598">Tipo di interfaccia da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-598">The type of interface to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="95bcb-599">Oggetto che fornisce l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-599">The object that provides the interface.</span></span></param>
        <summary><span data-ttu-id="95bcb-600">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-600">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-601">Restituisce un puntatore a un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) che rappresenta l'interfaccia specificata sull'oggetto del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-601">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on an object of the specified type.</span></span> <span data-ttu-id="95bcb-602">L'accesso all'interfaccia di query è abilitato per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-602">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="95bcb-603">Puntatore a interfaccia che rappresenta l'interfaccia <paramref name="TInterface" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-603">The interface pointer that represents the <paramref name="TInterface" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-604">Questo metodo restituisce un puntatore a interfaccia che rappresenta il `TInterface` interfaccia sull'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-604">This method returns an interface pointer that represents the `TInterface` interface on the specified object.</span></span> <span data-ttu-id="95bcb-605">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-605">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="95bcb-606">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-606">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-607">Utilizzare sempre il <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> metodo per decrementare il conteggio dei riferimenti quando il puntatore è stato completato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-607">Always use the <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> method to decrement the reference count when you have finished with the pointer.</span></span> <span data-ttu-id="95bcb-608">È necessario rispettare le regole definite da COM quando si utilizzano i puntatori a interfaccia COM non elaborati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-608">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="95bcb-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <xref:System.IntPtr> tipo, o con marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="95bcb-610">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore all'interno COM callable wrapper dell'oggetto, sebbene sia meno comune.</span><span class="sxs-lookup"><span data-stu-id="95bcb-610">You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</span></span> <span data-ttu-id="95bcb-611">Ad esempio, è possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> su un oggetto gestito che viene esportato in COM per ottenere un puntatore a interfaccia per <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-611">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-612">Il <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> overload del metodo che consente la personalizzazione dell'interfaccia di query per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-612">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="95bcb-613">Per specificare se applicare la personalizzazione dell'interfaccia di query, utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-613">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="95bcb-614">Per ulteriori informazioni, vedere il [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), e [Introduzione all'interfaccia di classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) argomenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-614">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-615">Il parametro <paramref name="TInterface" /> non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-615">The <paramref name="TInterface" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="95bcb-616">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-616">-or-</span></span>  
  
 <span data-ttu-id="95bcb-617">Il tipo non è visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-617">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="95bcb-618">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-618">-or-</span></span>  
  
 <span data-ttu-id="95bcb-619">Il parametro <typeparamref name="T" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-619">The <typeparamref name="T" /> parameter is an open generic type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="95bcb-620">Il parametro <paramref name="o" /> non supporta l'interfaccia <paramref name="TInterface" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-620">The <paramref name="o" /> parameter does not support the <paramref name="TInterface" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-621">Il valore del parametro <paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-621">The <paramref name="o" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-622">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-622">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-623">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-623">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-624">Oggetto che fornisce l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-624">The object that provides the interface.</span></span></param>
        <param name="t"><span data-ttu-id="95bcb-625">Tipo di interfaccia richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-625">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-626">Restituisce un puntatore a interfaccia che rappresenta l'interfaccia specificata per un oggetto, se il chiamante appartiene allo stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-626">Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-627">Puntatore a interfaccia specificato da <paramref name="t" /> che rappresenta l'interfaccia per l'oggetto specificato oppure <see langword="null" /> se il chiamante non appartiene allo stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-627">The interface pointer specified by <paramref name="t" /> that represents the interface for the specified object, or <see langword="null" /> if the caller is not in the same context as the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-628">Questo metodo è identico <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> ad eccezione del fatto che venga restituito `null` se il chiamante non è presente nello stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-628">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span> <span data-ttu-id="95bcb-629">È particolarmente utile se si dispone di un metodo non gestito che è previsto che venga passato un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-629">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-630"><paramref name="t" /> non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-630"><paramref name="t" /> is not an interface.</span></span>  
  
 <span data-ttu-id="95bcb-631">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-631">-or-</span></span>  
  
 <span data-ttu-id="95bcb-632">Il tipo non è visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-632">The type is not visible to COM.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="95bcb-633"><paramref name="o" /> non supporta l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-633"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-634"><paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-634"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-635">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-635">-or-</span></span>  
  
 <span data-ttu-id="95bcb-636"><paramref name="t" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-636"><paramref name="t" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-637">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-637">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-638">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-638">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="95bcb-639">Oggetto COM che contiene i dati desiderati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-639">The COM object that contains the data that you want.</span></span></param>
        <param name="key"><span data-ttu-id="95bcb-640">Chiave nella tabella hash interna di <c>obj</c> da cui recuperare i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-640">The key in the internal hash table of <c>obj</c> to retrieve the data from.</span></span></param>
        <summary><span data-ttu-id="95bcb-641">Recupera i dati ai quali fa riferimento la chiave specificata dall'oggetto COM specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-641">Retrieves data that is referenced by the specified key from the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-642">Dati rappresentati dal parametro <paramref name="key" /> nella tabella hash interna del parametro <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-642">The data represented by the <paramref name="key" /> parameter in the internal hash table of the <paramref name="obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-643">Tutti gli oggetti COM di cui è stato eseguito il wrapping in un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) dispongono di un hash associato tabella cui <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> recupera.</span><span class="sxs-lookup"><span data-stu-id="95bcb-643">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) have an associated hash table, which <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> retrieves.</span></span> <span data-ttu-id="95bcb-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> Aggiunge dati alla tabella hash.</span><span class="sxs-lookup"><span data-stu-id="95bcb-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> adds data to the hash table.</span></span> <span data-ttu-id="95bcb-645">È necessario non chiamare il metodo dal codice.</span><span class="sxs-lookup"><span data-stu-id="95bcb-645">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-646"><paramref name="obj" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-646"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-647">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-647">-or-</span></span>  
  
 <span data-ttu-id="95bcb-648"><paramref name="key" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-648"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-649"><paramref name="obj" /> non è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-649"><paramref name="obj" /> is not a COM object.</span></span>  
  
 <span data-ttu-id="95bcb-650">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-650">-or-</span></span>  
  
 <span data-ttu-id="95bcb-651"><paramref name="obj" /> è un oggetto [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-651"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-652">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-652">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-653">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-653">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="95bcb-654">Oggetto che rappresenta un metodo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-654">An object that represents an interface method.</span></span></param>
        <summary><span data-ttu-id="95bcb-655">Recupera lo slot della tabella della funzione virtuale (V-Table o VTBL) per un tipo <see cref="T:System.Reflection.MemberInfo" /> specificato quando quel tipo è esposto a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-655">Retrieves the virtual function table (v-table or VTBL) slot for a specified <see cref="T:System.Reflection.MemberInfo" /> type when that type is exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="95bcb-656">Identificatore <paramref name="m" /> dello slot VTBL quando è esposto a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-656">The VTBL slot <paramref name="m" /> identifier when it is exposed to COM.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-657">Il numero di slot in base zero restituito da questo metodo tiene conto di tre [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ed eventualmente di quattro [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) metodi, impostando il valore del primo slot disponibile su 3 o 7.</span><span class="sxs-lookup"><span data-stu-id="95bcb-657">The zero-based slot number returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="95bcb-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-659">È possibile utilizzare questo metodo per recuperare i numeri di slot per i membri delle interfacce che non sono visibili da COM e per i membri delle interfacce private.</span><span class="sxs-lookup"><span data-stu-id="95bcb-659">You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</span></span> <span data-ttu-id="95bcb-660">I numeri di slot restituiti corrispondono ai numeri v-table che sarebbero riservati se il tipo è esposto a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-660">The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</span></span> <span data-ttu-id="95bcb-661">I membri invisibili a COM occupano effettivamente uno slot in una tabella v esposto, anche se il client COM non è possibile utilizzare lo slot.</span><span class="sxs-lookup"><span data-stu-id="95bcb-661">COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</span></span> <span data-ttu-id="95bcb-662">Non è possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> su un'interfaccia di classe passando <xref:System.Reflection.MemberInfo> da una classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-662">You cannot use <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> on a class interface by passing <xref:System.Reflection.MemberInfo> from a class.</span></span> <span data-ttu-id="95bcb-663">Per ulteriori informazioni, vedere [Introduzione all'interfaccia di classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="95bcb-663">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-664">Il valore del parametro <paramref name="m" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-664">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-665">Il parametro <paramref name="m" /> non è un oggetto <see cref="T:System.Reflection.MemberInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-665">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MemberInfo" /> object.</span></span>  
  
 <span data-ttu-id="95bcb-666">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-666">-or-</span></span>  
  
 <span data-ttu-id="95bcb-667">Il parametro <paramref name="m" /> non è un metodo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-667">The <paramref name="m" /> parameter is not an interface method.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-668">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-668">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-669">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-669">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-670">Puntatore alla funzione non gestita da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-670">The unmanaged function pointer to be converted.</span></span></param>
        <param name="t"><span data-ttu-id="95bcb-671">Tipo di delegato da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-671">The type of the delegate to be returned.</span></span></param>
        <summary><span data-ttu-id="95bcb-672">Converte un puntatore a funzione non gestito in un delegato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-672">Converts an unmanaged function pointer to a delegate.</span></span></summary>
        <returns><span data-ttu-id="95bcb-673">Istanza di delegato di cui è possibile eseguire il cast al tipo di delegato appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-673">A delegate instance that can be cast to the appropriate delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-674">Nelle versioni 1.0 e 1.1 di .NET Framework, è possibile passare un delegato che rappresenta un metodo gestito a codice non gestito come un puntatore a funzione, consentendo il codice non gestito di chiamare il metodo gestito tramite il puntatore a funzione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-674">In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</span></span> <span data-ttu-id="95bcb-675">È inoltre possibile per il codice non gestito passare il puntatore a funzione al codice gestito e il puntatore è stato risolto correttamente al metodo gestito sottostante.</span><span class="sxs-lookup"><span data-stu-id="95bcb-675">It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</span></span>  
  
 <span data-ttu-id="95bcb-676">In .NET Framework 2.0 e versioni successive, è possibile utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> e <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> metodi per il marshalling di delegati in entrambe le direzioni.</span><span class="sxs-lookup"><span data-stu-id="95bcb-676">In the .NET Framework 2.0 and later versions, you can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> methods to marshal delegates in both directions.</span></span> <span data-ttu-id="95bcb-677">Con <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` viene importato come un <xref:System.IntPtr?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-677">With <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` is imported as a <xref:System.IntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-678">Oggetto <xref:System.IntPtr?displayProperty=nameWithType> può essere ottenuto per un delegato gestito chiamando <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> e passato come parametro; può quindi essere chiamato all'interno del metodo non gestito da.</span><span class="sxs-lookup"><span data-stu-id="95bcb-678">A <xref:System.IntPtr?displayProperty=nameWithType> can be obtained for a managed delegate by calling <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> and passed as a parameter; it can then be called from inside the unmanaged method.</span></span> <span data-ttu-id="95bcb-679">Si noti che il gestore di marshalling del parametro può anche effettuare il marshalling di delegati in .NET Framework 2.0 e versioni successive i puntatori a funzione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-679">Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</span></span>  
  
 <span data-ttu-id="95bcb-680">Il <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> metodo presenta le restrizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="95bcb-680">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="95bcb-681">Generics non supportati in scenari di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="95bcb-681">Generics are not supported in interop scenarios.</span></span>  
  
-   <span data-ttu-id="95bcb-682">A questo metodo, è possibile passare un puntatore a funzione non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-682">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="95bcb-683">È possibile utilizzare questo metodo solo per i puntatori a funzione non gestita pure.</span><span class="sxs-lookup"><span data-stu-id="95bcb-683">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="95bcb-684">È possibile utilizzare questo metodo con puntatori a funzione ottenuti tramite C++ o dal <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-684">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="95bcb-685">È possibile utilizzare questo metodo per creare un delegato da un puntatore a funzione a un altro delegato gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-685">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-686">Il parametro <paramref name="t" /> non è un delegato o è generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-686">The <paramref name="t" /> parameter is not a delegate or is generic.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-687">Il valore del parametro <paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-687">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-688">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-688">-or-</span></span>  
  
 <span data-ttu-id="95bcb-689">Il valore del parametro <paramref name="t" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-689">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-690">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-690">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-691">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-691">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="95bcb-692">Tipo del delegato da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-692">The type of the delegate to return.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="95bcb-693">Puntatore alla funzione non gestita da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-693">The unmanaged function pointer to convert.</span></span></param>
        <summary><span data-ttu-id="95bcb-694">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-694">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-695">Converte un puntatore a funzione non gestito in un delegato di un tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-695">Converts an unmanaged function pointer to a delegate of a specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-696">Istanza del tipo di delegato specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-696">A instance of the specified delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-697">È possibile utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> e <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> metodi per il marshalling di delegati in entrambe le direzioni.</span><span class="sxs-lookup"><span data-stu-id="95bcb-697">You can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> methods to marshal delegates in both directions.</span></span>  
  
 <span data-ttu-id="95bcb-698">Il <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> metodo presenta le restrizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="95bcb-698">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="95bcb-699">A questo metodo, è possibile passare un puntatore a funzione non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-699">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="95bcb-700">È possibile utilizzare questo metodo solo per i puntatori a funzione non gestita pure.</span><span class="sxs-lookup"><span data-stu-id="95bcb-700">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="95bcb-701">È possibile utilizzare questo metodo con puntatori a funzione ottenuti tramite C++ o dal <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-701">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="95bcb-702">È possibile utilizzare questo metodo per creare un delegato da un puntatore a funzione a un altro delegato gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-702">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-703">Il parametro generico <paramref name="TDelegate" /> non è un delegato oppure è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-703">The <paramref name="TDelegate" /> generic parameter is not a delegate, or it is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-704">Il valore del parametro <paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-704">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-705">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-705">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-706">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-706">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-707">Tipo che rappresenta un'interfaccia o classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-707">A type that represents an interface or class.</span></span></param>
        <summary><span data-ttu-id="95bcb-708">Recupera l'ultimo slot della tabella della funzione virtuale (V-Table o VTBL) di un tipo quando è esposto a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-708">Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="95bcb-709">Ultimo slot VTBL dell'interfaccia quando è esposto a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-709">The last VTBL slot of the interface when exposed to COM.</span></span> <span data-ttu-id="95bcb-710">Se il parametro <paramref name="t" /> è una classe, lo slot VTBL restituito è l'ultimo slot nell'interfaccia generata dalla classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-710">If the <paramref name="t" /> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-711">Questo metodo restituisce il numero di v-table in base zero, per un'interfaccia o una classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-711">This method returns the zero-based, v-table number for an interface or a class.</span></span> <span data-ttu-id="95bcb-712">Quando utilizzato in una classe, il numero di slot restituito fa riferimento all'interfaccia di classe per la classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-712">When used on a class, the slot number returned refers to the class interface for the class.</span></span> <span data-ttu-id="95bcb-713">Se l'interfaccia della classe è auto-dual, questo metodo restituisce sempre -1 per indicare che l'interfaccia solo dispatch non espone una tabella v ai client gestiti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-713">If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="95bcb-714">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> e <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in combinazione con <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> per passare gli slot all'interno di un intervallo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-714">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="95bcb-715">Per ulteriori informazioni, vedere [Introduzione all'interfaccia di classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="95bcb-715">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-716">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-716">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-717">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-717">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-718">Recupera un codice che identifica il tipo dell'eccezione che si è verificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-718">Retrieves a code that identifies the type of the exception that occurred.</span></span></summary>
        <returns><span data-ttu-id="95bcb-719">Tipo dell'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-719">The type of the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> viene esposta per il supporto del compilatore di strutturata (SEH) solo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span> <span data-ttu-id="95bcb-721">Se questo metodo viene chiamato prima che venga generata un'eccezione, viene restituito 0x0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-721">If this method is called before an exception is thrown, it returns 0x0.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-722">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-722">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-723">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-723">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-724">Converte un codice errore HRESULT in un oggetto <see cref="T:System.Exception" /> corrispondente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-724">Converts an HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="95bcb-725">Codice errore HRESULT da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-725">The HRESULT to be converted.</span></span></param>
        <summary><span data-ttu-id="95bcb-726">Converte il codice errore HRESULT specificato in un oggetto <see cref="T:System.Exception" /> corrispondente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-726">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-727">Oggetto che rappresenta l'HRESULT convertito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-727">An object that represents the converted HRESULT.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-728">Utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> metodo per ottenere un <xref:System.Exception> basato su un valore HRESULT, senza necessità di chiamare il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> metodo e rilevare l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-728">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception.</span></span>  
  
 <span data-ttu-id="95bcb-729">Corrente [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interfaccia viene utilizzata per costruire l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-729">The current [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface is used to construct the exception.</span></span>  
  
 <span data-ttu-id="95bcb-730">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere [come: mappa di HRESULT ed eccezioni](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-730">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-731">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-731">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-732">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-732">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="95bcb-733">Codice errore HRESULT da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-733">The HRESULT to be converted.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="95bcb-734">Puntatore all'interfaccia <see langword="IErrorInfo" /> che fornisce ulteriori informazioni sull'errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-734">A pointer to the <see langword="IErrorInfo" /> interface that provides more information about the error.</span></span> <span data-ttu-id="95bcb-735">È possibile specificare <c>IntPtr(0)</c> per usare l'interfaccia <see langword="IErrorInfo" /> corrente oppure <c>IntPtr(-1)</c> per ignorare l'interfaccia <see langword="IErrorInfo" /> corrente e costruire l'eccezione unicamente dal codice di errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-735">You can specify <c>IntPtr(0)</c> to use the current <see langword="IErrorInfo" /> interface, or <c>IntPtr(-1)</c> to ignore the current <see langword="IErrorInfo" /> interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="95bcb-736">Converte il codice di errore HRESULT specificato in un oggetto <see cref="T:System.Exception" /> corrispondente, con ulteriori informazioni sull'errore passate in un'interfaccia [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) per l'oggetto eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-736">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object, with additional error information passed in an [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface for the exception object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-737">Oggetto che rappresenta HRESULT convertito e le informazioni ottenute da <paramref name="errorInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-737">An object that represents the converted HRESULT and information obtained from <paramref name="errorInfo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-738">Utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> metodo per ottenere un <xref:System.Exception> basato su un valore HRESULT, senza necessità di chiamare il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> metodo e rilevare l'eccezione (evitando in tal modo il sovraccarico delle prestazioni corrispondenti).</span><span class="sxs-lookup"><span data-stu-id="95bcb-738">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception (thus avoiding the corresponding performance overhead).</span></span> <span data-ttu-id="95bcb-739">Il `errorInfo` parametro fornisce informazioni aggiuntive sull'errore, ad esempio la descrizione testuale e l'identificatore univoco globale (GUID) per l'interfaccia che definisce l'errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-739">The `errorInfo` parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</span></span>  
  
 <span data-ttu-id="95bcb-740">Utilizzare questo overload del metodo se si dispone di informazioni personalizzate sugli errori che è necessario fornire la conversione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-740">Use this method overload if you have custom error information that you have to supply in the conversion.</span></span>  
  
 <span data-ttu-id="95bcb-741">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere [come: mappa di HRESULT ed eccezioni](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-741">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-742">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-742">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-743">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-743">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-744">Recupera la descrizione di un'eccezione indipendente dal computer e le informazioni sullo stato esistente per il thread nel momento in cui si è verificata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-744">Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</span></span></summary>
        <returns><span data-ttu-id="95bcb-745">Puntatore a una struttura [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648).</span><span class="sxs-lookup"><span data-stu-id="95bcb-745">A pointer to an [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648) structure.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> viene esposta per il supporto del compilatore di strutturata (SEH) solo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-747">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-747">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-748">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-748">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="95bcb-749">Delegato da passare al codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-749">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="95bcb-750">Converte un delegato in un puntatore a funzione disponibile per la chiamata dal codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-750">Converts a delegate into a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="95bcb-751">Valore che può essere passato al codice non gestito, che a sua volta può usarlo per chiamare il delegato gestito sottostante.</span><span class="sxs-lookup"><span data-stu-id="95bcb-751">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-752">Il delegato `d` viene convertito in un puntatore a funzione che può essere passato a codice non gestito utilizzando il [stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convenzione di chiamata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-752">The delegate `d` is converted to a function pointer that can be passed to unmanaged code using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="95bcb-753">È necessario impedire manualmente il delegato venga raccolto dal garbage collector da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-753">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="95bcb-754">Il garbage collector non tiene traccia dei riferimenti a codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-754">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-755">Il parametro <paramref name="d" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-755">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-756">Il valore del parametro <paramref name="d" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-756">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-757">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-757">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-758">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-758">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="95bcb-759">Tipo di delegato da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-759">The type of delegate to convert.</span></span></typeparam>
        <param name="d"><span data-ttu-id="95bcb-760">Delegato da passare al codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-760">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="95bcb-761">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-761">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-762">Converte un delegato di un tipo specificato in un puntatore a funzione disponibile per la chiamata dal codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-762">Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="95bcb-763">Valore che può essere passato al codice non gestito, che a sua volta può usarlo per chiamare il delegato gestito sottostante.</span><span class="sxs-lookup"><span data-stu-id="95bcb-763">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-764">Il delegato `d` viene convertito in un puntatore a funzione che può essere passato a codice non gestito da utilizzando il [stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convenzione di chiamata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-764">The delegate `d` is converted to a function pointer that can be passed to unmanaged code by using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="95bcb-765">È necessario impedire manualmente il delegato venga raccolto dal garbage collector da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-765">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="95bcb-766">Il garbage collector non tiene traccia dei riferimenti a codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-766">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-767">Il parametro <paramref name="d" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-767">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-768">Il valore del parametro <paramref name="d" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-768">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-769">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-769">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-770">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-770">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="95bcb-771">Modulo di cui si desidera l'HINSTANCE.</span><span class="sxs-lookup"><span data-stu-id="95bcb-771">The module whose HINSTANCE is desired.</span></span></param>
        <summary><span data-ttu-id="95bcb-772">Restituisce l'handle di istanza (HINSTANCE) per il modulo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-772">Returns the instance handle (HINSTANCE) for the specified module.</span></span></summary>
        <returns><span data-ttu-id="95bcb-773">HINSTANCE per <paramref name="m" />; o -1 se il modulo non contiene un HINSTANCE.</span><span class="sxs-lookup"><span data-stu-id="95bcb-773">The HINSTANCE for <paramref name="m" />; or -1 if the module does not have an HINSTANCE.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-774">Quando i moduli dinamici o in memoria, non contiene un HINSTANCE.</span><span class="sxs-lookup"><span data-stu-id="95bcb-774">When dynamic or in-memory, modules do not have an HINSTANCE.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-775">Il valore del parametro <paramref name="m" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-775">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-776">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-776">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-777">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-777">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="95bcb-778">Eccezione da convertire in valore HRESULT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-778">The exception to convert to an HRESULT.</span></span></param>
        <summary><span data-ttu-id="95bcb-779">Converte l'eccezione specificata in valore HRESULT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-779">Converts the specified exception to an HRESULT.</span></span></summary>
        <returns><span data-ttu-id="95bcb-780">Valore HRESULT mappato all'eccezione fornita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-780">The HRESULT mapped to the supplied exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> Inoltre, installa un [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interfaccia per l'eccezione che può essere ottenuto chiamando la funzione COM GetErrorInfoNEEDGUID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> also sets up an [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</span></span> <span data-ttu-id="95bcb-782">È possibile utilizzare questa funzione per restituire un valore HRESULT sull'implementazione di una classe gestita di un'interfaccia COM in cui si applica il <xref:System.Runtime.InteropServices.PreserveSigAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-782">You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <xref:System.Runtime.InteropServices.PreserveSigAttribute> attribute.</span></span> <span data-ttu-id="95bcb-783">Le eccezioni catch tutti metodo con attributi e utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> per restituire il valore HRESULT appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-783">Have the attributed method catch all exceptions and use the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method to return the appropriate HRESULT value.</span></span> <span data-ttu-id="95bcb-784">Consentendo un'eccezione di propagarsi all'esterno del metodo produce un comportamento non corretto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-784">Allowing an exception to propagate outside the method produces incorrect behavior.</span></span> <span data-ttu-id="95bcb-785">(In realtà, common language runtime non riesce a passare un'eccezione a un client COM che chiama tale metodo tramite una v-table.)</span><span class="sxs-lookup"><span data-stu-id="95bcb-785">(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</span></span>  
  
 <span data-ttu-id="95bcb-786">Si noti che il <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> metodo imposta la [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interfaccia del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-786">Note that the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method sets the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread.</span></span> <span data-ttu-id="95bcb-787">Questo può causare risultati imprevisti per metodi come il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> metodi che per impostazione predefinita il [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) del thread corrente, se è impostato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-787">This can cause unexpected results for methods like the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> methods that default to using the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) of the current thread if it is set.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-788">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-788">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-789">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-789">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-790">Restituisce il valore HRESULT corrispondente all'ultimo errore in cui è incorso il codice Win32 eseguito usando <see cref="T:System.Runtime.InteropServices.Marshal" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-790">Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <see cref="T:System.Runtime.InteropServices.Marshal" />.</span></span></summary>
        <returns><span data-ttu-id="95bcb-791">HRESULT corrispondente all'ultimo codice errore Win32.</span><span class="sxs-lookup"><span data-stu-id="95bcb-791">The HRESULT corresponding to the last Win32 error code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-792">La funzione di destinazione deve essere stato il `setLastError` impostato flag di metadati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-792">The target function must have had the `setLastError` metadata flag set.</span></span> <span data-ttu-id="95bcb-793">Ad esempio, il `SetLastError` campo il <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> deve essere `true`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-793">For example, the `SetLastError` field of the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> must be `true`.</span></span> <span data-ttu-id="95bcb-794">Il processo per l'impostazione di questo flag dipende dal linguaggio di origine utilizzato: c# e C++ sono `false` per impostazione predefinita, ma la `Declare` istruzione in Visual Basic è `true`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-794">The process for setting this flag depends on the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-795">Nell'esempio seguente viene illustrato come recuperare un valore HRESULT corrispondente a un codice di errore Win32 usando il <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-795">The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-796">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-796">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-797">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-797">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-798">Oggetto di cui è richiesta l'interfaccia <see langword="IDispatch" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-798">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-799">Restituisce un'interfaccia [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) da un oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-799">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-800">Puntatore <see langword="IDispatch" /> per il parametro <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-800">The <see langword="IDispatch" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-801">Nel codice gestito, raramente si lavora direttamente con il `IDispatch` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-801">In managed code, you seldom work directly with the `IDispatch` interface.</span></span> <span data-ttu-id="95bcb-802">Tuttavia, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <xref:System.IntPtr> tipo, o con marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-802">However, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="95bcb-803">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-803">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-804">Utilizzare sempre <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-804">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span>  
  
 <span data-ttu-id="95bcb-805">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore a interfaccia a COM callable wrapper per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-805">You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</span></span> <span data-ttu-id="95bcb-806">Per ulteriori informazioni, vedere [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-806">For additional information, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="95bcb-807"><paramref name="o" /> non supporta l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-807"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-808">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-808">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-809">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-809">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-810">Oggetto di cui è richiesta l'interfaccia <see langword="IDispatch" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-810">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-811">Restituisce un puntatore a interfaccia [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) da un oggetto gestito se il chiamante appartiene allo stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-811">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface pointer from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-812">Puntatore a interfaccia <see langword="IDispatch" /> per l'oggetto specificato, oppure <see langword="null" /> se il chiamante non appartiene allo stesso contesto dell'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-812">The <see langword="IDispatch" /> interface pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-813">Questo metodo è identico <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> ad eccezione del fatto che venga restituito `null` se il chiamante non è presente nello stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-813">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="95bcb-814"><paramref name="o" /> non supporta l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-814"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-815"><paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-815"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-816">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-816">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-817">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-817">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-818">Tipo di cui è richiesta l'interfaccia <see langword="ITypeInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-818">The type whose <see langword="ITypeInfo" /> interface is being requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-819">Restituisce un'interfaccia <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> da un tipo gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-819">Returns a <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface from a managed type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-820">Puntatore all'interfaccia <see langword="ITypeInfo" /> per il parametro <paramref name="t" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-820">A pointer to the <see langword="ITypeInfo" /> interface for the <paramref name="t" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-821">Questo metodo restituisce un puntatore a un `ITypeInfo` implementazione che è in base al tipo originale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-821">This method returns a pointer to an `ITypeInfo` implementation that is based on the original type.</span></span> <span data-ttu-id="95bcb-822">La chiamata a un oggetto con <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> fa sì che il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-822">Calling an object with <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-823">Utilizzare sempre <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-823">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="95bcb-824">È possibile applicare il <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> per sostituire il comportamento di marshalling di interoperabilità standard con il gestore di marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-824">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-825">Nell'esempio seguente viene illustrato come recuperare un puntatore al `ITypeInfo` interfaccia per un tipo usando il <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-825">The following example demonstrates how to retrieve a pointer to the `ITypeInfo` interface for a type using the <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-826"><paramref name="t" /> non è un tipo visibile a COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-826"><paramref name="t" /> is not a visible type to COM.</span></span>  
  
 <span data-ttu-id="95bcb-827">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-827">-or-</span></span>  
  
 <span data-ttu-id="95bcb-828"><paramref name="t" /> è un tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-828"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="95bcb-829">È stata registrata una libreria dei tipi per l'assembly che contiene il tipo, ma non è possibile trovare la definizione del tipo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-829">A type library is registered for the assembly that contains the type, but the type definition cannot be found.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-830">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-830">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-831">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-831">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-832">Oggetto di cui è richiesta l'interfaccia <see langword="IUnknown" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-832">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-833">Restituisce un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) da un oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-833">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-834">Puntatore <see langword="IUnknown" /> per il parametro <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-834">The <see langword="IUnknown" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-835">Nel codice gestito, raramente si lavora direttamente con il `IUnknown` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-835">In managed code, you seldom work directly with the `IUnknown` interface.</span></span> <span data-ttu-id="95bcb-836">Tuttavia, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> è utile quando si chiama un metodo che espone un parametro di un oggetto COM come un <xref:System.IntPtr> tipo, o con marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-836">However, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="95bcb-837">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-837">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-838">Utilizzare sempre <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-838">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="95bcb-839">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-839">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="95bcb-840">È inoltre possibile utilizzare questo metodo su un oggetto gestito per ottenere un puntatore a interfaccia per il [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-840">You can also use this method on a managed object to obtain an interface pointer to the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) for the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-841">Nell'esempio seguente viene illustrato come recuperare un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interfaccia per un oggetto gestito utilizzando il <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-841">The following example demonstrates how to retrieve an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-842">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-842">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-843">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-843">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-844">Oggetto di cui è richiesta l'interfaccia <see langword="IUnknown" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-844">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="95bcb-845">Restituisce un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) da un oggetto gestito se il chiamante appartiene allo stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-845">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-846">Puntatore <see langword="IUnknown" /> per l'oggetto specificato, o <see langword="null" /> se il chiamante non appartiene allo stesso contesto dell'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-846">The <see langword="IUnknown" /> pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-847">Questo metodo è identico <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> ad eccezione del fatto che venga restituito `null` se il chiamante non è presente nello stesso contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-847">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-848">Nell'esempio seguente viene illustrato come recuperare un `IUnknown` interfaccia per un oggetto gestito utilizzando il <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-848">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-849">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-849">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-850">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-850">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-851">Restituisce il codice errore restituito dall'ultima funzione non gestita chiamata mediante una chiamata platform invoke con il flag <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> impostato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-851">Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.</span></span></summary>
        <returns><span data-ttu-id="95bcb-852">Ultimo codice di errore impostato da una chiamata alla funzione Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656).</span><span class="sxs-lookup"><span data-stu-id="95bcb-852">The last error code set by a call to the Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656) function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> espone Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) funzione da Kernel32.DLL.</span><span class="sxs-lookup"><span data-stu-id="95bcb-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> exposes the Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) function from Kernel32.DLL.</span></span> <span data-ttu-id="95bcb-854">Questo metodo è disponibile perché non è possibile effettuare una piattaforma diretta chiamata a `GetLastError` per ottenere queste informazioni.</span><span class="sxs-lookup"><span data-stu-id="95bcb-854">This method exists because it is not safe to make a direct platform invoke call to `GetLastError` to obtain this information.</span></span> <span data-ttu-id="95bcb-855">Se si desidera accedere a questo codice di errore, è necessario chiamare <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> anziché scrivere la propria definizione di platform invoke per `GetLastError` e chiamata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-855">If you want to access this error code, you must call <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> instead of writing your own platform invoke definition for `GetLastError` and calling it.</span></span> <span data-ttu-id="95bcb-856">Common language runtime può eseguire chiamate interne alle API di sovrascriveranno il `GetLastError` gestiti dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-856">The common language runtime can make internal calls to APIs that overwrite the `GetLastError` maintained by the operating system.</span></span>  
  
 <span data-ttu-id="95bcb-857">È possibile utilizzare questo metodo per ottenere i codici di errore solo se si applica il <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> per la firma del metodo e il set di <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo`true`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-857">You can use this method to obtain error codes only if you apply the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> to the method signature and set the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field to`true`.</span></span> <span data-ttu-id="95bcb-858">Il processo per questo varia in base al linguaggio di origine utilizzato: c# e C++ sono `false` per impostazione predefinita, ma la `Declare` istruzione in Visual Basic è `true`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-858">The process for this varies depending upon the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-859">Nel codice riportato di seguito viene illustrata la chiamata al metodo <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-859">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> method.</span></span> <span data-ttu-id="95bcb-860">Nell'esempio viene innanzitutto illustrato il metodo senza errori presenti e quindi viene illustrata la chiamata al metodo con un errore presentano.</span><span class="sxs-lookup"><span data-stu-id="95bcb-860">The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-861">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-861">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-862">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-862">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="95bcb-863">Puntatore al metodo di cui effettuare il marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-863">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="95bcb-864">Puntatore alla firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-864">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="95bcb-865">Numero di byte in <c>pbSignature</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-865">The number of bytes in <c>pbSignature</c>.</span></span></param>
        <summary><span data-ttu-id="95bcb-866">Ottiene un puntatore a una funzione generata a runtime che effettua il marshalling di una chiamata da codice gestito a codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-866">Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="95bcb-867">Puntatore alla funzione che eseguirà il marshalling di una chiamata dal parametro <paramref name="pfnMethodToWrap" /> a codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-867">A pointer to the function that will marshal a call from the <paramref name="pfnMethodToWrap" /> parameter to unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> viene esposta per il supporto del compilatore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-869">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-869">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-870">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-870">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-871">Tipo per il quale recuperare <see cref="T:System.Reflection.MemberInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-871">The type for which the <see cref="T:System.Reflection.MemberInfo" /> is to be retrieved.</span></span></param>
        <param name="slot"><span data-ttu-id="95bcb-872">Slot VTBL.</span><span class="sxs-lookup"><span data-stu-id="95bcb-872">The VTBL slot.</span></span></param>
        <param name="memberType"><span data-ttu-id="95bcb-873">A corretto completamento, uno dei valori di enumerazione che specifica il tipo del membro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-873">On successful return, one of the enumeration values that specifies the type of the member.</span></span></param>
        <summary><span data-ttu-id="95bcb-874">Recupera un oggetto <see cref="T:System.Reflection.MemberInfo" /> per lo slot della tabella di funzione virtuale specificata (V-Table o VTBL).</span><span class="sxs-lookup"><span data-stu-id="95bcb-874">Retrieves a <see cref="T:System.Reflection.MemberInfo" /> object for the specified virtual function table (v-table or VTBL) slot.</span></span></summary>
        <returns><span data-ttu-id="95bcb-875">Oggetto che rappresenta il membro nello slot VTBL specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-875">The object that represents the member at the specified VTBL slot.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-876">Il valore restituito può essere un <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, o <xref:System.Reflection.PropertyInfo> oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-876">The return value may be a <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, or <xref:System.Reflection.PropertyInfo> object.</span></span> <span data-ttu-id="95bcb-877">Il valore restituito dipende dal tipo di membro gestito che esiste nello slot COM specificato (pertanto il tipo restituito generalizzato <xref:System.Reflection.MemberInfo> dal quale derivano tutti i tre).</span><span class="sxs-lookup"><span data-stu-id="95bcb-877">The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <xref:System.Reflection.MemberInfo> from which all three derive).</span></span>  
  
 <span data-ttu-id="95bcb-878">Il numero di slot in base zero che viene restituito da questo metodo tiene conto di tre [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ed eventualmente di quattro [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) metodi, impostando il valore del primo slot disponibile su 3 o 7.</span><span class="sxs-lookup"><span data-stu-id="95bcb-878">The zero-based slot number that is returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="95bcb-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-880">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in combinazione con <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> per passare gli slot all'interno di un intervallo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-880">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> to pass slots within a specified range.</span></span>  
  
 <span data-ttu-id="95bcb-881">Il `memberType` parametro è importante solo in fase di restituzione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-881">The `memberType` parameter is important only on return.</span></span> <span data-ttu-id="95bcb-882">Contiene il tipo di membro COM (un metodo regolare o una funzione di accesso) che corrisponde all'oggetto restituito <xref:System.Reflection.MemberInfo> oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-882">It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <xref:System.Reflection.MemberInfo> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-883"><paramref name="t" /> non è visibile da COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-883"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-884">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-884">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-885">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-885">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="95bcb-886">Oggetto per il quale ottenere un tipo COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-886">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="95bcb-887">Puntatore per ricevere il tipo VARIANT corrispondente al parametro <c>obj</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-887">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span></span></param>
        <summary><span data-ttu-id="95bcb-888">Converte un oggetto nel tipo COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-888">Converts an object to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-889">Il `pDstNativeVariant` parametro deve puntare a una memoria sufficiente per memorizzare il VARIANT risulta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-889">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="95bcb-890">Inoltre, l'implementazione di questo metodo chiama il [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) funzione nella memoria non elaborata che il `pDstNativeVariant` punta al parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-890">Also, the implementation of this method calls the [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-891">Il parametro <paramref name="obj" /> è un'istanza di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-891">The <paramref name="obj" /> parameter is an instance of a generic type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-892">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-892">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-893">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-893">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-894">Tipo dell'oggetto da convertire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-894">The type of the object to convert.</span></span></typeparam>
        <param name="obj"><span data-ttu-id="95bcb-895">Oggetto per il quale ottenere un tipo COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-895">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="95bcb-896">Puntatore per ricevere il tipo VARIANT corrispondente al parametro <c>obj</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-896">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span></span></param>
        <summary><span data-ttu-id="95bcb-897">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-897">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-898">Esegue la conversione da un oggetto di tipo specificato in un oggetto COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-898">Converts an object of a specified type to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-899">Il `pDstNativeVariant` parametro deve puntare a una memoria sufficiente per memorizzare il VARIANT risulta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-899">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="95bcb-900">Inoltre, l'implementazione di questo metodo chiama [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) funzione nella memoria non elaborata che il `pDstNativeVariant` punta al parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-900">Also, the implementation of this method calls [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-901">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-901">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-902">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-902">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="95bcb-903">Puntatore all'interfaccia <see langword="IUnknown" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-903">A pointer to the <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="95bcb-904">Restituisce un'istanza di un tipo che rappresenta un oggetto COM tramite un puntatore alla relativa interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003).</span><span class="sxs-lookup"><span data-stu-id="95bcb-904">Returns an instance of a type that represents a COM object by a pointer to its [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span></span></summary>
        <returns><span data-ttu-id="95bcb-905">Oggetto che rappresenta l'oggetto COM non gestito specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-905">An object that represents the specified unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-906">Questo metodo esegue il wrapping `IUnknown` in un oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-906">This method wraps `IUnknown` in a managed object.</span></span> <span data-ttu-id="95bcb-907">Questo ha l'effetto di incrementare il conteggio dei riferimenti del componente COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-907">This has the effect of incrementing the reference count of the COM component.</span></span> <span data-ttu-id="95bcb-908">Il conteggio dei riferimenti verranno decrementato quando il runtime esegue garbage collection sull'oggetto gestito che rappresenta l'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-908">The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</span></span>  
  
 <span data-ttu-id="95bcb-909">Il `pUnk` parametro rappresenta un `IUnknown` puntatore a interfaccia; tuttavia, poiché tutte le interfacce COM derivano direttamente o indirettamente da `IUnknown`, è possibile passare qualsiasi interfaccia COM a questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-909">The `pUnk` parameter represents an `IUnknown` interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="95bcb-910">L'oggetto restituito da <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> è un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), che common language runtime gestisce come esegue qualsiasi altro oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-910">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), which the common language runtime manages as it does any other managed object.</span></span> <span data-ttu-id="95bcb-911">Il tipo di questo wrapper è spesso una base `System.__ComObject` tipo, ovvero un tipo nascosto utilizzato quando il tipo di wrapper è ambiguo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-911">The type of this wrapper is often a base `System.__ComObject` type, which is a hidden type used when the wrapper type is ambiguous.</span></span> <span data-ttu-id="95bcb-912">È comunque possibile apportare chiamate ad associazione tardiva a questo tipo è un tipo di base fino a quando l'oggetto COM implementa il [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-912">You can still make late-bound calls to such a base type as long as the COM object implements the [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) interface.</span></span> <span data-ttu-id="95bcb-913">Analogamente, è possibile impostare l'oggetto restituito da un'interfaccia COM appropriata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-913">Likewise, you can cast the returned object to an appropriate COM interface.</span></span>  
  
 <span data-ttu-id="95bcb-914">Per un oggetto di cui eseguire il wrapping con un tipo specifico di classe gestita e non è un tipo di wrapper generica, è necessario rispettare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="95bcb-914">For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</span></span>  
  
-   <span data-ttu-id="95bcb-915">Implementare il [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interfaccia per l'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-915">Implement the [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interface for the COM object.</span></span>  
  
-   <span data-ttu-id="95bcb-916">Registrare l'assembly contenitore con il [Regasm.exe (strumento di registrazione di Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-916">Register the containing assembly with the [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span></span>  
  
 <span data-ttu-id="95bcb-917">In alternativa, è possibile ignorare questi requisiti e ottenere comunque un oggetto che viene eseguito il wrapping con un tipo classe gestito specifico tramite il <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-917">Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-918">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-918">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-919">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-919">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant"><span data-ttu-id="95bcb-920">Puntatore a un COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-920">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="95bcb-921">Converte un tipo COM VARIANT in un oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-921">Converts a COM VARIANT to an object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-922">Oggetto che corrisponde al parametro <paramref name="pSrcNativeVariant" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-922">An object that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> Restituisce un oggetto gestito che corrisponde a un puntatore non elaborato a un tipo VARIANT non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="95bcb-924">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-924">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="95bcb-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-926">Quando il tipo di variante è VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> restituisce un oggetto di tipo `Int32` anziché `UInt32`.</span><span class="sxs-lookup"><span data-stu-id="95bcb-926">When the VARIANT type is VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns an object of type `Int32` instead of `UInt32`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="95bcb-927"><paramref name="pSrcNativeVariant" /> non è un tipo VARIANT valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-927"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="95bcb-928"><paramref name="pSrcNativeVariant" /> presenta un tipo non supportato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-928"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-929">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-929">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-930">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-930">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-931">Tipo in cui convertire COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-931">The type to which to convert the COM VARIANT.</span></span></typeparam>
        <param name="pSrcNativeVariant"><span data-ttu-id="95bcb-932">Puntatore a un COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-932">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="95bcb-933">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-933">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-934">Esegue la conversione da un oggetto di tipo specificato a un oggetto COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-934">Converts a COM VARIANT to an object of a specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-935">Oggetto del tipo specificato che corrisponde al parametro <paramref name="pSrcNativeVariant" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-935">An object of the specified type that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> Restituisce un oggetto gestito di tipo `T` che corrisponde a un puntatore non elaborato a un tipo VARIANT non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> returns a managed object of type `T` that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="95bcb-937">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-937">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="95bcb-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="95bcb-939"><paramref name="pSrcNativeVariant" /> non è un tipo VARIANT valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-939"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="95bcb-940"><paramref name="pSrcNativeVariant" /> presenta un tipo non supportato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-940"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-941">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-941">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-942">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-942">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant"><span data-ttu-id="95bcb-943">Puntatore al primo elemento di una matrice di COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-943">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="95bcb-944">Numero di tipi COM VARIANT in <c>aSrcNativeVariant</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-944">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span></span></param>
        <summary><span data-ttu-id="95bcb-945">Converte una matrice di tipi COM [VARIANT](http://go.microsoft.com/fwlink/?LinkId=148670) in una matrice di oggetti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-945">Converts an array of COM [VARIANTs](http://go.microsoft.com/fwlink/?LinkId=148670) to an array of objects.</span></span></summary>
        <returns><span data-ttu-id="95bcb-946">Matrice di oggetti che corrisponde a <paramref name="aSrcNativeVariant" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-946">An object array that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> Restituisce una matrice di oggetti gestiti che corrisponde a un puntatore non elaborato in una matrice di tipo C di tipi VARIANT non gestiti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="95bcb-948">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-948">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="95bcb-949">Il metodo restituisce una matrice vuota quando il `cVars` parametro è 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-949">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="95bcb-950">La matrice di oggetti (il valore restituito) Ottiene raccolto nel garbage collector come di consueto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-950">The object array (the return value) gets garbage collected as usual.</span></span> <span data-ttu-id="95bcb-951">La matrice di input non gestita o varianti singole nella matrice di input non vengono liberate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-951">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="95bcb-952">Pertanto è responsabilità dell'utente liberarle in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-952">Therefore it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-953"><paramref name="cVars" /> è un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-953"><paramref name="cVars" /> is a negative number.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-954">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-954">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-955">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-955">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-956">Tipo della matrice da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-956">The type of the array to return.</span></span></typeparam>
        <param name="aSrcNativeVariant"><span data-ttu-id="95bcb-957">Puntatore al primo elemento di una matrice di COM VARIANT.</span><span class="sxs-lookup"><span data-stu-id="95bcb-957">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="95bcb-958">Numero di tipi COM VARIANT in <c>aSrcNativeVariant</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-958">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span></span></param>
        <summary><span data-ttu-id="95bcb-959">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-959">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-960">Converte una matrice di tipi COM VARIANT in una matrice di un tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-960">Converts an array of COM VARIANTs to an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-961">Matrice di oggetti <typeparamref name="T" /> che corrisponde a <paramref name="aSrcNativeVariant" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-961">An array of <typeparamref name="T" /> objects that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> Restituisce una matrice di `T` che corrisponde a un puntatore non elaborato in una matrice di tipo C di tipi VARIANT non gestiti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> returns an array of `T` that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="95bcb-963">Il interopmarshaler esegue la trasformazione identica quando si espone un tipo VARIANT per codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-963">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="95bcb-964">Il metodo restituisce una matrice vuota quando il `cVars` parametro è 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-964">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="95bcb-965">La matrice restituita è sottoposto a garbage collection come di consueto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-965">The returned array is garbage-collected as usual.</span></span> <span data-ttu-id="95bcb-966">La matrice di input non gestita o varianti singole nella matrice di input non vengono liberate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-966">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="95bcb-967">Pertanto, è responsabilità dell'utente liberarle in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-967">Therefore, it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="95bcb-968"><paramref name="cVars" /> è un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-968"><paramref name="cVars" /> is a negative number.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-969">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-969">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-970">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-970">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-971">Tipo che rappresenta un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-971">A type that represents an interface.</span></span></param>
        <summary><span data-ttu-id="95bcb-972">Ottiene il primo slot nella tabella di funzioni virtual (V-Table o VTBL) che contiene metodi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-972">Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</span></span></summary>
        <returns><span data-ttu-id="95bcb-973">Primo slot VTBL che contiene metodi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-973">The first VTBL slot that contains user-defined methods.</span></span> <span data-ttu-id="95bcb-974">Il primo slot è 3 se l'interfaccia è basata su [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) e 7 se l'interfaccia è basata su [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</span><span class="sxs-lookup"><span data-stu-id="95bcb-974">The first slot is 3 if the interface is based on [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003), and 7 if the interface is based on [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-975">Questo metodo restituisce il numero in base zero v-table per una classe o un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-975">This method returns the zero-based v-table number for an interface or a class.</span></span> <span data-ttu-id="95bcb-976">Quando utilizzato in una classe, che viene restituito il numero di slot fa riferimento all'interfaccia di classe per la classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-976">When used on a class, the slot number that is returned refers to the class interface for the class.</span></span> <span data-ttu-id="95bcb-977">Se l'interfaccia della classe è l'invio automatico, questo metodo restituisce sempre -1 per indicare che l'interfaccia solo dispatch non espone una tabella v ai client gestiti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-977">If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="95bcb-978">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> e <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in combinazione con <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> per passare gli slot all'interno di un intervallo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-978">You can use <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="95bcb-979">Per ulteriori informazioni, vedere [Introduzione all'interfaccia di classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="95bcb-979">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-980"><paramref name="t" /> non è visibile da COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-980"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-981">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-981">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-982">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-982">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie"><span data-ttu-id="95bcb-983">Intero che rappresenta un fiber cookie.</span><span class="sxs-lookup"><span data-stu-id="95bcb-983">An integer that represents a fiber cookie.</span></span></param>
        <summary><span data-ttu-id="95bcb-984">Converte un fiber cookie nella corrispondente istanza di <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-984">Converts a fiber cookie into the corresponding <see cref="T:System.Threading.Thread" /> instance.</span></span></summary>
        <returns><span data-ttu-id="95bcb-985">Thread che corrisponde al parametro <paramref name="cookie" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-985">A thread that corresponds to the <paramref name="cookie" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-986">Fiber cookie sono opachi i token utilizzati dall'host durante la segnalazione di common language runtime per le decisioni di pianificazione fiber.</span><span class="sxs-lookup"><span data-stu-id="95bcb-986">Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</span></span> <span data-ttu-id="95bcb-987">Sono costituiti da uno stack e registrare contesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-987">They consist of a stack and register context.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-988">Il parametro <paramref name="cookie" /> è 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-988">The <paramref name="cookie" /> parameter is 0.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-989">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-989">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-990">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-990">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="95bcb-991">Puntatore all'interfaccia <see langword="IUnknown" /> dell'oggetto non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-991">A pointer to the <see langword="IUnknown" /> interface of the unmanaged object.</span></span></param>
        <param name="t"><span data-ttu-id="95bcb-992">Tipo della classe gestita richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-992">The type of the requested managed class.</span></span></param>
        <summary><span data-ttu-id="95bcb-993">Restituisce un oggetto gestito di un tipo specificato che rappresenta un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-993">Returns a managed object of a specified type that represents a COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-994">Istanza della classe corrispondente all'oggetto <see cref="T:System.Type" /> che rappresenta l'oggetto COM non gestito richiesto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-994">An instance of the class corresponding to the <see cref="T:System.Type" /> object that represents the requested unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-995">Il `t` parametro deve essere un tipo importato da COM o un sottotipo di un tipo importato da COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-995">The `t` parameter must be either a COM-imported type or a subtype of a COM-imported type.</span></span> <span data-ttu-id="95bcb-996">Inoltre, `t` deve essere un tipo i cui metadati sono stati importati dal [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento.</span><span class="sxs-lookup"><span data-stu-id="95bcb-996">In addition, `t` must be a type whose metadata was imported by the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span> <span data-ttu-id="95bcb-997">Questo tipo deve essere una classe e non un'interfaccia, coclasse associata che porta il nome della classe COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-997">This type must be a class and not an associated coclass interface, which carries the name of the COM class.</span></span> <span data-ttu-id="95bcb-998">Se, ad esempio, Importa Tlbimp.exe `Myclass` come una classe denominata `MyclassClass` e come un'interfaccia di coclasse chiamato `Myclass`, è necessario utilizzare `MyclassClass` (non `Myclass`) con questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-998">For example, if Tlbimp.exe imports `Myclass` as a class called `MyclassClass` and as a coclass interface called `Myclass`, you must use `MyclassClass` (not `Myclass`) with this method.</span></span> <span data-ttu-id="95bcb-999">Per ulteriori informazioni sulle interfacce di coclasse e le classi importate, vedere [importati conversione del tipo](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).</span><span class="sxs-lookup"><span data-stu-id="95bcb-999">For additional information about imported classes and coclass interfaces, see [Imported Type Conversion](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).</span></span>  
  
 <span data-ttu-id="95bcb-1000">Se un oggetto già ottenuto per il `pUnk` parametro `t` viene ignorato e viene restituito l'oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1000">If an object has already been obtained for the `pUnk` parameter, `t` is ignored and the existing object is returned.</span></span> <span data-ttu-id="95bcb-1001">`pUnk` rappresenta un[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore a interfaccia; tuttavia, poiché tutte le interfacce COM derivano direttamente o indirettamente da `IUnknown`, è possibile passare qualsiasi interfaccia COM a questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1001">`pUnk` represents an[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="95bcb-1002">L'oggetto restituito da <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> è un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), che common language runtime gestisce come esegue qualsiasi altro oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1002">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), which the common language runtime manages as it does any other managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1003">A <paramref name="t" /> non è applicato l'attribuito <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1003"><paramref name="t" /> is not attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span></span>  
  
 <span data-ttu-id="95bcb-1004">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1004">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1005"><paramref name="t" /> è un tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-1005"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1006">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1006">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1007">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1007">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo"><span data-ttu-id="95bcb-1008">Interfaccia <see langword="ITypeInfo" /> di cui effettuare il marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1008">The <see langword="ITypeInfo" /> interface to marshal.</span></span></param>
        <summary><span data-ttu-id="95bcb-1009">Converte un oggetto [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) non gestito in un oggetto <see cref="T:System.Type" /> gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1009">Converts an unmanaged [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object into a managed <see cref="T:System.Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1010">Tipo gestito che rappresenta l'oggetto <see langword="ITypeInfo" /> non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1010">A managed type that represents the unmanaged <see langword="ITypeInfo" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> Restituisce un <xref:System.Type?displayProperty=nameWithType> istanza in cui è in base al tipo originale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> returns a <xref:System.Type?displayProperty=nameWithType> instance that is based on the original type.</span></span> <span data-ttu-id="95bcb-1012">È possibile applicare il <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> per sostituire il comportamento di marshalling di interoperabilità standard con il gestore di marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1012">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span> <span data-ttu-id="95bcb-1013">Il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento utilizza il gestore di marshalling personalizzato per convertire `ITypeInfo` parametri <xref:System.Type?displayProperty=nameWithType> parametri.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1013">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool uses the custom marshaler to translate `ITypeInfo` parameters to <xref:System.Type?displayProperty=nameWithType> parameters.</span></span> <span data-ttu-id="95bcb-1014">Tuttavia, se si ottiene un `ITypeInfo` interfaccia da alcuni significa diverso Tlbimp.exe, è possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> per eseguire manualmente la stessa conversione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1014">However, if you obtain an `ITypeInfo` interface by some means other than Tlbimp.exe, you can use <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> to manually perform the same translation.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1015">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1015">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1016">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1016">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="95bcb-1017">CLSID del tipo da restituire.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1017">The CLSID of the type to return.</span></span></param>
        <summary><span data-ttu-id="95bcb-1018">Restituisce il tipo associato all'identificatore di classe specificato (CLSID).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1018">Returns the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns>
          <span data-ttu-id="95bcb-1019"><see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1019"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1020">Recupera il nome del tipo rappresentato da un oggetto [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1020">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="95bcb-1021">Oggetto che rappresenta un puntatore <see langword="ITypeInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1021">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="95bcb-1022">Recupera il nome del tipo rappresentato da un oggetto [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1022">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1023">Nome del tipo a cui punta il parametro <paramref name="typeInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1023">The name of the type that the <paramref name="typeInfo" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1024">È inoltre possibile recuperare il nome del tipo rappresentato da un `ITypeInfo` chiamando il <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodo e passando -1 per il primo parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1024">You can also retrieve the name of the type represented by an `ITypeInfo` by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1025">Il valore del parametro <paramref name="typeInfo" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1025">The <paramref name="typeInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1026">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1026">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1027">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1027">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI"><span data-ttu-id="95bcb-1028">Oggetto che rappresenta un puntatore <see langword="ITypeInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1028">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="95bcb-1029">Recupera il nome del tipo rappresentato da un oggetto [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1029">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1030">Nome del tipo a cui punta il parametro <paramref name="pTI" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1030">The name of the type that the <paramref name="pTI" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1031">È inoltre possibile recuperare il nome del tipo rappresentato da un `ITypeInfo` oggetto chiamando il <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodo e passando -1 per il primo parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1031">You can also retrieve the name of the type represented by an `ITypeInfo` object by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1032">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1032">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1033">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1033">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1034">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1034">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="95bcb-1035">Libreria dei tipi di cui deve essere recuperato LIBID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1035">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1036">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1036">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1037">LIBID della libreria dei tipi specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1037">The LIBID of the specified type library.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> estrae il LIBID direttamente da una libreria dei tipi esistente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="95bcb-1039">Questa azione è diverso da quello di <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> metodo, che calcola il LIBID necessario in base all'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1039">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="95bcb-1040">Per ulteriori informazioni sugli identificatori di libreria, vedere [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1040">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1041">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1041">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1042">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1042">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="95bcb-1043">Libreria dei tipi di cui deve essere recuperato LIBID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1043">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1044">Recupera il LIBID (Library Identifier) di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1044">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1045">LIBID della libreria dei tipi a cui punta il parametro <paramref name="pTLB" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1045">The LIBID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> estrae il LIBID direttamente da una libreria dei tipi esistente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="95bcb-1047">Questa azione è diverso da quello di <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> metodo, che calcola il LIBID necessario in base all'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1047">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="95bcb-1048">Per ulteriori informazioni sugli identificatori di libreria, vedere [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1048">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1049">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1049">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1050">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm"><span data-ttu-id="95bcb-1051">Assembly dal quale è stata esportata la libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1051">The assembly from which the type library was exported.</span></span></param>
        <summary><span data-ttu-id="95bcb-1052">Recupera il LIBID assegnato a una libreria dei tipi quando viene esportato dall'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1052">Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1053">LIBID che viene assegnato a una libreria dei tipi quando viene esportata dall'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1053">The LIBID that is assigned to a type library when it is exported from the specified assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1054">Quando vengono esportati gli assembly di librerie dei tipi, la libreria dei tipi viene assegnata un LIBID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1054">When assemblies are exported to type libraries, the type library is assigned a LIBID.</span></span> <span data-ttu-id="95bcb-1055">È possibile impostare in modo esplicito il LIBID applicando il <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> di assembly livello oppure può essere generato automaticamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1055">You can set the LIBID explicitly by applying the <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> at the assembly level, or it can be generated automatically.</span></span> <span data-ttu-id="95bcb-1056">Il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento consente di calcolare un valore LIBID in base all'identità dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1056">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool calculates a LIBID value based on the identity of the assembly.</span></span> <span data-ttu-id="95bcb-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> Restituisce il LIBID che è associato il <xref:System.Runtime.InteropServices.GuidAttribute>, se viene applicato l'attributo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> returns the LIBID that is associated with the <xref:System.Runtime.InteropServices.GuidAttribute>, if the attribute is applied.</span></span> <span data-ttu-id="95bcb-1058">In caso contrario, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> restituisce il valore calcolato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1058">Otherwise, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> returns the calculated value.</span></span> <span data-ttu-id="95bcb-1059">In alternativa, è possibile utilizzare il <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> metodo per estrarre il reale LIBID da una libreria dei tipi esistente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1059">Alternatively, you can use the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> method to extract the actual LIBID from an existing type library.</span></span>  
  
 <span data-ttu-id="95bcb-1060">Vedere il [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) per ulteriori informazioni sugli identificatori di libreria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1060">See the [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) topic for more information about library identifiers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1061"><paramref name="asm" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1061"><paramref name="asm" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1062">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1062">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1063">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1063">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1064">Recupera l'LCID di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1064">Retrieves the LCID of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="95bcb-1065">Libreria dei tipi di cui deve essere recuperato LCID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1065">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1066">Recupera l'LCID di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1066">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1067">LCID della libreria dei tipi a cui punta il parametro <paramref name="typelib" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1067">The LCID of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1068">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1068">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1069">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1069">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="95bcb-1070">Libreria dei tipi di cui deve essere recuperato LCID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1070">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1071">Recupera l'LCID di una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1071">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1072">LCID della libreria dei tipi a cui punta il parametro <paramref name="pTLB" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1072">The LCID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1073">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1073">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1074">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1074">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1075">Recupera il nome di una libreria di tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1075">Retrieves the name of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="95bcb-1076">Libreria dei tipi di cui deve essere recuperato il nome.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1076">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1077">Recupera il nome di una libreria di tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1077">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1078">Nome della libreria dei tipi a cui punta il parametro <paramref name="typelib" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1078">The name of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1079">Il nome restituito da questo metodo è l'identificatore utilizzato con l'istruzione di libreria, ad esempio ADODB per la libreria dei tipi Microsoft ADO.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1079">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="95bcb-1080">Il nome non è un nome di file.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1080">The name is not a file name.</span></span>  
  
 <span data-ttu-id="95bcb-1081">È anche possibile recuperare il nome della libreria di tipo chiamando il <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodo e passando -1 per il primo parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1081">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1082">Il valore del parametro <paramref name="typelib" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1082">The <paramref name="typelib" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1083">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1083">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1084">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1084">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="95bcb-1085">Libreria dei tipi di cui deve essere recuperato il nome.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1085">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="95bcb-1086">Recupera il nome di una libreria di tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1086">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1087">Nome della libreria dei tipi a cui punta il parametro <paramref name="pTLB" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1087">The name of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1088">Il nome restituito da questo metodo è l'identificatore utilizzato con l'istruzione di libreria, ad esempio ADODB per la libreria dei tipi Microsoft ADO.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1088">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="95bcb-1089">Il nome non è un nome di file.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1089">The name is not a file name.</span></span>  
  
 <span data-ttu-id="95bcb-1090">È anche possibile recuperare il nome della libreria di tipo chiamando il <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodo e passando -1 per il primo parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1090">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1091">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1091">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1092">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1092">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly"><span data-ttu-id="95bcb-1093">Assembly gestiti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1093">A managed assembly.</span></span></param>
        <param name="majorVersion"><span data-ttu-id="95bcb-1094">Numero di versione principale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1094">The major version number.</span></span></param>
        <param name="minorVersion"><span data-ttu-id="95bcb-1095">Numero di versione secondario.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1095">The minor version number.</span></span></param>
        <summary><span data-ttu-id="95bcb-1096">Recupera il numero di versione di una libreria dei tipi che verrà esportata dall'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1096">Retrieves the version number of a type library that will be exported from the specified assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1097">Prima di esportare un assembly utilizzando <xref:System.Runtime.InteropServices.TypeLibExporterFlags> con il `CallerResolvedReferences` valore, è possibile utilizzare questo metodo per recuperare la versione della libreria dei tipi dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1097">Before exporting an assembly by using <xref:System.Runtime.InteropServices.TypeLibExporterFlags> with the `CallerResolvedReferences` value, you can use this method to retrieve the type library version from the assembly.</span></span>  
  
 <span data-ttu-id="95bcb-1098">Se non si applica il <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> attributo a un assembly esportato per controllare in modo esplicito il numero di versione della libreria dei tipi generati, la libreria dei tipi avrà lo stesso numero di versione dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1098">If you do not apply the <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1099"><paramref name="inputAssembly" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1099"><paramref name="inputAssembly" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1100">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1100">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1101">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1101">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown"><span data-ttu-id="95bcb-1102">Puntatore gestito a un'interfaccia <see langword="IUnknown" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1102">A managed pointer to an <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="95bcb-1103">Crea un oggetto [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) univoco per un'interfaccia [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1103">Creates a unique [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) object for a given [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1104">RCW univoco per l'interfaccia <see langword="IUnknown" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1104">A unique RCW for the specified <see langword="IUnknown" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1105">Il <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> metodo garantisce la ricezione di un RCW univoco, perché non corrisponde un `IUnknown` puntatore a un oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1105">The <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> method ensures that you receive a unique RCW, because it does not match an `IUnknown` pointer to an existing object.</span></span> <span data-ttu-id="95bcb-1106">Utilizzare questo metodo quando è necessario creare un RCW che non venga interessato da altro codice che chiama il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1106">Use this method when you have to create a unique RCW that is not impacted by other code that calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1107">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1108">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="95bcb-1109">Puntatore al metodo di cui effettuare il marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1109">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="95bcb-1110">Puntatore alla firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1110">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="95bcb-1111">Numero di byte in <c>pbSignature</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1111">The number of bytes in <c>pbSignature</c>.</span></span></param>
        <summary><span data-ttu-id="95bcb-1112">Ottiene un puntatore a una funzione generata a runtime che effettua il marshalling di una chiamata da codice non gestito a codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1112">Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1113">Puntatore a una funzione che eseguirà il marshalling di una chiamata da <paramref name="pfnMethodToWrap" /> al codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1113">A pointer to a function that will marshal a call from <paramref name="pfnMethodToWrap" /> to managed code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> viene esposta per il supporto del compilatore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1115">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1115">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1116">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1116">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-1117">Oggetto da controllare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1117">The object to check.</span></span></param>
        <summary><span data-ttu-id="95bcb-1118">Indica se un oggetto specificato rappresenta un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1118">Indicates whether a specified object represents a COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="95bcb-1119"><see langword="true" /> se il parametro <paramref name="o" /> è un tipo COM; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1119"><see langword="true" /> if the <paramref name="o" /> parameter is a COM type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> Restituisce `true` se il tipo di classe dell'istanza è attribuito <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> o se deriva direttamente o indirettamente da una classe con attributi <xref:System.Runtime.InteropServices.ComImportAttribute>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> returns `true` if the class type of the instance is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> or if it derives directly or indirectly from a class attributed with <xref:System.Runtime.InteropServices.ComImportAttribute>.</span></span> <span data-ttu-id="95bcb-1121">Il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento applica questo attributo per l'utente quando si importa una libreria dei tipi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1121">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span>  
  
 <span data-ttu-id="95bcb-1122">Altri due metodi inoltre determinano se un oggetto specificato rappresenta un oggetto COM, ma i requisiti per la restituzione `true` differiscono dai requisiti di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1122">Two other methods also determine whether a specified object represents a COM object, but the requirements for returning `true` differ from this method's requirements.</span></span> <span data-ttu-id="95bcb-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> Restituisce `true` se la classe (o l'interfaccia) è attribuito <xref:System.Runtime.InteropServices.ComImportAttribute> direttamente; non restituisce `true` per i tipi derivati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> returns `true` if the class (or interface) is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> directly; it does not return `true` for derived types.</span></span> <span data-ttu-id="95bcb-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> Restituisce `true` se il tipo è attribuito <xref:System.Runtime.InteropServices.ComImportAttribute> o deriva da un tipo con lo stesso GUID.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> returns `true` if the type is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> or derives from a type with the same GUID.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1125"><paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1125"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-1126">Tipo di cui verificare la visibilità COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1126">The type to check for COM visibility.</span></span></param>
        <summary><span data-ttu-id="95bcb-1127">Indica se un tipo è visibile ai client COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1127">Indicates whether a type is visible to COM clients.</span></span></summary>
        <returns>
          <span data-ttu-id="95bcb-1128"><see langword="true" /> se il tipo è visibile a COM. In caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1128"><see langword="true" /> if the type is visible to COM; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> Consente di controllare la visibilità COM in un unico passaggio.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> enables you to check for COM visibility in one step.</span></span> <span data-ttu-id="95bcb-1130">Impossibile utilizzare tipi che non sono visibili da COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1130">Types that are not visible cannot be used from COM.</span></span> <span data-ttu-id="95bcb-1131">Un tipo è visibile se è `public` e non è nascosto mediante il <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1131">A type is visible if it is `public` and not hidden with the <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="95bcb-1132">Metodo da controllare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1132">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="95bcb-1133">Calcola il numero di byte nella memoria non gestita necessari per contenere i parametri per il metodo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1133">Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1134">Numero di byte necessari per rappresentare i parametri del metodo nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1134">The number of bytes required to represent the method parameters in unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1135">Il <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> metodo restituisce la dimensione dello stack (in byte) necessaria per rappresentare i parametri di una firma del metodo nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1135">The <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</span></span>  
  
 <span data-ttu-id="95bcb-1136">Si noti che il valore restituito di questo metodo è dipendente dalla piattaforma.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1136">Note that the return value of this method is platform-dependent.</span></span> <span data-ttu-id="95bcb-1137">Una firma con un solo parametro integer, ad esempio, restituisce un valore pari a 4 in piattaforme a 32 bit e un valore pari a 8 su piattaforme a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1137">For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1138">Il valore del parametro <paramref name="m" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1138">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1139">Il parametro <paramref name="m" /> non è un oggetto <see cref="T:System.Reflection.MethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1139">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1140">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1140">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1141">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1141">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-1142">Tipo di valore o tipo di riferimento formattato che specifica la classe gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1142">A value type or formatted reference type that specifies the managed class.</span></span> <span data-ttu-id="95bcb-1143">È necessario applicare <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> alla classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1143">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> to the class.</span></span></param>
        <param name="fieldName"><span data-ttu-id="95bcb-1144">Campo all'interno del parametro <c>t</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1144">The field within the <c>t</c> parameter.</span></span></param>
        <summary><span data-ttu-id="95bcb-1145">Restituisce l'offset del campo della forma non gestita della classe gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1145">Returns the field offset of the unmanaged form of the managed class.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1146">Offset, in byte, per il parametro <paramref name="fieldName" /> all'interno della classe specificata dichiarata tramite platform invoke.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1146">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> fornisce la differenza in termini di layout della struttura non gestita, che non corrisponde necessariamente all'offset del layout della struttura gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="95bcb-1148">Il marshalling della struttura, è possibile trasformare il layout e modificare l'offset.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1148">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="95bcb-1149">Il `t` parametro può essere un tipo di valore o un tipo di riferimento formattato (con layout sequenziale o esplicito).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1149">The `t` parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="95bcb-1150">È possibile ottenere la dimensione dell'intero layout utilizzando il <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1150">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="95bcb-1151">Per ulteriori informazioni, vedere [di marshalling predefinito per i tipi valore](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1151">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-1152">A partire da .NET Framework versione 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> può esporre campi privati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1152">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1153">La classe non può essere esportata come struttura o il campo è non pubblico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1153">The class cannot be exported as a structure or the field is nonpublic.</span></span> <span data-ttu-id="95bcb-1154">A partire da .NET Framework versione 2.0, il campo può essere privato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1154">Beginning with the .NET Framework version 2.0, the field may be private.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1155">Il valore del parametro <paramref name="t" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1155">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1156">Tipo di valore definito o tipo di riferimento formattato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1156">A managed value type or formatted reference type.</span></span> <span data-ttu-id="95bcb-1157">È necessario applicare l'attributo <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> alla classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1157">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute to the class.</span></span></typeparam>
        <param name="fieldName"><span data-ttu-id="95bcb-1158">Nome del campo nel tipo <c>T</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1158">The name of the field in the <c>T</c> type.</span></span></param>
        <summary><span data-ttu-id="95bcb-1159">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1159">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1160">Restituisce l'offset del campo della forma non gestita della classe gestita specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1160">Returns the field offset of the unmanaged form of a specified managed class.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1161">Offset, in byte, per il parametro <paramref name="fieldName" /> all'interno della classe specificata dichiarata tramite platform invoke.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1161">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> fornisce la differenza in termini di layout della struttura non gestita, che non corrisponde necessariamente all'offset del layout della struttura gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="95bcb-1163">Il marshalling della struttura, è possibile trasformare il layout e modificare l'offset.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1163">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="95bcb-1164">Il `T` parametro di tipo generico può essere un tipo di valore o un tipo di riferimento formattato (con layout sequenziale o esplicito).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1164">The `T` generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="95bcb-1165">È possibile ottenere la dimensione dell'intero layout utilizzando il <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1165">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method.</span></span> <span data-ttu-id="95bcb-1166">Per ulteriori informazioni, vedere [di marshalling predefinito per i tipi valore](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1166">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-1167">A partire da .NET Framework versione 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> può esporre campi privati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1167">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="95bcb-1168">Metodo da controllare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1168">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="95bcb-1169">Esegue in un'unica operazione le attività di configurazione del metodo senza chiamarlo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1169">Executes one-time method setup tasks without calling the method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1170">Attività di configurazione forniscono prima inizializzazione e vengono eseguite automaticamente quando viene richiamato il metodo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1170">Setup tasks provide early initialization and are performed automatically when the target method is invoked.</span></span> <span data-ttu-id="95bcb-1171">Le prime attività includono:</span><span class="sxs-lookup"><span data-stu-id="95bcb-1171">First-time tasks include the following:</span></span>  
  
-   <span data-ttu-id="95bcb-1172">Verifica che i metadati PInvoke è formattato correttamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1172">Verifying that the platform invoke metadata is correctly formatted.</span></span>  
  
-   <span data-ttu-id="95bcb-1173">Verifica che tutti i tipi gestiti sono parametri validi della piattaforma di richiamare le funzioni.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1173">Verifying that all the managed types are valid parameters of platform invoke functions.</span></span>  
  
-   <span data-ttu-id="95bcb-1174">Individuare e caricare la DLL non gestita nel processo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1174">Locating and loading the unmanaged DLL into the process.</span></span>  
  
-   <span data-ttu-id="95bcb-1175">Individuare il punto di ingresso del processo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1175">Locating the entry point in the process.</span></span>  
  
 <span data-ttu-id="95bcb-1176">La chiamata <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> su un metodo all'esterno di platform invoke non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1176">Calling <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> on a method outside of platform invoke has no effect.</span></span> <span data-ttu-id="95bcb-1177">Per eseguire il programma di installazione nella piattaforma tutte le attività chiamare i metodi in un tipo, utilizzare <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1177">To execute setup tasks on all platform invoke methods in a type, use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1178">Il valore del parametro <paramref name="m" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1178">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1179">Il parametro <paramref name="m" /> non è un oggetto <see cref="T:System.Reflection.MethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1179">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1180">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1180">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1181">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1181">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="95bcb-1182">Classe di cui è necessario controllare metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1182">The class whose methods are to be checked.</span></span></param>
        <summary><span data-ttu-id="95bcb-1183">Esegue un controllo pre-collegamento per tutti i metodi di una classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1183">Performs a pre-link check for all methods on a class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1184">Il <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> Richiama metodo <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> su ogni metodo per un determinato tipo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1184">The <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> method invokes <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> on every method for a given type.</span></span> <span data-ttu-id="95bcb-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> esegue attività di configurazione in un'unica operazione senza chiamare ogni metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> executes one-time method setup tasks without calling each method.</span></span> <span data-ttu-id="95bcb-1186">È possibile utilizzare <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> solo per chiamate platform invoke.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1186">You can use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> only for platform invoke calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1187">Il valore del parametro <paramref name="c" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1187">The <paramref name="c" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1188">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1188">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1189">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1190">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia tutta o parte di una stringa ANSI non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1190">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged ANSI string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1191">L'indirizzo del primo carattere della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1191">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="95bcb-1192">Copia tutti i caratteri fino al primo carattere Null da una stringa ANSI non gestita a un oggetto <see cref="T:System.String" /> gestito e trasforma ogni carattere ANSI in Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1192">Copies all characters up to the first null character from an unmanaged ANSI string to a managed <see cref="T:System.String" />, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1193">Stringa gestita che contiene una copia della stringa ANSI non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1193">A managed string that holds a copy of the unmanaged ANSI string.</span></span> <span data-ttu-id="95bcb-1194">Se <paramref name="ptr" /> è <see langword="null" />, il metodo restituisce una stringa Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1194">If <paramref name="ptr" /> is <see langword="null" />, the method returns a null string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1196">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1196">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1197">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1197">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1198">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> metodo per creare una stringa gestita da una funzione non gestita `char` matrice.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1198">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged `char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1199">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1200">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1201">L'indirizzo del primo carattere della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1201">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="95bcb-1202">Conteggio dei byte della stringa di input da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1202">The byte count of the input string to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1203">Alloca un oggetto <see cref="T:System.String" /> gestito, vi copia un numero di caratteri specificato da una stringa ANSI non gestita e trasforma ciascun carattere ANSI nel formato Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1203">Allocates a managed <see cref="T:System.String" />, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1204">Stringa gestita contenente una copia della stringa ANSI nativa se il valore del parametro <paramref name="ptr" /> non è <see langword="null" />; in caso contrario, il metodo restituisce <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1204">A managed string that holds a copy of the native ANSI string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1206">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1206">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1207">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1207">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1208">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> metodo per creare una stringa gestita da una funzione non gestita`char` matrice.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1208">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged`char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1209"><paramref name="len" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1209"><paramref name="len" /> is less than zero.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1210">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1210">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1211">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1211">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1212">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia tutta o parte di una stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1212">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1213">Per le piattaforme Unicode, l'indirizzo del primo carattere Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1213">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="95bcb-1214">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1214">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1215">Per le piattaforme ANSI, l'indirizzo del primo carattere ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1215">For ANSI plaforms, the address of the first ANSI character.</span></span></param>
        <summary><span data-ttu-id="95bcb-1216">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia tutti i caratteri fino al primo carattere null da una stringa archiviata nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1216">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1217">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <paramref name="ptr" /> non è <see langword="null" />; in caso contrario, questo metodo restituisce <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1217">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1218">Se la piattaforma corrente è Unicode, ogni carattere ANSI viene trasformato in un carattere Unicode e questo metodo chiama <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1218">If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span></span> <span data-ttu-id="95bcb-1219">In caso contrario, questo metodo chiama <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1219">Otherwise, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span>  
  
 <span data-ttu-id="95bcb-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1221">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1221">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> fornisce la funzionalità di opposto di <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1223">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1223">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1224">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1224">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1225">Per le piattaforme Unicode, l'indirizzo del primo carattere Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1225">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="95bcb-1226">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1226">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1227">Per le piattaforme ANSI, l'indirizzo del primo carattere ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1227">For ANSI plaforms, the address of the first ANSI character.</span></span></param>
        <param name="len"><span data-ttu-id="95bcb-1228">Numero di caratteri da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1228">The number of characters to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1229">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia il numero di caratteri specificato da una stringa archiviata nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1229">Allocates a managed <see cref="T:System.String" /> and copies the specified number of characters from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1230">Stringa gestita che contiene una copia della stringa nativa se il valore del parametro <paramref name="ptr" /> non è <see langword="null" />; in caso contrario, questo metodo restituisce <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1230">A managed string that holds a copy of the native string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1231">Su piattaforme Unicode, questo metodo chiama <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; piattaforme ANSI, chiama <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1231">On Unicode platforms, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; on ANSI platforms, it calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span> <span data-ttu-id="95bcb-1232">Prima di questi metodi vengono chiamati, viene eseguita alcuna trasformazione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1232">No transformations are done before these methods are called.</span></span>  
  
 <span data-ttu-id="95bcb-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1234">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1234">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> fornisce la funzionalità di opposto <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1236"><paramref name="len" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1236"><paramref name="len" /> is less than zero.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1237">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1237">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1238">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1238">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1239">L'indirizzo del primo carattere della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1239">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="95bcb-1240">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia una [stringa binaria (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) archiviata nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1240">Allocates a managed <see cref="T:System.String" /> and copies a [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1241">Stringa gestita che contiene una copia della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1241">A managed string that holds a copy of the unmanaged string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1242">Chiamare questo metodo solo su stringhe allocate con le [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) e [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) funzioni.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1242">Call this method only on strings that were allocated with the unmanaged [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) and [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) functions.</span></span>  
  
 <span data-ttu-id="95bcb-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1244">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1244">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1245">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1245">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1246"><paramref name="ptr" /> è uguale a <see cref="F:System.IntPtr.Zero" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1246"><paramref name="ptr" /> equals <see cref="F:System.IntPtr.Zero" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1247">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1247">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1248">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1248">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1249">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia tutta o parte di una stringa Unicode non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1249">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged Unicode string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1250">L'indirizzo del primo carattere della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1250">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="95bcb-1251">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia tutti i caratteri fino al primo carattere Null da una stringa Unicode non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1251">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1252">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <paramref name="ptr" /> non è <see langword="null" />; in caso contrario, questo metodo restituisce <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1252">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1254">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1254">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1255">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1255">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1256">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1256">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1257">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1257">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1258">L'indirizzo del primo carattere della stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1258">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="95bcb-1259">Numero di caratteri Unicode da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1259">The number of Unicode characters to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1260">Alloca un oggetto <see cref="T:System.String" /> gestito e vi copia un numero di caratteri specificato da una stringa Unicode non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1260">Allocates a managed <see cref="T:System.String" /> and copies a specified number of characters from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1261">Stringa gestita che contiene una copia della stringa non gestita se il valore del parametro <paramref name="ptr" /> non è <see langword="null" />; in caso contrario, questo metodo restituisce <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1261">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1263">Poiché questo metodo crea una copia del contenuto della stringa non gestita, è necessario liberare la stringa originale come appropriato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1263">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="95bcb-1264">Questo metodo fornisce la funzionalità opposta rispetto di <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1264">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1265">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1265">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1266">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1266">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1267">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1267">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1268">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1268">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="95bcb-1269">Oggetto nel quale devono essere copiati i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1269">The object to which the data is to be copied.</span></span> <span data-ttu-id="95bcb-1270">Deve essere un'istanza di una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1270">This must be an instance of a formatted class.</span></span></param>
        <summary><span data-ttu-id="95bcb-1271">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1271">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come un <xref:System.IntPtr?displayProperty=nameWithType> valore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="95bcb-1273">È possibile utilizzare questo metodo di overload con tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1273">You cannot use this overload method with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1274">Il layout della struttura non è sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1274">Structure layout is not sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1275">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1275">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1276">La struttura è un tipo valore boxed.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1276">Structure is a boxed value type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1277">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1277">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1278">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1278">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1279">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1279">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structureType"><span data-ttu-id="95bcb-1280">Tipo di oggetto da creare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1280">The type of object to be created.</span></span> <span data-ttu-id="95bcb-1281">Questo oggetto deve rappresentare una classe formattata o una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1281">This object must represent a formatted class or a structure.</span></span></param>
        <summary><span data-ttu-id="95bcb-1282">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito appena allocato del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1282">Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1283">Oggetto gestito contenente i dati a cui punta il parametro <paramref name="ptr" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1283">A managed object containing the data pointed to by the <paramref name="ptr" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come un <xref:System.IntPtr?displayProperty=nameWithType> valore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="95bcb-1285">È possibile passare un tipo di valore a questo metodo di overload.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1285">You can pass a value type to this overload method.</span></span> <span data-ttu-id="95bcb-1286">In questo caso, l'oggetto restituito è un'istanza di tipo boxed.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1286">In this case, the returned object is a boxed instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1287">Nell'esempio seguente viene creata una struttura gestita, trasferirla in memoria non gestita e quindi lo trasferisce alla memoria gestita tramite il <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1287">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 <span data-ttu-id="95bcb-1288">Nell'esempio seguente viene illustrato come effettuare il marshalling di un blocco di memoria da una struttura gestita tramite non gestita di <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1288">The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bcb-1289">Questo codice si presuppone la compilazione a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1289">This code assumes 32-bit compilation.</span></span> <span data-ttu-id="95bcb-1290">Prima di usare un compilatore a 64 bit, sostituire <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> con <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1290">Before using a 64-bit compiler, replace <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> with <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1291">Il layout del parametro <paramref name="structureType" /> non è sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1291">The <paramref name="structureType" /> parameter layout is not sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1292">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1292">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1293">Il parametro <paramref name="structureType" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1293">The <paramref name="structureType" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1294"><paramref name="structureType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1294"><paramref name="structureType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="95bcb-1295">La classe specificata da <paramref name="structureType" /> non dispone di un costruttore predefinito accessibile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1295">The class specified by <paramref name="structureType" /> does not have an accessible default constructor.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1296">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1296">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1297">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1297">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1298">Tipo dell'oggetto nel quale devono essere copiati i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1298">The type of the object to which the data is to be copied.</span></span> <span data-ttu-id="95bcb-1299">Questo deve rappresentare una classe formattata o una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1299">This must be a formatted class or a structure.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="95bcb-1300">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1300">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="95bcb-1301">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1301">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1302">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito appena allocato del tipo specificato per un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1302">Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1303">Oggetto gestito che contiene i dati a cui punta il parametro <paramref name="ptr" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1303">A managed object that contains the data that the <paramref name="ptr" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come <xref:System.IntPtr?displayProperty=nameWithType> valori.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="95bcb-1305">È possibile passare un tipo di valore a questo overload di metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1305">You can pass a value type to this method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1306">Il layout di <typeparamref name="T" /> non è sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1306">The layout of <typeparamref name="T" /> is not sequential or explicit.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="95bcb-1307">La classe specificata da <typeparamref name="T" /> non dispone di un costruttore predefinito accessibile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1307">The class specified by <typeparamref name="T" /> does not have an accessible default constructor.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1308">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1308">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1309">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1309">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1310">Il tipo di <c>struttura</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1310">The type of <c>structure</c>.</span></span> <span data-ttu-id="95bcb-1311">Deve essere una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1311">This must be a formatted class.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="95bcb-1312">Puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1312">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="95bcb-1313">Oggetto nel quale devono essere copiati i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1313">The object to which the data is to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1314">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1314">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1315">Effettua il marshalling di dati da un blocco di memoria non gestita a un oggetto gestito di un tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1315">Marshals data from an unmanaged block of memory to a managed object of the specified type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> è spesso necessario in COM interoperabilità e platform invoke quando i parametri della struttura sono rappresentati come <xref:System.IntPtr> valori.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr> values.</span></span> <span data-ttu-id="95bcb-1317">È possibile utilizzare questo overload del metodo con i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1317">You cannot use this method overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1318">Il layout della struttura non è sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1318">Structure layout is not sequential or explicit.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1319">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1319">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1320">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1320">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="95bcb-1321">Interfaccia su cui eseguire una query.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1321">The interface to be queried.</span></span></param>
        <param name="iid"><span data-ttu-id="95bcb-1322">Identificatore di interfaccia (IID) dell'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1322">The interface identifier (IID) of the requested interface.</span></span></param>
        <param name="ppv"><span data-ttu-id="95bcb-1323">Quando questo metodo restituisce un risultato, contiene un riferimento all'interfaccia restituita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1323">When this method returns, contains a reference to the returned interface.</span></span></param>
        <summary><span data-ttu-id="95bcb-1324">Richiede un puntatore a un'interfaccia specificata da un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1324">Requests a pointer to a specified interface from a COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1325">HRESULT che indica l'esito positivo o negativo della chiamata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1325">An HRESULT that indicates the success or failure of the call.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1326">Il <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> metodo espone il [IUnknown:: QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) metodo di un oggetto COM, che tenta di ottenere un puntatore a interfaccia specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1326">The <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> method exposes the [IUnknown::QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) method of a COM object, which attempts to obtain a specific interface pointer.</span></span> <span data-ttu-id="95bcb-1327">Utilizzando `QueryInterface` su una COM oggetto è uguale all'esecuzione di un'operazione cast in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1327">Using `QueryInterface` on a COM object is the same as performing a cast operation in managed code.</span></span> <span data-ttu-id="95bcb-1328">La chiamata di un oggetto con questo metodo determina il conteggio dei riferimenti incrementare sul puntatore a interfaccia prima che venga restituito il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1328">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="95bcb-1329">Utilizzare sempre <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> per decrementare il conteggio dei riferimenti dopo aver completato con il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1329">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="95bcb-1330">Per ottenere un <xref:System.IntPtr> valore che rappresenta un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore a interfaccia, è possibile chiamare <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, o <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1330">To obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer, you can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1331">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1331">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1332">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1332">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1333">Legge un singolo byte da memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1333">Reads a single byte from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1334">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1334">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1335">Indirizzo nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1335">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="95bcb-1336">Legge un singolo byte da memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1336">Reads a single byte from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1337">Byte letto da memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1337">The byte read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> dispone di un offset implicito di 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> has an implied offset of 0.</span></span> <span data-ttu-id="95bcb-1339">Questo metodo consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1339">This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1340">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1340">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1341">Nell'esempio seguente viene creato un blocco di memoria non gestita, scrive un byte nella memoria non gestita, legge i byte da memoria non gestita e quindi elimina la memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1341">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 <span data-ttu-id="95bcb-1342">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metodo per leggere il valore di un carattere non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1342">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1343"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1343"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1344">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1344">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1345"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1345"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1346">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1346">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1347"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1347"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1348">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1348">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1349">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1349">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1350">Indirizzo di base nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1350">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1351">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1351">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1352">Legge un singolo byte in base a un determinato offset (o indice) dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1352">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1353">Byte letto da memoria non gestita all'offset fornito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1353">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1355">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1355">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1356">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1356">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 <span data-ttu-id="95bcb-1357">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metodo per leggere il valore di un carattere non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1357">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1358">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1358">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1359">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1359">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1360">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1360">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1361">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1361">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1362">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1362">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1363">Legge un singolo byte in base a un determinato offset (o indice) dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1363">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1364">Byte letto da memoria non gestita all'offset fornito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1364">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1366">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1366">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1367">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1367">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1368"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1368"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1369">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1369">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1370">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1370">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1371">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1371">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1372">Legge un valore intero con segno a 16 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1372">Reads a 16-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1373">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1373">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1374">Indirizzo nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1374">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="95bcb-1375">Legge un valore intero con segno a 16 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1375">Reads a 16-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1376">Intero con segno a 16 bit letto dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1376">The 16-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> dispone di un offset implicito di 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> has an implied offset of 0.</span></span> <span data-ttu-id="95bcb-1378">Questo metodo consente l'interazione diretta con un tipo non gestito C `Int16` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1378">This method enables direct interaction with an unmanaged C-style `Int16` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1379">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1379">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1380">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1380">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="95bcb-1381">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metodo per leggere il valore di una funzione non gestita `short` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1381">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1382"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1382"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1383">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1383">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1384"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1384"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1385">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1385">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1386"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1386"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1387">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1387">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1388">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1388">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1389">Indirizzo di base nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1389">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1390">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1390">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1391">Legge un intero con segno a 16 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1391">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1392">Intero con segno a 16 bit letto dalla memoria non gestita a un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1392">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1394">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1394">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1395">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1395">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="95bcb-1396">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metodo per leggere il valore di una funzione non gestita `short` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1396">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1397">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1397">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1398">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1398">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1399">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1399">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1400">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1400">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1401">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1401">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1402">Legge un intero con segno a 16 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1402">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1403">Intero con segno a 16 bit letto dalla memoria non gestita a un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1403">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1405">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1405">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1406">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1406">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1407"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1407"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1408">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1408">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1409">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1409">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1410">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1410">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1411">Legge un valore intero con segno a 32 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1411">Reads a 32-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1412">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1412">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1413">Indirizzo nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1413">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="95bcb-1414">Legge un valore intero con segno a 32 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1414">Reads a 32-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1415">Intero con segno a 32 bit letto dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1415">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> dispone di un offset implicito di 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> has an implied offset of 0.</span></span> <span data-ttu-id="95bcb-1417">Questo metodo consente l'interazione diretta con un tipo non gestito C `Int32` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1417">This method enables direct interaction with an unmanaged C-style `Int32` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1418">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1418">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1419">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1419">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="95bcb-1420">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metodo per leggere il valore di una funzione non gestita `int` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1420">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1421"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1421"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1422">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1422">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1423"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1423"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1424">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1424">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1425"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1425"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1426">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1426">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1427">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1427">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1428">Indirizzo di base nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1428">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1429">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1429">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1430">Legge un Intero con segno a 32 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1430">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1431">Intero con segno a 32 bit letto dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1431">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1433">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1433">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1434">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1434">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="95bcb-1435">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metodo per leggere il valore di una funzione non gestita `int` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1435">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1436">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1436">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1437">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1437">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1438">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1438">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1439">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1439">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1440">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1440">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1441">Legge un Intero con segno a 32 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1441">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1442">Intero con segno a 32 bit letto dalla memoria non gestita a un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1442">The 32-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1444">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1444">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1445">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1445">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1446"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1446"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1447">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1447">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1448">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1448">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1449">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1449">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1450">Legge un valore intero con segno a 64 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1450">Reads a 64-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1451">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1451">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1452">Indirizzo nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1452">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="95bcb-1453">Legge un valore intero con segno a 64 bit dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1453">Reads a 64-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1454">Intero con segno a 64 bit letto dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1454">The 64-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> dispone di un offset implicito di 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> has an implied offset of 0.</span></span> <span data-ttu-id="95bcb-1456">Questo metodo consente l'interazione diretta con un tipo non gestito C `Int64` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1456">This method enables direct interaction with an unmanaged C-style `Int64` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1457">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1457">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1458">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1458">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="95bcb-1459">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metodo per leggere il valore di una funzione non gestita `__int64` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1459">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1460"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1460"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1461">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1461">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1462"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1462"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1463">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1463">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1464"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1464"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1465">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1465">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1466">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1466">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1467">Indirizzo di base nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1467">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1468">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1468">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1469">Legge un Intero con segno a 64 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1469">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1470">Intero con segno a 64 bit letto dalla memoria non gestita a un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1470">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1472">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1472">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1473">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1473">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="95bcb-1474">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metodo per leggere il valore di una funzione non gestita `__int64` variabile.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1474">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1475">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1475">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1476">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1476">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1477">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1477">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1478">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1478">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1479">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1479">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1480">Legge un Intero con segno a 64 bit a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1480">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1481">Intero con segno a 64 bit letto dalla memoria non gestita a un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1481">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1483">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1483">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1484">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1484">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1485"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1485"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1486">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1486">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1487">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1487">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1488">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1488">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1489">Legge un valore intero della dimensione nativa del processore dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1489">Reads a processor native sized integer from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1490">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1490">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1491">Indirizzo nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1491">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="95bcb-1492">Legge un intero di dimensioni native del processore dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1492">Reads a processor native-sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1493">Intero letto da memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1493">The integer read from unmanaged memory.</span></span> <span data-ttu-id="95bcb-1494">In computer a 32 bit viene restituito un intero a 32 bit, mentre in computer a 64 bit viene restituito un intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1494">A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> dispone di un offset implicito di 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> has an implied offset of 0.</span></span> <span data-ttu-id="95bcb-1496">Questo metodo consente l'interazione diretta con un tipo non gestito C `IntPtr` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1496">This method enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1497">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1497">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1498">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1498">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1499"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1499"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1500">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1500">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1501"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1501"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1502">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1502">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1503"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1503"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1504">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1504">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1505">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1505">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1506">Indirizzo di base nella memoria non gestita da cui leggere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1506">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1507">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1507">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1508">Legge un intero di dimensioni native del processore a un offset specificato dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1508">Reads a processor native sized integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1509">Intero letto da memoria non gestita all'offset fornito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1509">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> Consente l'interazione diretta con un tipo non gestito C `IntPtr` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1511">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1511">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1512">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1512">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1513">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1513">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1514">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1514">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1515">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1515">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1516">Indirizzo di base dell'oggetto di origine nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1516">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1517">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1517">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="95bcb-1518">Legge un valore intero della dimensione nativa del processore dalla memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1518">Reads a processor native sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1519">Intero letto da memoria non gestita all'offset fornito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1519">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> Consente l'interazione diretta con un tipo non gestito C `IntPtr` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di leggere i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1521">La lettura da posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1521">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1522">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1522">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1523"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1523"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1524">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1524">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1525">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1525">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1526">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1526">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="95bcb-1527">Puntatore alla memoria allocata con <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1527">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="95bcb-1528">Nuova dimensione del blocco allocato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1528">The new size of the allocated block.</span></span></param>
        <summary><span data-ttu-id="95bcb-1529">Ridimensiona un blocco di memoria allocato in precedenza con <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1529">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1530">Intero che rappresenta l'indirizzo del blocco di memoria riallocato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1530">An integer representing the address of the reallocated block of memory.</span></span> <span data-ttu-id="95bcb-1531">Questa memoria deve essere liberata con <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1531">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> è uno dei due metodi di riallocazione della memoria nella <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> is one of two memory reallocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="95bcb-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> è l'altro.) Inizio del contenuto della memoria riallocata corrisponde al contenuto originale. Tuttavia, è possibile l'intero blocco di memoria in un percorso diverso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</span></span> <span data-ttu-id="95bcb-1534">Questo metodo espone il COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) funzione, viene considerato l'allocatore di memoria delle attività COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1534">This method exposes the COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1535">Memoria insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1535">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1536">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1536">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1537">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1537">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="95bcb-1538">Puntatore alla memoria allocata con <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1538">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="95bcb-1539">Nuova dimensione del blocco allocato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1539">The new size of the allocated block.</span></span> <span data-ttu-id="95bcb-1540">Non si tratta di un puntatore; corrisponde al conteggio dei byte richiesti, di cui è stato eseguito il cast al tipo <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1540">This is not a pointer; it is the byte count you are requesting, cast to type <see cref="T:System.IntPtr" />.</span></span> <span data-ttu-id="95bcb-1541">Se si passa un puntatore, viene trattato come una dimensione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1541">If you pass a pointer, it is treated as a size.</span></span></param>
        <summary><span data-ttu-id="95bcb-1542">Ridimensiona un blocco di memoria allocato in precedenza con <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1542">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1543">Puntatore alla memoria riallocata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1543">A pointer to the reallocated memory.</span></span> <span data-ttu-id="95bcb-1544">Questa memoria deve essere liberata usando <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1544">This memory must be released using <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> è una delle operazioni di riallocazione della memoria due metodi API di <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is one of two memory reallocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="95bcb-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> è l'altro.)</span><span class="sxs-lookup"><span data-stu-id="95bcb-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> is the other.)</span></span>  
  
 <span data-ttu-id="95bcb-1547">Questo metodo espone Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) funzione da Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1547">This method exposes the Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) function from Kernel32.dll.</span></span> <span data-ttu-id="95bcb-1548">Il puntatore restituito può essere diverso dall'originale.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1548">The returned pointer can differ from the original.</span></span> <span data-ttu-id="95bcb-1549">Se è diverso, il contenuto del blocco di memoria originale è stato copiato nel nuovo blocco e il blocco di memoria originale è stato liberato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1549">If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1550">Memoria insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1550">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1551">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1551">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1552">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1552">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="95bcb-1553">Interfaccia da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1553">The interface to release.</span></span></param>
        <summary><span data-ttu-id="95bcb-1554">Riduce il numero di riferimenti nell'interfaccia specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1554">Decrements the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1555">Nuovo valore del numero di riferimenti nell'interfaccia specificata dal parametro <paramref name="pUnk" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1555">The new value of the reference count on the interface specified by the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1556">Common language runtime gestisce il conteggio dei riferimenti di un oggetto COM per l'utente, rendendo non è necessario utilizzare questo metodo direttamente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1556">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="95bcb-1557">Utilizzare questo valore solo a scopo di test.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1557">Use this value only for testing purposes.</span></span> <span data-ttu-id="95bcb-1558">In rari casi, ad esempio test di un gestore di marshalling personalizzato, potrebbe essere necessario modificare manualmente la durata dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1558">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="95bcb-1559">Solo i programmi che chiamano <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> deve chiamare <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1559">Only programs that call <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> should call <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span></span> <span data-ttu-id="95bcb-1560">La chiamata <xref:System.Runtime.InteropServices.Marshal.Release%2A> il conteggio dei riferimenti raggiunge zero causa un comportamento indefinito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1560">Calling <xref:System.Runtime.InteropServices.Marshal.Release%2A> after the reference count has reached zero causes undefined behavior.</span></span>  
  
 <span data-ttu-id="95bcb-1561">È possibile chiamare <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, o <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> per ottenere un <xref:System.IntPtr> valore che rappresenta un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) puntatore a interfaccia da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1561">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer to release.</span></span> <span data-ttu-id="95bcb-1562">È inoltre possibile utilizzare questi metodi e <xref:System.Runtime.InteropServices.Marshal.Release%2A> metodo su oggetti gestiti per rilasciare le interfacce COM rappresentate dall'oggetto gestito [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1562">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method on managed objects to release the COM interfaces represented by the managed object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1563">Nell'esempio seguente viene illustrato come recuperare un `IUnknown` interfaccia per un oggetto gestito utilizzando il <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1563">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span> <span data-ttu-id="95bcb-1564">Nell'esempio viene quindi rilascia il puntatore a interfaccia chiamando il <xref:System.Runtime.InteropServices.Marshal.Release%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1564">The example then releases the interface pointer by calling the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1565">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1565">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1566">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1566">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="95bcb-1567">Oggetto COM da rilasciare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1567">The COM object to release.</span></span></param>
        <summary><span data-ttu-id="95bcb-1568">Decrementa il conteggio dei riferimenti del [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) associato all'oggetto COM specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1568">Decrements the reference count of the [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) associated with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1569">Nuovo valore del conteggio dei riferimenti dell'RCW associato a <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1569">The new value of the reference count of the RCW associated with <paramref name="o" />.</span></span> <span data-ttu-id="95bcb-1570">Questo valore in genere è zero poiché RCW conserva solo un riferimento all'oggetto COM incluso indipendentemente dal numero dei client gestiti che lo chiamano.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1570">This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1571">Questo metodo viene utilizzato per controllare in modo esplicito la durata di un oggetto COM dal codice gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1571">This method is used to explicitly control the lifetime of a COM object used from managed code.</span></span> <span data-ttu-id="95bcb-1572">Utilizzare questo metodo per liberare l'oggetto COM sottostante che contiene i riferimenti alle risorse in modo tempestivo o quando gli oggetti devono essere liberati in un ordine specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1572">You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</span></span>  
  
 <span data-ttu-id="95bcb-1573">Ogni volta che un puntatore a interfaccia COM entra in common language runtime (CLR), viene eseguito il wrapping in un RCW.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1573">Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</span></span>  
  
 <span data-ttu-id="95bcb-1574">Il wrapper RCW presenta un conteggio di riferimenti viene incrementato ogni volta che viene eseguito il mapping di un puntatore a interfaccia COM a esso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1574">The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</span></span> <span data-ttu-id="95bcb-1575">Il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo decrementa il conteggio dei riferimenti di un RCW.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1575">The <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method decrements the reference count of an RCW.</span></span> <span data-ttu-id="95bcb-1576">Quando il conteggio dei riferimenti arriva a zero, il runtime rilascia tutti i relativi riferimenti all'oggetto COM non gestito e genera un <xref:System.NullReferenceException?displayProperty=nameWithType> se si tenta di utilizzare ulteriormente l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1576">When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <xref:System.NullReferenceException?displayProperty=nameWithType> if you attempt to use the object further.</span></span> <span data-ttu-id="95bcb-1577">Se la stessa interfaccia COM viene passata più volte da non gestito al codice gestito, il conteggio dei riferimenti sul wrapper viene incrementato ogni volta e la chiamata <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> restituisce il numero di riferimenti rimanenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1577">If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> returns the number of remaining references.</span></span>  
  
 <span data-ttu-id="95bcb-1578">Questo metodo consente di forzare una versione di conteggio di riferimento RCW in modo che si verifica con precisione quando si desidera.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1578">This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</span></span> <span data-ttu-id="95bcb-1579">Tuttavia, l'uso improprio di <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> potrebbe rallentare l'applicazione non riesce, o potrebbe causare una violazione di accesso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1579">However, improper use of <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> may cause your application to fail, or may cause an access violation.</span></span>  
  
 <span data-ttu-id="95bcb-1580">Si consideri uno scenario in cui il codice gestito in un dominio applicazione è mantiene un RCW che rappresenta un componente COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1580">Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</span></span> <span data-ttu-id="95bcb-1581">Se si chiama il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo sul RCW, il codice gestito, sarà in grado di accedere a RCW e genererà un <xref:System.Runtime.InteropServices.InvalidComObjectException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1581">If you call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the RCW, the managed code will be unable to access the RCW and will raise an <xref:System.Runtime.InteropServices.InvalidComObjectException> exception.</span></span>  
  
 <span data-ttu-id="95bcb-1582">Se una chiamata a RCW è in esecuzione quando viene rilasciato il RCW, potrebbe verificarsi un errore più grave.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1582">A more serious error may occur if a call to the RCW is executing when the RCW is released.</span></span> <span data-ttu-id="95bcb-1583">In questo caso, è probabile che il thread che effettua la chiamata causerà una violazione di accesso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1583">In this case, there is a good chance that the thread making the call will cause an access violation.</span></span> <span data-ttu-id="95bcb-1584">Tuttavia, potrebbe venire danneggiata memoria del processo e il processo può continuare per l'esecuzione fino a quando non riesce per motivi molto difficili da eseguire il debug.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1584">However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</span></span>  
  
 <span data-ttu-id="95bcb-1585">Questo rischio è maggiore di quando il componente COM che è in uso è un singleton, per il motivo seguente: CLR attiva componenti COM chiamando il componente COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) funzione che restituisce lo stesso puntatore di interfaccia ogni ora che viene chiamato per i componenti COM singleton.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1585">This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) function, which returns the same interface pointer every time it is called for singleton COM components.</span></span> <span data-ttu-id="95bcb-1586">Pertanto, separati e indipendente parti del codice gestito in un dominio applicazione possono utilizzare lo stesso RCW per un componente COM singleton e se uno chiama il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo sul componente COM, l'altro verrà interrotto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1586">Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the COM component, the other will be broken.</span></span>  
  
 <span data-ttu-id="95bcb-1587">Pertanto, utilizzare il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> solo se è assolutamente necessario.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1587">Therefore, use the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> only if it is absolutely required.</span></span> <span data-ttu-id="95bcb-1588">Se si desidera chiamare questo metodo per garantire che un componente COM viene rilasciato in un determinato momento, è consigliabile utilizzare il <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1588">If you want to call this method to ensure that a COM component is released at a determined time, consider using the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method instead.</span></span> <span data-ttu-id="95bcb-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> rilascerà il componente COM sottostante indipendentemente da quante volte è stato immesso nuovamente CLR.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> will release the underlying COM component regardless of how many times it has re-entered the CLR.</span></span> <span data-ttu-id="95bcb-1590">Il conteggio dei riferimenti interni del RCW viene incrementato di uno ogni volta che il componente COM immette nuovamente il CLR.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1590">The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</span></span> <span data-ttu-id="95bcb-1591">Pertanto, è possibile chiamare il <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodo in un ciclo fino a quando il valore restituito è zero.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1591">Therefore, you could call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until the value returned is zero.</span></span> <span data-ttu-id="95bcb-1592">Lo stesso risultato viene ottenuto il <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1592">This achieves the same result as the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1593"><paramref name="o" /> non è un oggetto COM valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1593"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="95bcb-1594"><paramref name="o" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1594"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1595">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1595">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1596">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1596">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bcb-1597">Rilascia la cache del thread.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1597">Releases the thread cache.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1598">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1598">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1599">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1599">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1600">Oggetto gestito da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1600">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1601">Alloca una [stringa binaria (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) non gestita e vi copia il contenuto di un oggetto <see cref="T:System.Security.SecureString" /> gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1601">Allocates an unmanaged [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) and copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1602">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <paramref name="s" />, oppure 0 se è stato fornito un oggetto Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1602">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1603">Il <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1603">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1604">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la `BSTR` termine chiamando il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1604">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1605">Il valore del parametro <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1605">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95bcb-1606">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1606">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1607">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1607">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1608">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1608">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1609">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1609">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="95bcb-1610">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1610">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1611">Oggetto gestito da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1611">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1612">Copia il contenuto di un oggetto <see cref="T:System.Security.SecureString" /> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1612">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1613">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <paramref name="s" />, oppure 0 se è stato fornito un oggetto Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1613">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1614">Il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1614">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1615">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1615">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span></span> <span data-ttu-id="95bcb-1616">I caratteri della stringa vengono copiati come caratteri ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1616">The characters of the string are copied as ANSI characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1617">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metodo per effettuare il marshalling e decrittografare il contenuto di un <xref:System.Security.SecureString> oggetto in un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1617">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="95bcb-1618">Viene quindi utilizzato il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> metodo per azzerare ed eliminare il blocco non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1618">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1619">Il valore del parametro <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1619">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95bcb-1620">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1620">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1621">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1621">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1622">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1622">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1623">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1623">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="95bcb-1624">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1624">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1625">Oggetto gestito da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1625">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1626">Copia il contenuto di un oggetto <see cref="T:System.Security.SecureString" /> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1626">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1627">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <paramref name="s" />, oppure 0 se è stato fornito un oggetto Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1627">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1628">Il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1628">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1629">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1629">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method.</span></span> <span data-ttu-id="95bcb-1630">I caratteri della stringa vengono copiati come caratteri Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1630">The characters of the string are copied as Unicode characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1631">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> metodo per effettuare il marshalling e decrittografare il contenuto di un <xref:System.Security.SecureString> oggetto in un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1631">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="95bcb-1632">Viene quindi utilizzato il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> metodo per azzerare ed eliminare il blocco non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1632">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1633">Il valore del parametro <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1633">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95bcb-1634">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1634">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1635">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1635">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1636">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1636">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1637">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1637">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="95bcb-1638">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1638">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1639">Oggetto gestito da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1639">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1640">Copia il contenuto di un oggetto <see cref="T:System.Security.SecureString" /> gestito nella memoria non gestita, effettuando contemporaneamente la conversione nel formato ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1640">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1641">Indirizzo, nella memoria non gestita, in cui è stato copiato il parametro <paramref name="s" />, oppure 0 se è stato fornito un oggetto Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1641">The address, in unmanaged memory, to where the <paramref name="s" /> parameter was copied, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1642">Il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metodo è utile per il marshalling personalizzato o quando si unisce e codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1642">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1643">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1643">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1644">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metodo per effettuare il marshalling e decrittografare il contenuto di un <xref:System.Security.SecureString> oggetto in un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1644">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="95bcb-1645">Viene quindi utilizzato il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metodo per azzerare ed eliminare il blocco non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1645">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1646">Il valore del parametro <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1646">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95bcb-1647">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1647">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1648">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1648">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1649">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1649">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1650">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1650">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="95bcb-1651">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1651">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1652">Oggetto gestito da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1652">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="95bcb-1653">Copia il contenuto di un oggetto <see cref="T:System.Security.SecureString" /> gestito nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1653">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1654">Indirizzo, nella memoria non gestita, in cui è stato copiato <paramref name="s" /> oppure 0 se <paramref name="s" /> è un oggetto <see cref="T:System.Security.SecureString" /> con lunghezza 0.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1654">The address, in unmanaged memory, where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is a <see cref="T:System.Security.SecureString" /> object whose length is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1655">Il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metodo è utile per il marshalling personalizzato o per l'utilizzo quando la combinazione di codice gestito e.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1655">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1656">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1656">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1657">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metodo con tipo non gestito `LogonUser` funzione per eseguire la rappresentazione con la <xref:System.Security.SecureString> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1657">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="95bcb-1658">Nell'esempio viene utilizzata la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> per azzerare e liberare il riferimento alla stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1658">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1659">Il valore del parametro <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1659">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="95bcb-1660">Il computer corrente non esegue Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1660">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1661">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1661">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1662">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1662">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1663">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1663">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="95bcb-1664">Questo metodo è supportato solo nei computer che eseguono Windows 2000 Service Pack 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1664">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="95bcb-1665">Oggetto COM in cui archiviare i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1665">The COM object in which to store the data.</span></span></param>
        <param name="key"><span data-ttu-id="95bcb-1666">Chiave nella tabella hash interna dell'oggetto COM in cui archiviare i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1666">The key in the internal hash table of the COM object in which to store the data.</span></span></param>
        <param name="data"><span data-ttu-id="95bcb-1667">Dati da impostare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1667">The data to set.</span></span></param>
        <summary><span data-ttu-id="95bcb-1668">Imposta i dati ai quali fa riferimento la chiave specificata nell'oggetto COM specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1668">Sets data referenced by the specified key in the specified COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="95bcb-1669"><see langword="true" /> se i dati sono stati impostati correttamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1669"><see langword="true" /> if the data was set successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1670">Tutti gli oggetti COM di cui è stato eseguito il wrapping in un [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) dispone di una tabella hash associata, a cui <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> aggiunge i dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1670">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) have an associated hash table, to which <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> adds data.</span></span> <span data-ttu-id="95bcb-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> Recupera i dati dalla tabella hash.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> retrieves data from the hash table.</span></span> <span data-ttu-id="95bcb-1672">È necessario non chiamare il metodo dal codice.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1672">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="95bcb-1673"><paramref name="obj" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1673"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1674">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1674">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1675"><paramref name="key" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1675"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1676"><paramref name="obj" /> non è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1676"><paramref name="obj" /> is not a COM object.</span></span>  
  
 <span data-ttu-id="95bcb-1677">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1677">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1678"><paramref name="obj" /> è un oggetto [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="95bcb-1678"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1679">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1679">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1680">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1680">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1681">Restituisce in byte la dimensione non gestita di una classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1681">Returns the unmanaged size, in bytes, of a class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="95bcb-1682">Oggetto di cui verrà restituita la dimensione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1682">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="95bcb-1683">Restituisce la dimensione non gestita di un oggetto, espressa in byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1683">Returns the unmanaged size of an object in bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1684">Dimensione dell'oggetto specificato nel codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1684">The size of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1685">Questo metodo accetta un'istanza di una struttura, che può essere un tipo riferimento o un tipo di valore boxed.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1685">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="95bcb-1686">Il layout deve essere sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1686">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1687">La dimensione restituita è la dimensione dell'oggetto non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1687">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="95bcb-1688">Le dimensioni gestite e non di un oggetto può essere diverso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1688">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="95bcb-1689">Per i tipi di carattere, la dimensione dipende dal <xref:System.Runtime.InteropServices.CharSet> valore applicato a tale classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1689">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="95bcb-1690">È possibile utilizzare il <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> metodo per determinare la quantità di memoria non gestita da allocare utilizzando il <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> e <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1690">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1691">Nell'esempio seguente viene creata una struttura gestita, trasferirla in memoria non gestita e quindi lo trasferisce alla memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1691">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</span></span> <span data-ttu-id="95bcb-1692">Questo esempio viene utilizzato il <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> metodo per determinare la quantità di memoria non gestita da allocare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1692">This example uses the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1693">Il valore del parametro <paramref name="structure" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1693">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="95bcb-1694">Tipo di cui verrà restituita la dimensione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1694">The type whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="95bcb-1695">Restituisce la dimensione di un tipo non gestito espressa in byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1695">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1696">Dimensione del tipo specificato nel codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1696">The size of the specified type in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1697">È possibile utilizzare questo metodo quando non si dispone di una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1697">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="95bcb-1698">Il layout deve essere sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1698">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1699">La dimensione restituita è la dimensione di tipo non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1699">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="95bcb-1700">Le dimensioni gestite e non di un oggetto può essere diverso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1700">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="95bcb-1701">Per i tipi di carattere, la dimensione dipende dal <xref:System.Runtime.InteropServices.CharSet> valore applicato a tale classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1701">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1702">Nel codice riportato di seguito viene illustrata la chiamata al metodo <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1702">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method.</span></span> <span data-ttu-id="95bcb-1703">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1703">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bcb-1704">Il parametro <paramref name="t" /> è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1704">The <paramref name="t" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1705">Il valore del parametro <paramref name="t" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1705">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1706">Tipo di cui verrà restituita la dimensione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1706">The type whose size is to be returned.</span></span></typeparam>
        <summary><span data-ttu-id="95bcb-1707">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1707">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1708">Restituisce la dimensione di un tipo non gestito espressa in byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1708">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1709">Dimensione, in byte, del tipo specificato dal parametro di tipo generico <typeparamref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1709">The size, in bytes, of the type that is specified by the <typeparamref name="T" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1710">È possibile utilizzare questo metodo quando non si dispone di una struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1710">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="95bcb-1711">Il layout deve essere sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1711">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1712">La dimensione restituita è la dimensione di tipo non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1712">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="95bcb-1713">Le dimensioni gestite e non di un oggetto può essere diverso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1713">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="95bcb-1714">Per i tipi di carattere, la dimensione dipende dal <xref:System.Runtime.InteropServices.CharSet> valore applicato a tale classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1714">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1715">Il tipo di <c>struttura</c> parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1715">The type of the <c>structure</c> parameter.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="95bcb-1716">Oggetto di cui verrà restituita la dimensione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1716">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="95bcb-1717">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1717">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1718">Restituisce la dimensione non gestita di un oggetto di un tipo specifico in byte.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1718">Returns the unmanaged size of an object of a specified type in bytes.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1719">Dimensione, in byte, dell'oggetto specificato nel codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1719">The size, in bytes, of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1720">Questo metodo accetta un'istanza di una struttura, che può essere un tipo riferimento o un tipo di valore boxed.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1720">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="95bcb-1721">Il layout deve essere sequenziale o esplicito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1721">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="95bcb-1722">La dimensione restituita è la dimensione dell'oggetto non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1722">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="95bcb-1723">Le dimensioni gestite e non di un oggetto può essere diverso.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1723">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="95bcb-1724">Per i tipi di carattere, la dimensione dipende dal <xref:System.Runtime.InteropServices.CharSet> valore applicato a tale classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1724">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="95bcb-1725">È possibile utilizzare il <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> metodo per determinare la quantità di memoria non gestita per allocare usando il <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> e <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1725">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method to determine how much unmanaged memory to allocate by using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bcb-1726">Il valore del parametro <paramref name="structure" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1726">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1727">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1727">The managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1728">Alloca un elemento [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) e vi copia il contenuto di un oggetto <see cref="T:System.String" /> gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1728">Allocates a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) and copies the contents of a managed <see cref="T:System.String" /> into it.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1729">Puntatore non gestito a <see langword="BSTR" /> o 0 se <paramref name="s" /> è Null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1729">An unmanaged pointer to the <see langword="BSTR" />, or 0 if <paramref name="s" /> is null.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1731">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la `BSTR` termine chiamando <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1731">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-1732">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1732">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1733">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1733">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1734">La lunghezza di <paramref name="s" />non è compresa nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1734">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1735">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1735">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1736">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1736">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1737">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1737">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1738">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1738">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1739">Intero che rappresenta un puntatore al blocco di memoria allocato per la stringa oppure 0 se <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1739">An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1741">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1741">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="95bcb-1742">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1742">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-1743">I caratteri della stringa vengono copiati come caratteri ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1743">The characters of the string are copied as ANSI characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1744">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1744">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1745">Il parametro <paramref name="s" /> supera la lunghezza massima consentita dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1745">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1746">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1746">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1747">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1747">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1748">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1748">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1749">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1749">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1750">Blocco di memoria allocato o 0 se <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1750">The allocated memory block, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1752">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1752">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="95bcb-1753">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1753">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1754">I caratteri della stringa vengono copiati come caratteri ANSI o Unicode, a seconda del sistema operativo in cui è in esecuzione il codice.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1754">The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</span></span> <span data-ttu-id="95bcb-1755">In Windows 98, i caratteri vengono copiati come caratteri ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1755">On Windows 98, the characters are copied as ANSI characters.</span></span> <span data-ttu-id="95bcb-1756">In Windows NT 4.0, Windows 2000, Windows XP e in Windows Server 2003, i caratteri vengono copiati come caratteri Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1756">On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1757">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1757">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1758">La lunghezza di <paramref name="s" />non è compresa nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1758">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1759">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1759">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1760">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1760">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1761">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1761">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1762">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito in un blocco di memoria allocato dall'allocatore di memoria delle attività COM non gestite.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1762">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1763">Intero che rappresenta un puntatore al blocco di memoria allocato per la stringa oppure 0 se s è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1763">An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1765">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1765">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-1766">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1766">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="95bcb-1767">I caratteri della stringa vengono copiati come caratteri Unicode.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1767">The characters of the string are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1768">Il parametro <paramref name="s" /> supera la lunghezza massima consentita dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1768">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1769">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1769">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1770">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1770">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1771">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1771">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1772">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1772">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1773">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito nella memoria non gestita, effettuando contemporaneamente la conversione nel formato ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1773">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1774">Indirizzo, nella memoria non gestita, in cui è stato copiato <paramref name="s" />, oppure 0 se <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1774">The address, in unmanaged memory, to where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> è utile per il marshalling personalizzato o quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1776">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1776">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="95bcb-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1778">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1778">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1779">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <xref:System.String> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1779">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1780">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1780">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1781">Il parametro <paramref name="s" /> supera la lunghezza massima consentita dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1781">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1782">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1782">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1783">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1783">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1784">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1784">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1785">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito nella memoria non gestita, effettuando, se necessario, la conversione nel formato ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1785">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format if required.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1786">Indirizzo, nella memoria non gestita, in cui è stata copiata la stringa, oppure 0 se <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1786">The address, in unmanaged memory, to where the string was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1788">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1788">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="95bcb-1789">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1789">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1790">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1790">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1791">Nell'esempio riportato di seguito viene illustrato come convertire il contenuto di un oggetto gestito <xref:System.String> classe nella memoria non gestita e quindi eliminare la memoria non gestita al termine.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1791">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1792">La memoria disponibile è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1792">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1793">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1793">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1794">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1794">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-1795">Stringa gestita da copiare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1795">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="95bcb-1796">Copia il contenuto di un oggetto <see cref="T:System.String" /> gestito nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1796">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1797">Indirizzo, nella memoria non gestita, in cui è stato copiato <paramref name="s" />, oppure 0 se <paramref name="s" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1797">The address, in unmanaged memory, to where the <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> è utile per il marshalling personalizzato o per l'uso quando si unisce il codice gestito e non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="95bcb-1799">Poiché questo metodo alloca la memoria non gestita necessaria per una stringa, liberare sempre la memoria chiamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1799">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="95bcb-1800">Questo metodo fornisce la funzionalità opposta di <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1800">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1801">Questo metodo copia i caratteri null incorporati e include un carattere di terminazione null.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1801">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="95bcb-1802">Il metodo non è riuscito ad allocare memoria dell'heap nativo sufficiente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1802">The method could not allocate enough native heap memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="95bcb-1803">Il parametro <paramref name="s" /> supera la lunghezza massima consentita dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1803">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1804">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1804">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1805">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1805">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="95bcb-1806">Oggetto gestito che contiene i dati di cui effettuare il marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1806">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="95bcb-1807">L'oggetto deve essere una struttura o un'istanza di una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1807">This object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="95bcb-1808">Puntatore a un blocco di memoria non gestito che deve essere allocato prima della chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1808">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld">
          <span data-ttu-id="95bcb-1809"><see langword="true" /> per chiamare il metodo <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> sul parametro <c>ptr</c> prima che il metodo esegua la copia dei dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1809"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method on the <c>ptr</c> parameter before this method copies the data.</span></span> <span data-ttu-id="95bcb-1810">Il blocco deve contenere dati validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1810">The block must contain valid data.</span></span> <span data-ttu-id="95bcb-1811">Si noti che passare il valore <see langword="false" /> quando il blocco di memoria contiene già dei dati può causare una perdita di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1811">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="95bcb-1812">Effettua il marshalling di dati da un oggetto gestito a un blocco di memoria non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1812">Marshals data from a managed object to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1813">Se `structure` è un tipo di valore, può essere sottoposto a boxing o alla conversione unboxing.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1813">If `structure` is a value type, it can be boxed or unboxed.</span></span> <span data-ttu-id="95bcb-1814">Se viene sottoposto a boxing, è unboxed prima della copia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1814">If it is boxed, it is unboxed before copying.</span></span>  
  
 <span data-ttu-id="95bcb-1815">Una classe formattata è un tipo di riferimento il cui layout viene specificato per il <xref:System.Runtime.InteropServices.StructLayoutAttribute> attributo, come <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1815">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> Copia il contenuto di `structure` preallocati blocco di memoria che di `ptr` punta al parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="95bcb-1817">Se `structure` contiene i tipi di riferimento che il marshalling di puntatori a interfaccia COM (interfacce, classi senza layout, e <xref:System.Object?displayProperty=nameWithType>), gli oggetti gestiti vengono mantenuti attivi con i conteggi dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1817">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="95bcb-1818">Tutti gli altri tipi di riferimento (ad esempio, stringhe e matrici) vengono eseguito il marshalling per le copie.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1818">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="95bcb-1819">Per rilasciare gli oggetti gestiti o non gestiti, è necessario chiamare il <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> metodo prima liberare il blocco di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1819">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="95bcb-1820">Se si utilizza il <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> metodo per copiare un'istanza diversa per il blocco di memoria in un secondo momento, specificare `true` per `fDeleteOld` per rimuovere un riferimento i conteggi per i tipi di riferimento nell'istanza precedente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1820">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="95bcb-1821">In caso contrario, le copie di riferimenti gestiti typesand non gestita in modo efficace vengono comunicate.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1821">Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="95bcb-1822">Lo schema generale per l'utilizzo di <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> è indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="95bcb-1822">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> is as follows:</span></span>  
  
1.  <span data-ttu-id="95bcb-1823">La prima chiamata al <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> dopo che è stato allocato un blocco di memoria, `fDeleteOld` deve essere `false`, in quanto nessun contenuto da cancellare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1823">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="95bcb-1824">Specificare `true` per `fDeleteOld` solo se il blocco contiene dati validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1824">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="95bcb-1825">Se si copia un'istanza diversa per il blocco di memoria e l'oggetto contiene i tipi di riferimento, `fDeleteOld` deve essere `true` per liberare i tipi di riferimento del contenuto precedente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1825">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="95bcb-1826">Se l'oggetto contiene i tipi di riferimento, è necessario chiamare il <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> metodo prima liberare il blocco di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1826">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-1827">Per aggiungere una struttura esistente anziché copiarlo, usare il <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> tipo per creare un handle bloccato per la struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1827">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="95bcb-1828">Per informazioni dettagliate su come aggiungere, vedere [copia e blocco](~/docs/framework/interop/copying-and-pinning.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1828">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1829">Nell'esempio seguente viene creata una struttura gestita che viene trasferita all'utilizzo di memoria non gestita di <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> (metodo) e quindi trasferita alla memoria gestita tramite il <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1829">The following example creates a managed structure, transfers it to unmanaged memory using the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1830"><paramref name="structure" /> è un tipo di riferimento che non corrisponde a una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1830"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span>  
  
 <span data-ttu-id="95bcb-1831">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1831">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1832"><paramref name="structure" /> è un'istanza di un tipo generico (in .NET Framework 4.5 e versioni precedenti).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1832"><paramref name="structure" /> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</span></span> </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1833">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1833">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1834">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1834">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1835">Tipo dell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1835">The type of the managed object.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="95bcb-1836">Oggetto gestito che contiene i dati di cui effettuare il marshalling.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1836">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="95bcb-1837">L'oggetto deve essere una struttura o un'istanza di una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1837">The object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="95bcb-1838">Puntatore a un blocco di memoria non gestito che deve essere allocato prima della chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1838">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld">
          <span data-ttu-id="95bcb-1839"><see langword="true" /> per chiamare il metodo <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> sul parametro <c>ptr</c> prima che il metodo esegua la copia dei dati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1839"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> method on the <c>ptr</c> parameter before this method copies the data.</span></span> <span data-ttu-id="95bcb-1840">Il blocco deve contenere dati validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1840">The block must contain valid data.</span></span> <span data-ttu-id="95bcb-1841">Si noti che passare il valore <see langword="false" /> quando il blocco di memoria contiene già dei dati può causare una perdita di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1841">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="95bcb-1842">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1842">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1843">Effettua il marshalling di dati da un oggetto gestito di un tipo specificato a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1843">Marshals data from a managed object of a specified type to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1844">Una classe formattata è un tipo di riferimento il cui layout viene specificato per il <xref:System.Runtime.InteropServices.StructLayoutAttribute> attributo, come <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1844">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="95bcb-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> Copia il contenuto di `structure` preallocati blocco di memoria che di `ptr` punta al parametro.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="95bcb-1846">Se `structure` contiene i tipi di riferimento che il marshalling di puntatori a interfaccia COM (interfacce, classi senza layout, e <xref:System.Object?displayProperty=nameWithType>), gli oggetti gestiti vengono mantenuti attivi con i conteggi dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1846">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="95bcb-1847">Tutti gli altri tipi di riferimento (ad esempio, stringhe e matrici) vengono eseguito il marshalling per le copie.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1847">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="95bcb-1848">Per rilasciare gli oggetti gestiti o non gestiti, è necessario chiamare il <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> metodo prima liberare il blocco di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1848">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="95bcb-1849">Se si utilizza il <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> metodo per copiare un'istanza diversa per il blocco di memoria in un secondo momento, specificare `true` per `fDeleteOld` per rimuovere un riferimento i conteggi per i tipi di riferimento nell'istanza precedente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1849">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="95bcb-1850">In caso contrario, i tipi di riferimenti gestiti e una copia non gestita in modo efficace viene comunicati.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1850">Otherwise, the managed reference types and unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="95bcb-1851">Lo schema generale per l'utilizzo di <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> è indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="95bcb-1851">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="95bcb-1852">La prima chiamata al <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> dopo che è stato allocato un blocco di memoria, `fDeleteOld` deve essere `false`, in quanto nessun contenuto da cancellare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1852">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="95bcb-1853">Specificare `true` per `fDeleteOld` solo se il blocco contiene dati validi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1853">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="95bcb-1854">Se si copia un'istanza diversa per il blocco di memoria e l'oggetto contiene i tipi di riferimento, `fDeleteOld` deve essere `true` per liberare i tipi di riferimento del contenuto precedente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1854">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="95bcb-1855">Se l'oggetto contiene i tipi di riferimento, è necessario chiamare il <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> metodo prima liberare il blocco di memoria.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1855">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bcb-1856">Per aggiungere una struttura esistente anziché copiarlo, usare il <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> tipo per creare un handle bloccato per la struttura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1856">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="95bcb-1857">Per informazioni dettagliate su come aggiungere, vedere [copia e blocco](~/docs/framework/interop/copying-and-pinning.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1857">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1858"><paramref name="structure" /> è un tipo di riferimento che non corrisponde a una classe formattata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1858"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1859">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1859">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1860">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1860">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bcb-1861">Rappresenta la dimensione predefinita del carattere nel sistema. Il valore predefinito è 2 per i sistemi Unicode e 1 per i sistemi ANSI.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1861">Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</span></span> <span data-ttu-id="95bcb-1862">Questo campo è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1862">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95bcb-1863">Nell'esempio seguente viene illustrato il <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> campo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1863">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="95bcb-1864">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1864">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bcb-1865">Rappresenta la dimensione massima di un set di caratteri a doppio byte (DBCS, double-byte character set), in byte, per il sistema operativo corrente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1865">Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</span></span> <span data-ttu-id="95bcb-1866">Questo campo è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1866">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95bcb-1867">Nell'esempio seguente viene illustrato il <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> campo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1867">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="95bcb-1868">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1868">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1869">Genera un'eccezione con un valore HRESULT di un errore specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1869">Throws an exception with a specific failure HRESULT value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="95bcb-1870">Valore HRESULT corrispondente all'eccezione desiderata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1870">The HRESULT corresponding to the desired exception.</span></span></param>
        <summary><span data-ttu-id="95bcb-1871">Genera un'eccezione con un valore HRESULT di un errore specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1871">Throws an exception with a specific failure HRESULT value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1872">Questo metodo crea un oggetto di eccezione per il valore HRESULT specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1872">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="95bcb-1873">Se il valore HRESULT è 0 o positivo (codice di esito positivo), il metodo restituisce senza creare o generare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1873">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="95bcb-1874">Si noti che il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> metodo restituisce un'eccezione in base il [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interfaccia del thread corrente, se impostata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1874">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="95bcb-1875">In questo caso, il `errorCode` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1875">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="95bcb-1876">Alcuni HRESULT di errore il mapping a eccezioni definite, mentre altri no.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1876">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="95bcb-1877">Se il valore HRESULT mappato a un'eccezione definita, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> crea un'istanza dell'eccezione e genera.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1877">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="95bcb-1878">In caso contrario, crea un'istanza di <xref:System.Runtime.InteropServices.COMException>, inizializza il campo di codice di errore con il valore HRESULT e genera l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1878">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="95bcb-1879">Quando <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> viene richiamato, tenta di recuperare informazioni aggiuntive relative all'errore tramite non gestito [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) (funzione).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1879">When <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) function.</span></span>  
  
 <span data-ttu-id="95bcb-1880">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere [come: mappa di HRESULT ed eccezioni](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1880">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 <span data-ttu-id="95bcb-1881">In alcuni casi, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> potrebbe restituire un'eccezione da una precedente chiamata COM.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1881">Occasionally, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> might return an exception from a previous COM call.</span></span> <span data-ttu-id="95bcb-1882">In questo caso, è possibile utilizzare la soluzione seguente e passare `IntPtr(-1)` come secondo parametro (`errorInfo`):</span><span class="sxs-lookup"><span data-stu-id="95bcb-1882">In this case, you can use the following workaround and pass `IntPtr(-1)` as the second parameter (`errorInfo`):</span></span>  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1883">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1883">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1884">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1884">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="95bcb-1885">Valore HRESULT corrispondente all'eccezione desiderata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1885">The HRESULT corresponding to the desired exception.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="95bcb-1886">Puntatore all'interfaccia [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) che fornisce informazioni aggiuntive sull'errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1886">A pointer to the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface that provides more information about the error.</span></span> <span data-ttu-id="95bcb-1887">È possibile specificare <c>IntPtr(0)</c> per usare l'interfaccia [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) corrente oppure <c>IntPtr(-1)</c> per ignorare l'interfaccia [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) corrente e costruire l'eccezione unicamente dal codice di errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1887">You can specify <c>IntPtr(0)</c> to use the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface, or <c>IntPtr(-1)</c> to ignore the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="95bcb-1888">Genera un'eccezione con un valore HRESULT di errore specifico, basato sull'interfaccia [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1888">Throws an exception with a specific failure HRESULT, based on the specified [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1889">Questo metodo crea un oggetto di eccezione per il valore HRESULT specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1889">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="95bcb-1890">Se il valore HRESULT è 0 o positivo (codice di esito positivo), il metodo restituisce senza creare o generare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1890">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="95bcb-1891">Il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> metodo rilascia il `errorInfo` conteggio di parametro, diminuendo il COM dei riferimenti di [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interfaccia.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1891">The <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method releases the `errorInfo` parameter, decreasing the COM reference count of the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span></span>  
  
 <span data-ttu-id="95bcb-1892">Si noti che il <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> metodo restituisce un'eccezione in base il [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interfaccia del thread corrente, se impostata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1892">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="95bcb-1893">In questo caso, il `errorCode` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1893">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="95bcb-1894">Alcuni HRESULT di errore il mapping a eccezioni definite, mentre altri no.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1894">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="95bcb-1895">Se il valore HRESULT mappato a un'eccezione definita, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> crea un'istanza dell'eccezione e genera.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1895">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="95bcb-1896">In caso contrario, crea un'istanza di <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, inizializza il campo di codice di errore con il valore HRESULT e genera l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1896">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="95bcb-1897">Il `errorInfo` parametro viene utilizzato per recuperare informazioni aggiuntive relative all'errore.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1897">The `errorInfo` parameter is used to retrieve extra information regarding the error.</span></span>  
  
 <span data-ttu-id="95bcb-1898">Per il mapping da ciascun HRESULT alla relativa classe di eccezioni corrispondente in .NET Framework, vedere [come: mappa di HRESULT ed eccezioni](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="95bcb-1898">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1899">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1899">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1900">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1900">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr"><span data-ttu-id="95bcb-1901">Matrice che contiene l'elemento desiderato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1901">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="95bcb-1902">Indice nel parametro <c>arr</c> dell'elemento desiderato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1902">The index in the <c>arr</c> parameter of the desired element.</span></span></param>
        <summary><span data-ttu-id="95bcb-1903">Ottiene l'indirizzo dell'elemento in corrispondenza dell'indice specificato all'interno della matrice specificata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1903">Gets the address of the element at the specified index inside the specified array.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1904">Indirizzo di <paramref name="index" /> all'interno di <paramref name="arr" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1904">The address of <paramref name="index" /> inside <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1905">La matrice deve essere bloccata utilizzando un <xref:System.Runtime.InteropServices.GCHandle> prima di essere passato a questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1905">The array must be pinned using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="95bcb-1906">Per ottenere prestazioni ottimali, questo metodo non convalida la matrice passata. Questo può causare comportamenti imprevisti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1906">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1907">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1907">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1908">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1908">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="95bcb-1909">Tipo della matrice</span><span class="sxs-lookup"><span data-stu-id="95bcb-1909">The type of the array.</span></span></typeparam>
        <param name="arr"><span data-ttu-id="95bcb-1910">Matrice che contiene l'elemento desiderato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1910">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="95bcb-1911">Indice dell'elemento desiderato nella matrice <c>arr</c>.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1911">The index of the desired element in the <c>arr</c> array.</span></span></param>
        <summary><span data-ttu-id="95bcb-1912">[Supportato in .NET Framework 4.5.1 e versioni successive]</span><span class="sxs-lookup"><span data-stu-id="95bcb-1912">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="95bcb-1913">Ottiene l'indirizzo dell'elemento in corrispondenza dell'indice specificato in una matrice del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1913">Gets the address of the element at the specified index in an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="95bcb-1914">Indirizzo di <paramref name="index" /> all'interno di <paramref name="arr" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1914">The address of <paramref name="index" /> in <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1915">La matrice deve essere bloccata utilizzando un <xref:System.Runtime.InteropServices.GCHandle> prima di essere passato a questo metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1915">The array must be pinned by using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="95bcb-1916">Per ottenere prestazioni ottimali, questo metodo non convalida la matrice passata. Questo può causare comportamenti imprevisti.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1916">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1917">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1917">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1918">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1918">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1919">Scrive un valore a singolo byte nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1919">Writes a single byte value to unmanaged memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1920">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1920">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1921">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1921">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1922">Scrive un valore a singolo byte nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1922">Writes a single byte value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1924">Nell'esempio seguente viene creato un blocco di memoria non gestita, scrive un byte nella memoria non gestita, legge i byte da memoria non gestita e quindi elimina la memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1924">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1925"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1925"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1926">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1926">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1927"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1927"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1928">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1928">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1929"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1929"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1930">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1930">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1931">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1931">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1932">Indirizzo di base nella memoria non gestita su cui scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1932">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1933">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1933">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1934">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1934">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1935">Scrive un valore a singolo byte nella memoria non gestita a un offset specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1935">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1937">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1937">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1938">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1938">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1939">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1939">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1940">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1940">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1941">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1941">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1942">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1942">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1943">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1943">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1944">Scrive un valore a singolo byte nella memoria non gestita a un offset specifico.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1944">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1946">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1946">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-1947"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1947"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-1948">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1948">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1949">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1949">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1950">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1950">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-1951">Scrive un valore intero con segno a 16 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1951">Writes a 16-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="95bcb-1952">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1952">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1953">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1953">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1954">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1954">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1955">Scrive un carattere sotto forma di intero a 16 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1955">Writes a character as a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1957">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1957">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1958">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1958">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1959"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1959"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1960">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1960">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1961"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1961"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1962">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1962">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1963"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1963"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1964">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1964">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1965">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1965">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1966">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1966">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1967">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1967">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1968">Scrive un valore intero a 16 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1968">Writes a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1970">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1970">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1971">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1971">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-1972"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1972"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-1973">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1973">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1974"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1974"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-1975">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-1975">-or-</span></span>  
  
 <span data-ttu-id="95bcb-1976"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1976"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1977">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1977">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1978">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1978">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1979">L'indirizzo di base nell'heap nativo su cui scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1979">The base address in the native heap to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1980">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1980">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1981">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1981">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1982">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1982">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1984">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1984">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1985">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1985">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1986">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1986">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1987">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1987">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1988">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1988">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1989">Indirizzo di base nella memoria non gestita su cui scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1989">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-1990">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1990">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-1991">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1991">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-1992">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1992">Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-1994">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1994">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-1995">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1995">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-1996">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1996">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-1997">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1997">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-1998">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1998">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-1999">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-1999">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2000">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2000">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2001">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2001">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2002">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2002">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2004">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2004">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2005">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2005">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-2006"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2006"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-2007">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2007">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2008">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2008">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2009">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2009">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2010">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2010">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2011">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2011">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2012">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2012">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2013">Scrive un intero con segno a 16 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2013">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Consente l'interazione diretta con una matrice con segno a 16 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2015">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2015">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2016">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2016">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-2017"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2017"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-2018">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2018">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2019">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2019">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2020">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2020">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-2021">Scrive un valore intero con segno a 32 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2021">Writes a 32-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="95bcb-2022">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2022">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2023">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2023">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2024">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2024">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2025">Scrive un valore intero con segno a 32 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2025">Writes a 32-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2027">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2027">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2028">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2028">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-2029"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2029"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-2030">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2030">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2031"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2031"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-2032">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2032">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2033"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2033"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2034">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2034">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2035">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2036">Indirizzo di base nella memoria non gestita su cui scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2036">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2037">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2037">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2038">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2038">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2039">Scrive un Intero con segno a 32 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2039">Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2041">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2041">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2042">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2042">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2043">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2043">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2044">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2044">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2045">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2045">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2046">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2046">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2047">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2047">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2048">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2048">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2049">Scrive un Intero con segno a 32 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2049">Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Consente l'interazione diretta con una matrice con segno a 32 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2051">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2051">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2052">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2052">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-2053"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2053"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-2054">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2054">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2055">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2055">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2056">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2056">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-2057">Scrive un valore intero con segno a 64 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2057">Writes a 64-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="95bcb-2058">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2058">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2059">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2059">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2060">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2060">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2061">Scrive un valore intero con segno a 64 bit nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2061">Writes a 64-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2063">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2063">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2064">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2064">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-2065"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2065"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-2066">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2066">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2067"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2067"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-2068">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2068">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2069"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2069"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2070">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2070">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2071">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2071">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2072">Indirizzo di base nella memoria non gestita da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2072">The base address in unmanaged memory to write.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2073">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2073">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2074">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2074">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2075">Scrive un Intero con segno a 64 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2075">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2077">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2077">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2078">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2078">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2079">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2079">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2080">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2080">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2081">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2081">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2082">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2082">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2083">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2083">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2084">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2084">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2085">Scrive un Intero con segno a 64 bit nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2085">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Consente l'interazione diretta con una matrice con segno a 64 bit non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2087">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2087">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2088">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2088">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-2089"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2089"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-2090">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2090">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2091">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2091">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2092">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2092">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bcb-2093">Scrive un intero di dimensioni native del processore nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2093">Writes a processor native-sized integer value to unmanaged memory.</span></span> <span data-ttu-id="95bcb-2094">Gli interi a 32 bit vengono scritti in sistemi a 32 bit e gli interi a 64 bit vengono scritti in sistemi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2094">32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</span></span> <span data-ttu-id="95bcb-2095">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2095">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2096">Indirizzo nella memoria non gestita sul quale scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2096">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2097">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2097">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2098">Scrive un valore intero della dimensione nativa del processore nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2098">Writes a processor native sized integer value into unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Consente l'interazione diretta con un tipo non gestito C `IntPtr` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2100">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2100">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2101">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2101">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="95bcb-2102"><paramref name="ptr" /> non è un formato riconosciuto.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2102"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="95bcb-2103">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2103">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2104"><paramref name="ptr" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2104"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="95bcb-2105">oppure</span><span class="sxs-lookup"><span data-stu-id="95bcb-2105">-or-</span></span>  
  
 <span data-ttu-id="95bcb-2106"><paramref name="ptr" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2106"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2107">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2108">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2109">Indirizzo di base nella memoria non gestita su cui scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2109">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2110">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2110">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2111">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2111">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2112">Scrive un intero di dimensioni native del processore nella memoria non gestita in corrispondenza di un offset specificato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2112">Writes a processor native-sized integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2113">Questo metodo scrive un intero a 32 bit su sistemi a 32 bit e un valore integer a 64 bit su sistemi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2113">This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</span></span>  
  
 <span data-ttu-id="95bcb-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Consente l'interazione diretta con un tipo non gestito C `IntPtr` matrice, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2115">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2115">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2116">Nell'esempio riportato di seguito viene illustrato come leggere e scrivere in una matrice non gestita usando il <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2116">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2117">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2117">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2118">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2118">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2119">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2119">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="95bcb-2120">L'indirizzo di base dell'oggetto di destinazione nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2120">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="95bcb-2121">Offset di byte supplementare, aggiunto al parametro <c>ptr</c> prima della scrittura.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2121">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="95bcb-2122">Valore da scrivere.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2122">The value to write.</span></span></param>
        <summary><span data-ttu-id="95bcb-2123">Scrive un valore intero della dimensione nativa del processore nella memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2123">Writes a processor native sized integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Consente l'interazione diretta con una matrice di byte di tipo C non gestita, eliminando l'inconveniente di copiare un'intera matrice non gestita (tramite <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in una matrice gestita separata prima di impostare i valori degli elementi.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="95bcb-2125">La scrittura in posizioni di memoria non allineate è supportata.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2125">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="95bcb-2126">L'indirizzo di base (<paramref name="ptr" />) più il byte di offset (<paramref name="ofs" />) produce un indirizzo Null o non valido.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2126">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="95bcb-2127"><paramref name="ptr" /> è un oggetto <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2127"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="95bcb-2128">Questo metodo non accetta parametri <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2128">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2129">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2129">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2130">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2130">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-2131">Indirizzo dell'elemento <see langword="BSTR" /> da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2131">The address of the <see langword="BSTR" /> to free.</span></span></param>
        <summary><span data-ttu-id="95bcb-2132">Libera un puntatore [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) allocato usando il metodo <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2132">Frees a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2133">Il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> metodo imposta prima di tutto il contenuto di BSTR su zero e quindi libera BSTR.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2133">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method first sets the contents of the BSTR to zero, and then frees the BSTR.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2134">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2134">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2135">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2135">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-2136">Indirizzo della stringa non gestita da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2136">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="95bcb-2137">Libera un puntatore a una stringa non gestita allocato tramite il metodo <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2137">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2138">Il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2138">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2139">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metodo per effettuare il marshalling e decrittografare il contenuto di un <xref:System.Security.SecureString> oggetto in un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2139">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="95bcb-2140">Viene quindi utilizzato il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> metodo per azzerare ed eliminare il blocco non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2140">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2141">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2141">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2142">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-2143">Indirizzo della stringa non gestita da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2143">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="95bcb-2144">Libera un puntatore a una stringa non gestita allocato tramite il metodo <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2144">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2145">Il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2145">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2146">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2146">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2147">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-2148">Indirizzo della stringa non gestita da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2148">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="95bcb-2149">Libera un puntatore a una stringa non gestita allocato tramite il metodo <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2149">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2150">Il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2150">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2151">L'esempio seguente usa il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metodo per effettuare il marshalling e decrittografare il contenuto di un <xref:System.Security.SecureString> oggetto in un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2151">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="95bcb-2152">Viene quindi utilizzato il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metodo per azzerare ed eliminare il blocco non gestito.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2152">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2153">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2153">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2154">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2154">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="95bcb-2155">Indirizzo della stringa non gestita da liberare.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2155">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="95bcb-2156">Libera un puntatore a una stringa non gestita allocato tramite il metodo <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2156">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bcb-2157">Il <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> metodo innanzitutto azzera e quindi libera la memoria non gestita allocato tramite il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2157">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bcb-2158">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metodo con tipo non gestito `LogonUser` funzione per eseguire la rappresentazione con la <xref:System.Security.SecureString> classe.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2158">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="95bcb-2159">Nell'esempio viene utilizzata la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> per azzerare e liberare il riferimento alla stringa non gestita.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2159">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bcb-2160">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2160">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bcb-2161">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="95bcb-2161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>