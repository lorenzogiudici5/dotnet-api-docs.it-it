<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1b291b7f17adbbd6bcc7b3b354069112b40071c7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36538381" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica che il metodo con attributi viene esposto da una libreria di collegamento dinamico (DLL) non gestita come un punto di ingresso statico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile applicare questo attributo per i metodi.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo fornisce le informazioni necessarie per chiamare una funzione esportata da una DLL non gestita. Come requisito minimo, è necessario fornire il nome della DLL contenente il punto di ingresso.  
  
 Si applica questo attributo direttamente a c# e definizioni di metodo C++. Tuttavia, il compilatore Visual Basic genera questo attributo quando si usa il `Declare` istruzione. Per le definizioni di metodo complesse che includono <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi, si applica questo attributo direttamente alle definizioni del metodo di Visual Basic.  
  
 **Nota** JScript non supporta questo attributo. È possibile utilizzare classi wrapper di Visual Basic o c# per accedere ai metodi dell'API non gestiti da programmi JScript.  
  
 Per ulteriori informazioni sull'uso di platform invoke servizio per accedere alle funzioni DLL non gestite, vedere [utilizzo di funzioni DLL non gestite](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Il <xref:System.Runtime.InteropServices.DllImportAttribute> non supporta il marshalling di tipi generici.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nome della DLL che contiene il metodo non gestito. Può includere il nome visualizzato di un assembly, se la DLL è inclusa in un assembly.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> con il nome della DLL che contiene il metodo da importare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un file DLL non gestita è incluso in un assembly, ad esempio, tramite il linker o la `/linkresource` l'opzione del compilatore, è possibile specificare il nome visualizzato dell'assembly come parte di `dllName`. Se, ad esempio, una DLL non gestita denominata `unmanaged.dll` è incluso in un assembly gestito denominato `MyAssembly`, l'attributo può essere specificato come illustrato nel codice seguente.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita il comportamento di mapping più appropriato per la conversione di caratteri Unicode in caratteri ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `true`, con mapping più appropriato è attivato; in caso contrario il mapping più appropriato è disabilitato. Il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo `true` per impostazione predefinita. Le impostazioni per questo campo sostituiscono le impostazioni a qualsiasi livello per il <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attributo.  
  
 Common language runtime Converte caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me. Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. tali caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti nei caratteri pericolosi, ad esempio la barra rovesciata '\\' carattere che possa modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante generando un'eccezione.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita. Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL in codice gestito. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo fa parte di questi casi. Nell'esempio seguente viene illustrato come applicare il più restrittivo sicurezza mapping caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando comportamento più appropriato e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la convenzione di chiamata di un punto di ingresso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo è impostato su uno del <xref:System.Runtime.InteropServices.CallingConvention> membri dell'enumerazione. Il valore predefinito per il <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, che a sua volta per impostazione predefinita <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convenzione.  
  
 Per altre informazioni, vedere la convenzione di chiamata in MSDN library.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL in codice gestito. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo fa parte di questi casi.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica come eseguire il marshalling dei parametri di stringa nel metodo e controlla l'alterazione dei nomi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo campo con un membro con il <xref:System.Runtime.InteropServices.CharSet> enumerazione per specificare il comportamento di marshalling di parametri di stringa e per specificare il nome del punto di ingresso per richiamare (il nome esatto specificato o un nome che termina con "A" o "W"). Il membro di enumerazione predefinito per c# e Visual Basic viene `CharSet.Ansi` e il membro di enumerazione predefinito per C++ `CharSet.None`, che equivale a `CharSet.Ansi`. In Visual Basic, utilizzare il `Declare` istruzione per specificare il `CharSet` campo.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influisce sul comportamento del `CharSet` campo nome del punto di ingresso da richiamare. Per una descrizione dettagliata ed esempi del marshalling della stringa e il nome corrispondente comportamento associato il `CharSet` campo, vedere [specifica un Set di caratteri](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica il nome o l'ordinale del punto di ingresso DLL da chiamare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile specificare il nome di punto di ingresso attraverso l'inserimento di una stringa che indica il nome della DLL contenente il punto di ingresso, oppure è possibile identificare il punto di ingresso tramite il proprio ordinale. Gli ordinali sono precedute dal prefisso con il simbolo #, ad esempio, #1. Se si omette questo campo, common language runtime usa il nome del metodo.NET contrassegnato con il <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Per ulteriori informazioni, vedere [che identifica le funzioni nelle DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Per esempi che mostrano come usare il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, vedere [che specifica un punto di ingresso](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  Nell'esempio di codice viene utilizzata la <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> proprietà per specificare la funzione per importare e quindi passa il nome da `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controlla se il campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> fa in modo che Common Language Runtime cerchi in una DLL non gestita i nomi dei punti di ingresso diversi da quello specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `false`, viene richiamato il nome del punto di ingresso aggiunto con la lettera A quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo viene impostato su `CharSet.Ansi`, e il nome di punto di ingresso aggiunto con la lettera W viene richiamato quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo viene impostato il `CharSet.Unicode`. In genere, i compilatori gestiti impostano questo campo.  
  
 Nella tabella seguente viene illustrata la relazione tra i <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> e <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campi, in base ai valori predefiniti imposti dal linguaggio di programmazione. Eseguire l'override dell'impostazione predefinita, è possibile farlo con attenzione.  
  
|Linguaggio|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling:=False|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo fa parte di questi casi.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se i metodi non gestiti con valore restituito <see langword="HRESULT" /> o <see langword="retval" /> vengono convertiti direttamente o se il valore restituito <see langword="HRESULT" /> o <see langword="retval" /> viene convertito automaticamente in eccezioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true` per convertire direttamente le firme non gestite con `HRESULT` o `retval` valori; impostarlo su `false` convertire automaticamente `HRESULT` o `retval` valori per le eccezioni. Per impostazione predefinita, il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true`.  
  
 Quando si `true`, la firma del metodo risultante restituisce un valore intero che contiene il `HRESULT` valore.  In questo caso, è necessario manualmente il valore restituito di controllare e rispondere di conseguenza nell'applicazione.  
  
 Quando si imposta la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `false`, la firma del metodo risultante contiene un tipo restituito void anziché un numero intero (`HRESULT`) tipo restituito.  Quando il metodo non gestito genera un' `HRESULT`, il runtime ignora automaticamente un valore restituito di `S_OK` (o 0) e non viene generata un'eccezione.  Per `HRESULT`s diverso da `S_OK`, il runtime genera automaticamente un'eccezione che corrisponde alla `HRESULT`.  Si noti che il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo solo esegue questa conversione in metodi che restituiscono un `HRESULT`.  
  
 È possibile decidere di modificare il comportamento da segnalazione degli errori di predefinito `HRESULT`in eccezioni nei casi in cui queste meglio si adattino alla struttura dell'applicazione di segnalazione degli errori.  
  
 Questo campo è simile ai <xref:System.Runtime.InteropServices.PreserveSigAttribute>; tuttavia, in contrasto con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, il valore predefinito per l'attributo è `false`.  
  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo fa parte di questi casi.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> da importare non gestito `SHAutoComplete` funzione una volta con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `true` e quindi con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `false`.  L'esempio di codice seguente genera il `SHAutoComplete` funzione generare errori con un'eccezione una volta e un `HRESULT` successivo.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il destinatario della chiamata chiama la funzione API Win32 <see langword="SetLastError" /> prima della restituzione di un risultato dal metodo con attributi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che il chiamato chiamerà `SetLastError`; in caso contrario, `false`. Il valore predefinito è `false`.  
  
 Il gestore di marshalling di Common Language runtime chiama `GetLastError` e memorizza nella cache il valore restituito per evitare che venga sovrascritto da altre chiamate API. È possibile recuperare il codice di errore chiamando <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo fa parte di questi casi.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita la generazione di un'eccezione su un carattere Unicode di cui non è possibile eseguire il mapping convertito in un carattere ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che un'eccezione viene generata ogni volta che il marshalling di interoperabilità converte un carattere; `false` per indicare che il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo è disabilitato. Questo campo è `false` per impostazione predefinita.  
  
 Common language runtime Converte caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me. Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. tali caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti nei caratteri pericolosi, ad esempio la barra rovesciata '\\' carattere che possa modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante generando un'eccezione.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita. Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute> per definire una funzione di DLL in codice gestito, anziché utilizzare il `Declare` istruzione. Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo fa parte di questi casi. Nell'esempio seguente viene illustrato come applicare il più restrittivo sicurezza mapping caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando comportamento più appropriato e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del file DLL che contiene il punto di ingresso.</summary>
        <value>Nome del file DLL che contiene il punto di ingresso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile fornire un percorso completo o relativo. Se non si specifica alcun percorso, la DLL deve trovarsi nel percorso corrente in fase di esecuzione, a meno che la DLL viene caricata in altro modo. Tenere presente, tuttavia, che tramite il percorso completo può comportare imprecisioni se la DLL viene spostata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>