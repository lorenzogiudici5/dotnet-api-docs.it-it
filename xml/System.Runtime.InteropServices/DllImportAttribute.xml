<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1b291b7f17adbbd6bcc7b3b354069112b40071c7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36538381" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="24471-101">Indica che il metodo con attributi viene esposto da una libreria di collegamento dinamico (DLL) non gestita come un punto di ingresso statico.</span>
      <span class="sxs-lookup">
        <span data-stu-id="24471-101">Indicates that the attributed method is exposed by an unmanaged dynamic-link library (DLL) as a static entry point.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-102">È possibile applicare questo attributo per i metodi.</span><span class="sxs-lookup"><span data-stu-id="24471-102">You can apply this attribute to methods.</span></span>  
  
 <span data-ttu-id="24471-103">Il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo fornisce le informazioni necessarie per chiamare una funzione esportata da una DLL non gestita.</span><span class="sxs-lookup"><span data-stu-id="24471-103">The <xref:System.Runtime.InteropServices.DllImportAttribute> attribute provides the information needed to call a function exported from an unmanaged DLL.</span></span> <span data-ttu-id="24471-104">Come requisito minimo, è necessario fornire il nome della DLL contenente il punto di ingresso.</span><span class="sxs-lookup"><span data-stu-id="24471-104">As a minimum requirement, you must supply the name of the DLL containing the entry point.</span></span>  
  
 <span data-ttu-id="24471-105">Si applica questo attributo direttamente a c# e definizioni di metodo C++. Tuttavia, il compilatore Visual Basic genera questo attributo quando si usa il `Declare` istruzione.</span><span class="sxs-lookup"><span data-stu-id="24471-105">You apply this attribute directly to C# and C++ method definitions; however, the Visual Basic compiler emits this attribute when you use the `Declare` statement.</span></span> <span data-ttu-id="24471-106">Per le definizioni di metodo complesse che includono <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi, si applica questo attributo direttamente alle definizioni del metodo di Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="24471-106">For complex method definitions that include <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields, you apply this attribute directly to Visual Basic method definitions.</span></span>  
  
 <span data-ttu-id="24471-107">**Nota** JScript non supporta questo attributo.</span><span class="sxs-lookup"><span data-stu-id="24471-107">**Note** JScript does not support this attribute.</span></span> <span data-ttu-id="24471-108">È possibile utilizzare classi wrapper di Visual Basic o c# per accedere ai metodi dell'API non gestiti da programmi JScript.</span><span class="sxs-lookup"><span data-stu-id="24471-108">You can use C# or Visual Basic wrapper classes to access unmanaged API methods from JScript programs.</span></span>  
  
 <span data-ttu-id="24471-109">Per ulteriori informazioni sull'uso di platform invoke servizio per accedere alle funzioni DLL non gestite, vedere [utilizzo di funzioni DLL non gestite](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="24471-109">For additional information about using the platform invoke service to access functions in unmanaged DLLs, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="24471-110">Il <xref:System.Runtime.InteropServices.DllImportAttribute> non supporta il marshalling di tipi generici.</span><span class="sxs-lookup"><span data-stu-id="24471-110">The <xref:System.Runtime.InteropServices.DllImportAttribute> does not support marshaling of generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-111">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).</span><span class="sxs-lookup"><span data-stu-id="24471-111">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="24471-112">L'esempio di codice chiama quindi il metodo importato.</span><span class="sxs-lookup"><span data-stu-id="24471-112">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">
          <span data-ttu-id="24471-113">Nome della DLL che contiene il metodo non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-113">The name of the DLL that contains the unmanaged method.</span>
          </span>
          <span data-ttu-id="24471-114">Può includere il nome visualizzato di un assembly, se la DLL è inclusa in un assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-114">This can include an assembly display name, if the DLL is included in an assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24471-115">Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> con il nome della DLL che contiene il metodo da importare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-115">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> class with the name of the DLL containing the method to import.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-116">Se un file DLL non gestita è incluso in un assembly, ad esempio, tramite il linker o la `/linkresource` l'opzione del compilatore, è possibile specificare il nome visualizzato dell'assembly come parte di `dllName`.</span><span class="sxs-lookup"><span data-stu-id="24471-116">If an unmanaged DLL file is included in an assembly, for example, by using the linker or the `/linkresource` compiler option, you can specify the assembly display name as part of `dllName`.</span></span> <span data-ttu-id="24471-117">Se, ad esempio, una DLL non gestita denominata `unmanaged.dll` è incluso in un assembly gestito denominato `MyAssembly`, l'attributo può essere specificato come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="24471-117">For example, if an unmanaged DLL named `unmanaged.dll` is included in a managed assembly named `MyAssembly`, the attribute might be specified as shown in the following code.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="24471-118">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).</span><span class="sxs-lookup"><span data-stu-id="24471-118">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="24471-119">L'esempio di codice chiama quindi il metodo importato.</span><span class="sxs-lookup"><span data-stu-id="24471-119">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-120">Abilita o disabilita il comportamento di mapping più appropriato per la conversione di caratteri Unicode in caratteri ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-120">Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-121">Se `true`, con mapping più appropriato è attivato; in caso contrario il mapping più appropriato è disabilitato.</span><span class="sxs-lookup"><span data-stu-id="24471-121">If `true`, best-fit mapping behavior is enabled; otherwise, best-fit mapping is disabled.</span></span> <span data-ttu-id="24471-122">Il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo `true` per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="24471-122">The <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is `true` by default.</span></span> <span data-ttu-id="24471-123">Le impostazioni per questo campo sostituiscono le impostazioni a qualsiasi livello per il <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="24471-123">Settings for this field override the any level settings for the <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attribute.</span></span>  
  
 <span data-ttu-id="24471-124">Common language runtime Converte caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me.</span><span class="sxs-lookup"><span data-stu-id="24471-124">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="24471-125">Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta.</span><span class="sxs-lookup"><span data-stu-id="24471-125">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="24471-126">Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI.</span><span class="sxs-lookup"><span data-stu-id="24471-126">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="24471-127">Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. tali caratteri sono denominati possibile eseguire il mapping.</span><span class="sxs-lookup"><span data-stu-id="24471-127">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="24471-128">I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.</span><span class="sxs-lookup"><span data-stu-id="24471-128">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="24471-129">Alcuni caratteri Unicode vengono convertiti nei caratteri pericolosi, ad esempio la barra rovesciata '\\' carattere che possa modificare inavvertitamente un percorso.</span><span class="sxs-lookup"><span data-stu-id="24471-129">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="24471-130">Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante generando un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="24471-130">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="24471-131">Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita.</span><span class="sxs-lookup"><span data-stu-id="24471-131">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="24471-132">Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="24471-132">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="24471-133">Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="24471-133">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-134">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="24471-134">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="24471-135">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-135">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is one of those cases.</span></span> <span data-ttu-id="24471-136">Nell'esempio seguente viene illustrato come applicare il più restrittivo sicurezza mapping caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando comportamento più appropriato e generare un'eccezione in caratteri Unicode non mappati.</span><span class="sxs-lookup"><span data-stu-id="24471-136">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-137">Indica la convenzione di chiamata di un punto di ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-137">Indicates the calling convention of an entry point.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-138">Questo campo è impostato su uno del <xref:System.Runtime.InteropServices.CallingConvention> membri dell'enumerazione.</span><span class="sxs-lookup"><span data-stu-id="24471-138">You set this field to one of the <xref:System.Runtime.InteropServices.CallingConvention> enumeration members.</span></span> <span data-ttu-id="24471-139">Il valore predefinito per il <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, che a sua volta per impostazione predefinita <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convenzione.</span><span class="sxs-lookup"><span data-stu-id="24471-139">The default value for the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, which in turn defaults to <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convention.</span></span>  
  
 <span data-ttu-id="24471-140">Per altre informazioni, vedere la convenzione di chiamata in MSDN library.</span><span class="sxs-lookup"><span data-stu-id="24471-140">For more information, see Calling Convention in the MSDN library.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-141">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="24471-141">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="24471-142">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-142">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is one of those cases.</span></span>  
  
 <span data-ttu-id="24471-143">System.Runtime.InteropServices.DllImportAttribute#1</span><span class="sxs-lookup"><span data-stu-id="24471-143">System.Runtime.InteropServices.DllImportAttribute#1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-144">Indica come eseguire il marshalling dei parametri di stringa nel metodo e controlla l'alterazione dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-144">Indicates how to marshal string parameters to the method and controls name mangling.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-145">Utilizzare questo campo con un membro con il <xref:System.Runtime.InteropServices.CharSet> enumerazione per specificare il comportamento di marshalling di parametri di stringa e per specificare il nome del punto di ingresso per richiamare (il nome esatto specificato o un nome che termina con "A" o "W").</span><span class="sxs-lookup"><span data-stu-id="24471-145">Use this field with a member of the <xref:System.Runtime.InteropServices.CharSet> enumeration to specify the marshaling behavior of string parameters and to specify which entry-point name to invoke (the exact name given or a name ending with "A" or "W").</span></span> <span data-ttu-id="24471-146">Il membro di enumerazione predefinito per c# e Visual Basic viene `CharSet.Ansi` e il membro di enumerazione predefinito per C++ `CharSet.None`, che equivale a `CharSet.Ansi`.</span><span class="sxs-lookup"><span data-stu-id="24471-146">The default enumeration member for C# and Visual Basic is `CharSet.Ansi` and the default enumeration member for C++ is `CharSet.None`, which is equivalent to `CharSet.Ansi`.</span></span> <span data-ttu-id="24471-147">In Visual Basic, utilizzare il `Declare` istruzione per specificare il `CharSet` campo.</span><span class="sxs-lookup"><span data-stu-id="24471-147">In Visual Basic, you use the `Declare` statement to specify the `CharSet` field.</span></span>  
  
 <span data-ttu-id="24471-148">Il <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influisce sul comportamento del `CharSet` campo nome del punto di ingresso da richiamare.</span><span class="sxs-lookup"><span data-stu-id="24471-148">The <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field influences the behavior of the `CharSet` field in determining which entry-point name to invoke.</span></span> <span data-ttu-id="24471-149">Per una descrizione dettagliata ed esempi del marshalling della stringa e il nome corrispondente comportamento associato il `CharSet` campo, vedere [specifica un Set di caratteri](~/docs/framework/interop/specifying-a-character-set.md).</span><span class="sxs-lookup"><span data-stu-id="24471-149">For a detailed description and examples of the string marshaling and name matching behavior associated with the `CharSet` field, see [Specifying a Character Set](~/docs/framework/interop/specifying-a-character-set.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-150">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).</span><span class="sxs-lookup"><span data-stu-id="24471-150">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="24471-151">L'esempio di codice chiama quindi il metodo importato.</span><span class="sxs-lookup"><span data-stu-id="24471-151">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-152">Indica il nome o l'ordinale del punto di ingresso DLL da chiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-152">Indicates the name or ordinal of the DLL entry point to be called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-153">È possibile specificare il nome di punto di ingresso attraverso l'inserimento di una stringa che indica il nome della DLL contenente il punto di ingresso, oppure è possibile identificare il punto di ingresso tramite il proprio ordinale.</span><span class="sxs-lookup"><span data-stu-id="24471-153">You can specify the entry-point name by supplying a string indicating the name of the DLL containing the entry point, or you can identify the entry point by its ordinal.</span></span> <span data-ttu-id="24471-154">Gli ordinali sono precedute dal prefisso con il simbolo #, ad esempio, #1.</span><span class="sxs-lookup"><span data-stu-id="24471-154">Ordinals are prefixed with the # sign, for example, #1.</span></span> <span data-ttu-id="24471-155">Se si omette questo campo, common language runtime usa il nome del metodo.NET contrassegnato con il <xref:System.Runtime.InteropServices.DllImportAttribute>.</span><span class="sxs-lookup"><span data-stu-id="24471-155">If you omit this field, the common language runtime uses the name of the.NET method marked with the <xref:System.Runtime.InteropServices.DllImportAttribute>.</span></span>  
  
 <span data-ttu-id="24471-156">Per ulteriori informazioni, vedere [che identifica le funzioni nelle DLL](~/docs/framework/interop/identifying-functions-in-dlls.md).</span><span class="sxs-lookup"><span data-stu-id="24471-156">For additional information, see [Identifying Functions in DLLs](~/docs/framework/interop/identifying-functions-in-dlls.md).</span></span> <span data-ttu-id="24471-157">Per esempi che mostrano come usare il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, vedere [che specifica un punto di ingresso](~/docs/framework/interop/specifying-an-entry-point.md).</span><span class="sxs-lookup"><span data-stu-id="24471-157">For examples showing how to use the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> field, see [Specifying an Entry Point](~/docs/framework/interop/specifying-an-entry-point.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-158">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).</span><span class="sxs-lookup"><span data-stu-id="24471-158">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="24471-159">Nell'esempio di codice viene utilizzata la <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> proprietà per specificare la funzione per importare e quindi passa il nome da `MyNewMessageBoxMethod`.</span><span class="sxs-lookup"><span data-stu-id="24471-159">The code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> property to specify the function to import and then changes the name to `MyNewMessageBoxMethod`.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-160">Controlla se il campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> fa in modo che Common Language Runtime cerchi in una DLL non gestita i nomi dei punti di ingresso diversi da quello specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-160">Controls whether the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> field causes the common language runtime to search an unmanaged DLL for entry-point names other than the one specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-161">Se `false`, viene richiamato il nome del punto di ingresso aggiunto con la lettera A quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo viene impostato su `CharSet.Ansi`, e il nome di punto di ingresso aggiunto con la lettera W viene richiamato quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo viene impostato il `CharSet.Unicode`.</span><span class="sxs-lookup"><span data-stu-id="24471-161">If `false`, the entry point name appended with the letter A is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to `CharSet.Ansi`, and the entry-point name appended with the letter W is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to the `CharSet.Unicode`.</span></span> <span data-ttu-id="24471-162">In genere, i compilatori gestiti impostano questo campo.</span><span class="sxs-lookup"><span data-stu-id="24471-162">Typically, managed compilers set this field.</span></span>  
  
 <span data-ttu-id="24471-163">Nella tabella seguente viene illustrata la relazione tra i <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> e <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campi, in base ai valori predefiniti imposti dal linguaggio di programmazione.</span><span class="sxs-lookup"><span data-stu-id="24471-163">The following table shows the relationship between the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> and <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> fields, based on default values imposed by the programming language.</span></span> <span data-ttu-id="24471-164">Eseguire l'override dell'impostazione predefinita, è possibile farlo con attenzione.</span><span class="sxs-lookup"><span data-stu-id="24471-164">You can override the default setting, but do so with caution.</span></span>  
  
|<span data-ttu-id="24471-165">Linguaggio</span><span class="sxs-lookup"><span data-stu-id="24471-165">Language</span></span>|<span data-ttu-id="24471-166">ANSI</span><span class="sxs-lookup"><span data-stu-id="24471-166">ANSI</span></span>|<span data-ttu-id="24471-167">Unicode</span><span class="sxs-lookup"><span data-stu-id="24471-167">Unicode</span></span>|<span data-ttu-id="24471-168">Auto</span><span class="sxs-lookup"><span data-stu-id="24471-168">Auto</span></span>|  
|--------------|----------|-------------|----------|  
|<span data-ttu-id="24471-169">Visual Basic</span><span class="sxs-lookup"><span data-stu-id="24471-169">Visual Basic</span></span>|<span data-ttu-id="24471-170">ExactSpelling:=True</span><span class="sxs-lookup"><span data-stu-id="24471-170">ExactSpelling:=True</span></span>|<span data-ttu-id="24471-171">ExactSpelling:=True</span><span class="sxs-lookup"><span data-stu-id="24471-171">ExactSpelling:=True</span></span>|<span data-ttu-id="24471-172">ExactSpelling:=False</span><span class="sxs-lookup"><span data-stu-id="24471-172">ExactSpelling:=False</span></span>|  
|<span data-ttu-id="24471-173">C#</span><span class="sxs-lookup"><span data-stu-id="24471-173">C#</span></span>|<span data-ttu-id="24471-174">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-174">ExactSpelling=false</span></span>|<span data-ttu-id="24471-175">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-175">ExactSpelling=false</span></span>|<span data-ttu-id="24471-176">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-176">ExactSpelling=false</span></span>|  
|<span data-ttu-id="24471-177">C++</span><span class="sxs-lookup"><span data-stu-id="24471-177">C++</span></span>|<span data-ttu-id="24471-178">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-178">ExactSpelling=false</span></span>|<span data-ttu-id="24471-179">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-179">ExactSpelling=false</span></span>|<span data-ttu-id="24471-180">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="24471-180">ExactSpelling=false</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="24471-181">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="24471-181">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="24471-182">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-182">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-183">Indica se i metodi non gestiti con valore restituito <see langword="HRESULT" /> o <see langword="retval" /> vengono convertiti direttamente o se il valore restituito <see langword="HRESULT" /> o <see langword="retval" /> viene convertito automaticamente in eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-183">Indicates whether unmanaged methods that have <see langword="HRESULT" /> or <see langword="retval" /> return values are directly translated or whether <see langword="HRESULT" /> or <see langword="retval" /> return values are automatically converted to exceptions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-184">Impostare il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true` per convertire direttamente le firme non gestite con `HRESULT` o `retval` valori; impostarlo su `false` convertire automaticamente `HRESULT` o `retval` valori per le eccezioni.</span><span class="sxs-lookup"><span data-stu-id="24471-184">Set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `true` to directly translate unmanaged signatures with `HRESULT` or `retval` values; set it to `false` to automatically convert `HRESULT` or `retval` values to exceptions.</span></span> <span data-ttu-id="24471-185">Per impostazione predefinita, il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true`.</span><span class="sxs-lookup"><span data-stu-id="24471-185">By default, the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is `true`.</span></span>  
  
 <span data-ttu-id="24471-186">Quando si `true`, la firma del metodo risultante restituisce un valore intero che contiene il `HRESULT` valore.</span><span class="sxs-lookup"><span data-stu-id="24471-186">When `true`, the resulting method signature returns an integer value that contains the `HRESULT` value.</span></span>  <span data-ttu-id="24471-187">In questo caso, è necessario manualmente il valore restituito di controllare e rispondere di conseguenza nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="24471-187">In this case, you must manually inspect the return value and respond accordingly in your application.</span></span>  
  
 <span data-ttu-id="24471-188">Quando si imposta la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `false`, la firma del metodo risultante contiene un tipo restituito void anziché un numero intero (`HRESULT`) tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="24471-188">When you set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `false`, the resulting method signature contains a void return type instead of an integer (`HRESULT`) return type.</span></span>  <span data-ttu-id="24471-189">Quando il metodo non gestito genera un' `HRESULT`, il runtime ignora automaticamente un valore restituito di `S_OK` (o 0) e non viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="24471-189">When the unmanaged method produces an `HRESULT`, the runtime automatically ignores a return value of `S_OK` (or 0) and does not throw an exception.</span></span>  <span data-ttu-id="24471-190">Per `HRESULT`s diverso da `S_OK`, il runtime genera automaticamente un'eccezione che corrisponde alla `HRESULT`.</span><span class="sxs-lookup"><span data-stu-id="24471-190">For `HRESULT`s other than `S_OK`, the runtime automatically throws an exception that corresponds to the `HRESULT`.</span></span>  <span data-ttu-id="24471-191">Si noti che il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo solo esegue questa conversione in metodi che restituiscono un `HRESULT`.</span><span class="sxs-lookup"><span data-stu-id="24471-191">Note that the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute only performs this conversion to methods that return an `HRESULT`.</span></span>  
  
 <span data-ttu-id="24471-192">È possibile decidere di modificare il comportamento da segnalazione degli errori di predefinito `HRESULT`in eccezioni nei casi in cui queste meglio si adattino alla struttura dell'applicazione di segnalazione degli errori.</span><span class="sxs-lookup"><span data-stu-id="24471-192">You might decide to change the default error reporting behavior from `HRESULT`s to exceptions in cases where exceptions better fit the error reporting structure of your application.</span></span>  
  
 <span data-ttu-id="24471-193">Questo campo è simile ai <xref:System.Runtime.InteropServices.PreserveSigAttribute>; tuttavia, in contrasto con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, il valore predefinito per l'attributo è `false`.</span><span class="sxs-lookup"><span data-stu-id="24471-193">This field is similar to the <xref:System.Runtime.InteropServices.PreserveSigAttribute>; however, in contrast to the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field, the default value for the attribute is `false`.</span></span>  
  
 <span data-ttu-id="24471-194">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="24471-194">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="24471-195">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-195">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is one of those cases.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-196">Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> da importare non gestito `SHAutoComplete` funzione una volta con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `true` e quindi con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="24471-196">The following code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute> to import the unmanaged `SHAutoComplete` function once with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `true` and again with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `false`.</span></span>  <span data-ttu-id="24471-197">L'esempio di codice seguente genera il `SHAutoComplete` funzione generare errori con un'eccezione una volta e un `HRESULT` successivo.</span><span class="sxs-lookup"><span data-stu-id="24471-197">This code example causes the `SHAutoComplete` function to generate any errors with an exception one time and an `HRESULT` the next.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-198">Indica se il destinatario della chiamata chiama la funzione API Win32 <see langword="SetLastError" /> prima della restituzione di un risultato dal metodo con attributi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-198">Indicates whether the callee calls the <see langword="SetLastError" /> Win32 API function before returning from the attributed method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-199">`true` per indicare che il chiamato chiamerà `SetLastError`; in caso contrario, `false`.</span><span class="sxs-lookup"><span data-stu-id="24471-199">`true` to indicate that the callee will call `SetLastError`; otherwise, `false`.</span></span> <span data-ttu-id="24471-200">Il valore predefinito è `false`.</span><span class="sxs-lookup"><span data-stu-id="24471-200">The default is `false`.</span></span>  
  
 <span data-ttu-id="24471-201">Il gestore di marshalling di Common Language runtime chiama `GetLastError` e memorizza nella cache il valore restituito per evitare che venga sovrascritto da altre chiamate API.</span><span class="sxs-lookup"><span data-stu-id="24471-201">The runtime marshaler calls `GetLastError` and caches the value returned to prevent it from being overwritten by other API calls.</span></span> <span data-ttu-id="24471-202">È possibile recuperare il codice di errore chiamando <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="24471-202">You can retrieve the error code by calling <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-203">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="24471-203">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="24471-204">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-204">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-205">Abilita o disabilita la generazione di un'eccezione su un carattere Unicode di cui non è possibile eseguire il mapping convertito in un carattere ANSI "?".</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-205">Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-206">`true` per indicare che un'eccezione viene generata ogni volta che il marshalling di interoperabilità converte un carattere; `false` per indicare che il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo è disabilitato.</span><span class="sxs-lookup"><span data-stu-id="24471-206">`true` to indicate that an exception is thrown each time the interop marshaler converts an unmappable character; `false` to indicate that the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is disabled.</span></span> <span data-ttu-id="24471-207">Questo campo è `false` per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="24471-207">This field is `false` by default.</span></span>  
  
 <span data-ttu-id="24471-208">Common language runtime Converte caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me.</span><span class="sxs-lookup"><span data-stu-id="24471-208">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="24471-209">Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta.</span><span class="sxs-lookup"><span data-stu-id="24471-209">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="24471-210">Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI.</span><span class="sxs-lookup"><span data-stu-id="24471-210">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="24471-211">Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. tali caratteri sono denominati possibile eseguire il mapping.</span><span class="sxs-lookup"><span data-stu-id="24471-211">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="24471-212">I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.</span><span class="sxs-lookup"><span data-stu-id="24471-212">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="24471-213">Alcuni caratteri Unicode vengono convertiti nei caratteri pericolosi, ad esempio la barra rovesciata '\\' carattere che possa modificare inavvertitamente un percorso.</span><span class="sxs-lookup"><span data-stu-id="24471-213">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="24471-214">Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante generando un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="24471-214">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="24471-215">Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita.</span><span class="sxs-lookup"><span data-stu-id="24471-215">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="24471-216">Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="24471-216">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="24471-217">Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="24471-217">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24471-218">In alcuni casi, gli sviluppatori Visual Basic utilizzano le <xref:System.Runtime.InteropServices.DllImportAttribute> per definire una funzione di DLL in codice gestito, anziché utilizzare il `Declare` istruzione.</span><span class="sxs-lookup"><span data-stu-id="24471-218">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute> to define a DLL function in managed code, instead of using the `Declare` statement.</span></span> <span data-ttu-id="24471-219">Impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo fa parte di questi casi.</span><span class="sxs-lookup"><span data-stu-id="24471-219">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is one of those cases.</span></span> <span data-ttu-id="24471-220">Nell'esempio seguente viene illustrato come applicare il più restrittivo sicurezza mapping caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando comportamento più appropriato e generare un'eccezione in caratteri Unicode non mappati.</span><span class="sxs-lookup"><span data-stu-id="24471-220">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24471-221">Ottiene il nome del file DLL che contiene il punto di ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-221">Gets the name of the DLL file that contains the entry point.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24471-222">Nome del file DLL che contiene il punto di ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24471-222">The name of the DLL file that contains the entry point.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24471-223">È possibile fornire un percorso completo o relativo.</span><span class="sxs-lookup"><span data-stu-id="24471-223">You can provide a full or relative path.</span></span> <span data-ttu-id="24471-224">Se non si specifica alcun percorso, la DLL deve trovarsi nel percorso corrente in fase di esecuzione, a meno che la DLL viene caricata in altro modo.</span><span class="sxs-lookup"><span data-stu-id="24471-224">If you provide no path, the DLL must be in the current path at run time, unless the DLL is loaded by some other means.</span></span> <span data-ttu-id="24471-225">Tenere presente, tuttavia, che tramite il percorso completo può comportare imprecisioni se la DLL viene spostata.</span><span class="sxs-lookup"><span data-stu-id="24471-225">Be aware, however, that using a fully qualified path can introduce inaccuracy if the DLL is moved.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>