<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="23e3cd02f7b0f8ccc396f11c5abc9af18628f6b7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica che il metodo con attributi viene esposto da una libreria di collegamento dinamico (DLL) non gestita come un punto di ingresso statico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile applicare questo attributo ai metodi.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo fornisce le informazioni necessarie per chiamare una funzione esportata da una DLL non gestita. Come requisito minimo, è necessario fornire il nome della DLL contenente il punto di ingresso.  
  
 Si applica questo attributo direttamente in c# e definizioni di metodo C++. Tuttavia, il compilatore Visual Basic crea questo attributo quando si utilizza il `Declare` istruzione. Per le definizioni di metodo complesse che includono <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi, si applica questo attributo direttamente alle definizioni del metodo di Visual Basic.  
  
 **Nota** JScript non supporta questo attributo. È possibile utilizzare classi c# o Visual Basic wrapper per accedere ai metodi dell'API non gestiti da programmi JScript.  
  
 Per ulteriori informazioni sull'utilizzo di platform invoke servizio per accedere alle funzioni DLL non gestite, vedere [utilizzo di funzioni DLL non gestite](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Il <xref:System.Runtime.InteropServices.DllImportAttribute> non supporta il marshalling dei tipi generici.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nome della DLL che contiene il metodo non gestito. Può includere il nome visualizzato di un assembly, se la DLL è inclusa in un assembly.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> con il nome della DLL che contiene il metodo da importare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un file DLL non gestita è incluso in un assembly, ad esempio, utilizzando il linker o `/linkresource` l'opzione del compilatore, è possibile specificare il nome visualizzato dell'assembly come parte di `dllName`. Ad esempio, se una DLL non gestita denominata `unmanaged.dll` è incluso in un assembly gestito denominato `MyAssembly`, l'attributo può essere specificato come illustrato nel codice seguente.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita il comportamento di mapping più appropriato per la conversione di caratteri Unicode in caratteri ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `true`il mapping più appropriato è attivato; in caso contrario il mapping più appropriato è disabilitato. Il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo `true` per impostazione predefinita. Le impostazioni per questo campo sostituiscono le impostazioni a qualsiasi livello per il <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attributo.  
  
 Common language runtime consente di convertire in caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me. Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. Questi caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti in caratteri rischiosi, ad esempio la barra rovesciata '\\' carattere che è possibile modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, generando un'eccezione, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita i cui elementi è caratteri ANSI o LPSTR a una matrice sicura non gestita. Il mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL nel codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> è uno dei casi. Nell'esempio seguente viene illustrato come applicare il più rigoroso sicurezza mapping di caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando il comportamento di mapping migliore, e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la convenzione di chiamata di un punto di ingresso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo è impostato su uno del <xref:System.Runtime.InteropServices.CallingConvention> i membri dell'enumerazione. Il valore predefinito per il <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, che a sua volta per impostazione predefinita <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convenzione.  
  
 Per ulteriori informazioni, vedere la convenzione di chiamata in MSDN library.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione per definire una funzione di DLL nel codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> è uno dei casi.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica come eseguire il marshalling dei parametri di stringa nel metodo e controlla l'alterazione dei nomi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo campo con un membro con il <xref:System.Runtime.InteropServices.CharSet> enumerazione per specificare il comportamento di marshalling di parametri di stringa e per specificare il nome del punto di ingresso per richiamare (il nome esatto specificato o un nome che termina con "A" o "W"). Il membro di enumerazione predefinito per c# e Visual Basic è `CharSet.Ansi` e il membro di enumerazione predefinito di C++ è `CharSet.None`, che equivale a `CharSet.Ansi`. In Visual Basic, utilizzare il `Declare` istruzione per specificare il `CharSet` campo.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influisce sul comportamento del `CharSet` campo nome del punto di ingresso da richiamare. Per una descrizione dettagliata ed esempi di marshalling della stringa e del comportamento associato di corrispondenza di `CharSet` campo, vedere [specifica un Set di caratteri](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica il nome o l'ordinale del punto di ingresso DLL da chiamare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile specificare il nome del punto di ingresso fornendo una stringa che indica il nome della DLL contenente il punto di ingresso oppure è possibile identificare il punto di ingresso tramite il proprio ordinale. Gli ordinali sono preceduti dal simbolo #, ad esempio, #1. Se si omette questo campo, common language runtime utilizza il nome del metodo.NET contrassegnato con il <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Per ulteriori informazioni, vedere [che identifica le funzioni nelle DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Per esempi che illustrano come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, vedere [specificando un punto di ingresso](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  Nell'esempio di codice viene utilizzato il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> proprietà per specificare la funzione da importare e quindi modificato il nome in `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controlla se il campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> fa in modo che Common Language Runtime cerchi in una DLL non gestita i nomi dei punti di ingresso diversi da quello specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `false`, il nome del punto di ingresso aggiunto con la lettera A viene richiamato quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo è impostato su `CharSet.Ansi`, e il nome del punto di ingresso aggiunto con la lettera W viene richiamato quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo è impostato sul `CharSet.Unicode`. In genere, i compilatori gestiti impostano questo campo.  
  
 Nella tabella seguente viene illustrata la relazione tra il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> e <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campi, in base ai valori predefiniti imposti dal linguaggio di programmazione. È possibile ignorare l'impostazione predefinita, ma procedere con cautela.  
  
|Linguaggio|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling:=False|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL nel codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> è uno dei casi.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se i metodi non gestiti con valore restituito <see langword="HRESULT" /> o <see langword="retval" /> vengono convertiti direttamente o se il valore restituito <see langword="HRESULT" /> o <see langword="retval" /> viene convertito automaticamente in eccezioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true` per convertire direttamente le firme non gestite con `HRESULT` o `retval` valori; impostarlo su `false` per convertire automaticamente `HRESULT` o `retval` i valori per le eccezioni. Per impostazione predefinita, il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true`.  
  
 Quando `true`, la firma del metodo risultante restituisce un valore intero che contiene il `HRESULT` valore.  In questo caso, è necessario manualmente il valore restituito di controllare e rispondere di conseguenza dell'applicazione.  
  
 Quando si imposta la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `false`, la firma del metodo risultante contiene un tipo restituito void anziché un numero intero (`HRESULT`) il tipo restituito.  Quando il metodo non gestito produce un `HRESULT`, il runtime ignora automaticamente un valore restituito di `S_OK` (o 0) e non viene generata un'eccezione.  Per `HRESULT`diversi da `S_OK`, il runtime genera automaticamente un'eccezione che corrisponde alla `HRESULT`.  Si noti che il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo solo esegue questa conversione in metodi che restituiscono un `HRESULT`.  
  
 È possibile decidere di modificare il comportamento di segnalazione degli errori predefinita `HRESULT`in eccezioni nei casi in cui queste meglio si adattino alla struttura dell'applicazione di segnalazione degli errori.  
  
 Questo campo è simile al <xref:System.Runtime.InteropServices.PreserveSigAttribute>; tuttavia, al contrario di <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, il valore predefinito per l'attributo è `false`.  
  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL nel codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> è uno dei casi.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> da importare non gestito `SHAutoComplete` funzione una volta con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `true` e con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `false`.  L'esempio di codice seguente genera il `SHAutoComplete` funzione genera tutti gli errori con un'eccezione una volta e un `HRESULT` successivo.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il destinatario della chiamata chiama la funzione API Win32 <see langword="SetLastError" /> prima della restituzione di un risultato dal metodo con attributi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che il chiamato chiamerà `SetLastError`; in caso contrario, `false`. Il valore predefinito è `false`.  
  
 Il gestore di marshalling di Common Language runtime chiama `GetLastError` e memorizza nella cache il valore restituito per evitare che venga sovrascritto da altre chiamate API. È possibile recuperare il codice di errore chiamando <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché utilizzare il `Declare` istruzione per definire una funzione di DLL nel codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> è uno dei casi.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita la generazione di un'eccezione su un carattere Unicode di cui non è possibile eseguire il mapping convertito in un carattere ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che un'eccezione viene generata ogni volta che il marshalling di interoperabilità converte un carattere; `false` per indicare che il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo è disabilitato. Questo campo è `false` per impostazione predefinita.  
  
 Common language runtime consente di convertire in caratteri ANSI che qualsiasi carattere Unicode gestito passato a un metodo non gestito in esecuzione in Windows 98 o Windows Me. Fallback con mapping consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando non esiste alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode per "c" per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione con mapping più appropriata. Questi caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti in caratteri rischiosi, ad esempio la barra rovesciata '\\' carattere che è possibile modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, generando un'eccezione, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti forniti dal <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita i cui elementi è caratteri ANSI o LPSTR a una matrice sicura non gestita. Il mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori di Visual Basic, utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> per definire una funzione di DLL in codice gestito, anziché utilizzare il `Declare` istruzione. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> è uno dei casi. Nell'esempio seguente viene illustrato come applicare il più rigoroso sicurezza mapping di caratteri per una piattaforma di richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando il comportamento di mapping migliore, e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del file DLL che contiene il punto di ingresso.</summary>
        <value>Nome del file DLL che contiene il punto di ingresso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile specificare un percorso completo o relativo. Se non si specifica alcun percorso, la DLL deve trovarsi nel percorso corrente in fase di esecuzione, a meno che la DLL viene caricata in un altro modo. Tenere presente, tuttavia, che tramite un percorso completo può introdurre errori se la DLL viene spostata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>