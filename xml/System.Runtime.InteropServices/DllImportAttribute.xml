<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f4469ed6eb0893368ed6b1c6583d42ccb3162bb0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37470230" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica che il metodo con attributi viene esposto da una libreria di collegamento dinamico (DLL) non gestita come un punto di ingresso statico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile applicare questo attributo ai metodi.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo fornisce le informazioni necessarie per chiamare una funzione esportata da una DLL non gestita. Come requisito minimo, è necessario fornire il nome della DLL che contiene il punto di ingresso.  
  
 Si applica questo attributo direttamente ai linguaggi c# e definizioni di metodo C++. Tuttavia, il compilatore Visual Basic genera questo attributo quando si usa il `Declare` istruzione. Per le definizioni di metodo complesso che includono <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi, si applica questo attributo direttamente alle definizioni del metodo di Visual Basic.  
  
 **Nota** JScript non supporta questo attributo. È possibile utilizzare per accedere ai metodi dell'API non gestiti da JScript programmi c# o le classi wrapper Visual Basic.  
  
 Per altre informazioni sull'uso di platform invoke del servizio per accedere alle funzioni DLL non gestite, vedere [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Il <xref:System.Runtime.InteropServices.DllImportAttribute> non supporta il marshalling di tipi generici.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nome della DLL che contiene il metodo non gestito. Può includere il nome visualizzato di un assembly, se la DLL è inclusa in un assembly.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> con il nome della DLL che contiene il metodo da importare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un file DLL non gestita è incluso in un assembly, ad esempio, tramite il linker o la `/linkresource` l'opzione del compilatore, è possibile specificare il nome visualizzato dell'assembly come parte di `dllName`. Ad esempio, se una DLL non gestita denominata `unmanaged.dll` è incluso in un assembly gestito denominato `MyAssembly`, l'attributo può essere specificato come illustrato nel codice seguente.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita il comportamento di mapping più appropriato per la conversione di caratteri Unicode in caratteri ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `true`, con mapping più appropriato il comportamento di mapping è abilitato; in caso contrario, il mapping più appropriato è disabilitato. Il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo è `true` per impostazione predefinita. Le impostazioni per questo campo sostituiscono le impostazioni a qualsiasi livello per il <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attributo.  
  
 Common language runtime consente di convertire in caratteri ANSI che tutti i caratteri Unicode passati a un metodo non gestito in esecuzione in Windows 98 o Windows Me. gestiti Mapping più appropriato consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando è presente alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode in 'c' per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione in forma con mapping più appropriato; Questi caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti in caratteri dannosi, ad esempio la barra rovesciata '\\' carattere, che può modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, generando un'eccezione, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti specificati per il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita. Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione, per definire una funzione di DLL in codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo è uno di tali case. Nell'esempio seguente viene illustrato come applicare più stretto sicurezza mapping di caratteri in una piattaforma a richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando migliore comportamento di mapping e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la convenzione di chiamata di un punto di ingresso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo è impostato su uno del <xref:System.Runtime.InteropServices.CallingConvention> membri dell'enumerazione. Il valore predefinito per il <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo viene <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, che per impostazione predefinita, a sua volta a <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convenzione.  
  
 Per altre informazioni, vedere la convenzione di chiamata in MSDN library.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché il `Declare` istruzione, per definire una funzione di DLL in codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo è uno di tali case.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica come eseguire il marshalling dei parametri di stringa nel metodo e controlla l'alterazione dei nomi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo campo con un membro con il <xref:System.Runtime.InteropServices.CharSet> enumerazione per specificare il comportamento di marshalling dei parametri della stringa e per specificare il nome del punto di ingresso per richiamare (il nome esatto specificato o un nome che termina con "A" o "W"). Il membro di enumerazione predefinito per c# e Visual Basic viene `CharSet.Ansi` e il membro di enumerazione predefinito per C++ viene `CharSet.None`, che equivale a `CharSet.Ansi`. In Visual Basic, utilizza il `Declare` istruzione per specificare il `CharSet` campo.  
  
 Il <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influisce sul comportamento del `CharSet` campo nome del punto di ingresso da richiamare. Per una descrizione dettagliata ed esempi del marshalling delle stringhe e il nome associato con comportamento di corrispondenza di `CharSet` campo, vedere [specifica un Set di caratteri](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice chiama quindi il metodo importato.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica il nome o l'ordinale del punto di ingresso DLL da chiamare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile specificare il nome del punto di ingresso specificando una stringa che indica il nome della DLL che contiene il punto di ingresso, oppure è possibile identificare il punto di ingresso tramite il proprio ordinale. Gli ordinali hanno come prefisso il simbolo #, ad esempio, #1. Se si omette questo campo, common language runtime usa il nome del metodo.NET contrassegnato con il <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Per altre informazioni, vedere [che identifica le funzioni nelle DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Per esempi che illustrano come usare il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, vedere [specificando un punto di ingresso](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo importare Win32 `MessageBox` (funzione).  L'esempio di codice Usa il <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> proprietà per specificare la funzione per importare e quindi passa il nome da `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controlla se il campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> fa in modo che Common Language Runtime cerchi in una DLL non gestita i nomi dei punti di ingresso diversi da quello specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `false`, viene richiamato il nome del punto di ingresso aggiunto con la lettera A quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo è impostato su `CharSet.Ansi`, e il nome del punto di ingresso aggiunto con la lettera s viene richiamato quando il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo è impostato sul `CharSet.Unicode`. In genere, i compilatori gestiti impostano questo campo.  
  
 La tabella seguente illustra la relazione tra il <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> e <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campi, in base ai valori predefiniti imposti dal linguaggio di programmazione. È possibile eseguire l'override dell'impostazione predefinita, ma procedere con cautela.  
  
|Linguaggio|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling:=False|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché usare il `Declare` istruzione, per definire una funzione di DLL in codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo è uno di tali case.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se i metodi non gestiti con valore restituito <see langword="HRESULT" /> o <see langword="retval" /> vengono convertiti direttamente o se il valore restituito <see langword="HRESULT" /> o <see langword="retval" /> viene convertito automaticamente in eccezioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true` convertire direttamente le firme non gestite con `HRESULT` o `retval` valori; impostato su `false` convertire automaticamente `HRESULT` o `retval` valori per le eccezioni. Per impostazione predefinita, il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo è `true`.  
  
 Quando `true`, la firma del metodo risultante restituisce un valore intero che contiene il `HRESULT` valore.  In questo caso, è necessario manualmente ispezionare il valore restituito e rispondere di conseguenza nell'applicazione.  
  
 Quando si imposta la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `false`, la firma del metodo risultante contiene un tipo restituito void anziché un numero intero (`HRESULT`) il tipo restituito.  Quando il metodo non gestito genera un' `HRESULT`, il runtime ignora automaticamente un valore restituito di `S_OK` (o 0) e non viene generata un'eccezione.  Per la `HRESULT`diversi da `S_OK`, il runtime genera automaticamente un'eccezione che corrisponde alla `HRESULT`.  Si noti che il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo esegue solo la conversione per i metodi che restituiscono un `HRESULT`.  
  
 È possibile decidere di modificare il comportamento dal relativo alla segnalazione di errori predefinito `HRESULT`in eccezioni nei casi in cui le eccezioni adattino alla struttura dell'applicazione di segnalazione degli errori.  
  
 Questo campo è simile al <xref:System.Runtime.InteropServices.PreserveSigAttribute>; tuttavia, a differenza del <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, il valore predefinito per l'attributo è `false`.  
  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché usare il `Declare` istruzione, per definire una funzione di DLL in codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo è uno di tali case.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Runtime.InteropServices.DllImportAttribute> da importare non gestito `SHAutoComplete` funzione una volta con i <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `true` e quindi con il <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo impostato su `false`.  L'esempio di codice seguente genera il `SHAutoComplete` funzione per generare errori con un'eccezione di una sola volta e un `HRESULT` successivo.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il destinatario della chiamata chiama la funzione API Win32 <see langword="SetLastError" /> prima della restituzione di un risultato dal metodo con attributi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che il chiamato chiamerà `SetLastError`; in caso contrario, `false`. Il valore predefinito è `false`.  
  
 Il gestore di marshalling di runtime chiama `GetLastError` e memorizza nella cache il valore restituito per evitare che vengano sovrascritti da altre chiamate API. È possibile recuperare il codice di errore chiamando <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute>, anziché usare il `Declare` istruzione, per definire una funzione di DLL in codice gestito. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo è uno di tali case.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abilita o disabilita la generazione di un'eccezione su un carattere Unicode di cui non è possibile eseguire il mapping convertito in un carattere ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` per indicare che un'eccezione viene generata ogni volta che il marshalling di interoperabilità converte un carattere; `false` per indicare che il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo è disabilitato. Questo campo è `false` per impostazione predefinita.  
  
 Common language runtime consente di convertire in caratteri ANSI che tutti i caratteri Unicode passati a un metodo non gestito in esecuzione in Windows 98 o Windows Me. gestiti Mapping più appropriato consente il marshalling di interoperabilità fornire un carattere di chiusura corrispondente quando è presente alcuna corrispondenza esatta. Ad esempio, il gestore di marshalling converte il carattere di copyright Unicode in 'c' per i metodi non gestiti che accettano caratteri ANSI. Alcuni caratteri non dispongono di una rappresentazione in forma con mapping più appropriato; Questi caratteri sono denominati possibile eseguire il mapping. I caratteri vengono convertiti in genere sul valore predefinito '?' Carattere ANSI.  
  
> [!CAUTION]
>  Alcuni caratteri Unicode vengono convertiti in caratteri dannosi, ad esempio la barra rovesciata '\\' carattere, che può modificare inavvertitamente un percorso. Impostando il <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, generando un'eccezione, è possibile segnalare la presenza di un carattere possibile eseguire il mapping al chiamante.  
  
> [!CAUTION]
>  Non è possibile modificare i valori predefiniti specificati per il <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campi quando si passa una matrice gestita cui elementi sono caratteri ANSI o LPSTR a una matrice sicura non gestita. Mapping più appropriato è sempre abilitata e viene generata alcuna eccezione. Tenere presente che questa combinazione potrebbe compromettere il modello di sicurezza.  
  
   
  
## Examples  
 In alcuni casi, gli sviluppatori Visual Basic usano la <xref:System.Runtime.InteropServices.DllImportAttribute> per definire una funzione di DLL in codice gestito, invece di usare il `Declare` istruzione. L'impostazione di <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo è uno di tali case. Nell'esempio seguente viene illustrato come applicare più stretto sicurezza mapping di caratteri in una piattaforma a richiamare le definizioni di metodo che specifica il set di caratteri ANSI, disabilitando migliore comportamento di mapping e generare un'eccezione in caratteri Unicode non mappati.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del file DLL che contiene il punto di ingresso.</summary>
        <value>Nome del file DLL che contiene il punto di ingresso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile fornire un percorso completo o relativo. Se non si specifica alcun percorso, la DLL deve trovarsi nel percorso corrente in fase di esecuzione, a meno che la DLL viene caricata in un altro modo. Tenere presente, tuttavia, che usa un percorso completo può comportare imprecisioni se la DLL viene spostata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>