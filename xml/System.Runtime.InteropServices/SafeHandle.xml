<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52be7711ddbbcd95a2f906f5949976e7af850878" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646587" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e3ef3-101">Rappresenta una classe wrapper per gli handle del sistema operativo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-101">Represents a wrapper class for operating system handles.</span>
      </span>
      <span data-ttu-id="e3ef3-102">La classe deve essere ereditata.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-102">This class must be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-103">Il <xref:System.Runtime.InteropServices.SafeHandle> classe fornisce la finalizzazione critica delle risorse di handle, impedendo agli handle di essere recuperati in anticipo da garbage collection e di essere riciclati da Windows per fare riferimento a oggetti non gestiti non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-103">The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</span></span>  
  
 <span data-ttu-id="e3ef3-104">Questo argomento include le sezioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e3ef3-104">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="e3ef3-105">[Il motivo per cui SafeHandle?](#Why) </span><span class="sxs-lookup"><span data-stu-id="e3ef3-105">[Why SafeHandle?](#Why) </span></span>  
 <span data-ttu-id="e3ef3-106">[Funzionamento di SafeHandle](#Does) </span><span class="sxs-lookup"><span data-stu-id="e3ef3-106">[What SafeHandle does](#Does) </span></span>  
 [<span data-ttu-id="e3ef3-107">Classi derivate da SafeHandle</span><span class="sxs-lookup"><span data-stu-id="e3ef3-107">Classes derived from SafeHandle</span></span>](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a><span data-ttu-id="e3ef3-108">Il motivo per cui SafeHandle?</span><span class="sxs-lookup"><span data-stu-id="e3ef3-108">Why SafeHandle?</span></span>  
 <span data-ttu-id="e3ef3-109">Prima di .NET Framework versione 2.0, sistema operativo tutti gli handle possono solo essere incapsulati nel <xref:System.IntPtr> oggetto wrapper gestito.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-109">Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object.</span></span> <span data-ttu-id="e3ef3-110">Mentre questo è un modo pratico per l'interoperabilità con codice nativo, gli handle è stato possibile andrà persa per le eccezioni asincrone, ad esempio un thread che si interrompe in modo imprevisto o un overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-110">While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</span></span> <span data-ttu-id="e3ef3-111">Queste eccezioni asincrone sono un ostacolo alla pulizia delle risorse di sistema operativo e possono verificarsi quasi ovunque nell'app.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-111">These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</span></span>  
  
 <span data-ttu-id="e3ef3-112">Anche se esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo consente la pulizia delle risorse non gestite quando un oggetto viene sottoposto a garbage collection, in alcune circostanze, oggetti finalizzabili possono essere recuperati da garbage collection durante l'esecuzione di un metodo all'interno di una piattaforma di richiamare chiamare.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-112">Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</span></span> <span data-ttu-id="e3ef3-113">Se un finalizzatore rilascia l'handle passato a tale piattaforma chiamata invoke, ciò potrebbe causare per il danneggiamento di gestire.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-113">If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</span></span> <span data-ttu-id="e3ef3-114">L'handle può anche essere recuperato mentre il metodo è bloccato durante una chiamata PInvoke, ad esempio durante la lettura di un file.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-114">The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</span></span>  
  
 <span data-ttu-id="e3ef3-115">Ancora più importante, poiché Windows viene riciclato in modo aggressivo gli handle, un handle può essere riciclato e puntare a un'altra risorsa che potrebbe contenere dati sensibili.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-115">More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</span></span> <span data-ttu-id="e3ef3-116">Questo è noto come un attacco di riciclo e può potenzialmente danneggiare i dati e rappresentare una minaccia alla sicurezza.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-116">This is known as a recycle attack and can potentially corrupt data and be a security threat.</span></span>  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a><span data-ttu-id="e3ef3-117">Funzionamento di SafeHandle</span><span class="sxs-lookup"><span data-stu-id="e3ef3-117">What SafeHandle does</span></span>  
 <span data-ttu-id="e3ef3-118">Il <xref:System.Runtime.InteropServices.SafeHandle> classe semplifica molti di questi problemi di durata degli oggetti ed è integrata con platform invoke in modo che si verifichino perdite di risorse del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-118">The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</span></span> <span data-ttu-id="e3ef3-119">Il <xref:System.Runtime.InteropServices.SafeHandle> classe risolve i problemi di durata degli oggetti assegnando e rilasciando handle senza interruzione.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-119">The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="e3ef3-120">Contiene un finalizzatore critico la cui garantisce che l'handle è chiuso e verrà sicuramente eseguito durante imprevisto <xref:System.AppDomain> viene scaricato, anche in casi in cui la chiamata di PInvoke presuppone che sia stato danneggiato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-120">It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</span></span>  
  
 <span data-ttu-id="e3ef3-121">In quanto <xref:System.Runtime.InteropServices.SafeHandle> eredita da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tutti i finalizzatori non critici vengono richiamati prima di qualsiasi dei finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-121">Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers.</span></span> <span data-ttu-id="e3ef3-122">I finalizzatori vengono richiamati su oggetti che non sono più in tempo reale durante il passaggio della garbage collection stessa.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-122">The finalizers are called on objects that are no longer live during the same garbage collection pass.</span></span> <span data-ttu-id="e3ef3-123">Ad esempio, un <xref:System.IO.FileStream> oggetto può eseguire un finalizzatore normale per cancellare i dati memorizzati nel buffer esistenti senza il rischio che l'handle viene persa o riciclati.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-123">For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</span></span> <span data-ttu-id="e3ef3-124">Questo ordinamento molto debole tra dei finalizzatori critici e non per uso generale.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-124">This very weak ordering between critical and noncritical finalizers is not intended for general use.</span></span> <span data-ttu-id="e3ef3-125">Esiste principalmente per facilitare la migrazione delle raccolte esistenti, consentendo a tali librerie da utilizzare <xref:System.Runtime.InteropServices.SafeHandle> senza modificare la semantica.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-125">It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics.</span></span> <span data-ttu-id="e3ef3-126">Inoltre, il finalizzatore critico e qualsiasi valore chiama, ad esempio il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodo, deve essere in un'area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-126">Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method, must be in a constrained execution region.</span></span> <span data-ttu-id="e3ef3-127">Ciò impone vincoli per il tipo di codice può essere scritti nel grafico delle chiamate del finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-127">This imposes constraints on what code can be written within the finalizer's call graph.</span></span>  
  
 <span data-ttu-id="e3ef3-128">Operazioni automaticamente di platform invoke incrementare il conteggio dei riferimenti degli handle incapsulato da un <xref:System.Runtime.InteropServices.SafeHandle> e li decremento dopo il completamento.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-128">Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion.</span></span> <span data-ttu-id="e3ef3-129">Ciò garantisce che l'handle non verrà riciclato o chiusa in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-129">This ensures that the handle will not be recycled or closed unexpectedly.</span></span>  
  
 <span data-ttu-id="e3ef3-130">È possibile specificare la proprietà di handle sottostante durante la costruzione <xref:System.Runtime.InteropServices.SafeHandle> oggetti fornendo un valore per il `ownsHandle` argomento nel <xref:System.Runtime.InteropServices.SafeHandle> costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-130">You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor.</span></span> <span data-ttu-id="e3ef3-131">Consente di controllare se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto verrà rilasciato l'handle dopo che l'oggetto è stato eliminato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-131">This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.</span></span>  <span data-ttu-id="e3ef3-132">Ciò è utile per gli handle con requisiti particolari durata o per l'utilizzo di un handle di cui durata è controllata da un altro utente.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-132">This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</span></span>  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a><span data-ttu-id="e3ef3-133">Classi derivate da SafeHandle</span><span class="sxs-lookup"><span data-stu-id="e3ef3-133">Classes derived from SafeHandle</span></span>  
 <span data-ttu-id="e3ef3-134"><xref:System.Runtime.InteropServices.SafeHandle> è una classe wrapper astratta per gli handle del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-134"><xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles.</span></span> <span data-ttu-id="e3ef3-135">La derivazione da questa classe è difficile.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-135">Deriving from this class is difficult.</span></span> <span data-ttu-id="e3ef3-136">Utilizzare invece le classi derivate nello spazio dei nomi <xref:Microsoft.Win32.SafeHandles> che forniscono handle sicuri per gli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e3ef3-136">Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:</span></span>  
  
-   <span data-ttu-id="e3ef3-137">I file (il <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-137">Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-138">File mappati alla memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-138">Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-139">Pipe (il <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-139">Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-140">Visualizzazioni di memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-140">Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-141">Costrutti di crittografia (il <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classi).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-141">Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span></span>  
  
-   <span data-ttu-id="e3ef3-142">I processi (il <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-142">Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-143">Le chiavi del Registro di sistema (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-143">Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).</span></span>  
  
-   <span data-ttu-id="e3ef3-144">Handle di attesa (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-144">Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3ef3-145">Esempio di codice seguente crea un handle sicuro personalizzato per un handle di file del sistema operativo, che deriva da <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-145">The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span></span> <span data-ttu-id="e3ef3-146">Legge i byte da un file e visualizza i valori esadecimali.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-146">It reads bytes from a file and displays their hexadecimal values.</span></span> <span data-ttu-id="e3ef3-147">Contiene anche un test harness degli errori che causa l'interruzione del thread, ma il valore dell'handle viene liberato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-147">It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</span></span>  <span data-ttu-id="e3ef3-148">Quando si usa un <xref:System.IntPtr> per rappresentare gli handle, l'handle viene perso occasionalmente a causa dell'interruzione del thread asincroni.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-148">When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</span></span>  
  
 <span data-ttu-id="e3ef3-149">È necessario un file di testo nella stessa cartella dell'applicazione compilata.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-149">You will need a text file in the same folder as the compiled application.</span></span> <span data-ttu-id="e3ef3-150">Supponendo che il nome dell'applicazione "HexViewer", l'utilizzo della riga di comando è:</span><span class="sxs-lookup"><span data-stu-id="e3ef3-150">Assuming that you name the application "HexViewer", the command line usage is:</span></span>  
  
 `HexViewer <filename> -Fault`  
  
 <span data-ttu-id="e3ef3-151">Facoltativamente, specificare `-Fault` intenzionalmente tentativi di perdere l'handle per l'interruzione del thread in una determinata finestra.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-151">Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window.</span></span> <span data-ttu-id="e3ef3-152">Usare lo strumento Windows Perfmon.exe per monitorare i conteggi di handle durante l'inserimento di errori.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-152">Use the Windows Perfmon.exe tool to monitor handle counts while injecting faults.</span></span>  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="e3ef3-153">per un'attendibilità totale per gli eredi.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-153">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="e3ef3-154">Questo membro non può essere ereditato da codice parzialmente attendibile.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-154">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="e3ef3-155">richiede l'attendibilità totale per il chiamante immediato.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-155">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="e3ef3-156">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e3ef3-156">This member cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="e3ef3-157">Per creare una classe derivata da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario sapere come creare database e un handle del sistema operativo.</span>
        <span class="sxs-lookup">
          <span data-stu-id="e3ef3-157">To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle.</span>
        </span>
        <span data-ttu-id="e3ef3-158">Questo processo è diverso per i tipi di handle diverso perché alcune usano i [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funzionare, mentre in altre funzioni più specifiche, ad esempio [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) o [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span>
        <span class="sxs-lookup">
          <span data-stu-id="e3ef3-158">This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span>
        </span>
        <span data-ttu-id="e3ef3-159">Per questo motivo, è necessario creare una classe derivata di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> per ogni tipo di handle del sistema operativo che si desidera eseguire il wrapping in un handle sicuro.</span>
        <span class="sxs-lookup">
          <span data-stu-id="e3ef3-159">For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.</span>
        </span>
        <span data-ttu-id="e3ef3-160">Quando si eredita da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario eseguire l'override dei seguenti membri: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> e <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="e3ef3-160">When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span>
        </span>
        <span data-ttu-id="e3ef3-161">È inoltre necessario fornire un costruttore predefinito che chiama il costruttore di base con un valore che rappresentano un valore di handle non valido, e un <see cref="T:System.Boolean" /> valore che indica se l'handle nativo è di proprietà per il <see cref="T:System.Runtime.InteropServices.SafeHandle" /> e, di conseguenza, deve essere liberata quando che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> byla zahozena.</span>
        <span class="sxs-lookup">
          <span data-stu-id="e3ef3-161">You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</span>
        </span>
      </para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="e3ef3-162">Valore di un handle non valido (in genere 0 o -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-162">The value of an invalid handle (usually 0 or -1).</span>
          </span>
          <span data-ttu-id="e3ef3-163">L'implementazione di <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> dovrebbe restituire <see langword="true" /> per questo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-163">Your implementation of <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> should return <see langword="true" /> for this value.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="e3ef3-164">
            <see langword="true" /> per fare in modo che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> rilasci in modo affidabile l'handle durante la fase di finalizzazione; in caso contrario, <see langword="false" /> (opzione non consigliata).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-164">
              <see langword="true" /> to reliably let <see cref="T:System.Runtime.InteropServices.SafeHandle" /> release the handle during the finalization phase; otherwise, <see langword="false" /> (not recommended).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e3ef3-165">Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> con il valore di handle non valido specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-165">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-166">Se il `ownsHandle` parametro è `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non viene mai chiamato; pertanto, non è consigliabile usare questo valore del parametro come il codice potrà verificarsi perdite di risorse.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-166">If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="e3ef3-167">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-167">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="e3ef3-168">per un'attendibilità totale per gli eredi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-168">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="e3ef3-169">Questo membro non può essere ereditato da codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-169">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e3ef3-170">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-170">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e3ef3-171">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-171">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-172">Contrassegna l'handle per il rilascio delle risorse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-172">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-173">Chiama il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare le risorse.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-173">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="e3ef3-174">Ciò potrebbe non avvenire immediatamente se altri thread utilizza lo stesso oggetto handle sicuro, ma verrà eseguito non appena non è questo il caso.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-174">This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="e3ef3-175">Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.SafeHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni dati allo stato di memoria).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-175">Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="e3ef3-176">In questo caso, la classe può fornire un finalizzatore che ti consente di eseguire prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-176">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="e3ef3-177">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo al termine usando il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-177">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3ef3-178">Chiamare sempre <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-178">Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="e3ef3-179">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-179">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-180">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-180">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-181">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-182">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-182">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <span data-ttu-id="e3ef3-183">
            <see langword="true" /> se il numero di riferimenti è stato incrementato correttamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-183">
              <see langword="true" /> if the reference counter was successfully incremented; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e3ef3-184">Incrementa manualmente il numero di riferimenti nelle istanze di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-184">Manually increments the reference counter on <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instances.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-185">Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> metodo che impedisce il recupero della memoria usata da un handle di common language runtime (che si verifica quando il runtime chiama il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo)).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-185">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method).</span></span> <span data-ttu-id="e3ef3-186">È possibile usare questo metodo per incrementare manualmente il conteggio dei riferimenti in un <xref:System.Runtime.InteropServices.SafeHandle> istanza.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-186">You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance.</span></span> <span data-ttu-id="e3ef3-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Restituisce un valore booleano usando un `ref` parametro (`success`) che indica se il conteggio dei riferimenti è stato incrementato correttamente.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully.</span></span> <span data-ttu-id="e3ef3-188">In questo modo la logica del programma di tornare indietro in caso di errore.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-188">This allows your program logic to back out in case of failure.</span></span> <span data-ttu-id="e3ef3-189">È consigliabile impostare `success` al `false` prima di chiamare <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-189">You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="e3ef3-190">Se `success` viene `true`, evitare perdite di risorse creando una corrispondenza tra la chiamata a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> con una chiamata corrispondente al <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-190">If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e3ef3-191">Questo metodo è destinato agli utenti avanzati e deve essere sempre utilizzato con attenzione.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-191">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="e3ef3-192">Per evitare perdite di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non la interrompa l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-192">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-193">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-193">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-194">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-194">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-195">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-195">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-196">Restituisce il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-196">Returns the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e3ef3-197">Valore <see langword="IntPtr" /> che rappresenta il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-197">An <see langword="IntPtr" /> representing the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
          <span data-ttu-id="e3ef3-198">Se l'handle è stato contrassegnato come non valido con <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, questo metodo restituisce comunque il valore di handle originale, che può essere un valore non aggiornato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-198">If the handle has been marked invalid with <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, this method still returns the original handle value, which can be a stale value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-199">È possibile usare questo metodo per recuperare il valore dell'handle effettivo da un'istanza del <xref:System.Runtime.InteropServices.SafeHandle> classe derivata.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-199">You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span> <span data-ttu-id="e3ef3-200">Questo metodo è necessario per garantire la compatibilità poiché molte proprietà in .NET Framework restituito `IntPtr` gestiscono tipi.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-200">This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types.</span></span> <span data-ttu-id="e3ef3-201">`IntPtr` tipi di handle sono tipi specifici della piattaforma usati per rappresentare un puntatore o un handle.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-201">`IntPtr` handle types are platform-specific types used to represent a pointer or a handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e3ef3-202">Usando il <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo può comportare rischi per la sicurezza in quanto, se l'handle è stato contrassegnato come non valido con <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> restituisce comunque il valore di handle originale, potrebbe non essere aggiornato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-202">Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value.</span></span> <span data-ttu-id="e3ef3-203">L'handle restituito può anche essere riutilizzata in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-203">The returned handle can also be recycled at any point.</span></span> <span data-ttu-id="e3ef3-204">Nel migliore dei casi, ciò significa che l'handle potrebbe smettere di funzionare improvvisamente.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-204">At best, this means the handle might suddenly stop working.</span></span> <span data-ttu-id="e3ef3-205">Nel peggiore dei casi, se l'handle o la risorsa che rappresenta l'handle viene esposto al codice non attendibile, questo può causare un attacco alla sicurezza riciclo nell'handle di riutilizzato o restituito.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-205">At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</span></span> <span data-ttu-id="e3ef3-206">Un chiamante non attendibile, ad esempio, possibile query sui dati dell'handle appena restituiti e ricevere informazioni per una risorsa completamente non correlata.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-206">For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</span></span> <span data-ttu-id="e3ef3-207">Vedere la <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodi per altre informazioni sull'uso di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> modo sicuro, vedere.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-207">See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-208">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-208">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-209">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-209">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-210">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-210">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-211">Decrementa manualmente il numero di riferimenti in un'istanza di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-211">Manually decrements the reference counter on a <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-212">Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodo è equivalente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-212">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="e3ef3-213">Si deve corrispondere sempre una chiamata per il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> con una chiamata al metodo <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-213">You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e3ef3-214">Questo metodo è destinato agli utenti avanzati e deve essere sempre utilizzato con attenzione.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-214">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="e3ef3-215">Per evitare perdite di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non la interrompa l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-215">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span> <span data-ttu-id="e3ef3-216">Nello stesso modo che non corrispondenti <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> le chiamate possono causare perdite di risorse, senza corrispondenza <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate possono provocare stati handle non valido diventare visibili agli altri thread.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-216">In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads.</span></span> <span data-ttu-id="e3ef3-217">Non esporre <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate a codice non attendibile.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-217">Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-218">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-218">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-219">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-219">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-220">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-220">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-221">Rilascia le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-221">Releases the resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-222">Rilascia tutte le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-222">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-223">Chiama il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare le risorse.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-223">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="e3ef3-224">Ciò potrebbe non avvenire immediatamente se altri thread utilizza la stessa istanza dell'handle sicuro, ma verrà eseguito non appena non è questo il caso.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-224">This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="e3ef3-225">Anche se più classi tramite <xref:System.Runtime.InteropServices.SafeHandle> non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o per il writeback di alcuni dati in memoria).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-225">Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="e3ef3-226">In questo caso, si può fornire un finalizzatore che ti consente di eseguire prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-226">In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="e3ef3-227">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo al termine usando il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-227">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="e3ef3-228">Il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo lascia il <xref:System.Runtime.InteropServices.SafeHandle> oggetto in uno stato inutilizzabile.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-228">The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3ef3-229">Chiamare sempre il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-229">Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="e3ef3-230">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-230">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-231">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-231">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-232">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-232">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-233">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-233">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="e3ef3-234">
            <see langword="true" /> per una normale operazione di eliminazione, <see langword="false" /> per finalizzare l'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-234">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e3ef3-235">Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> specificando se eseguire una normale operazione di eliminazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-235">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-236">È necessario chiamare in modo esplicito il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo con il `disposing` parametro impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-236">You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-237">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-237">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-238">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-238">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-239">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-239">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-240">Libera tutte le risorse associate all'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-240">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-241">Il <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metodo è il distruttore per il <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-241">The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span> <span data-ttu-id="e3ef3-242">Il codice dell'applicazione non deve chiamare direttamente questo metodo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-242">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-243">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-243">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-244">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-244">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-245">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-245">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-246">Specifica l'handle di cui eseguire il wrapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-246">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-247">L'handle non espongono pubblicamente (vale a dire, all'esterno della classe derivata).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-247">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-248">Ottiene un valore che indica se l'handle è chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-248">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e3ef3-249">
            <see langword="true" /> se l'handle è chiuso; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-249">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-250">Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo viene restituito un valore che indica se il <xref:System.Runtime.InteropServices.SafeHandle> handle dell'oggetto non è più associato a una risorsa nativa.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-250">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="e3ef3-251">Questo comportamento è diverso dalla definizione del <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà, che consente di calcolare se un handle specificato viene considerato sempre valido.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-251">This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="e3ef3-252">Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un `true` valore nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e3ef3-252">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="e3ef3-253">Il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-253">The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="e3ef3-254">Il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo è stato chiamato e non sono presenti riferimenti per il <xref:System.Runtime.InteropServices.SafeHandle> oggetti in altri thread.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-254">The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-255">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-255">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-256">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-256">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-257">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-257">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-258">Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-258">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e3ef3-259">
            <see langword="true" /> se il valore dell'handle non è valido; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-259">
              <see langword="true" /> if the handle value is invalid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-260">Le classi derivate devono implementare il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà in modo che common language runtime può determinare se è richiesta finalizzazione critica.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-260">Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="e3ef3-261">Le classi derivate devono fornire un'implementazione che indica il tipo generale di handle che supportano (0 o -1 non è valido).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-261">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="e3ef3-262">Queste classi possono essere derivate ulteriormente per i tipi di handle sicuro specifico.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-262">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="e3ef3-263">A differenza di <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> proprietà, che indica se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto ha terminato di utilizzare l'handle sottostante, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà calcola se il valore di handle specificato viene considerato sempre valido.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-263">Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="e3ef3-264">Pertanto, il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà restituisce sempre lo stesso valore per qualsiasi valore dell'handle.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-264">Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3ef3-265">L'esempio seguente controlla se un file è stata aperta correttamente.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-265">The following example checks if a file was opened successfully.</span></span> <span data-ttu-id="e3ef3-266">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-266">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-267">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-267">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-268">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-268">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-269">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-269">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-270">Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-270">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e3ef3-271">
            <see langword="true" /> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-271">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e3ef3-272">In questo caso, genera un assistente al debug gestito [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-272">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-273">Il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodo è garantito a essere chiamato solo una volta e solo se l'handle è valido, come definito dal <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-273">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property.</span></span> <span data-ttu-id="e3ef3-274">Implementare questo metodo nel <xref:System.Runtime.InteropServices.SafeHandle> dalle classi derivate per eseguire il codice necessario per liberare l'handle.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-274">Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="e3ef3-275">Perché una delle funzioni di <xref:System.Runtime.InteropServices.SafeHandle> consiste nel garantire la prevenzione di perdite di risorse, il codice nell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non deve mai avere esito negativo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-275">Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="e3ef3-276">Il garbage collector chiama <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> dopo l'esecuzione dei finalizzatori normale per gli oggetti che sono stati sottoposti a garbage collection nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-276">The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time.</span></span> <span data-ttu-id="e3ef3-277">Il garbage collector garantisce le risorse necessarie per richiamare questo metodo e che il metodo non verrà interrotto mentre è in corso.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-277">The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</span></span> <span data-ttu-id="e3ef3-278">Questo metodo verrà preparato come area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico chiamate in modo statico determinabile).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-278">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="e3ef3-279">Sebbene ciò impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre i percorsi di errore negli sottoposto a override <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e3ef3-279">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="e3ef3-280">In particolare, si applicano i <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> dell'attributo per tutti i metodi chiamati da <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-280">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="e3ef3-281">Nella maggior parte dei casi questo codice deve essere:</span><span class="sxs-lookup"><span data-stu-id="e3ef3-281">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="e3ef3-282">Inoltre, per la pulizia semplice (ad esempio, chiamando l'API Win32 `CloseHandle` su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-282">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="e3ef3-283">Per la pulizia delle complessa, si potrebbe avere più logica di programma e molte chiamate al metodo, alcuni dei quali può avere esito negativo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-283">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="e3ef3-284">È necessario assicurarsi che la logica del programma è codice fallback per ognuno di tali case.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-284">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="e3ef3-285">Se <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> restituisce `false` per qualsiasi motivo, genera un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) assistente al debug gestito.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-285">If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  <span data-ttu-id="e3ef3-286">Ciò consente di rilevare i casi in cui il tentativo di rilasciare le risorse abbia esito negativo.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-286">This helps you detect cases where your attempt to release resources fails.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e3ef3-287">Esempio di codice seguente rilascia l'handle e fa parte di un esempio più esaustivo disponibile per il <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-287">The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-288">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-288">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-289">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-289">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-290">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-290">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c">
          <span data-ttu-id="e3ef3-291">Diagnostica degli errori di Run-time assistenti al debug gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-291">Diagnosing Run-time Errors with Managed Debugging Assistants</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51">
          <span data-ttu-id="e3ef3-292">releaseHandleFailed)</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-292">ReleaseHandleFailed</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="e3ef3-293">Handle preesistente da usare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-293">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e3ef3-294">Imposta l'handle sull'handle preesistente specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-294">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-295">Usare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura) nell'infrastruttura di interoperabilità COM di .NET Framework supporta il marshalling degli handle in una struttura di output.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-295">Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-296">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-296">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-297">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-297">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-298">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e3ef3-299">Contrassegna un handle come non più usato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-299">Marks a handle as no longer used.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e3ef3-300">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo solo quando si certi che l'handle fa più riferimento a una risorsa.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-300">Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource.</span></span> <span data-ttu-id="e3ef3-301">In questo modo non modifica il valore della <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; solo l'handle viene contrassegnato come chiuso.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-301">Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed.</span></span> <span data-ttu-id="e3ef3-302">L'handle potrebbe essere quindi contenere un valore potrebbe non essere aggiornato.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-302">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="e3ef3-303">L'effetto di questa chiamata è che viene eseguito alcun tentativo per liberare le risorse.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-303">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="e3ef3-304">Come con le <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo, usare <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> solo se è necessario supportare un handle preesistente.</span><span class="sxs-lookup"><span data-stu-id="e3ef3-304">As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e3ef3-305">l'autorizzazione chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-305">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e3ef3-306">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-306">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="e3ef3-307">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e3ef3-307">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>