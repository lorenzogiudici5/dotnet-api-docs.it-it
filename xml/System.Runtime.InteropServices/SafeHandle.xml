<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c4334868cde5130ed9da65bfda7e798c24b12cd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="78b96-101">Rappresenta una classe wrapper per gli handle del sistema operativo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-101">Represents a wrapper class for operating system handles.</span>
      </span>
      <span data-ttu-id="78b96-102">La classe deve essere ereditata.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-102">This class must be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-103">La <xref:System.Runtime.InteropServices.SafeHandle> classe fornisce la finalizzazione critica di risorse di handle, impedendo agli handle di essere recuperati tramite garbage collection in modo anomalo e di essere riciclati da Windows per fare riferimento a oggetti non gestiti non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="78b96-103">The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</span></span>  
  
 <span data-ttu-id="78b96-104">Questo argomento include le sezioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="78b96-104">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="78b96-105">[Motivo per cui SafeHandle?](#Why) </span><span class="sxs-lookup"><span data-stu-id="78b96-105">[Why SafeHandle?](#Why) </span></span>  
 <span data-ttu-id="78b96-106">[Che cosa SafeHandle](#Does) </span><span class="sxs-lookup"><span data-stu-id="78b96-106">[What SafeHandle does](#Does) </span></span>  
 [<span data-ttu-id="78b96-107">Classi derivate da SafeHandle</span><span class="sxs-lookup"><span data-stu-id="78b96-107">Classes derived from SafeHandle</span></span>](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a><span data-ttu-id="78b96-108">Motivo per cui SafeHandle?</span><span class="sxs-lookup"><span data-stu-id="78b96-108">Why SafeHandle?</span></span>  
 <span data-ttu-id="78b96-109">Prima di .NET Framework versione 2.0, tutti i sistemi operativi handle possono solo essere incapsulati nel <xref:System.IntPtr> oggetto wrapper gestito.</span><span class="sxs-lookup"><span data-stu-id="78b96-109">Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object.</span></span> <span data-ttu-id="78b96-110">Mentre questo è un modo pratico per l'interoperabilità con codice nativo, gli handle potrebbero essere comunicati per le eccezioni asincrone, ad esempio un thread di interruzione in modo imprevisto o un overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="78b96-110">While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</span></span> <span data-ttu-id="78b96-111">Queste eccezioni asincrone sono un ostacolo alla pulizia delle risorse del sistema operativo e possono verificarsi praticamente ovunque nell'app.</span><span class="sxs-lookup"><span data-stu-id="78b96-111">These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</span></span>  
  
 <span data-ttu-id="78b96-112">Anche se l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo consentire la pulizia delle risorse non gestite quando un oggetto viene sottoposto a garbage collection, in alcuni casi, oggetti finalizzabili possono essere recuperati tramite garbage collection durante l'esecuzione di un metodo all'interno di una piattaforma invoke chiamata.</span><span class="sxs-lookup"><span data-stu-id="78b96-112">Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</span></span> <span data-ttu-id="78b96-113">Se un finalizzatore libera l'handle passato a tale piattaforma chiamata PInvoke, può causare l'handle venga danneggiato.</span><span class="sxs-lookup"><span data-stu-id="78b96-113">If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</span></span> <span data-ttu-id="78b96-114">L'handle può anche essere recuperato mentre il metodo è bloccato durante una chiamata PInvoke, ad esempio durante la lettura di un file.</span><span class="sxs-lookup"><span data-stu-id="78b96-114">The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</span></span>  
  
 <span data-ttu-id="78b96-115">Ancora più importante, poiché Windows riciclati handle, un handle potrebbe essere riciclati e puntare a un'altra risorsa che potrebbe contenere dati sensibili.</span><span class="sxs-lookup"><span data-stu-id="78b96-115">More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</span></span> <span data-ttu-id="78b96-116">Questo è noto come attacco riciclo e può danneggiare i dati e rappresentare una minaccia alla sicurezza.</span><span class="sxs-lookup"><span data-stu-id="78b96-116">This is known as a recycle attack and can potentially corrupt data and be a security threat.</span></span>  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a><span data-ttu-id="78b96-117">Che cosa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="78b96-117">What SafeHandle does</span></span>  
 <span data-ttu-id="78b96-118">Il <xref:System.Runtime.InteropServices.SafeHandle> classe semplifica molti di questi problemi di durata degli oggetti ed è integrata con platform invoke in modo che si verifichino perdite di risorse del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="78b96-118">The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</span></span> <span data-ttu-id="78b96-119">La <xref:System.Runtime.InteropServices.SafeHandle> classe risolve i problemi di durata degli oggetti assegnando e rilasciando handle senza interruzione.</span><span class="sxs-lookup"><span data-stu-id="78b96-119">The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="78b96-120">Contiene un finalizzatore critico che garantisce che l'handle è chiuso e verrà sicuramente eseguito durante imprevisto <xref:System.AppDomain> viene scaricata, anche nei casi in cui la chiamata di PInvoke si presuppone che sia in uno stato danneggiato.</span><span class="sxs-lookup"><span data-stu-id="78b96-120">It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</span></span>  
  
 <span data-ttu-id="78b96-121">Poiché <xref:System.Runtime.InteropServices.SafeHandle> eredita da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tutti i finalizzatori non critici vengono chiamati prima di qualsiasi dei finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="78b96-121">Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers.</span></span> <span data-ttu-id="78b96-122">I finalizzatori vengono richiamati su oggetti che non sono più in tempo reale durante il passaggio della garbage collection stessa.</span><span class="sxs-lookup"><span data-stu-id="78b96-122">The finalizers are called on objects that are no longer live during the same garbage collection pass.</span></span> <span data-ttu-id="78b96-123">Ad esempio, un <xref:System.IO.FileStream> oggetto può eseguire un finalizzatore normale per cancellare i dati memorizzati nel buffer esistenti senza il rischio che l'handle viene perduto o venga riciclato.</span><span class="sxs-lookup"><span data-stu-id="78b96-123">For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</span></span> <span data-ttu-id="78b96-124">Questo ordinamento tra finalizzatori critici e non è per uso generale.</span><span class="sxs-lookup"><span data-stu-id="78b96-124">This very weak ordering between critical and noncritical finalizers is not intended for general use.</span></span> <span data-ttu-id="78b96-125">Esiste principalmente per facilitare la migrazione di librerie esistenti consentendo a tali librerie da utilizzare <xref:System.Runtime.InteropServices.SafeHandle> senza modificare la semantica.</span><span class="sxs-lookup"><span data-stu-id="78b96-125">It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics.</span></span> <span data-ttu-id="78b96-126">Inoltre, il finalizzatore critico e tutto ciò che chiama, ad esempio il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodo, deve essere in un'area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="78b96-126">Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method, must be in a constrained execution region.</span></span> <span data-ttu-id="78b96-127">Questo impone vincoli per il codice che può essere scritti nel grafico delle chiamate del finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="78b96-127">This imposes constraints on what code can be written within the finalizer's call graph.</span></span>  
  
 <span data-ttu-id="78b96-128">Le operazioni pInvoke automaticamente incrementa il conteggio dei riferimenti degli handle incapsulati da un <xref:System.Runtime.InteropServices.SafeHandle> e li decremento dopo il completamento.</span><span class="sxs-lookup"><span data-stu-id="78b96-128">Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion.</span></span> <span data-ttu-id="78b96-129">Ciò garantisce che l'handle non verrà riciclato o chiuso in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="78b96-129">This ensures that the handle will not be recycled or closed unexpectedly.</span></span>  
  
 <span data-ttu-id="78b96-130">È possibile specificare la proprietà dell'handle sottostante durante la costruzione di <xref:System.Runtime.InteropServices.SafeHandle> oggetti fornendo un valore per il `ownsHandle` argomento in di <xref:System.Runtime.InteropServices.SafeHandle> costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="78b96-130">You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor.</span></span> <span data-ttu-id="78b96-131">Controlla se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto causerà il rilascio di handle dopo l'oggetto è stato eliminato.</span><span class="sxs-lookup"><span data-stu-id="78b96-131">This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.</span></span>  <span data-ttu-id="78b96-132">Ciò è utile per gli handle con requisiti particolari durata o per l'utilizzo di un handle la cui durata è controllata da un altro utente.</span><span class="sxs-lookup"><span data-stu-id="78b96-132">This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</span></span>  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a><span data-ttu-id="78b96-133">Classi derivate da SafeHandle</span><span class="sxs-lookup"><span data-stu-id="78b96-133">Classes derived from SafeHandle</span></span>  
 <span data-ttu-id="78b96-134"><xref:System.Runtime.InteropServices.SafeHandle> è una classe wrapper astratta per gli handle del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="78b96-134"><xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles.</span></span> <span data-ttu-id="78b96-135">La derivazione da questa classe è difficile.</span><span class="sxs-lookup"><span data-stu-id="78b96-135">Deriving from this class is difficult.</span></span> <span data-ttu-id="78b96-136">Utilizzare invece le classi derivate nello spazio dei nomi <xref:Microsoft.Win32.SafeHandles> che forniscono handle sicuri per gli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="78b96-136">Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:</span></span>  
  
-   <span data-ttu-id="78b96-137">I file (il <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-137">Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-138">File mappati alla memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-138">Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-139">Pipe (la <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-139">Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-140">Visualizzazioni di memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-140">Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-141">Costrutti di crittografia (il <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classi).</span><span class="sxs-lookup"><span data-stu-id="78b96-141">Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span></span>  
  
-   <span data-ttu-id="78b96-142">I processi (la <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-142">Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-143">Le chiavi del Registro di sistema (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-143">Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).</span></span>  
  
-   <span data-ttu-id="78b96-144">Handle di attesa (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="78b96-144">Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b96-145">Esempio di codice seguente crea un handle sicuro personalizzato per un handle di file del sistema operativo, la derivazione da <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span><span class="sxs-lookup"><span data-stu-id="78b96-145">The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span></span> <span data-ttu-id="78b96-146">Legge i byte da un file e consente di visualizzare i valori esadecimali.</span><span class="sxs-lookup"><span data-stu-id="78b96-146">It reads bytes from a file and displays their hexadecimal values.</span></span> <span data-ttu-id="78b96-147">Contiene inoltre un test harness di errore che causa l'interruzione del thread, ma il valore dell'handle viene liberato.</span><span class="sxs-lookup"><span data-stu-id="78b96-147">It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</span></span>  <span data-ttu-id="78b96-148">Quando si utilizza un <xref:System.IntPtr> per rappresentare gli handle, l'handle viene occasionalmente perso a causa dell'interruzione di thread asincroni.</span><span class="sxs-lookup"><span data-stu-id="78b96-148">When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</span></span>  
  
 <span data-ttu-id="78b96-149">È necessario un file di testo nella stessa cartella dell'applicazione compilata.</span><span class="sxs-lookup"><span data-stu-id="78b96-149">You will need a text file in the same folder as the compiled application.</span></span> <span data-ttu-id="78b96-150">Supponendo che il nome dell'applicazione "HexViewer", l'utilizzo della riga di comando è:</span><span class="sxs-lookup"><span data-stu-id="78b96-150">Assuming that you name the application "HexViewer", the command line usage is:</span></span>  
  
 `HexViewer <filename> -Fault`  
  
 <span data-ttu-id="78b96-151">Facoltativamente specificare `-Fault` per tentare intenzionalmente di perdere l'handle per l'interruzione del thread in una determinata finestra.</span><span class="sxs-lookup"><span data-stu-id="78b96-151">Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window.</span></span> <span data-ttu-id="78b96-152">Utilizzare lo strumento Windows Perform.exe per monitorare i conteggi degli handle durante l'inserimento di errori.</span><span class="sxs-lookup"><span data-stu-id="78b96-152">Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</span></span>  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="78b96-153">per l'attendibilità totale per gli eredi.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-153">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="78b96-154">Questo membro non può essere ereditato da codice parzialmente attendibile.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-154">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="78b96-155">richiede l'attendibilità totale per il chiamante immediato.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-155">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="78b96-156">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78b96-156">This member cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="78b96-157">Per creare una classe derivata da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario sapere come creare e liberare un handle del sistema operativo.</span>
        <span class="sxs-lookup">
          <span data-stu-id="78b96-157">To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle.</span>
        </span>
        <span data-ttu-id="78b96-158">Questo processo è diverso per i tipi di handle diversi perché alcuni utilizzano il [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funzione, mentre altri utilizzano le funzioni più specifiche, ad esempio [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) o [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span>
        <span class="sxs-lookup">
          <span data-stu-id="78b96-158">This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span>
        </span>
        <span data-ttu-id="78b96-159">Per questo motivo, è necessario creare una classe derivata di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> per ogni tipo di handle del sistema operativo che si desidera eseguire il wrapping in un handle sicuro.</span>
        <span class="sxs-lookup">
          <span data-stu-id="78b96-159">For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.</span>
        </span>
        <span data-ttu-id="78b96-160">Quando si eredita da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario eseguire l'override dei seguenti membri: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> e <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="78b96-160">When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span>
        </span>
        <span data-ttu-id="78b96-161">È inoltre necessario fornire un costruttore predefinito che chiama il costruttore base con un valore che rappresenta un valore di handle non valido, e un <see cref="T:System.Boolean" /> valore che indica se l'handle nativo è di proprietà di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> e pertanto deve essere liberata quando che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> è stato eliminato.</span>
        <span class="sxs-lookup">
          <span data-stu-id="78b96-161">You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</span>
        </span>
      </para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="78b96-162">Valore di un handle non valido (in genere 0 o -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-162">The value of an invalid handle (usually 0 or -1).</span>
          </span>
          <span data-ttu-id="78b96-163">L'implementazione di <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> dovrebbe restituire <see langword="true" /> per questo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-163">Your implementation of <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> should return <see langword="true" /> for this value.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="78b96-164">
            <see langword="true" /> per fare in modo che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> rilasci in modo affidabile l'handle durante la fase di finalizzazione; in caso contrario, <see langword="false" /> (opzione non consigliata).</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-164">
              <see langword="true" /> to reliably let <see cref="T:System.Runtime.InteropServices.SafeHandle" /> release the handle during the finalization phase; otherwise, <see langword="false" /> (not recommended).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78b96-165">Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> con il valore di handle non valido specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-165">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-166">Se il `ownsHandle` parametro `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non viene mai chiamato; pertanto, non è consigliabile utilizzare questo valore del parametro come il codice può provocare la perdita di risorse.</span><span class="sxs-lookup"><span data-stu-id="78b96-166">If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="78b96-167">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-167">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="78b96-168">per l'attendibilità totale per gli eredi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-168">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="78b96-169">Questo membro non può essere ereditato da codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-169">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78b96-170">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-170">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78b96-171">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-171">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-172">Contrassegna l'handle per il rilascio delle risorse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-172">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-173">La chiamata di <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare risorse.</span><span class="sxs-lookup"><span data-stu-id="78b96-173">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="78b96-174">Potrebbe non verificarsi immediatamente se altri thread utilizza lo stesso oggetto handle sicuro, ma verrà eseguito non appena non è questo il caso.</span><span class="sxs-lookup"><span data-stu-id="78b96-174">This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="78b96-175">Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.SafeHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria).</span><span class="sxs-lookup"><span data-stu-id="78b96-175">Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="78b96-176">In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.</span><span class="sxs-lookup"><span data-stu-id="78b96-176">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="78b96-177">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="78b96-177">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78b96-178">Chiamare sempre il metodo <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="78b96-178">Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="78b96-179">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="78b96-179">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-180">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-180">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-181">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-182">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-182">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <span data-ttu-id="78b96-183">
            <see langword="true" /> se il numero di riferimenti è stato incrementato correttamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-183">
              <see langword="true" /> if the reference counter was successfully incremented; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78b96-184">Incrementa manualmente il numero di riferimenti nelle istanze di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-184">Manually increments the reference counter on <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instances.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-185">Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> metodo che impedisce il recupero della memoria usata da un handle di common language runtime (che si verifica quando il runtime chiama il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo)).</span><span class="sxs-lookup"><span data-stu-id="78b96-185">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method).</span></span> <span data-ttu-id="78b96-186">È possibile utilizzare questo metodo per incrementare manualmente il conteggio dei riferimenti in un <xref:System.Runtime.InteropServices.SafeHandle> istanza.</span><span class="sxs-lookup"><span data-stu-id="78b96-186">You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance.</span></span> <span data-ttu-id="78b96-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Restituisce un valore booleano utilizzando un `ref` parametro (`success`) che indica se il conteggio dei riferimenti è stato incrementato correttamente.</span><span class="sxs-lookup"><span data-stu-id="78b96-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully.</span></span> <span data-ttu-id="78b96-188">In questo modo la logica del programma di tornare indietro, in caso di errore.</span><span class="sxs-lookup"><span data-stu-id="78b96-188">This allows your program logic to back out in case of failure.</span></span> <span data-ttu-id="78b96-189">È consigliabile impostare `success` a `false` prima di chiamare <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="78b96-189">You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="78b96-190">Se `success` è `true`, evitare perdite di risorse creando una corrispondenza tra la chiamata a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> con una chiamata corrispondente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="78b96-190">If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78b96-191">Questo metodo è destinato agli utenti esperti e deve sempre essere utilizzato con attenzione.</span><span class="sxs-lookup"><span data-stu-id="78b96-191">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="78b96-192">Per evitare la perdita di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non è possibile interrompere l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="78b96-192">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-193">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-193">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-194">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-194">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-195">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-195">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-196">Restituisce il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-196">Returns the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78b96-197">Valore <see langword="IntPtr" /> che rappresenta il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-197">An <see langword="IntPtr" /> representing the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
          <span data-ttu-id="78b96-198">Se l'handle è stato contrassegnato come non valido con <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, questo metodo restituisce comunque il valore di handle originale, che può essere un valore non aggiornato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-198">If the handle has been marked invalid with <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, this method still returns the original handle value, which can be a stale value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-199">È possibile utilizzare questo metodo per recuperare il valore effettivo dell'handle da un'istanza di <xref:System.Runtime.InteropServices.SafeHandle> classe derivata.</span><span class="sxs-lookup"><span data-stu-id="78b96-199">You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span> <span data-ttu-id="78b96-200">Questo metodo è necessario per la compatibilità poiché molte proprietà in .NET Framework restituiscono `IntPtr` gestire tipi.</span><span class="sxs-lookup"><span data-stu-id="78b96-200">This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types.</span></span> <span data-ttu-id="78b96-201">`IntPtr` tipi di handle sono tipi specifici della piattaforma usati per rappresentare un puntatore o un handle.</span><span class="sxs-lookup"><span data-stu-id="78b96-201">`IntPtr` handle types are platform-specific types used to represent a pointer or a handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78b96-202">Utilizzo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo può comportare rischi di sicurezza in quanto, se l'handle è stato contrassegnato come non valido con <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> restituisce comunque il valore di handle originale, potrebbe non essere aggiornato.</span><span class="sxs-lookup"><span data-stu-id="78b96-202">Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value.</span></span> <span data-ttu-id="78b96-203">L'handle restituito può anche essere riutilizzata in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="78b96-203">The returned handle can also be recycled at any point.</span></span> <span data-ttu-id="78b96-204">Nel migliore dei casi, ciò significa che l'handle improvvisamente potrebbe smettere di funzionare.</span><span class="sxs-lookup"><span data-stu-id="78b96-204">At best, this means the handle might suddenly stop working.</span></span> <span data-ttu-id="78b96-205">Nel peggiore dei casi, se l'handle o la risorsa che rappresenta l'handle è esposto al codice non attendibile, ciò può causare un attacco alla sicurezza riciclo dell'handle riutilizzato o restituito.</span><span class="sxs-lookup"><span data-stu-id="78b96-205">At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</span></span> <span data-ttu-id="78b96-206">Ad esempio, un chiamante non attendibile può query sui dati dell'handle appena restituiti e ricevere informazioni per una risorsa completamente non correlata.</span><span class="sxs-lookup"><span data-stu-id="78b96-206">For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</span></span> <span data-ttu-id="78b96-207">Vedere il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodi per ulteriori informazioni sull'utilizzo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="78b96-207">See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-208">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-208">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-209">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-209">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-210">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-210">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-211">Decrementa manualmente il numero di riferimenti in un'istanza di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-211">Manually decrements the reference counter on a <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-212">Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodo è equivalente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="78b96-212">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="78b96-213">Si deve sempre corrispondere una chiamata al <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> con una chiamata al metodo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="78b96-213">You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78b96-214">Questo metodo è destinato agli utenti esperti e deve sempre essere utilizzato con attenzione.</span><span class="sxs-lookup"><span data-stu-id="78b96-214">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="78b96-215">Per evitare la perdita di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non è possibile interrompere l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="78b96-215">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span> <span data-ttu-id="78b96-216">Nello stesso modo che non corrispondenti <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> chiamata può causare perdite di risorse, senza corrispondenza <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamata può causare gli stati di handle non valido per diventano visibili ad altri thread.</span><span class="sxs-lookup"><span data-stu-id="78b96-216">In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads.</span></span> <span data-ttu-id="78b96-217">Non esporre <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate a codice non attendibile.</span><span class="sxs-lookup"><span data-stu-id="78b96-217">Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-218">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-218">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-219">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-219">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-220">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-220">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="78b96-221">Rilascia le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-221">Releases the resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-222">Rilascia tutte le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-222">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-223">La chiamata di <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare risorse.</span><span class="sxs-lookup"><span data-stu-id="78b96-223">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="78b96-224">Potrebbe non verificarsi immediatamente se altri thread utilizza la stessa istanza di handle sicuro, ma verrà eseguito non appena non è questo il caso.</span><span class="sxs-lookup"><span data-stu-id="78b96-224">This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="78b96-225">Anche se più classi che utilizzano <xref:System.Runtime.InteropServices.SafeHandle> non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o eseguire il writeback di alcuni dati in memoria).</span><span class="sxs-lookup"><span data-stu-id="78b96-225">Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="78b96-226">In questo caso, forniscono un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.</span><span class="sxs-lookup"><span data-stu-id="78b96-226">In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="78b96-227">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="78b96-227">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="78b96-228">Il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo lascia la <xref:System.Runtime.InteropServices.SafeHandle> oggetto in uno stato inutilizzabile.</span><span class="sxs-lookup"><span data-stu-id="78b96-228">The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78b96-229">Chiamare sempre il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="78b96-229">Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="78b96-230">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="78b96-230">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-231">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-231">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-232">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-232">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-233">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-233">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="78b96-234">
            <see langword="true" /> per una normale operazione di eliminazione, <see langword="false" /> per finalizzare l'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-234">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78b96-235">Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> specificando se eseguire una normale operazione di eliminazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-235">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-236">È necessario chiamare mai in modo esplicito il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo con il `disposing` parametro impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="78b96-236">You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-237">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-237">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-238">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-238">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-239">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-239">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-240">Libera tutte le risorse associate all'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-240">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-241">Il <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metodo è il distruttore per la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="78b96-241">The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span> <span data-ttu-id="78b96-242">Il codice dell'applicazione non deve chiamare questo metodo direttamente.</span><span class="sxs-lookup"><span data-stu-id="78b96-242">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-243">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-243">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-244">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-244">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-245">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-245">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="78b96-246">Specifica l'handle di cui eseguire il wrapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-246">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-247">Non esporre pubblicamente l'handle (ovvero, all'esterno della classe derivata).</span><span class="sxs-lookup"><span data-stu-id="78b96-247">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="78b96-248">Ottiene un valore che indica se l'handle è chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-248">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="78b96-249">
            <see langword="true" /> se l'handle è chiuso; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-249">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-250">Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un valore che indica se il <xref:System.Runtime.InteropServices.SafeHandle> handle dell'oggetto non è più associato a una risorsa nativa.</span><span class="sxs-lookup"><span data-stu-id="78b96-250">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="78b96-251">Questo comportamento è diverso dalla definizione della <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà, che calcola se un handle specificato è sempre considerato non valido.</span><span class="sxs-lookup"><span data-stu-id="78b96-251">This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="78b96-252">Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un `true` valore nei seguenti casi:</span><span class="sxs-lookup"><span data-stu-id="78b96-252">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="78b96-253">Il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="78b96-253">The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="78b96-254">Il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo è stato chiamato e non sono presenti riferimenti per il <xref:System.Runtime.InteropServices.SafeHandle> in altri thread.</span><span class="sxs-lookup"><span data-stu-id="78b96-254">The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-255">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-255">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-256">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-256">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-257">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-257">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="78b96-258">Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-258">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="78b96-259">
            <see langword="true" /> se il valore dell'handle non è valido; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-259">
              <see langword="true" /> if the handle value is invalid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-260">Le classi derivate devono implementare il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà in modo da common language runtime può determinare se è necessaria la finalizzazione critica.</span><span class="sxs-lookup"><span data-stu-id="78b96-260">Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="78b96-261">Classi derivate devono fornire un'implementazione adatta il tipo di handle supportano generale (0 o -1 non è valido).</span><span class="sxs-lookup"><span data-stu-id="78b96-261">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="78b96-262">Queste classi possono essere ulteriormente derivate per i tipi di handle sicuro specifico.</span><span class="sxs-lookup"><span data-stu-id="78b96-262">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="78b96-263">A differenza di <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> proprietà, che indica se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto ha terminato di utilizzare l'handle sottostante, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà calcola se il valore di handle specificato viene sempre considerato non valido.</span><span class="sxs-lookup"><span data-stu-id="78b96-263">Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="78b96-264">Pertanto, il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà restituisce sempre lo stesso valore per ogni valore dell'handle.</span><span class="sxs-lookup"><span data-stu-id="78b96-264">Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b96-265">L'esempio seguente verifica se un file è stato aperto correttamente.</span><span class="sxs-lookup"><span data-stu-id="78b96-265">The following example checks if a file was opened successfully.</span></span> <span data-ttu-id="78b96-266">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="78b96-266">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-267">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-267">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-268">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-268">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-269">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-269">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-270">Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-270">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78b96-271">
            <see langword="true" /> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-271">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="78b96-272">In questo caso, genera un assistente al debug gestito [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-272">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-273">Il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> garantito per essere chiamato solo una volta e solo se l'handle è valido, come definito dal metodo di <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="78b96-273">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property.</span></span> <span data-ttu-id="78b96-274">Implementare questo metodo nel <xref:System.Runtime.InteropServices.SafeHandle> dalle classi derivate per eseguire il codice necessario per liberare l'handle.</span><span class="sxs-lookup"><span data-stu-id="78b96-274">Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="78b96-275">Perché una delle funzioni di <xref:System.Runtime.InteropServices.SafeHandle> consiste nell'impedire la perdita di risorse, il codice nell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non deve mai avere esito negativo.</span><span class="sxs-lookup"><span data-stu-id="78b96-275">Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="78b96-276">Il garbage collector chiama <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> dopo l'esecuzione dei finalizzatori normale per gli oggetti che sono state sottoposte a garbage collection nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="78b96-276">The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time.</span></span> <span data-ttu-id="78b96-277">Le risorse per richiamare questo metodo assicura che il garbage collector e che il metodo non verrà interrotto mentre è in corso.</span><span class="sxs-lookup"><span data-stu-id="78b96-277">The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</span></span> <span data-ttu-id="78b96-278">Questo metodo verrà preparato come un'area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico delle chiamate di determinare in modo statico).</span><span class="sxs-lookup"><span data-stu-id="78b96-278">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="78b96-279">Sebbene questo impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre percorsi qualsiasi errore sottoposto a override <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="78b96-279">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="78b96-280">In particolare, applicare il <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attributo per tutti i metodi chiamati da <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="78b96-280">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="78b96-281">Nella maggior parte dei casi questo codice deve essere:</span><span class="sxs-lookup"><span data-stu-id="78b96-281">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="78b96-282">Inoltre, per la pulizia semplice (ad esempio, la chiamata API Win32 `CloseHandle` su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke.</span><span class="sxs-lookup"><span data-stu-id="78b96-282">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="78b96-283">Operazioni di pulizia complesse, potrebbe essere molto logica di programma e le chiamate al metodo, alcune delle quali potrebbe avere esito negativo.</span><span class="sxs-lookup"><span data-stu-id="78b96-283">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="78b96-284">È necessario assicurarsi che la logica del programma è codice di fallback per ognuno dei casi.</span><span class="sxs-lookup"><span data-stu-id="78b96-284">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="78b96-285">Se <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> restituisce `false` per qualsiasi motivo, viene generato un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) assistente al debug gestito.</span><span class="sxs-lookup"><span data-stu-id="78b96-285">If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  <span data-ttu-id="78b96-286">Ciò consente di rilevare i casi in cui il tentativo di rilasciare le risorse ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="78b96-286">This helps you detect cases where your attempt to release resources fails.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b96-287">Esempio di codice seguente rilascia l'handle e fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="78b96-287">The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-288">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-288">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-289">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-289">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-290">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-290">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="78b96-291">Handle preesistente da usare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-291">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78b96-292">Imposta l'handle sull'handle preesistente specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-292">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-293">Utilizzare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura), in quanto l'infrastruttura di interoperabilità COM di .NET Framework non supporta il marshalling degli handle in una struttura di output.</span><span class="sxs-lookup"><span data-stu-id="78b96-293">Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-294">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-294">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-295">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-295">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-296">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-296">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78b96-297">Contrassegna un handle come non più usato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-297">Marks a handle as no longer used.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b96-298">Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo solo quando si è certi che l'handle fa più riferimento a una risorsa.</span><span class="sxs-lookup"><span data-stu-id="78b96-298">Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource.</span></span> <span data-ttu-id="78b96-299">In questo modo, il valore di non modificare il <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; solo contrassegna l'handle come chiuso.</span><span class="sxs-lookup"><span data-stu-id="78b96-299">Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed.</span></span> <span data-ttu-id="78b96-300">L'handle potrebbe quindi contenere un valore non aggiornato.</span><span class="sxs-lookup"><span data-stu-id="78b96-300">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="78b96-301">L'effetto di questa chiamata è che viene eseguito alcun tentativo di liberare le risorse.</span><span class="sxs-lookup"><span data-stu-id="78b96-301">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="78b96-302">Come con la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo, utilizzare <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> solo se è necessario supportare un handle preesistente.</span><span class="sxs-lookup"><span data-stu-id="78b96-302">As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="78b96-303">l'autorizzazione per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-303">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="78b96-304">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-304">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="78b96-305">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="78b96-305">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>