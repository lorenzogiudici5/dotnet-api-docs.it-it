<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52be7711ddbbcd95a2f906f5949976e7af850878" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646587" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una classe wrapper per gli handle del sistema operativo. La classe deve essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle> classe fornisce la finalizzazione critica delle risorse di handle, impedendo agli handle di essere recuperati in anticipo da garbage collection e di essere riciclati da Windows per fare riferimento a oggetti non gestiti non intenzionali.  
  
 Questo argomento include le sezioni seguenti:  
  
 [Il motivo per cui SafeHandle?](#Why)   
 [Funzionamento di SafeHandle](#Does)   
 [Classi derivate da SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Il motivo per cui SafeHandle?  
 Prima di .NET Framework versione 2.0, sistema operativo tutti gli handle possono solo essere incapsulati nel <xref:System.IntPtr> oggetto wrapper gestito. Mentre questo è un modo pratico per l'interoperabilità con codice nativo, gli handle è stato possibile andrà persa per le eccezioni asincrone, ad esempio un thread che si interrompe in modo imprevisto o un overflow dello stack. Queste eccezioni asincrone sono un ostacolo alla pulizia delle risorse di sistema operativo e possono verificarsi quasi ovunque nell'app.  
  
 Anche se esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo consente la pulizia delle risorse non gestite quando un oggetto viene sottoposto a garbage collection, in alcune circostanze, oggetti finalizzabili possono essere recuperati da garbage collection durante l'esecuzione di un metodo all'interno di una piattaforma di richiamare chiamare. Se un finalizzatore rilascia l'handle passato a tale piattaforma chiamata invoke, ciò potrebbe causare per il danneggiamento di gestire. L'handle può anche essere recuperato mentre il metodo è bloccato durante una chiamata PInvoke, ad esempio durante la lettura di un file.  
  
 Ancora più importante, poiché Windows viene riciclato in modo aggressivo gli handle, un handle può essere riciclato e puntare a un'altra risorsa che potrebbe contenere dati sensibili. Questo è noto come un attacco di riciclo e può potenzialmente danneggiare i dati e rappresentare una minaccia alla sicurezza.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Funzionamento di SafeHandle  
 Il <xref:System.Runtime.InteropServices.SafeHandle> classe semplifica molti di questi problemi di durata degli oggetti ed è integrata con platform invoke in modo che si verifichino perdite di risorse del sistema operativo. Il <xref:System.Runtime.InteropServices.SafeHandle> classe risolve i problemi di durata degli oggetti assegnando e rilasciando handle senza interruzione. Contiene un finalizzatore critico la cui garantisce che l'handle è chiuso e verrà sicuramente eseguito durante imprevisto <xref:System.AppDomain> viene scaricato, anche in casi in cui la chiamata di PInvoke presuppone che sia stato danneggiato.  
  
 In quanto <xref:System.Runtime.InteropServices.SafeHandle> eredita da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tutti i finalizzatori non critici vengono richiamati prima di qualsiasi dei finalizzatori. I finalizzatori vengono richiamati su oggetti che non sono più in tempo reale durante il passaggio della garbage collection stessa. Ad esempio, un <xref:System.IO.FileStream> oggetto può eseguire un finalizzatore normale per cancellare i dati memorizzati nel buffer esistenti senza il rischio che l'handle viene persa o riciclati. Questo ordinamento molto debole tra dei finalizzatori critici e non per uso generale. Esiste principalmente per facilitare la migrazione delle raccolte esistenti, consentendo a tali librerie da utilizzare <xref:System.Runtime.InteropServices.SafeHandle> senza modificare la semantica. Inoltre, il finalizzatore critico e qualsiasi valore chiama, ad esempio il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodo, deve essere in un'area a esecuzione vincolata. Ciò impone vincoli per il tipo di codice può essere scritti nel grafico delle chiamate del finalizzatore.  
  
 Operazioni automaticamente di platform invoke incrementare il conteggio dei riferimenti degli handle incapsulato da un <xref:System.Runtime.InteropServices.SafeHandle> e li decremento dopo il completamento. Ciò garantisce che l'handle non verrà riciclato o chiusa in modo imprevisto.  
  
 È possibile specificare la proprietà di handle sottostante durante la costruzione <xref:System.Runtime.InteropServices.SafeHandle> oggetti fornendo un valore per il `ownsHandle` argomento nel <xref:System.Runtime.InteropServices.SafeHandle> costruttore della classe. Consente di controllare se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto verrà rilasciato l'handle dopo che l'oggetto è stato eliminato.  Ciò è utile per gli handle con requisiti particolari durata o per l'utilizzo di un handle di cui durata è controllata da un altro utente.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Classi derivate da SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> è una classe wrapper astratta per gli handle del sistema operativo. La derivazione da questa classe è difficile. Utilizzare invece le classi derivate nello spazio dei nomi <xref:Microsoft.Win32.SafeHandles> che forniscono handle sicuri per gli elementi seguenti:  
  
-   I file (il <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).  
  
-   File mappati alla memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).  
  
-   Pipe (il <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).  
  
-   Visualizzazioni di memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).  
  
-   Costrutti di crittografia (il <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classi).  
  
-   I processi (il <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).  
  
-   Le chiavi del Registro di sistema (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).  
  
-   Handle di attesa (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).  
  
   
  
## Examples  
 Esempio di codice seguente crea un handle sicuro personalizzato per un handle di file del sistema operativo, che deriva da <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Legge i byte da un file e visualizza i valori esadecimali. Contiene anche un test harness degli errori che causa l'interruzione del thread, ma il valore dell'handle viene liberato.  Quando si usa un <xref:System.IntPtr> per rappresentare gli handle, l'handle viene perso occasionalmente a causa dell'interruzione del thread asincroni.  
  
 È necessario un file di testo nella stessa cartella dell'applicazione compilata. Supponendo che il nome dell'applicazione "HexViewer", l'utilizzo della riga di comando è:  
  
 `HexViewer <filename> -Fault`  
  
 Facoltativamente, specificare `-Fault` intenzionalmente tentativi di perdere l'handle per l'interruzione del thread in una determinata finestra. Usare lo strumento Windows Perfmon.exe per monitorare i conteggi di handle durante l'inserimento di errori.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per un'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
    <block subset="none" type="overrides">
      <para>Per creare una classe derivata da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario sapere come creare database e un handle del sistema operativo. Questo processo è diverso per i tipi di handle diverso perché alcune usano i [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funzionare, mentre in altre funzioni più specifiche, ad esempio [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) o [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Per questo motivo, è necessario creare una classe derivata di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> per ogni tipo di handle del sistema operativo che si desidera eseguire il wrapping in un handle sicuro.  
  
Quando si eredita da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario eseguire l'override dei seguenti membri: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> e <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
È inoltre necessario fornire un costruttore predefinito che chiama il costruttore di base con un valore che rappresentano un valore di handle non valido, e un <see cref="T:System.Boolean" /> valore che indica se l'handle nativo è di proprietà per il <see cref="T:System.Runtime.InteropServices.SafeHandle" /> e, di conseguenza, deve essere liberata quando che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> byla zahozena.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valore di un handle non valido (in genere 0 o -1).  L'implementazione di <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> dovrebbe restituire <see langword="true" /> per questo valore.</param>
        <param name="ownsHandle">
          <see langword="true" /> per fare in modo che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> rilasci in modo affidabile l'handle durante la fase di finalizzazione; in caso contrario, <see langword="false" /> (opzione non consigliata).</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> con il valore di handle non valido specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `ownsHandle` parametro è `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non viene mai chiamato; pertanto, non è consigliabile usare questo valore del parametro come il codice potrà verificarsi perdite di risorse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per un'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna l'handle per il rilascio delle risorse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiama il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare le risorse. Ciò potrebbe non avvenire immediatamente se altri thread utilizza lo stesso oggetto handle sicuro, ma verrà eseguito non appena non è questo il caso. Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.SafeHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni dati allo stato di memoria). In questo caso, la classe può fornire un finalizzatore che ti consente di eseguire prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo al termine usando il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.  
  
> [!NOTE]
>  Chiamare sempre <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> se il numero di riferimenti è stato incrementato correttamente; in caso contrario, <see langword="false" />.</param>
        <summary>Incrementa manualmente il numero di riferimenti nelle istanze di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> metodo che impedisce il recupero della memoria usata da un handle di common language runtime (che si verifica quando il runtime chiama il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo)). È possibile usare questo metodo per incrementare manualmente il conteggio dei riferimenti in un <xref:System.Runtime.InteropServices.SafeHandle> istanza. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Restituisce un valore booleano usando un `ref` parametro (`success`) che indica se il conteggio dei riferimenti è stato incrementato correttamente. In questo modo la logica del programma di tornare indietro in caso di errore. È consigliabile impostare `success` al `false` prima di chiamare <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Se `success` viene `true`, evitare perdite di risorse creando una corrispondenza tra la chiamata a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> con una chiamata corrispondente al <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Questo metodo è destinato agli utenti avanzati e deve essere sempre utilizzato con attenzione. Per evitare perdite di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non la interrompa l'elaborazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>Valore <see langword="IntPtr" /> che rappresenta il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Se l'handle è stato contrassegnato come non valido con <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, questo metodo restituisce comunque il valore di handle originale, che può essere un valore non aggiornato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare questo metodo per recuperare il valore dell'handle effettivo da un'istanza del <xref:System.Runtime.InteropServices.SafeHandle> classe derivata. Questo metodo è necessario per garantire la compatibilità poiché molte proprietà in .NET Framework restituito `IntPtr` gestiscono tipi. `IntPtr` tipi di handle sono tipi specifici della piattaforma usati per rappresentare un puntatore o un handle.  
  
> [!CAUTION]
>  Usando il <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo può comportare rischi per la sicurezza in quanto, se l'handle è stato contrassegnato come non valido con <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> restituisce comunque il valore di handle originale, potrebbe non essere aggiornato. L'handle restituito può anche essere riutilizzata in qualsiasi momento. Nel migliore dei casi, ciò significa che l'handle potrebbe smettere di funzionare improvvisamente. Nel peggiore dei casi, se l'handle o la risorsa che rappresenta l'handle viene esposto al codice non attendibile, questo può causare un attacco alla sicurezza riciclo nell'handle di riutilizzato o restituito. Un chiamante non attendibile, ad esempio, possibile query sui dati dell'handle appena restituiti e ricevere informazioni per una risorsa completamente non correlata. Vedere la <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodi per altre informazioni sull'uso di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> modo sicuro, vedere.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decrementa manualmente il numero di riferimenti in un'istanza di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodo è equivalente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Si deve corrispondere sempre una chiamata per il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> con una chiamata al metodo <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Questo metodo è destinato agli utenti avanzati e deve essere sempre utilizzato con attenzione. Per evitare perdite di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non la interrompa l'elaborazione. Nello stesso modo che non corrispondenti <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> le chiamate possono causare perdite di risorse, senza corrispondenza <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate possono provocare stati handle non valido diventare visibili agli altri thread. Non esporre <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate a codice non attendibile.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiama il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare le risorse. Ciò potrebbe non avvenire immediatamente se altri thread utilizza la stessa istanza dell'handle sicuro, ma verrà eseguito non appena non è questo il caso. Anche se più classi tramite <xref:System.Runtime.InteropServices.SafeHandle> non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o per il writeback di alcuni dati in memoria). In questo caso, si può fornire un finalizzatore che ti consente di eseguire prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo al termine usando il <xref:System.Runtime.InteropServices.SafeHandle> oggetto. Il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo lascia il <xref:System.Runtime.InteropServices.SafeHandle> oggetto in uno stato inutilizzabile.  
  
> [!NOTE]
>  Chiamare sempre il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oppure <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per una normale operazione di eliminazione, <see langword="false" /> per finalizzare l'handle.</param>
        <summary>Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> specificando se eseguire una normale operazione di eliminazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare in modo esplicito il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo con il `disposing` parametro impostato su `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate all'handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metodo è il distruttore per il <xref:System.Runtime.InteropServices.SafeHandle> classe. Il codice dell'applicazione non deve chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'handle di cui eseguire il wrapping.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'handle non espongono pubblicamente (vale a dire, all'esterno della classe derivata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'handle è chiuso.</summary>
        <value>
          <see langword="true" /> se l'handle è chiuso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo viene restituito un valore che indica se il <xref:System.Runtime.InteropServices.SafeHandle> handle dell'oggetto non è più associato a una risorsa nativa. Questo comportamento è diverso dalla definizione del <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà, che consente di calcolare se un handle specificato viene considerato sempre valido. Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un `true` valore nei casi seguenti:  
  
-   Il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo è stato chiamato.  
  
-   Il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo è stato chiamato e non sono presenti riferimenti per il <xref:System.Runtime.InteropServices.SafeHandle> oggetti in altri thread.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</summary>
        <value>
          <see langword="true" /> se il valore dell'handle non è valido; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate devono implementare il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà in modo che common language runtime può determinare se è richiesta finalizzazione critica. Le classi derivate devono fornire un'implementazione che indica il tipo generale di handle che supportano (0 o -1 non è valido). Queste classi possono essere derivate ulteriormente per i tipi di handle sicuro specifico.  
  
 A differenza di <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> proprietà, che indica se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto ha terminato di utilizzare l'handle sottostante, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà calcola se il valore di handle specificato viene considerato sempre valido. Pertanto, il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà restituisce sempre lo stesso valore per qualsiasi valore dell'handle.  
  
   
  
## Examples  
 L'esempio seguente controlla se un file è stata aperta correttamente. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</summary>
        <returns>
          <see langword="true" /> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <see langword="false" />. In questo caso, genera un assistente al debug gestito [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodo è garantito a essere chiamato solo una volta e solo se l'handle è valido, come definito dal <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà. Implementare questo metodo nel <xref:System.Runtime.InteropServices.SafeHandle> dalle classi derivate per eseguire il codice necessario per liberare l'handle. Perché una delle funzioni di <xref:System.Runtime.InteropServices.SafeHandle> consiste nel garantire la prevenzione di perdite di risorse, il codice nell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non deve mai avere esito negativo. Il garbage collector chiama <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> dopo l'esecuzione dei finalizzatori normale per gli oggetti che sono stati sottoposti a garbage collection nello stesso momento. Il garbage collector garantisce le risorse necessarie per richiamare questo metodo e che il metodo non verrà interrotto mentre è in corso. Questo metodo verrà preparato come area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico chiamate in modo statico determinabile). Sebbene ciò impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre i percorsi di errore negli sottoposto a override <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo). In particolare, si applicano i <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> dell'attributo per tutti i metodi chiamati da <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Nella maggior parte dei casi questo codice deve essere:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Inoltre, per la pulizia semplice (ad esempio, chiamando l'API Win32 `CloseHandle` su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke. Per la pulizia delle complessa, si potrebbe avere più logica di programma e molte chiamate al metodo, alcuni dei quali può avere esito negativo. È necessario assicurarsi che la logica del programma è codice fallback per ognuno di tali case.  
  
 Se <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> restituisce `false` per qualsiasi motivo, genera un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) assistente al debug gestito.  Ciò consente di rilevare i casi in cui il tentativo di rilasciare le risorse abbia esito negativo.  
  
   
  
## Examples  
 Esempio di codice seguente rilascia l'handle e fa parte di un esempio più esaustivo disponibile per il <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c">Diagnostica degli errori di Run-time assistenti al debug gestito</related>
        <related type="Article" href="http://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51">releaseHandleFailed)</related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Handle preesistente da usare.</param>
        <summary>Imposta l'handle sull'handle preesistente specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura) nell'infrastruttura di interoperabilità COM di .NET Framework supporta il marshalling degli handle in una struttura di output.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna un handle come non più usato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo solo quando si certi che l'handle fa più riferimento a una risorsa. In questo modo non modifica il valore della <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; solo l'handle viene contrassegnato come chiuso. L'handle potrebbe essere quindi contenere un valore potrebbe non essere aggiornato. L'effetto di questa chiamata è che viene eseguito alcun tentativo per liberare le risorse.  
  
 Come con le <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo, usare <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> solo se è necessario supportare un handle preesistente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>