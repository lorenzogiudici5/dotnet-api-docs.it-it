<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c4334868cde5130ed9da65bfda7e798c24b12cd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una classe wrapper per gli handle del sistema operativo. La classe deve essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.InteropServices.SafeHandle> classe fornisce la finalizzazione critica di risorse di handle, impedendo agli handle di essere recuperati tramite garbage collection in modo anomalo e di essere riciclati da Windows per fare riferimento a oggetti non gestiti non intenzionali.  
  
 Questo argomento include le sezioni seguenti:  
  
 [Motivo per cui SafeHandle?](#Why)   
 [Che cosa SafeHandle](#Does)   
 [Classi derivate da SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Motivo per cui SafeHandle?  
 Prima di .NET Framework versione 2.0, tutti i sistemi operativi handle possono solo essere incapsulati nel <xref:System.IntPtr> oggetto wrapper gestito. Mentre questo è un modo pratico per l'interoperabilità con codice nativo, gli handle potrebbero essere comunicati per le eccezioni asincrone, ad esempio un thread di interruzione in modo imprevisto o un overflow dello stack. Queste eccezioni asincrone sono un ostacolo alla pulizia delle risorse del sistema operativo e possono verificarsi praticamente ovunque nell'app.  
  
 Anche se l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo consentire la pulizia delle risorse non gestite quando un oggetto viene sottoposto a garbage collection, in alcuni casi, oggetti finalizzabili possono essere recuperati tramite garbage collection durante l'esecuzione di un metodo all'interno di una piattaforma invoke chiamata. Se un finalizzatore libera l'handle passato a tale piattaforma chiamata PInvoke, può causare l'handle venga danneggiato. L'handle può anche essere recuperato mentre il metodo è bloccato durante una chiamata PInvoke, ad esempio durante la lettura di un file.  
  
 Ancora più importante, poiché Windows riciclati handle, un handle potrebbe essere riciclati e puntare a un'altra risorsa che potrebbe contenere dati sensibili. Questo è noto come attacco riciclo e può danneggiare i dati e rappresentare una minaccia alla sicurezza.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Che cosa SafeHandle  
 Il <xref:System.Runtime.InteropServices.SafeHandle> classe semplifica molti di questi problemi di durata degli oggetti ed è integrata con platform invoke in modo che si verifichino perdite di risorse del sistema operativo. La <xref:System.Runtime.InteropServices.SafeHandle> classe risolve i problemi di durata degli oggetti assegnando e rilasciando handle senza interruzione. Contiene un finalizzatore critico che garantisce che l'handle è chiuso e verrà sicuramente eseguito durante imprevisto <xref:System.AppDomain> viene scaricata, anche nei casi in cui la chiamata di PInvoke si presuppone che sia in uno stato danneggiato.  
  
 Poiché <xref:System.Runtime.InteropServices.SafeHandle> eredita da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tutti i finalizzatori non critici vengono chiamati prima di qualsiasi dei finalizzatori. I finalizzatori vengono richiamati su oggetti che non sono più in tempo reale durante il passaggio della garbage collection stessa. Ad esempio, un <xref:System.IO.FileStream> oggetto può eseguire un finalizzatore normale per cancellare i dati memorizzati nel buffer esistenti senza il rischio che l'handle viene perduto o venga riciclato. Questo ordinamento tra finalizzatori critici e non è per uso generale. Esiste principalmente per facilitare la migrazione di librerie esistenti consentendo a tali librerie da utilizzare <xref:System.Runtime.InteropServices.SafeHandle> senza modificare la semantica. Inoltre, il finalizzatore critico e tutto ciò che chiama, ad esempio il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metodo, deve essere in un'area a esecuzione vincolata. Questo impone vincoli per il codice che può essere scritti nel grafico delle chiamate del finalizzatore.  
  
 Le operazioni pInvoke automaticamente incrementa il conteggio dei riferimenti degli handle incapsulati da un <xref:System.Runtime.InteropServices.SafeHandle> e li decremento dopo il completamento. Ciò garantisce che l'handle non verrà riciclato o chiuso in modo imprevisto.  
  
 È possibile specificare la proprietà dell'handle sottostante durante la costruzione di <xref:System.Runtime.InteropServices.SafeHandle> oggetti fornendo un valore per il `ownsHandle` argomento in di <xref:System.Runtime.InteropServices.SafeHandle> costruttore della classe. Controlla se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto causerà il rilascio di handle dopo l'oggetto è stato eliminato.  Ciò è utile per gli handle con requisiti particolari durata o per l'utilizzo di un handle la cui durata è controllata da un altro utente.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Classi derivate da SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> è una classe wrapper astratta per gli handle del sistema operativo. La derivazione da questa classe è difficile. Utilizzare invece le classi derivate nello spazio dei nomi <xref:Microsoft.Win32.SafeHandles> che forniscono handle sicuri per gli elementi seguenti:  
  
-   I file (il <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).  
  
-   File mappati alla memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).  
  
-   Pipe (la <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).  
  
-   Visualizzazioni di memoria (il <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).  
  
-   Costrutti di crittografia (il <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classi).  
  
-   I processi (la <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).  
  
-   Le chiavi del Registro di sistema (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).  
  
-   Handle di attesa (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).  
  
   
  
## Examples  
 Esempio di codice seguente crea un handle sicuro personalizzato per un handle di file del sistema operativo, la derivazione da <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Legge i byte da un file e consente di visualizzare i valori esadecimali. Contiene inoltre un test harness di errore che causa l'interruzione del thread, ma il valore dell'handle viene liberato.  Quando si utilizza un <xref:System.IntPtr> per rappresentare gli handle, l'handle viene occasionalmente perso a causa dell'interruzione di thread asincroni.  
  
 È necessario un file di testo nella stessa cartella dell'applicazione compilata. Supponendo che il nome dell'applicazione "HexViewer", l'utilizzo della riga di comando è:  
  
 `HexViewer <filename> -Fault`  
  
 Facoltativamente specificare `-Fault` per tentare intenzionalmente di perdere l'handle per l'interruzione del thread in una determinata finestra. Utilizzare lo strumento Windows Perform.exe per monitorare i conteggi degli handle durante l'inserimento di errori.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
    <block subset="none" type="overrides">
      <para>Per creare una classe derivata da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario sapere come creare e liberare un handle del sistema operativo. Questo processo è diverso per i tipi di handle diversi perché alcuni utilizzano il [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funzione, mentre altri utilizzano le funzioni più specifiche, ad esempio [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) o [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Per questo motivo, è necessario creare una classe derivata di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> per ogni tipo di handle del sistema operativo che si desidera eseguire il wrapping in un handle sicuro.  
  
 Quando si eredita da <see cref="T:System.Runtime.InteropServices.SafeHandle" />, è necessario eseguire l'override dei seguenti membri: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> e <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 È inoltre necessario fornire un costruttore predefinito che chiama il costruttore base con un valore che rappresenta un valore di handle non valido, e un <see cref="T:System.Boolean" /> valore che indica se l'handle nativo è di proprietà di <see cref="T:System.Runtime.InteropServices.SafeHandle" /> e pertanto deve essere liberata quando che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> è stato eliminato.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valore di un handle non valido (in genere 0 o -1).  L'implementazione di <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> dovrebbe restituire <see langword="true" /> per questo valore.</param>
        <param name="ownsHandle">
          <see langword="true" /> per fare in modo che <see cref="T:System.Runtime.InteropServices.SafeHandle" /> rilasci in modo affidabile l'handle durante la fase di finalizzazione; in caso contrario, <see langword="false" /> (opzione non consigliata).</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> con il valore di handle non valido specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `ownsHandle` parametro `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non viene mai chiamato; pertanto, non è consigliabile utilizzare questo valore del parametro come il codice può provocare la perdita di risorse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna l'handle per il rilascio delle risorse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare risorse. Potrebbe non verificarsi immediatamente se altri thread utilizza lo stesso oggetto handle sicuro, ma verrà eseguito non appena non è questo il caso. Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.SafeHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria). In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.SafeHandle> oggetto.  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> se il numero di riferimenti è stato incrementato correttamente; in caso contrario, <see langword="false" />.</param>
        <summary>Incrementa manualmente il numero di riferimenti nelle istanze di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> metodo che impedisce il recupero della memoria usata da un handle di common language runtime (che si verifica quando il runtime chiama il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (metodo)). È possibile utilizzare questo metodo per incrementare manualmente il conteggio dei riferimenti in un <xref:System.Runtime.InteropServices.SafeHandle> istanza. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Restituisce un valore booleano utilizzando un `ref` parametro (`success`) che indica se il conteggio dei riferimenti è stato incrementato correttamente. In questo modo la logica del programma di tornare indietro, in caso di errore. È consigliabile impostare `success` a `false` prima di chiamare <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Se `success` è `true`, evitare perdite di risorse creando una corrispondenza tra la chiamata a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> con una chiamata corrispondente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Questo metodo è destinato agli utenti esperti e deve sempre essere utilizzato con attenzione. Per evitare la perdita di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non è possibile interrompere l'elaborazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>Valore <see langword="IntPtr" /> che rappresenta il valore del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Se l'handle è stato contrassegnato come non valido con <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, questo metodo restituisce comunque il valore di handle originale, che può essere un valore non aggiornato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo metodo per recuperare il valore effettivo dell'handle da un'istanza di <xref:System.Runtime.InteropServices.SafeHandle> classe derivata. Questo metodo è necessario per la compatibilità poiché molte proprietà in .NET Framework restituiscono `IntPtr` gestire tipi. `IntPtr` tipi di handle sono tipi specifici della piattaforma usati per rappresentare un puntatore o un handle.  
  
> [!CAUTION]
>  Utilizzo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo può comportare rischi di sicurezza in quanto, se l'handle è stato contrassegnato come non valido con <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> restituisce comunque il valore di handle originale, potrebbe non essere aggiornato. L'handle restituito può anche essere riutilizzata in qualsiasi momento. Nel migliore dei casi, ciò significa che l'handle improvvisamente potrebbe smettere di funzionare. Nel peggiore dei casi, se l'handle o la risorsa che rappresenta l'handle è esposto al codice non attendibile, ciò può causare un attacco alla sicurezza riciclo dell'handle riutilizzato o restituito. Ad esempio, un chiamante non attendibile può query sui dati dell'handle appena restituiti e ricevere informazioni per una risorsa completamente non correlata. Vedere il <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodi per ulteriori informazioni sull'utilizzo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> modo sicuro.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decrementa manualmente il numero di riferimenti in un'istanza di <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metodo è equivalente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Si deve sempre corrispondere una chiamata al <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> con una chiamata al metodo di <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Questo metodo è destinato agli utenti esperti e deve sempre essere utilizzato con attenzione. Per evitare la perdita di risorse di handle, chiamare sempre questo metodo all'interno di un'area a esecuzione vincolata (CER), in cui un'interruzione del thread non è possibile interrompere l'elaborazione. Nello stesso modo che non corrispondenti <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> chiamata può causare perdite di risorse, senza corrispondenza <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamata può causare gli stati di handle non valido per diventano visibili ad altri thread. Non esporre <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chiamate a codice non attendibile.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo consente di liberare risorse. Potrebbe non verificarsi immediatamente se altri thread utilizza la stessa istanza di handle sicuro, ma verrà eseguito non appena non è questo il caso. Anche se più classi che utilizzano <xref:System.Runtime.InteropServices.SafeHandle> non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o eseguire il writeback di alcuni dati in memoria). In questo caso, forniscono un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.SafeHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.SafeHandle> oggetto. Il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo lascia la <xref:System.Runtime.InteropServices.SafeHandle> oggetto in uno stato inutilizzabile.  
  
> [!NOTE]
>  Chiamare sempre il <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.SafeHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.SafeHandle> dell'oggetto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per una normale operazione di eliminazione, <see langword="false" /> per finalizzare l'handle.</param>
        <summary>Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> specificando se eseguire una normale operazione di eliminazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare mai in modo esplicito il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo con il `disposing` parametro impostato su `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate all'handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metodo è il distruttore per la <xref:System.Runtime.InteropServices.SafeHandle> classe. Il codice dell'applicazione non deve chiamare questo metodo direttamente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'handle di cui eseguire il wrapping.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esporre pubblicamente l'handle (ovvero, all'esterno della classe derivata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'handle è chiuso.</summary>
        <value>
          <see langword="true" /> se l'handle è chiuso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un valore che indica se il <xref:System.Runtime.InteropServices.SafeHandle> handle dell'oggetto non è più associato a una risorsa nativa. Questo comportamento è diverso dalla definizione della <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà, che calcola se un handle specificato è sempre considerato non valido. Il <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> metodo restituisce un `true` valore nei seguenti casi:  
  
-   Il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo è stato chiamato.  
  
-   Il <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metodo o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo è stato chiamato e non sono presenti riferimenti per il <xref:System.Runtime.InteropServices.SafeHandle> in altri thread.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</summary>
        <value>
          <see langword="true" /> se il valore dell'handle non è valido; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate devono implementare il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà in modo da common language runtime può determinare se è necessaria la finalizzazione critica. Classi derivate devono fornire un'implementazione adatta il tipo di handle supportano generale (0 o -1 non è valido). Queste classi possono essere ulteriormente derivate per i tipi di handle sicuro specifico.  
  
 A differenza di <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> proprietà, che indica se il <xref:System.Runtime.InteropServices.SafeHandle> oggetto ha terminato di utilizzare l'handle sottostante, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà calcola se il valore di handle specificato viene sempre considerato non valido. Pertanto, il <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà restituisce sempre lo stesso valore per ogni valore dell'handle.  
  
   
  
## Examples  
 L'esempio seguente verifica se un file è stato aperto correttamente. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</summary>
        <returns>
          <see langword="true" /> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <see langword="false" />. In questo caso, genera un assistente al debug gestito [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> garantito per essere chiamato solo una volta e solo se l'handle è valido, come definito dal metodo di <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> proprietà. Implementare questo metodo nel <xref:System.Runtime.InteropServices.SafeHandle> dalle classi derivate per eseguire il codice necessario per liberare l'handle. Perché una delle funzioni di <xref:System.Runtime.InteropServices.SafeHandle> consiste nell'impedire la perdita di risorse, il codice nell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non deve mai avere esito negativo. Il garbage collector chiama <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> dopo l'esecuzione dei finalizzatori normale per gli oggetti che sono state sottoposte a garbage collection nello stesso momento. Le risorse per richiamare questo metodo assicura che il garbage collector e che il metodo non verrà interrotto mentre è in corso. Questo metodo verrà preparato come un'area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico delle chiamate di determinare in modo statico). Sebbene questo impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre percorsi qualsiasi errore sottoposto a override <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodo. In particolare, applicare il <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attributo per tutti i metodi chiamati da <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Nella maggior parte dei casi questo codice deve essere:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Inoltre, per la pulizia semplice (ad esempio, la chiamata API Win32 `CloseHandle` su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke. Operazioni di pulizia complesse, potrebbe essere molto logica di programma e le chiamate al metodo, alcune delle quali potrebbe avere esito negativo. È necessario assicurarsi che la logica del programma è codice di fallback per ognuno dei casi.  
  
 Se <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> restituisce `false` per qualsiasi motivo, viene generato un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) assistente al debug gestito.  Ciò consente di rilevare i casi in cui il tentativo di rilasciare le risorse ha esito negativo.  
  
   
  
## Examples  
 Esempio di codice seguente rilascia l'handle e fa parte di un esempio più esaustivo disponibile per la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Handle preesistente da usare.</param>
        <summary>Imposta l'handle sull'handle preesistente specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura), in quanto l'infrastruttura di interoperabilità COM di .NET Framework non supporta il marshalling degli handle in una struttura di output.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna un handle come non più usato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodo solo quando si è certi che l'handle fa più riferimento a una risorsa. In questo modo, il valore di non modificare il <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; solo contrassegna l'handle come chiuso. L'handle potrebbe quindi contenere un valore non aggiornato. L'effetto di questa chiamata è che viene eseguito alcun tentativo di liberare le risorse.  
  
 Come con la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metodo, utilizzare <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> solo se è necessario supportare un handle preesistente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>