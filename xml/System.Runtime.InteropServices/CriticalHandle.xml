<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56d9d023a154981435b37666fa081861ca0100c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480145" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una classe wrapper per le risorse di handle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.CriticalHandle> è simile alla classe il <xref:System.Runtime.InteropServices.SafeHandle> classe, con la differenza che <xref:System.Runtime.InteropServices.SafeHandle> implementa il conteggio dei riferimenti. È possibile utilizzare <xref:System.Runtime.InteropServices.CriticalHandle> anziché <xref:System.Runtime.InteropServices.SafeHandle> per soddisfare specifiche esigenze di prestazioni quando è possibile fornire la sincronizzazione necessaria più efficiente se stessi.  
  
 Poiché la <xref:System.Runtime.InteropServices.CriticalHandle> classe esegue il conteggio dei riferimenti, non fornisce protezione da attacchi alla sicurezza di riciclo. Poiché il riferimento all'algoritmo di conteggio in modo implicito serializza operazioni, è anche persa una certa quantità di thread-safe. Se si chiama il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodo durante un'operazione che sta utilizzando l'handle è in attesa su un altro thread o se si chiama <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> da due thread contemporaneamente, i risultati sono non deterministici. Il <xref:System.Runtime.InteropServices.CriticalHandle> classe fornisce la finalizzazione critica garantita dalla <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile o trasparente.</permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valore di un handle non valido (in genere 0 o -1).</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> con il valore di handle non valido specificato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questo membro non può essere ereditato da codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna l'handle per il rilascio delle risorse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo consente di liberare risorse. A differenza di <xref:System.Runtime.InteropServices.SafeHandle> classe verrà sempre eseguita immediatamente poiché non esiste alcun conteggio dei riferimenti per indicare altri thread che utilizza questo handle. È pertanto necessario utilizzare un meccanismo di sincronizzazione per assicurarsi che sia possibile chiamare il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> metodo. Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.CriticalHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria). In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.CriticalHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.CriticalHandle> oggetto. Il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> metodo lascia la <xref:System.Runtime.InteropServices.CriticalHandle> oggetto in uno stato inutilizzabile.  
  
 **Nota** chiamare sempre <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.CriticalHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.CriticalHandle> dell'oggetto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Contrassegna l'handle per il rilascio delle risorse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo consente di liberare risorse. A differenza di <xref:System.Runtime.InteropServices.SafeHandle> classe verrà sempre eseguita immediatamente poiché non esiste alcun conteggio dei riferimenti per indicare altri thread che utilizza questo handle. È pertanto necessario utilizzare un meccanismo di sincronizzazione per assicurarsi che sia possibile chiamare il <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo. Sebbene la maggior parte delle classi che utilizzano il <xref:System.Runtime.InteropServices.CriticalHandle> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria). In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <xref:System.Runtime.InteropServices.CriticalHandle> finalizzatore critico.  
  
 Chiamare il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo dopo aver terminato con il <xref:System.Runtime.InteropServices.CriticalHandle> oggetto. Il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> metodo lascia la <xref:System.Runtime.InteropServices.CriticalHandle> oggetto in uno stato inutilizzabile.  
  
 **Nota** chiamare sempre il <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo prima di rilasciare l'ultimo riferimento al <xref:System.Runtime.InteropServices.CriticalHandle> oggetto. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Runtime.InteropServices.CriticalHandle> dell'oggetto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per una normale operazione di eliminazione, <see langword="false" /> per finalizzare l'handle.</param>
        <summary>Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> specificando se eseguire una normale operazione di eliminazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare mai in modo esplicito il <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo con il `disposing` parametro impostato su `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate all'handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> metodo è il distruttore per la <xref:System.Runtime.InteropServices.CriticalHandle> classe. Il codice dell'applicazione non deve chiamare questo metodo direttamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'handle di cui eseguire il wrapping.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esporre pubblicamente l'handle (ovvero, all'esterno della classe derivata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'handle è chiuso.</summary>
        <value>
          <see langword="true" /> se l'handle è chiuso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> metodo restituisce un valore che indica se il <xref:System.Runtime.InteropServices.CriticalHandle> handle dell'oggetto non è più associato a una risorsa nativa. Questo comportamento è diverso dalla definizione della <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> proprietà, che calcola se un handle specificato è sempre considerato non valido. Il <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> metodo restituisce un `true` valore nei seguenti casi:  
  
-   Il <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> metodo è stato chiamato.  
  
-   Il <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> metodo è stato chiamato e non sono presenti riferimenti per il <xref:System.Runtime.InteropServices.CriticalHandle> in altri thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</summary>
        <value>
          <see langword="true" /> se l'handle è valido. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate devono implementare il <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> proprietà in modo da common language runtime può determinare se è necessaria la finalizzazione critica. Classi derivate devono fornire un'implementazione adatta il tipo di handle supportano generale (0 o -1 non è valido). Queste classi possono essere ulteriormente derivate per i tipi di handle sicuro specifico.  
  
 A differenza di <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> proprietà, che indica se il <xref:System.Runtime.InteropServices.CriticalHandle> oggetto ha terminato di utilizzare l'handle sottostante, la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> proprietà calcola se il valore di handle specificato viene sempre considerato non valido. Pertanto, il <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> proprietà restituisce sempre lo stesso valore per ogni valore dell'handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</summary>
        <returns>
          <see langword="true" /> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <see langword="false" />. In questo caso, genera un assistente al debug gestito [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> metodo è chiamato una sola volta, purché venga utilizzato un meccanismo per garantire che solo una chiamata per la sincronizzazione di <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> metodo è costituito. Il <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> (metodo) non verrà chiamato se il <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> proprietà `true`. Implementare questo metodo nel <xref:System.Runtime.InteropServices.CriticalHandle> dalle classi derivate per eseguire il codice necessario per liberare l'handle. Perché una delle funzioni di <xref:System.Runtime.InteropServices.CriticalHandle> consiste nell'impedire la perdita di risorse, il codice nell'implementazione di <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> non deve mai avere esito negativo. Il garbage collector chiama <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> dopo finalizzatori normali sono stati eseguiti per gli oggetti che sono stati sottoposti a garbage collection nello stesso momento e garantisce che le risorse di richiamare e che l'esecuzione non venga interrotta mentre si è in corso. Questo metodo verrà preparato come un'area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico delle chiamate di determinare in modo statico). Sebbene questo impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre percorsi qualsiasi errore sottoposto a override <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> metodo. In particolare, applicare il <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attributo per tutti i metodi chiamati da <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. Nella maggior parte dei casi questo codice deve essere:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Inoltre, per la pulizia semplice (ad esempio, la chiamata API Win32 `CloseHandle` su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke. Operazioni di pulizia complesse, potrebbe essere molto logica di programma e le chiamate al metodo, alcune delle quali potrebbe avere esito negativo. È necessario assicurarsi che la logica del programma è codice di fallback per ognuno dei casi.  
  
 Se il <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> restituisce `false` per qualsiasi motivo, viene generato un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) assistente al debug gestito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Handle preesistente da usare.</param>
        <summary>Imposta l'handle sull'handle preesistente specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura), in quanto l'infrastruttura di interoperabilità COM di .NET Framework non supporta il marshalling di handle in una struttura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna un handle come non valido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> metodo solo quando si sa che l'handle non è valido e che si desidera contrassegnarlo come tale. In questo modo, il valore di non modificare il <xref:System.Runtime.InteropServices.CriticalHandle.handle> campo; solo contrassegna l'handle come non validi. L'handle potrebbe quindi contenere un valore non aggiornato. L'effetto di questa chiamata è che viene eseguito alcun tentativo di liberare le risorse.  
  
 Come con la <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> metodo, utilizzare <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> solo se è necessario supportare un handle preesistente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>