<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CriticalHandle.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556d9d023a154981435b37666fa081861ca0100c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d9d023a154981435b37666fa081861ca0100c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Represents a wrapper class for handle resources.</source>
          <target state="translated">Rappresenta una classe wrapper per le risorse di handle.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> è simile alla classe il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> classe, con la differenza che <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implementa il conteggio dei riferimenti.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> anziché <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> per soddisfare specifiche esigenze di prestazioni quando è possibile fornire la sincronizzazione necessaria più efficiente se stessi.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</source>
          <target state="translated">Poiché la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> classe esegue il conteggio dei riferimenti, non fornisce protezione da attacchi alla sicurezza di riciclo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</source>
          <target state="translated">Poiché il riferimento all'algoritmo di conteggio in modo implicito serializza operazioni, è anche persa una certa quantità di thread-safe.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>If you call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.</source>
          <target state="translated">Se si chiama il <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> metodo durante un'operazione che sta utilizzando l'handle è in attesa su un altro thread o se si chiama <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> da due thread contemporaneamente, i risultati sono non deterministici.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> classe fornisce la finalizzazione critica garantita dalla <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">per l'attendibilità totale per gli eredi.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Questo membro non può essere ereditato da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questa classe non può essere utilizzata da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">Valore di un handle non valido (in genere 0 o -1).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> con il valore di handle non valido specificato.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">La classe derivata risiede in un assembly senza autorizzazione di accesso al codice non gestito.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>for full trust for inheritors.</source>
          <target state="translated">per l'attendibilità totale per gli eredi.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Questo membro non può essere ereditato da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questa classe non può essere utilizzata da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Contrassegna l'handle per il rilascio delle risorse.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo consente di liberare risorse.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> classe verrà sempre eseguita immediatamente poiché non esiste alcun conteggio dei riferimenti per indicare altri thread che utilizza questo handle.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">È pertanto necessario utilizzare un meccanismo di sincronizzazione per assicurarsi che sia possibile chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Sebbene la maggior parte delle classi che utilizzano il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> finalizzatore critico.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo dopo aver terminato con il <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> metodo lascia la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto in uno stato inutilizzabile.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Nota<ept id="p1">**</ept> chiamare sempre <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> prima di rilasciare l'ultimo riferimento al <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> dell'oggetto <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> non viene richiamato dal Garbage Collector.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Contrassegna l'handle per il rilascio delle risorse.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</source>
          <target state="translated">Rilascia tutte le risorse usate da <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo consente di liberare risorse.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> classe verrà sempre eseguita immediatamente poiché non esiste alcun conteggio dei riferimenti per indicare altri thread che utilizza questo handle.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">È pertanto necessario utilizzare un meccanismo di sincronizzazione per assicurarsi che sia possibile chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Sebbene la maggior parte delle classi che utilizzano il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> classe non è necessario fornire un finalizzatore, questo è talvolta necessario (ad esempio, per svuotare i buffer di file o scrivere alcuni nuovamente i dati in memoria).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">In questo caso, la classe può fornire un finalizzatore che viene eseguito prima il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> finalizzatore critico.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo dopo aver terminato con il <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> metodo lascia la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto in uno stato inutilizzabile.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Nota<ept id="p1">**</ept> chiamare sempre il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo prima di rilasciare l'ultimo riferimento al <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> dell'oggetto <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> non viene richiamato dal Garbage Collector.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per una normale operazione di eliminazione, <ph id="ph2">&lt;see langword="false" /&gt;</ph> per finalizzare l'handle.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">Rilascia le risorse non gestite usate dalla classe <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> specificando se eseguire una normale operazione di eliminazione.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">È necessario chiamare mai in modo esplicito il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo con il <ph id="ph2">`disposing`</ph> parametro impostato su <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">Libera tutte le risorse associate all'handle.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> metodo è il distruttore per la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">Il codice dell'applicazione non deve chiamare questo metodo direttamente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">Specifica l'handle di cui eseguire il wrapping.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">Non esporre pubblicamente l'handle (ovvero, all'esterno della classe derivata).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">Ottiene un valore che indica se l'handle è chiuso.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle è chiuso; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> metodo restituisce un valore che indica se il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> handle dell'oggetto non è più associato a una risorsa nativa.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">Questo comportamento è diverso dalla definizione della <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> proprietà, che calcola se un handle specificato è sempre considerato non valido.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> metodo restituisce un <ph id="ph2">`true`</ph> valore nei seguenti casi:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> metodo è stato chiamato.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> metodo è stato chiamato e non sono presenti riferimenti per il <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> in altri thread.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il valore dell'handle non è valido.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle è valido. In caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">Le classi derivate devono implementare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> proprietà in modo da common language runtime può determinare se è necessaria la finalizzazione critica.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">Classi derivate devono fornire un'implementazione adatta il tipo di handle supportano generale (0 o -1 non è valido).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">Queste classi possono essere ulteriormente derivate per i tipi di handle sicuro specifico.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> proprietà, che indica se il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> oggetto ha terminato di utilizzare l'handle sottostante, la <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> proprietà calcola se il valore di handle specificato viene sempre considerato non valido.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">Pertanto, il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> proprietà restituisce sempre lo stesso valore per ogni valore dell'handle.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">Quando ne viene eseguito l'override in una classe derivata, esegue il codice necessario per liberare l'handle.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle viene rilasciato correttamente; in caso contrario, se si verifica un errore irreversibile, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">In questo caso, genera un assistente al debug gestito <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> metodo è chiamato una sola volta, purché venga utilizzato un meccanismo per garantire che solo una chiamata per la sincronizzazione di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metodo è costituito.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> (metodo) non verrà chiamato se il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> proprietà <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">Implementare questo metodo nel <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> dalle classi derivate per eseguire il codice necessario per liberare l'handle.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">Perché una delle funzioni di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> consiste nell'impedire la perdita di risorse, il codice nell'implementazione di <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> non deve mai avere esito negativo.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</source>
          <target state="translated">Il garbage collector chiama <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> dopo finalizzatori normali sono stati eseguiti per gli oggetti che sono stati sottoposti a garbage collection nello stesso momento e garantisce che le risorse di richiamare e che l'esecuzione non venga interrotta mentre si è in corso.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">Questo metodo verrà preparato come un'area a esecuzione vincolata (CER) in fase di costruzione di istanza (insieme a tutti i metodi nel relativo grafico delle chiamate di determinare in modo statico).</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">Sebbene questo impedisce l'interruzione del thread, è necessario prestare attenzione a non introdurre percorsi qualsiasi errore sottoposto a override <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">In particolare, applicare il <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attributo per tutti i metodi chiamati da <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">Nella maggior parte dei casi questo codice deve essere:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">Inoltre, per la pulizia semplice (ad esempio, la chiamata API Win32 <ph id="ph1">`CloseHandle`</ph> su un handle di file) è possibile controllare il valore restituito per la singola chiamata PInvoke.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">Operazioni di pulizia complesse, potrebbe essere molto logica di programma e le chiamate al metodo, alcune delle quali potrebbe avere esito negativo.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">È necessario assicurarsi che la logica del programma è codice di fallback per ognuno dei casi.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> restituisce <ph id="ph2">`false`</ph> per qualsiasi motivo, viene generato un <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> assistente al debug gestito.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">Handle preesistente da usare.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">Imposta l'handle sull'handle preesistente specificato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> metodo solo se è necessario supportare un handle preesistente (ad esempio, se l'handle viene restituito in una struttura), in quanto l'infrastruttura di interoperabilità COM di .NET Framework non supporta il marshalling di handle in una struttura.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Marks a handle as invalid.</source>
          <target state="translated">Contrassegna un handle come non valido.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> metodo solo quando si sa che l'handle non è valido e che si desidera contrassegnarlo come tale.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.</source>
          <target state="translated">In questo modo, il valore di non modificare il <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> campo; solo contrassegna l'handle come non validi.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">L'handle potrebbe quindi contenere un valore non aggiornato.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">L'effetto di questa chiamata è che viene eseguito alcun tentativo di liberare le risorse.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">Come con la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> metodo, utilizzare <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> solo se è necessario supportare un handle preesistente.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>