<Type Name="CounterSet" FullName="System.Diagnostics.PerformanceData.CounterSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="28db19b296edf4b25db2105c1fa9c49c7103a8a1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30398185" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CounterSet : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CounterSet extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceData.CounterSet" />
  <TypeSignature Language="VB.NET" Value="Public Class CounterSet&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CounterSet : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definisce un insieme di contatori logici.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> metodo dopo aver terminato per rimuovere la registrazione del provider e per rilasciare tutte le risorse gestite e.  
  
   
  
## Examples  
 Per un esempio, vedere <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CounterSet (Guid providerGuid, Guid counterSetGuid, System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid, valuetype System.Guid counterSetGuid, valuetype System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.#ctor(System.Guid,System.Guid,System.Diagnostics.PerformanceData.CounterSetInstanceType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid, counterSetGuid As Guid, instanceType As CounterSetInstanceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CounterSet(Guid providerGuid, Guid counterSetGuid, System::Diagnostics::PerformanceData::CounterSetInstanceType instanceType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
        <Parameter Name="counterSetGuid" Type="System.Guid" />
        <Parameter Name="instanceType" Type="System.Diagnostics.PerformanceData.CounterSetInstanceType" />
      </Parameters>
      <Docs>
        <param name="providerGuid">GUID che identifica in modo univoco il provider dei dati dei contatori. Utilizzare il GUID specificato nel manifesto.</param>
        <param name="counterSetGuid">GUID che identifica in modo univoco l'insieme di contatori per un provider. Utilizzare il GUID specificato nel manifesto.</param>
        <param name="instanceType">Identifica il tipo dell'insieme di contatori, ad esempio se l'insieme di contatori è a istanza singola o multipla.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.PerformanceData.CounterSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registra il provider. La chiamata di <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> metodo rimuove la registrazione.  
  
   
  
## Examples  
 Per un esempio, vedere <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Memoria insufficiente per completare l’operazione.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Non supportato prima di Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">Uno o più parametri sono NULL o non validi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Una chiamata di funzione Win32 sottostante non è riuscita.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCounter">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un contatore all'insieme di contatori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCounter(int counterId, System::Diagnostics::PerformanceData::CounterType counterType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifica il contatore. Utilizzare lo stesso valore usato nel manifesto per definire il contatore.</param>
        <param name="counterType">Identifica il tipo di contatore. Il tipo di contatore determina come i dati dei contatori vengono calcolati, come se ne calcola la media e come vengono visualizzati.</param>
        <summary>Aggiunge un contatore all'insieme di contatori utilizzando identificatore e tipo di contatore specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario aggiungere i contatori all'insieme prima di creare un'istanza dell'insieme di contatori.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'identificatore di contatore esiste già nell'insieme oppure è negativo o il tipo di contatore è NULL o non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aggiungere contatori all'insieme dopo avere creato un'istanza dell'insieme di contatori.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCounter(int counterId, System::Diagnostics::PerformanceData::CounterType counterType, System::String ^ counterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifica il contatore. Utilizzare lo stesso valore usato nel manifesto per definire il contatore.</param>
        <param name="counterType">Identifica il tipo di contatore. Il tipo di contatore determina come i dati dei contatori vengono calcolati, come se ne calcola la media e come vengono visualizzati.</param>
        <param name="counterName">Nome del contatore. È possibile utilizzare questo nome per indicizzare il contatore nell'istanza dell'insieme di contatori. Per informazioni, vedere <see cref="P:System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet.Item(System.String)" />.</param>
        <summary>Aggiunge un contatore all'insieme di contatori utilizzando identificatore, tipo e nome di visualizzazione del contatore specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario aggiungere i contatori all'insieme prima di creare un'istanza dell'insieme di contatori.  
  
   
  
## Examples  
 Per un esempio, vedere <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'identificatore di contatore esiste già nell'insieme oppure è negativo o il tipo di contatore è NULL o non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aggiungere contatori all'insieme dopo avere creato un'istanza dell'insieme di contatori.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCounterSetInstance">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.CreateCounterSetInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCounterSetInstance (instanceName As String) As CounterSetInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::PerformanceData::CounterSetInstance ^ CreateCounterSetInstance(System::String ^ instanceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceData.CounterSetInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Nome dell’istanza. Il nome deve essere univoco.</param>
        <summary>Crea un'istanza dell'insieme di contatori.</summary>
        <returns>Un'istanza dell'insieme di contatori che contiene i dati dei contatori.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo una volta per insiemi di contatori a istanza singola e uno o più volte per insiemi di contatori di più istanze.  
  
 Il provider determina quando viene creata un'istanza. Se i dati del contatore sono più statici, il provider può creare un'istanza in fase di inizializzazione. Ad esempio, il numero di processori in un computer viene considerato statico, in modo da un provider che fornisce i dati del contatore per i processori è stato possibile creare un'istanza per ogni processore del computer in fase di inizializzazione. Per i contatori che sono più dinamici, ad esempio disco o contatori processo, i provider creerà le nuove istanze in risposta a un nuovo processo viene creato o di un nuovo dispositivo USB da aggiungere.  
  
 Il provider deve mantenere il contatore dati aggiornati in qualsiasi momento.  
  
   
  
## Examples  
 Per un esempio, vedere <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome dell'istanza è NULL.</exception>
        <exception cref="T:System.InvalidOperationException">È necessario aggiungere i contatori all'insieme prima di creare un'istanza dell'insieme di contatori.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse utilizzate dall'oggetto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse non gestite usate dall'oggetto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="True" /> se è stato chiamato dal metodo Dispose, <see langword="False" /> se è stato chiamato dal finalizzatore.</param>
        <summary>Rilascia tutte le risorse non gestite utilizzate dall'oggetto e, facoltativamente, rilascia le risorse gestite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CounterSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CounterSet ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera le risorse prima che l'oggetto venga recuperato dalla procedura di Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato automaticamente dal runtime.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>