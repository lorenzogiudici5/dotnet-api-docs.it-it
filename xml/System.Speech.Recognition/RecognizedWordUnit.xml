<Type Name="RecognizedWordUnit" FullName="System.Speech.Recognition.RecognizedWordUnit">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7f2649b3a25f6265c8e90a862299324fd8788ca3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36608529" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RecognizedWordUnit" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit RecognizedWordUnit extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.RecognizedWordUnit" />
  <TypeSignature Language="VB.NET" Value="Public Class RecognizedWordUnit" />
  <TypeSignature Language="C++ CLI" Value="public ref class RecognizedWordUnit" />
  <TypeSignature Language="F#" Value="type RecognizedWordUnit = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Text: {Text}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce l'unità atomica dell'input vocale riconosciuto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i risultati restituiti da un motore di riconoscimento vengono costruiti di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti.  
  
 Una matrice di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti è accessibile per qualsiasi operazione di riconoscimento tramite il <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà di <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
 Oltre a fornire una misura di certezza di riconoscimento (<xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A>) un <xref:System.Speech.Recognition.RecognizedWordUnit> istanza fornisce:  
  
-   Rappresentazioni di testo normalizzato ed esatto (o di lessicale) per una parola riconosciuta. Per altre informazioni, vedere <xref:System.Speech.Recognition.ReplacementText>, <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> e <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>.  
  
-   Informazioni di pronuncia utilizzo di caratteri da un alfabeto fonetico supportato, ad esempio il Universal Phone impostare (UPS) o all'alfabeto fonetico internazionale (IPA). Per altre informazioni, vedere <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>.  
  
-   Formattazione per la stampa. Per altre informazioni vedere la <xref:System.Speech.Recognition.DisplayAttributes> classe e il relativo <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> proprietà.  
  
   
  
## Examples  
 L'esempio seguente mostra una routine dell'utilità (`stringFromWordArray`) che consente di generare le stringhe. Le stringhe contengono l'output lessicale (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), normalizzato testo (mediante <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>), o fonetici caratteri dell'alfabeto fonetico internazionale (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). Le stringhe vengono formattate utilizzando <xref:System.Speech.Recognition.DisplayAttributes> oggetti ottengono i <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> proprietà da un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti. Il <xref:System.Speech.Recognition.RecognizedWordUnit> gli oggetti vengono ottenuti dal <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà sul <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(ReadOnlyCollection<RecognizedWordUnit> words, WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(String.Format("[0}: is not a valid input", type));  
    }  
    // Use display attribute  
  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RecognizedWordUnit (string text, float confidence, string pronunciation, string lexicalForm, System.Speech.Recognition.DisplayAttributes displayAttributes, TimeSpan audioPosition, TimeSpan audioDuration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, float32 confidence, string pronunciation, string lexicalForm, valuetype System.Speech.Recognition.DisplayAttributes displayAttributes, valuetype System.TimeSpan audioPosition, valuetype System.TimeSpan audioDuration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.RecognizedWordUnit.#ctor(System.String,System.Single,System.String,System.String,System.Speech.Recognition.DisplayAttributes,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RecognizedWordUnit(System::String ^ text, float confidence, System::String ^ pronunciation, System::String ^ lexicalForm, System::Speech::Recognition::DisplayAttributes displayAttributes, TimeSpan audioPosition, TimeSpan audioDuration);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.RecognizedWordUnit : string * single * string * string * System.Speech.Recognition.DisplayAttributes * TimeSpan * TimeSpan -&gt; System.Speech.Recognition.RecognizedWordUnit" Usage="new System.Speech.Recognition.RecognizedWordUnit (text, confidence, pronunciation, lexicalForm, displayAttributes, audioPosition, audioDuration)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="confidence" Type="System.Single" />
        <Parameter Name="pronunciation" Type="System.String" />
        <Parameter Name="lexicalForm" Type="System.String" />
        <Parameter Name="displayAttributes" Type="System.Speech.Recognition.DisplayAttributes" />
        <Parameter Name="audioPosition" Type="System.TimeSpan" />
        <Parameter Name="audioDuration" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="text">Il testo normalizzato per una parola riconosciuta.  Questo valore può essere <see langword="null" />, "", o <see cref="F:System.String.Empty" />.</param>
        <param name="confidence">Un valore <see langword="float" /> da 0,0 a 1,0 che indica la certezza del riconoscimento delle parole.</param>
        <param name="pronunciation">L'ortografia fonetica di una parola riconosciuta.  Questo valore può essere <see langword="null" />, "", o <see cref="F:System.String.Empty" />.</param>
        <param name="lexicalForm">Il testo non normalizzato per una parola riconosciuta.  Questo argomento è obbligatorio e non può essere <see langword="null" />, "" o <see cref="F:System.String.Empty" />.</param>
        <param name="displayAttributes">Definisce l'utilizzo dello spazio vuoto per visualizzare le parole riconosciute.</param>
        <param name="audioPosition">Il percorso della parola riconosciuta nel flusso di input audio.  Il valore può essere <see cref="F:System.TimeSpan.Zero" />.</param>
        <param name="audioDuration">La lunghezza dell'input audio che corrisponde all'input della parola riconosciuta.  Il valore può essere <see cref="F:System.TimeSpan.Zero" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `text` oppure `pronunciation` vengono `null`, "", o <xref:System.String.Empty> e il <xref:System.Speech.Recognition.RecognizedWordUnit> viene usato in un'operazione di riconoscimento, il motore di riconoscimento genererà i valori appropriati in alcun output <xref:System.Speech.Recognition.RecognizedWordUnit> istanza.  
  
 Indirizzare la costruzione di <xref:System.Speech.Recognition.RecognizedWordUnit> istanze viene in genere utilizzato solo per l'emulazione di operazioni di riconoscimento utilizzando il <xref:System.Speech.Recognition.SpeechRecognitionEngine.EmulateRecognize%2A> o <xref:System.Speech.Recognition.SpeechRecognitionEngine.EmulateRecognizeAsync%2A> metodi del <xref:System.Speech.Recognition.SpeechRecognitionEngine> classe e il <xref:System.Speech.Recognition.SpeechRecognizer.EmulateRecognize%2A> o <xref:System.Speech.Recognition.SpeechRecognizer.EmulateRecognizeAsync%2A> metodi il <xref:System.Speech.Recognition.SpeechRecognizer> classe.  
  
 Per le applicazioni effettive, non direttamente costruire <xref:System.Speech.Recognition.RecognizedWordUnit>, anziché ottenerla tramite il <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà sul <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
   
  
## Examples  
 L'esempio seguente è una prova in qualche modo ristretto di emulazione, in cui le nuove parole vengono generate dall'input passate all'emulatore di e quindi verificate.  
  
```csharp  
private void _emulateAndVerify_Click(object sender, EventArgs e)   
{  
  char[] delimiterChars = { ' ', ',', '.', ':', ';', '\t' };  
  string text = _emulateTextBox.Text;  
  string[] words = text.Split(delimiterChars);  
  
  RecognizedWordUnit[] InputWordUnits = new RecognizedWordUnit[words.Length];  
  for (int i = 0; i < words.Length; i++)   
  {  
    InputWordUnits[i] = new RecognizedWordUnit(  
        "",   
        0,   
        "",  
        words[i].ToLower(),   
        DisplayAttributes.OneTrailingSpace,   
        new TimeSpan(),   
        new TimeSpan());  
  }  
  
  RecognitionResult rec = _recognizer.EmulateRecognize(  
        InputWordUnits,   
        System.Globalization.CompareOptions.IgnoreCase);  
  if (rec == null)   
  {  
    MessageBox.Show(String.Format("Recognition emulation for {0} failed.\n", text));  
  }   
  else if (InputWordUnits.Length != rec.Words.Count)   
  {  
    MessageBox.Show(  
       String.Format("Length mismatch: Input was {0} words, Recognition has {1} words.\n}"));  
  }   
  else   
  {  
    for (int i = 0; i < InputWordUnits.Length; i++)   
    {  
  
      if (rec.Words[i].LexicalForm.ToLower() != InputWordUnits[i].LexicalForm.ToLower())   
      {  
        MessageBox.Show(  
          String.Format("Input word {0} \"{1}\" not found. Recognition output is {2}",  
          i, InputWordUnits[i].LexicalForm, rec.Words[i].LexicalForm));  
        continue;  
      }  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberSignature Language="F#" Value="member this.Confidence : single" Usage="System.Speech.Recognition.RecognizedWordUnit.Confidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore, assegnato dal riconoscimento, che rappresenta la probabilità che una parola riconosciuta corrisponda a un input specificato.</summary>
        <value>Una misura relativa della certezza del riconoscimento corretto per una parola. Il valore va da 0,0 a 1,0 rispettivamente per una probabilità da bassa ad alta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I punteggi di confidenza non indicano la probabilità assoluta che un word è stato riconosciuto correttamente. Al contrario, i punteggi di confidenza forniscono un meccanismo per il confronto tra la precisione relativa più alternative di riconoscimento per un input specificato. Ciò facilita la restituzione del risultato di riconoscimento più accurato. Ad esempio, se una parola riconosciuta ha un punteggio di confidenza pari a 0,8, ciò non significa che la parola ha una probabilità 80% che la corrispondenza corretta per l'input.  Significa che la parola è più probabile che sia la corrispondenza corretta per l'input di altri risultati con confidenza assegna un punteggio minore 0,8.  
  
 Un punteggio di confidenza per sé non è significativo solo se si dispone dei risultati alternativi per il confronto, la stessa operazione di riconoscimento o dal precedente riconoscimenti dell'input stesso.  
  
 I valori restituiti da <xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A> sono relativi e univoci per ogni motore di riconoscimento. Non vi è alcuna definizione di come confrontare i valori di confidenza tra due motori di riconoscimento diversa, né il modo in cui <xref:System.Speech.Recognition.RecognizedWordUnit.Confidence%2A> dei singoli <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti definiscono il <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A> di un <xref:System.Speech.Recognition.RecognizedPhrase>.  
  
 Un motore di riconoscimento vocale può assegnare un punteggio di confidenza basso input vocale per vari motivi, tra cui interferenze in background, inarticulate vocale, o parole impreviste o le sequenze di word. Se l'applicazione utilizza un <xref:System.Speech.Recognition.SpeechRecognitionEngine> istanza, è possibile modificare il livello di confidenza quali sintesi e riconoscimento vocale è accettato o rifiutato con uno degli input di <xref:System.Speech.Recognition.SpeechRecognitionEngine.UpdateRecognizerSetting%2A> metodi. Le soglie di probabilità per il riconoscimento condiviso, gestito da <xref:System.Speech.Recognition.SpeechRecognizer>, sono associati a un profilo utente e archiviati nel Registro di sistema Windows. Le applicazioni non scrivono le modifiche al Registro di sistema per le proprietà di riconoscimento condiviso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayAttributes">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.DisplayAttributes DisplayAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Speech.Recognition.DisplayAttributes DisplayAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayAttributes As DisplayAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::DisplayAttributes DisplayAttributes { System::Speech::Recognition::DisplayAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayAttributes : System.Speech.Recognition.DisplayAttributes" Usage="System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.DisplayAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le informazioni di formattazione utilizzate per creare l'output di testo dall'istanza corrente di <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</summary>
        <value>Specifica l'utilizzo di spazi vuoti nella visualizzazione del contenuto di un oggetto <see cref="T:System.Speech.Recognition.RecognizedWordUnit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Speech.Recognition.DisplayAttributes> oggetto restituito dal <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> proprietà consente di specificare gli spazi iniziali e finali da utilizzare con una determinata parola, se presente.  
  
 Per ulteriori informazioni su come usare queste informazioni di formattazione, vedere il <xref:System.Speech.Recognition.DisplayAttributes> enumerazione.  
  
   
  
## Examples  
 L'esempio seguente mostra una routine dell'utilità (`stringFromWordArray`) che genera una stringa formattata in uno dei tre modi: a livello lessicale (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), normalizzato (mediante <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>), o fonetico (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). L'output di testo viene ottenuto dal <xref:System.Speech.Recognition.RecognizedWordUnit.DisplayAttributes%2A> proprietà in un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti, ottenuto dal <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà in un <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
        ReadOnlyCollection<RecognizedWordUnit> words,   
        WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }  
    else if (type == WordType.Pronunciation)   
    {  
       wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
         String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="LexicalForm">
      <MemberSignature Language="C#" Value="public string LexicalForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LexicalForm" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.LexicalForm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LexicalForm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LexicalForm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LexicalForm : string" Usage="System.Speech.Recognition.RecognizedWordUnit.LexicalForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il testo non normalizzato di una parola riconosciuta.</summary>
        <value>Restituisce un oggetto <see cref="T:System.String" /> contenente il testo di una parola riconosciuta, senza alcuna normalizzazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi i valori restituiti da <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> e <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A> sono identici. Tuttavia, i moduli di riconoscimento potrebbero Usa la normalizzazione vocale per restituire più intuitiva o stilistici rappresentazioni di testo di input audio.  
  
 Normalizzazione di riconoscimento vocale è l'uso di costrutti speciali o i simboli per esprimere il riconoscimento vocale in scrittura. Ad esempio, normalizzazione possibile sostituire le parole parlate "un dollaro and centesimi sedici" con "$1.16" nel testo di output.  
  
   
  
## Examples  
 L'esempio seguente mostra una routine di utilità che generi il testo in uno dei tre formati: lessicale (mediante <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), normalizzato (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) e fonetiche (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). L'output di testo viene ottenuto da un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti, ottenuto dal <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà il <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
         ReadOnlyCollection<RecognizedWordUnit> words,   
         WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
          String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)  
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)  
    {  
    wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Pronunciation">
      <MemberSignature Language="C#" Value="public string Pronunciation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Pronunciation" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Pronunciation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Pronunciation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Pronunciation { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Pronunciation : string" Usage="System.Speech.Recognition.RecognizedWordUnit.Pronunciation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ortografia fonetica di una parola riconosciuta.</summary>
        <value>Una stringa di caratteri di un alfabeto fonetico supportato, come l'alfabeto fonetico internazionale (IPA) o il set UPS (Universal Phone Set).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il contenuto di <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A> indicano quali pronuncia il motore di riconoscimento vocale utilizzato per abbinare input vocale su uno dei relativi caricato <xref:System.Speech.Recognition.Grammar> oggetti. Pronuncia può essere definita nel lessico interno del motore di riconoscimento vocale, in un documento di lessico collegato da una grammatica del riconoscimento in caricato <xref:System.Speech.Recognition.Grammar> oggetto o inline nella grammatica riconoscimento in caricato <xref:System.Speech.Recognition.Grammar> oggetto. Un motore di riconoscimento vocale è anche possibile creare la pronuncia delle parole non comune cui pronuncia non è definita in un dizionario o grammatica a cui il motore di riconoscimento vocale dispone attualmente dell'accesso.  
  
 Molti tipi di carattere di Unicode basato su Windows, ad esempio Courier New, supportano la visualizzazione delle stringhe IPA. Per altre informazioni, vedere [alfabeto fonetico internazionale](http://go.microsoft.com/fwlink/?LinkId=58363).  
  
   
  
## Examples  
 L'esempio seguente mostra una routine di utilità che genera una stringa con uno dei tre formati possibili: lessicale (mediante <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), normalizzato (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) e fonetiche (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). L'output di testo viene ottenuto da un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti, ottenuto dal <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà il <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
          ReadOnlyCollection<RecognizedWordUnit> words,   
          WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
          String.Format("[0}: is not a valid input", type));  
    }  
    // Use display attribute  
  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)   
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)   
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DisplayAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.RecognizedWordUnit.Text" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Text : string" Usage="System.Speech.Recognition.RecognizedWordUnit.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il testo normalizzato per una parola riconosciuta.</summary>
        <value>Stringa contenente l'output di testo normalizzato per una determinata parola di input.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi i valori restituiti da <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A> e <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A> sarà identico. Tuttavia, i moduli di riconoscimento potrebbero Usa la normalizzazione vocale per restituire più intuitiva o stilistici rappresentazioni di testo di input audio.  
  
 Normalizzazione di riconoscimento vocale è l'uso di costrutti speciali o i simboli per esprimere il riconoscimento vocale in scrittura. Ad esempio, normalizzazione possibile sostituire le parole parlate "un dollaro and centesimi sedici" con "$1.16" nel testo di output.  
  
   
  
## Examples  
 L'esempio seguente mostra una routine di utilità che genera una stringa in uno dei tre formati: lessicale (mediante <xref:System.Speech.Recognition.RecognizedWordUnit.LexicalForm%2A>), normalizzato (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Text%2A>) e fonetiche (utilizzando <xref:System.Speech.Recognition.RecognizedWordUnit.Pronunciation%2A>). L'output di testo viene ottenuto da un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> di <xref:System.Speech.Recognition.RecognizedWordUnit> oggetti, ottenuto dal <xref:System.Speech.Recognition.RecognizedPhrase.Words%2A> proprietà il <xref:System.Speech.Recognition.RecognizedPhrase> oggetto.  
  
```csharp  
  
internal enum WordType   
{  
  Text,  
  Normalized = Text,  
  Lexical,  
  Pronunciation  
}  
```  
  
```csharp  
internal static string stringFromWordArray(  
          ReadOnlyCollection<RecognizedWordUnit> words,   
          WordType type)   
{  
  string text = "";  
  foreach (RecognizedWordUnit word in words)   
  {  
    string wordText = "";  
    if (type == WordType.Text || type == WordType.Normalized)   
    {  
      wordText = word.Text;  
    }   
    else if (type == WordType.Lexical)   
    {  
      wordText = word.LexicalForm;  
    }   
    else if (type == WordType.Pronunciation)   
    {  
      wordText = word.Pronunciation;  
    }   
    else   
    {  
      throw new InvalidEnumArgumentException(  
           String.Format("[0}: is not a valid input", type));  
    }  
  
    // Use display attribute  
    if ((word.DisplayAttributes & DisplayAttributes.OneTrailingSpace) != 0)   
    {  
      wordText += " ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.TwoTrailingSpaces) != 0)   
    {  
      wordText += "  ";  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ConsumeLeadingSpaces) != 0)   
    {  
      wordText = wordText.TrimStart();  
    }  
    if ((word.DisplayAttributes & DisplayAttributes.ZeroTrailingSpaces) != 0)   
    {  
      wordText = wordText.TrimEnd();  
    }  
  
    text += wordText;  
  
  }  
  return text;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>