<Type Name="MessageEncoder" FullName="System.ServiceModel.Channels.MessageEncoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="22ee9252c9ce868099022a94651209787100cf40" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52205931" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MessageEncoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageEncoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MessageEncoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageEncoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEncoder abstract" />
  <TypeSignature Language="F#" Value="type MessageEncoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Il codificatore è il componente utilizzato per scrivere messaggi in un flusso e leggere messaggi da un flusso.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MessageEncoder> è una classe di base che fornisce implementazioni che supportano un tipo di contenuto e una versione messaggi MIME (Multipurpose Internet Mail Extensions) e che definisce l'interfaccia per la serializzazione e la deserializzazione di messaggi in base al tipo di contenuto. Utilizzare questa classe come classe di base per la scrittura di un codificatore personalizzato.  
  
 Utilizzare questa classe se si desidera implementare un codificatore di messaggi personalizzato. Per implementare un codificatore di messaggi personalizzato, è necessario fornire implementazioni personalizzate delle classi base astratte seguenti:  
  
-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder>  
  
 Eseguire l'override di <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> per restituire un'istanza del codificatore <xref:System.ServiceModel.Channels.MessageEncoder> personalizzato. Associare quindi il <xref:System.ServiceModel.Channels.MessageEncoderFactory> personalizzato allo stack dell'elemento di associazione utilizzato per configurare il servizio o il client eseguendo l'override del metodo <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> per restituire un'istanza di questa factory.  
  
 La conversione tra la rappresentazione in memoria di un messaggio e la rappresentazione InfoSet XML che può essere scritta in un flusso viene incapsulata all'interno della classe <xref:System.ServiceModel.Channels.MessageEncoder>, che viene in genere utilizzata come una factory per i lettori e i writer XML che supportano tipi specifici di codifiche XML.  
  
 I metodi principali inclusi nella classe <xref:System.ServiceModel.Channels.MessageEncoder> sono <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> e <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>. <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> accetta un oggetto <xref:System.ServiceModel.Channels.Message> e lo scrive in un oggetto <xref:System.IO.Stream>. <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> accetta un oggetto <xref:System.IO.Stream> e una dimensione di intestazione massima e restituisce un oggetto <xref:System.ServiceModel.Channels.Message>.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un esempio di una classe derivata da <xref:System.ServiceModel.Channels.MessageEncoder>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageEncoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ServiceModel.Channels.MessageEncoder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteMessage">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWriteMessage (System.ServiceModel.Channels.Message message, System.IO.Stream stream, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteMessage(class System.ServiceModel.Channels.Message message, class System.IO.Stream stream, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.BeginWriteMessage(System.ServiceModel.Channels.Message,System.IO.Stream,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteMessage(System::ServiceModel::Channels::Message ^ message, System::IO::Stream ^ stream, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream * AsyncCallback * obj -&gt; IAsyncResult" Usage="messageEncoder.BeginWriteMessage (message, stream, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio.</param>
        <param name="stream">Flusso.</param>
        <param name="callback">Callback.</param>
        <param name="state">Stato.</param>
        <summary>Avvia la scrittura del messaggio per il codificatore di messaggi con il messaggio, il flusso, il callback e lo stato specificati.</summary>
        <returns>Risultato asincrono dell'operazione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public abstract string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.ServiceModel.Channels.MessageEncoder.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il tipo di contenuto MIME utilizzato dal codificatore.</summary>
        <value>Tipo di contenuto supportato dal codificatore di messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di contenuto è un'intestazione MIME Multipurpose Internet Mail Exchange) che viene visualizzata all'inizio di un messaggio MIME e all'interno delle singole parti del corpo del messaggio. Le intestazioni Content-Type vengono utilizzate per specificare il tipo e il sottotipo di supporto dei dati presenti nel corpo di un messaggio e per specificare completamente il tipo e il sottotipo di supporto dei dati presenti nel corpo di un messaggio, nonché per specificare la codifica dei caratteri (facoltativo) dei dati. Un esempio di un MIME del contenuto tipo che può essere supportato: "application/soap + xml; set di caratteri CharSet='utf8 ' ".  
  
 Cui viene descritta una grammatica che definisce la sintassi delle intestazioni content-type [RFC 2045](https://go.microsoft.com/fwlink/?LinkId=95945), Section 5.1. [RFC 2046](https://go.microsoft.com/fwlink/?LinkId=95944) fornendo informazioni dettagliate sui tipi di supporto MIME e sui relativi parametri.  
  
   
  
## Examples  
 [!code-csharp[S_UE_CustomTextMessageEncoder#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWriteMessage">
      <MemberSignature Language="C#" Value="public virtual void EndWriteMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWriteMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.EndWriteMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWriteMessage (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWriteMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteMessage : IAsyncResult -&gt; unit&#xA;override this.EndWriteMessage : IAsyncResult -&gt; unit" Usage="messageEncoder.EndWriteMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Risultato dell'operazione.</param>
        <summary>Termina la scrittura dei messaggi per il codificatore di messaggi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T GetProperty&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T GetProperty&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.GetProperty``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperty(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class virtual T GetProperty();" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : unit -&gt; 'T (requires 'T : null)&#xA;override this.GetProperty : unit -&gt; 'T (requires 'T : null)" Usage="messageEncoder.GetProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Oggetto tipizzato per il quale il metodo sta eseguendo una query.</typeparam>
        <summary>Se presente, restituisce un oggetto tipizzato richiesto dal livello appropriato nello stack dei canali.</summary>
        <returns>L'oggetto tipizzato <paramref name="T" /> richiesto se presente, <see langword="null" /> in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per richiedere un oggetto tipizzato, ad esempio un'interfaccia per l'impostazione di proprietà o per ottenere lo stato dal livello appropriato nello stack dei canali. L'oggetto richiesto viene restituito solo se tale azione è supportata dal livello. In caso contrario, delega la chiamata al livello successivo nello stack. Se raggiunge la fine dello stack e nessun livello del canale supporta l'oggetto richiesto, il metodo restituisce `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContentTypeSupported">
      <MemberSignature Language="C#" Value="public virtual bool IsContentTypeSupported (string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsContentTypeSupported(string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.IsContentTypeSupported(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsContentTypeSupported (contentType As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsContentTypeSupported(System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member IsContentTypeSupported : string -&gt; bool&#xA;override this.IsContentTypeSupported : string -&gt; bool" Usage="messageEncoder.IsContentTypeSupported contentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">Valore Content-Type a livello di messaggio che viene verificato.</param>
        <summary>Restituisce un valore che indica se il codificatore messaggi supporta un valore Content-Type a livello di messaggio specificato.</summary>
        <returns>
          <see langword="true" /> se il valore Content-Type a livello di messaggio specificato è supportato. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per determinare se il codificatore di messaggi può essere utilizzato per leggere un particolare stile di messaggio, in base al relativo valore Content-Type. Le informazioni incluse nella classe <xref:System.Net.Mime.ContentType> vengono utilizzate per descrivere i dati contenuti in un messaggio e per determinare se esiste una corrispondenza Content-Type.  
  
 Cui viene descritta una grammatica che definisce la sintassi delle intestazioni content-type [RFC 2045](https://go.microsoft.com/fwlink/?LinkId=95945) Section 5.1. [RFC 2046](https://go.microsoft.com/fwlink/?LinkId=95944) fornendo informazioni dettagliate sui tipi di supporto MIME Multipurpose Internet Mail Extensions () e i relativi parametri.  
  
   
  
## Examples  
 Nell'esempio di codice seguente viene illustrato come eseguire l'override di questo metodo per gestire tipi di contenuto diversi con lo stesso tipo di supporto.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#8)]
 [!code-csharp[S_UE_CustomTextMessageEncoder#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoderfactory.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public abstract string MediaType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ MediaType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string" Usage="System.ServiceModel.Channels.MessageEncoder.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il valore del tipo di supporto utilizzato dal codificatore.</summary>
        <value>Tipo di supporto supportato dal codificatore di messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di supporto fa parte dell'intestazione Content-Type.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato come implementare la proprietà `MediaType`.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageVersion">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.MessageVersion MessageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion MessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MessageEncoder.MessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::ServiceModel::Channels::MessageVersion ^ MessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageVersion : System.ServiceModel.Channels.MessageVersion" Usage="System.ServiceModel.Channels.MessageEncoder.MessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il valore della versione messaggi utilizzato dal codificatore.</summary>
        <value>Valore <see cref="T:System.ServiceModel.Channels.MessageVersion" /> utilizzato dal codificatore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica le versioni di SOAP e WS-Addressing associate a un messaggio e alle relative operazioni di scambio. Se non devono essere utilizzate versioni SOAP, è necessario eseguire l'override di questa proprietà per restituire <xref:System.ServiceModel.Channels.MessageVersion.None%2A>.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato come implementare la proprietà <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadMessage">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, legge un messaggio da un flusso specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message ReadMessage (ArraySegment&lt;byte&gt; buffer, System.ServiceModel.Channels.BufferManager bufferManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Channels.Message ReadMessage(valuetype System.ArraySegment`1&lt;unsigned int8&gt; buffer, class System.ServiceModel.Channels.BufferManager bufferManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.ArraySegment{System.Byte},System.ServiceModel.Channels.BufferManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ ReadMessage(ArraySegment&lt;System::Byte&gt; buffer, System::ServiceModel::Channels::BufferManager ^ bufferManager);" />
      <MemberSignature Language="F#" Value="member this.ReadMessage : ArraySegment&lt;byte&gt; * System.ServiceModel.Channels.BufferManager -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (buffer, bufferManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
      </Parameters>
      <Docs>
        <param name="buffer">Struttura <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> che fornisce il buffer dal quale viene deserializzato il messaggio.</param>
        <param name="bufferManager">Classe <see cref="T:System.ServiceModel.Channels.BufferManager" /> che gestisce il buffer dal quale viene deserializzato il messaggio.</param>
        <summary>Quando sottoposto a override in una classe derivata, legge un messaggio da un buffer specificato.</summary>
        <returns>Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> che viene letto dal buffer specificato.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message ReadMessage (System.IO.Stream stream, int maxSizeOfHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Channels.Message ReadMessage(class System.IO.Stream stream, int32 maxSizeOfHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ ReadMessage(System::IO::Stream ^ stream, int maxSizeOfHeaders);" />
      <MemberSignature Language="F#" Value="member this.ReadMessage : System.IO.Stream * int -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (stream, maxSizeOfHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="maxSizeOfHeaders" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> da cui viene letto il messaggio.</param>
        <param name="maxSizeOfHeaders">Dimensione massima delle intestazioni che possono essere lette dal messaggio.</param>
        <summary>Quando sottoposto a override in una classe derivata, legge un messaggio da un flusso specificato.</summary>
        <returns>Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> che viene letto dal flusso specificato.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.Message ReadMessage (ArraySegment&lt;byte&gt; buffer, System.ServiceModel.Channels.BufferManager bufferManager, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message ReadMessage(valuetype System.ArraySegment`1&lt;unsigned int8&gt; buffer, class System.ServiceModel.Channels.BufferManager bufferManager, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.ArraySegment{System.Byte},System.ServiceModel.Channels.BufferManager,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::Message ^ ReadMessage(ArraySegment&lt;System::Byte&gt; buffer, System::ServiceModel::Channels::BufferManager ^ bufferManager, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member ReadMessage : ArraySegment&lt;byte&gt; * System.ServiceModel.Channels.BufferManager * string -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (buffer, bufferManager, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="buffer">Struttura <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> che fornisce il buffer dal quale viene deserializzato il messaggio.</param>
        <param name="bufferManager">Classe <see cref="T:System.ServiceModel.Channels.BufferManager" /> che gestisce il buffer dal quale viene deserializzato il messaggio.</param>
        <param name="contentType">Valore Content-Type a livello di messaggio MIME (Multipurpose Internet Mail Extensions).</param>
        <summary>Quando sottoposto a override in una classe derivata, legge un messaggio da un flusso specificato.</summary>
        <returns>Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> che viene letto dal flusso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice seguente viene illustrato come implementare il metodo <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%28System.ArraySegment%7BSystem.Byte%7D%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.String%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMessage">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.Message ReadMessage (System.IO.Stream stream, int maxSizeOfHeaders, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message ReadMessage(class System.IO.Stream stream, int32 maxSizeOfHeaders, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ReadMessage(System.IO.Stream,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::Message ^ ReadMessage(System::IO::Stream ^ stream, int maxSizeOfHeaders, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="abstract member ReadMessage : System.IO.Stream * int * string -&gt; System.ServiceModel.Channels.Message" Usage="messageEncoder.ReadMessage (stream, maxSizeOfHeaders, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="maxSizeOfHeaders" Type="System.Int32" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> da cui viene letto il messaggio.</param>
        <param name="maxSizeOfHeaders">Dimensione massima delle intestazioni che possono essere lette dal messaggio.</param>
        <param name="contentType">Valore Content-Type a livello di messaggio MIME (Multipurpose Internet Mail Extensions).</param>
        <summary>Quando sottoposto a override in una classe derivata, legge un messaggio da un flusso specificato.</summary>
        <returns>Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> che viene letto dal flusso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice seguente viene illustrato come implementare il metodo <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%28System.IO.Stream%2CSystem.Int32%2CSystem.String%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="messageEncoder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il tipo di contenuto utilizzato dal codificatore di messaggi.</summary>
        <returns>Tipo di contenuto utilizzato dal codificatore di messaggi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessage">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, scrive un messaggio in un flusso o buffer specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public abstract void WriteMessage (System.ServiceModel.Channels.Message message, System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteMessage(class System.ServiceModel.Channels.Message message, class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteMessage(System::ServiceModel::Channels::Message ^ message, System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteMessage : System.ServiceModel.Channels.Message * System.IO.Stream -&gt; unit" Usage="messageEncoder.WriteMessage (message, stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da scrivere in <paramref name="stream" />.</param>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> in cui viene scritto <paramref name="message" />.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un messaggio in un flusso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nel codice seguente viene illustrato come implementare il metodo <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.IO.Stream%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public ArraySegment&lt;byte&gt; WriteMessage (System.ServiceModel.Channels.Message message, int maxMessageSize, System.ServiceModel.Channels.BufferManager bufferManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ArraySegment`1&lt;unsigned int8&gt; WriteMessage(class System.ServiceModel.Channels.Message message, int32 maxMessageSize, class System.ServiceModel.Channels.BufferManager bufferManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.Int32,System.ServiceModel.Channels.BufferManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArraySegment&lt;System::Byte&gt; WriteMessage(System::ServiceModel::Channels::Message ^ message, int maxMessageSize, System::ServiceModel::Channels::BufferManager ^ bufferManager);" />
      <MemberSignature Language="F#" Value="member this.WriteMessage : System.ServiceModel.Channels.Message * int * System.ServiceModel.Channels.BufferManager -&gt; ArraySegment&lt;byte&gt;" Usage="messageEncoder.WriteMessage (message, maxMessageSize, bufferManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ArraySegment&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="maxMessageSize" Type="System.Int32" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da scrivere nel buffer dei messaggi.</param>
        <param name="maxMessageSize">Dimensione massima consentita per la scrittura di un messaggio.</param>
        <param name="bufferManager">Classe <see cref="T:System.ServiceModel.Channels.BufferManager" /> che gestisce il buffer nel quale viene scritto il messaggio.</param>
        <summary>Scrive un messaggio di dimensione inferiore a quella specificata in un buffer di matrice di byte.</summary>
        <returns>Struttura <see cref="T:System.ArraySegment`1" /> di tipo <see langword="byte" /> che fornisce il buffer nel quale viene serializzato il messaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il metodo <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29> astratto con `messageOffset` = 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteMessage">
      <MemberSignature Language="C#" Value="public abstract ArraySegment&lt;byte&gt; WriteMessage (System.ServiceModel.Channels.Message message, int maxMessageSize, System.ServiceModel.Channels.BufferManager bufferManager, int messageOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.ArraySegment`1&lt;unsigned int8&gt; WriteMessage(class System.ServiceModel.Channels.Message message, int32 maxMessageSize, class System.ServiceModel.Channels.BufferManager bufferManager, int32 messageOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MessageEncoder.WriteMessage(System.ServiceModel.Channels.Message,System.Int32,System.ServiceModel.Channels.BufferManager,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract ArraySegment&lt;System::Byte&gt; WriteMessage(System::ServiceModel::Channels::Message ^ message, int maxMessageSize, System::ServiceModel::Channels::BufferManager ^ bufferManager, int messageOffset);" />
      <MemberSignature Language="F#" Value="abstract member WriteMessage : System.ServiceModel.Channels.Message * int * System.ServiceModel.Channels.BufferManager * int -&gt; ArraySegment&lt;byte&gt;" Usage="messageEncoder.WriteMessage (message, maxMessageSize, bufferManager, messageOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ArraySegment&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="maxMessageSize" Type="System.Int32" />
        <Parameter Name="bufferManager" Type="System.ServiceModel.Channels.BufferManager" />
        <Parameter Name="messageOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Oggetto <see cref="T:System.ServiceModel.Channels.Message" /> da scrivere nel buffer dei messaggi.</param>
        <param name="maxMessageSize">Dimensione massima consentita per la scrittura di un messaggio.</param>
        <param name="bufferManager">Classe <see cref="T:System.ServiceModel.Channels.BufferManager" /> che gestisce il buffer nel quale viene scritto il messaggio.</param>
        <param name="messageOffset">Offset del segmento che inizia dall'inizio della matrice di byte che fornisce il buffer.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un messaggio di dimensione inferiore a quella specificata in un buffer di matrice di byte in corrispondenza dell'offset specificato.</summary>
        <returns>Struttura <see cref="T:System.ArraySegment`1" /> di tipo <see langword="byte" /> che fornisce il buffer nel quale viene serializzato il messaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29>.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato come implementare il metodo <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%28System.ServiceModel.Channels.Message%2CSystem.Int32%2CSystem.ServiceModel.Channels.BufferManager%2CSystem.Int32%29>.  
  
 [!code-csharp[S_UE_CustomTextMessageEncoder#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_customtextmessageencoder/cs/customtextmessageencoder.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>