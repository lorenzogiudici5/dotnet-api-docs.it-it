<Type Name="MsmqTransportBindingElement" FullName="System.ServiceModel.Channels.MsmqTransportBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dc09a2a8966029e1ac832484cef4fe71dac84173" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34315059" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MsmqTransportBindingElement : System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MsmqTransportBindingElement extends System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MsmqTransportBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MsmqTransportBindingElement&#xA;Inherits MsmqBindingElementBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqTransportBindingElement sealed : System::ServiceModel::Channels::MsmqBindingElementBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.MsmqBindingElementBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta l'elemento di associazione usato per specificare le proprietà delle comunicazioni di accodamento per un servizio Windows Communication Foundation (WCF) che usa il protocollo di accodamento dei messaggi (MSMQ) nativo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MsmqTransportBindingElement> consente all'utente di impostare le proprietà per il canale di comunicazione in coda. Il canale delle comunicazioni in coda usa l'accodamento dei messaggi per il trasporto.  
  
 Questo è l'elemento di associazione predefinito usato dall'associazione standard dell'accodamento dei messaggi (<xref:System.ServiceModel.NetMsmqBinding>).  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/service.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MsmqTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MsmqTransportBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ServiceModel.Channels.MsmqTransportBindingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/service.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Classe  <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" /> o <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</typeparam>
        <param name="context">Classe <see cref="T:System.ServiceModel.Channels.BindingContext" /> utilizzabile per compilare la channel factory.</param>
        <summary>Compila una channel factory utilizzando il contesto fornito.</summary>
        <returns>Channel factory dell'accodamento dei messaggi (MSMQ) che può essere utilizzata per creare canali per inviare messaggi alle applicazioni di accodamento dei messaggi esistenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una channel factory viene creata e inizializzata utilizzando le proprietà impostate nell'elemento di associazione. La channel factory inizializzata viene quindi utilizzata per creare canali di output che possono essere utilizzati per inviare messaggi a una coda di messaggi.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di contesto è Null.</exception>
        <exception cref="T:System.ArgumentException">TChannel non è IOutputChannel o IOutputSessionChannel.</exception>
        <exception cref="T:System.InvalidOperationException">MsmqTransportSecurity.MsmqProtectionLevel è EncryptAndSign e UseActiveDirectory è False.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Il tipo di canale da utilizzare per compilare il listener del canale. Tipi di canale consentiti sono <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" /> o una classe <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</typeparam>
        <param name="context">Classe <see cref="T:System.ServiceModel.Channels.BindingContext" /> utilizzabile per compilare il listener del canale.</param>
        <summary>Compila un listener del canale utilizzando il contesto fornito.</summary>
        <returns>Un listener del canale dell'accodamento dei messaggi (MSMQ) che può essere utilizzato per creare canali per ricevere messaggi dalle applicazioni MSMQ esistenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di contesto è Null.</exception>
        <exception cref="T:System.ArgumentException">TChannel non è IInputChannel o IInputSessionChannel.</exception>
        <exception cref="T:System.InvalidOperationException">MsmqTransportSecurity.MsmqAuthenticationMode è Certificate o WindowsDomain e MsmqTransportSecurity.MsmqProtectionLevel è None.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Il tipo di canale da utilizzare per compilare il listener del canale. Tipi di canale consentiti sono <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" /> o una classe <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</typeparam>
        <param name="context">Classe <see cref="T:System.ServiceModel.Channels.BindingContext" /> utilizzabile per compilare la channel factory.</param>
        <summary>Restituisce un valore booleano che indica se è possibile compilare una channel factory con il contesto fornito.</summary>
        <returns>
          <see langword="true" /> se è possibile compilare una channel factory con il contesto fornito. In caso contrario, <see langword="false" />. L'elemento di associazione restituisce <see langword="true" /> solo quando <paramref name="TChannel" /> è <see cref="T:System.ServiceModel.Channels.IOutputChannel" /> o <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Il tipo di canale da utilizzare per compilare il listener del canale. Tipi di canale consentiti sono <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" /> o una classe <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</typeparam>
        <param name="context">Classe <see cref="T:System.ServiceModel.Channels.BindingContext" /> utilizzabile per compilare il listener del canale.</param>
        <summary>Restituisce un valore booleano che indica se è possibile compilare un listener del canale con il contesto fornito.</summary>
        <returns>
          <see langword="true" /> se è possibile compilare un listener del canale con il contesto fornito. In caso contrario, <see langword="false" />.  L'associazione restituisce <see langword="true" /> solo quando <paramref name="TChannel" /> è <see cref="T:System.ServiceModel.Channels.IInputChannel" /> o <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un clone dell'elemento dell'associazione.</summary>
        <returns>Clone dell'elemento dell'associazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPoolSize">
      <MemberSignature Language="C#" Value="public int MaxPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.MaxPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPoolSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPoolSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un numero intero che specifica la dimensione massima del pool che contiene oggetti di messaggi dell'Accodamento messaggi (MSMQ) interni.</summary>
        <value>Numero intero che specifica la dimensione massima del pool che contiene oggetti messaggio dell'accodamento dei messaggi interni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il pool di oggetti messaggio dell'accodamento dei messaggi interni viene utilizzato per evitare allocazioni di questi oggetti nell'invio e nella ricezione di messaggi. La dimensione massima del pool è un parametro di ottimizzazione delle prestazioni. Il valore predefinito è 8.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueTransferProtocol">
      <MemberSignature Language="C#" Value="public System.ServiceModel.QueueTransferProtocol QueueTransferProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.QueueTransferProtocol QueueTransferProtocol" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.QueueTransferProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueTransferProtocol As QueueTransferProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::QueueTransferProtocol QueueTransferProtocol { System::ServiceModel::QueueTransferProtocol get(); void set(System::ServiceModel::QueueTransferProtocol value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.QueueTransferProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Consente di ottenere o impostare un valore di enumerazione che indica il trasporto del canale di comunicazione in coda utilizzato da questa associazione.</summary>
        <value>Valore dell'enumerazione <see cref="T:System.ServiceModel.QueueTransferProtocol" /> che indica il trasporto utilizzato per il recapito dei messaggi tra i gestori delle code.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'accodamento dei messaggi (MSMQ) non supporta l'indirizzamento Active Directory quando si utilizza il protocollo SOAP Reliable Messaging Protocol (SRMP), pertanto non impostare <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.QueueTransferProtocol%2A> su <xref:System.ServiceModel.QueueTransferProtocol.Srmp> o <xref:System.ServiceModel.QueueTransferProtocol.Srmp> quando <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory%2A> è impostato su `true`.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore non appartiene all'enumerazione <see cref="T:System.ServiceModel.QueueTransferProtocol" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce <see cref="T:System.String" /> che contiene lo schema di indirizzamento utilizzato da questo elemento di associazione del trasporto.</summary>
        <value>
          <see cref="T:System.String" /> contiene lo schema di indirizzamento utilizzato da questo elemento di associazione del trasporto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.Scheme%2A> restituisce la stringa "net.msmq".  
  
 Il trasporto in coda dell'accodamento dei messaggi (MSMQ) supporta numerosi schemi di indirizzamento, incluso net.msmq.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseActiveDirectory">
      <MemberSignature Language="C#" Value="public bool UseActiveDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseActiveDirectory" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property UseActiveDirectory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseActiveDirectory { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un valore booleano che indica se convertire gli indirizzi delle code mediante Active Directory.</summary>
        <value>
          <see langword="true" /> se gli indirizzi delle code devono essere convertiti utilizzando Active Directory. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli indirizzi di coda del sistema di accodamento dei messaggi MSMQ possono essere costituiti da nomi di percorso o da nomi di formato Direct. Con un nome di formato Direct, MSMQ risolve il nome della coda utilizzando DNS, NetBIOS o IP. Con un nome di percorso, MSMQ risolve il nome della coda usando Active Directory.  
  
 Per impostazione predefinita, Windows Communication Foundation (WCF) in coda trasporto Converte l'URI di una coda di messaggi a un nome di formato direct. Impostando la proprietà <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory%2A> su `true`, un'applicazione può specificare che il trasporto in coda debba risolvere il nome del computer utilizzando Active Directory invece di DNS, NetBIOS o IP.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>