<Type Name="Extensions" FullName="System.Xml.Schema.Extensions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="317b5394bbc59e02e159f496bc8d34097c298d77" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51938927" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Schema.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Questa classe contiene i metodi di estensione LINQ to XML per la convalida XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe contiene inoltre i metodi per ottenere la post-schema-validation infoset (PSVI) di un nodo XML convalidato.  
  
 Quando si convalida un' <xref:System.Xml.Linq.XDocument>, <xref:System.Xml.Linq.XElement>, o <xref:System.Xml.Linq.XAttribute>, anche se lo si desidera è possibile popolare l'albero XML con l'infoset dopo la post-schema-validation. Informazioni PSVI viene aggiunto come un'annotazione di tipo <xref:System.Xml.Schema.XmlSchemaInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Lo schema XSD [File XSD di esempio: Customers e Orders](https://msdn.microsoft.com/library/8b05efe3-cc5e-4c7b-b322-892dbda41687) contiene uno schema che può essere utilizzato per convalidare il documento XML nelle [File XML di esempio: Customers e Orders (LINQ to XML)](https://msdn.microsoft.com/library/26790c41-5976-4558-a096-d0f67bfc4d92). Nell'esempio seguente carica il documento e lo schema, convalida il documento, il documento viene modificato in modo che il `xs:key` e `xs:keyref` relazione non è valida e quindi tenta di eseguire nuovamente la convalida.  
  
```csharp  
  
                XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", "CustomersOrders.xsd");  
  
XDocument custOrd = XDocument.Load("CustomersOrders.xml");  
  
Console.WriteLine("Validating custOrd");  
bool errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
  
// Modify the custOrd tree so that it is no longer valid.  
custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA";  
  
Console.WriteLine();  
Console.WriteLine("Validating custOrd");  
errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", "CustomersOrders.xsd")  
  
    Console.WriteLine("Validating custOrd")  
    Dim custOrd As XDocument = XDocument.Load("CustomersOrders.xml")  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating custOrd")  
    ' Modify the source document so that it will not validate.  
    custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA"  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating custOrd  
custOrd validated  
  
Validating custOrd  
The key sequence 'AAAAA' in Keyref fails to refer to some key.  
custOrd did not validate  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetSchemaInfo">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'infoset dopo la convalida dello schema (PSVI) di un nodo convalidato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver convalidato un <xref:System.Xml.Linq.XDocument>, è possibile recuperare l'infoset dopo la post-schema-validation per un <xref:System.Xml.Linq.XElement> o <xref:System.Xml.Linq.XAttribute> contenuta nel documento.  
  
 Dopo aver recuperato il <xref:System.Xml.Schema.IXmlSchemaInfo> dell'oggetto, è possibile usare il <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> oppure <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> proprietà per ottenere un tipo di convalida parziale (<xref:System.Xml.Schema.XmlSchemaElement> o <xref:System.Xml.Schema.XmlSchemaAttribute>). Per convalidare un attributo o una sottostruttura ad albero, è possibile utilizzare i tipi di convalida parziale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XAttribute source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XAttribute source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XAttribute)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XAttribute) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XAttribute ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XAttribute -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XAttribute" /> che è stato convalidato in precedenza.</param>
        <summary>Ottiene l'infoset dopo la convalida dello schema (PSVI) di un attributo convalidato.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> contenente l'infoset dopo la convalida dello schema per un <see cref="T:System.Xml.Linq.XAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Xml.Schema.IXmlSchemaInfo> restituito da questo metodo per determinare determinate caratteristiche di un attributo convalidato. Ad esempio, è possibile determinare se l'attributo proviene da un valore predefinito dell'attributo in uno schema XSD.  
  
 Si utilizza il <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> proprietà da ottenere un tipo di convalida parziale (<xref:System.Xml.Schema.XmlSchemaAttribute>). È possibile utilizzarlo per riconvalidare un attributo senza convalidare un intero documento.  
  
 Per un esempio di questa proprietà, vedere <xref:System.Xml.Schema.Extensions.Validate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XElement source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XElement source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XElement)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XElement) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XElement ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XElement -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XElement" /> che è stato convalidato in precedenza.</param>
        <summary>Ottiene l'infoset dopo la convalida dello schema (PSVI) di un elemento convalidato.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> contenente l'infoset dopo la convalida dello schema (PSVI) per un <see cref="T:System.Xml.Linq.XElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Xml.Schema.IXmlSchemaInfo> restituito da questo metodo per determinare determinate caratteristiche di un elemento convalidato. Ad esempio, è possibile determinare il tipo di schema dinamico dell'elemento.  
  
 Si utilizza il <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> proprietà da ottenere un tipo di convalida parziale (<xref:System.Xml.Schema.XmlSchemaElement>). È possibile utilizzarlo per riconvalidare un sottoalbero con radice di un elemento senza convalidare un intero documento.  
  
 Per un esempio di questa proprietà, vedere <xref:System.Xml.Schema.Extensions.Validate%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente consente di popolare l'albero con un PSVI. Dopo la convalida, vengono stampati tutti gli elementi e attributi nell'albero che non sono validi in base al PSVI.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
         @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
   <xsd:simpleType name='GCType'>  
    <xsd:restriction base='xsd:token'>  
     <xsd:enumeration value='AAA'/>  
     <xsd:enumeration value='BBB'/>  
    </xsd:restriction>  
   </xsd:simpleType>  
   <xsd:element name='Root'>  
    <xsd:complexType>  
     <xsd:sequence>  
      <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
       <xsd:complexType>  
        <xsd:sequence>  
         <xsd:element name='GrandChild1' type='GCType'/>  
         <xsd:element name='GrandChild2' type='GCType'/>  
         <xsd:element name='GrandChild3' type='GCType'/>  
        </xsd:sequence>  
       </xsd:complexType>  
      </xsd:element>  
     </xsd:sequence>  
    </xsd:complexType>  
   </xsd:element>  
  </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
                <xsd:enumeration value='AAA'/>  
                <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
        </xsd:simpleType>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:sequence>  
                                <xsd:element name='GrandChild1' type='GCType'/>  
                                <xsd:element name='GrandChild2' type='GCType'/>  
                                <xsd:element name='GrandChild3' type='GCType'/>  
                            </xsd:sequence>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>  
            <GrandChild1>AAA</GrandChild1>  
            <GrandChild2>ZZZ</GrandChild2>  
            <GrandChild3>ZZZ</GrandChild3>  
        </Child1>  
    </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convalida che un <see cref="T:System.Xml.Linq.XDocument" />, un <see cref="T:System.Xml.Linq.XElement" /> o un <see cref="T:System.Xml.Linq.XAttribute" /> è conforme a uno schema XSD in un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questi metodi usano un oggetto sottostante <xref:System.Xml.XmlReader> per convalidare l'albero XML rispetto a uno schema XSD.  
  
 Errore di convalida e i messaggi di avviso vengono gestiti usando i <xref:System.Xml.Schema.ValidationEventHandler> delegare. Se a questi metodi non viene fornito alcun gestore eventi, errori di convalida vengono esposti come un <xref:System.Xml.Schema.XmlSchemaValidationException>. Avvisi di convalida non provocano un <xref:System.Xml.Schema.XmlSchemaValidationException> generata.  
  
 Alcuni di questi metodi di estensione, facoltativamente, consentire il popolamento di post-schema-validation infoset (PSVI).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XDocument" /> da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <summary>Questo metodo convalida che un <see cref="T:System.Xml.Linq.XDocument" /> è conforme a uno schema XSD in un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo di estensione consente di verificare che il <xref:System.Xml.Linq.XDocument> è conforme al modello di contenuto dello schema in <xref:System.Xml.Schema.XmlSchemaSet>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un oggetto <xref:System.Xml.Schema.XmlSchemaSet>, quindi vengono convalidati due oggetti <xref:System.Xml.Linq.XDocument> rispetto al set di schemi. Uno dei documenti è valido, l'altro non lo è.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child2", "content1")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child2>content2</Child2>  
    </Root>  
  
    Dim doc2 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child3>content1</Child3>  
    </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XAttribute" /> da convalidare.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> che specifica la sottostruttura da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <summary>Questo metodo convalida che un <see cref="T:System.Xml.Linq.XAttribute" /> è conforme a un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> e a un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare questo metodo per convalidare che un <xref:System.Xml.Linq.XAttribute> conforme a uno schema. In genere possibile utilizzare questo metodo quando è stato modificato un attributo e si desidera assicurarsi che sia ancora conforme al relativo schema. È possibile convalidare l'intero documento, ma sia necessario meno tempo di elaborazione per la convalida solo l'attributo.  
  
 Se si passa `null` per `validationEventHandler`, questo metodo genera un'eccezione in base agli errori di convalida. Avvisi di convalida non genererà un'eccezione.  
  
 Per convalidare un attributo, si utilizza un'istanza di <xref:System.Xml.Schema.XmlSchemaObject>. È possibile ottenere questa istanza in vari modi. Un modo semplice consiste nel modo seguente:  
  
1.  Verificare che un documento conforme a uno schema.  
  
2.  Aggiungi post-schema-validation infoset (PSVI) chiamando il <xref:System.Xml.Schema.Extensions.Validate%2A> metodo di estensione.  
  
3.  Chiamare il <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodo di estensione per recuperare un oggetto che implementa <xref:System.Xml.Schema.IXmlSchemaInfo>. Dall'oggetto recuperato, è possibile ottenere un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XElement>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XAttribute>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Dopo aver creato un'istanza di un <xref:System.Xml.Schema.XmlSchemaObject>, è possibile usare questo metodo per convalidare un attributo.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XAttribute("Lang", "C#")  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
XAttribute lang = doc1.Root.Attribute("Lang");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Lang attribute invalid according to the schema  
lang.Value = "VC";  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
      <?xml version='1.0'?>  
      <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
          <xsd:element name='Root'>  
              <xsd:complexType>  
                  <xsd:simpleContent>  
                      <xsd:extension base='xsd:string'>  
                          <xsd:attribute name='Lang' use='required'>  
                              <xsd:simpleType>  
                                  <xsd:restriction base='xsd:token'>  
                                      <xsd:enumeration value='C#'/>  
                                      <xsd:enumeration value='VB'/>  
                                  </xsd:restriction>  
                              </xsd:simpleType>  
                          </xsd:attribute>  
                      </xsd:extension>  
                  </xsd:simpleContent>  
              </xsd:complexType>  
          </xsd:element>  
      </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Root.Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XDocument" /> da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> che indica se popolare l'infoset dopo la convalida dello schema (PSVI).</param>
        <summary>Convalida che un <see cref="T:System.Xml.Linq.XDocument" /> è conforme a uno schema XSD in un <see cref="T:System.Xml.Schema.XmlSchemaSet" />, popolando facoltativamente la struttura ad albero XML con l'infoset dopo la convalida dello schema (PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo di estensione consente di verificare che il <xref:System.Xml.Linq.XDocument> è conforme al modello di contenuto dello schema in <xref:System.Xml.Schema.XmlSchemaSet>.  
  
 Se `addSchemaInfo` è `true`, questo metodo consente di popolare l'albero XML con i post-schema-validation infoset (PSVI).  
  
 Esistono due passaggi per popolare l'albero XML con il PSVI.  
  
1.  In primo luogo, viene aggiunta un'annotazione a tutti i nodi dell'albero per consentono di chiamare <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> o <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> su un elemento o attributo nell'albero.  
  
2.  In secondo luogo, gli elementi predefiniti e gli attributi definiti nello schema XSD vengono aggiunti all'albero XML. Chiamando uno del <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodi, è possibile determinare se è stato aggiunto un elemento specifico o un attributo da XSD come un elemento o attributo predefinito.  
  
   
  
## Examples  
 Nell'esempio seguente contiene uno schema XSD che definisce il `Child2` elemento con un `Att1` attributo con un valore predefinito. Dopo aver completato la convalida del documento, l'attributo con il valore predefinito viene aggiunto all'albero XML. Si noti che l'attributo predefinito non è aggiunto a `doc2`, che non esegue la convalida rispetto allo schema.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                           {  
                               Console.WriteLine("{0}", e.Message);  
                               errors = true;  
                           }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:simpleContent>  
                                <xsd:extension base='xsd:string'>  
                                    <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                </xsd:extension>  
                            </xsd:simpleContent>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>c1</Child1>  
                                <Child2>c2</Child2>  
                            </Root>  
    Dim doc2 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>content1</Child1>  
                                <Child3>content1</Child3>  
                            </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 Nell'esempio seguente consente di popolare l'albero con PSVI. Dopo la convalida, vengono stampati tutti gli elementi e attributi nell'albero che non sono validi in base al PSVI.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
   string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
           <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
             <xsd:enumeration value='AAA'/>  
             <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
           </xsd:simpleType>  
           <xsd:element name='Root'>  
            <xsd:complexType>  
             <xsd:sequence>  
              <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
               <xsd:complexType>  
                <xsd:sequence>  
                 <xsd:element name='GrandChild1' type='GCType'/>  
                 <xsd:element name='GrandChild2' type='GCType'/>  
                 <xsd:element name='GrandChild3' type='GCType'/>  
                </xsd:sequence>  
               </xsd:complexType>  
              </xsd:element>  
             </xsd:sequence>  
            </xsd:complexType>  
           </xsd:element>  
          </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
        {  
            Console.WriteLine(e.Message);  
            errors = true;  
        }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:simpleType name='GCType'>  
                <xsd:restriction base='xsd:token'>  
                    <xsd:enumeration value='AAA'/>  
                    <xsd:enumeration value='BBB'/>  
                </xsd:restriction>  
            </xsd:simpleType>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' type='GCType'/>  
                                    <xsd:element name='GrandChild2' type='GCType'/>  
                                    <xsd:element name='GrandChild3' type='GCType'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>AAA</GrandChild1>  
                <GrandChild2>ZZZ</GrandChild2>  
                <GrandChild3>ZZZ</GrandChild3>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XElement" /> da convalidare.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> che specifica la sottostruttura da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <summary>Questo metodo convalida che una sottostruttura <see cref="T:System.Xml.Linq.XElement" /> è conforme a un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> e a un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare questo metodo per convalidare che una sottostruttura ad albero (con un <xref:System.Xml.Linq.XElement> la cui radice) conforme a uno schema. In genere possibile utilizzare questo metodo quando è stata modificata una sottostruttura ad albero e si desidera assicurarsi che sia ancora conforme al relativo schema. È possibile convalidare l'intero documento, ma sia necessario meno tempo di elaborazione per convalidare solo una sottostruttura ad albero.  
  
 Se si passa `null` per `validationEventHandler`, quindi questo metodo genera un'eccezione in base agli errori di convalida. Avvisi di convalida non genererà un'eccezione.  
  
 Per convalidare un sottoalbero, si utilizza un'istanza di <xref:System.Xml.Schema.XmlSchemaObject>. È possibile ottenere questa istanza in vari modi. Un modo semplice consiste nel modo seguente:  
  
1.  Verificare che un documento conforme a uno schema.  
  
2.  Aggiungi post-schema-validation infoset (PSVI) chiamando il <xref:System.Xml.Schema.Extensions.Validate%2A> metodo di estensione.  
  
3.  Chiamare il <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodo di estensione per recuperare un oggetto che implementa <xref:System.Xml.Schema.IXmlSchemaInfo>. Dall'oggetto recuperato, è possibile ottenere un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XElement>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XAttribute>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Dopo aver creato un'istanza di un <xref:System.Xml.Schema.XmlSchemaObject>, è possibile usare questo metodo per convalidare un sottoalbero.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:sequence>  
             <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
             <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
            </xsd:sequence>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1",  
            new XElement("GrandChild1", "gc"),  
            new XElement("GrandChild2", "gc")  
        )  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after first edit ...");  
XElement child1 = doc1.Element("Root").Element("Child1");  
child1.Add(new XElement("GrandChild2", "gc"));  
errors = false;  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Child1 element invalid according to the schema  
child1.Add(new XElement("GrandChild3", "gc"));  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after second edit ...");  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
                                    <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>gc</GrandChild1>  
                <GrandChild2>gc</GrandChild2>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after first edit ...")  
    Dim child1 As XElement = doc1.Element("Root").Element("Child1")  
    child1.Add(<GrandChild2>gc</GrandChild2>)  
    errors = False  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Child1 element invalid according to the schema  
    child1.Add(<GrandChild3>gc</GrandChild3>)  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after second edit ...")  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Child1 after first edit ...  
child1 validated  
  
Validating Child1 after second edit ...  
The element 'Child1' has invalid child element 'GrandChild3'.  
child1 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XAttribute" /> da convalidare.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> che specifica la sottostruttura da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> che indica se popolare l'infoset dopo la convalida dello schema (PSVI).</param>
        <summary>Convalida che un <see cref="T:System.Xml.Linq.XAttribute" /> è conforme a un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> specificato e a un <see cref="T:System.Xml.Schema.XmlSchemaSet" /> popolando facoltativamente la struttura ad albero XML con l'infoset dopo la convalida dello schema (PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare questo metodo per convalidare che un <xref:System.Xml.Linq.XAttribute> conforme a uno schema. In genere possibile utilizzare questo metodo quando è stato modificato un attributo e si desidera assicurarsi che sia ancora conforme al relativo schema. È possibile convalidare l'intero documento, ma sia necessario meno tempo di elaborazione per la convalida solo l'attributo.  
  
 Se `addSchemaInfo` è `true`, questo metodo popola l'attributo con la post-schema-validation infoset (PSVI). Dopo avere compilato l'albero XML con il PSVI, è possibile chiamare <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> sull'attributo convalidato. Ciò è utile se si scrive codice che si basa sui dati restituiti da <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A>.  
  
 Se si passa `null` per `validationEventHandler`, quindi questo metodo genera un'eccezione in base agli errori di convalida. Avvisi di convalida non genererà un'eccezione.  
  
 Per convalidare un attributo, si utilizza un'istanza di <xref:System.Xml.Schema.XmlSchemaObject>. È possibile ottenere questa istanza in vari modi. Un modo semplice consiste nel modo seguente:  
  
1.  Verificare che un documento conforme a uno schema.  
  
2.  Aggiungi post-schema-validation infoset (PSVI) chiamando il <xref:System.Xml.Schema.Extensions.Validate%2A> metodo di estensione.  
  
3.  Chiamare il <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodo di estensione per recuperare un oggetto che implementa <xref:System.Xml.Schema.IXmlSchemaInfo>. Dall'oggetto recuperato, è possibile ottenere un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XElement>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XAttribute>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Dopo aver creato un'istanza di un <xref:System.Xml.Schema.XmlSchemaObject>, è possibile usare questo metodo per convalidare un attributo.  
  
   
  
## Examples  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XAttribute("Lang", "C#")  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
    XAttribute lang = doc1.Element("Root").Attribute("Lang");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    // the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC";  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:simpleContent>  
                        <xsd:extension base='xsd:string'>  
                            <xsd:attribute name='Lang' use='required'>  
                                <xsd:simpleType>  
                                    <xsd:restriction base='xsd:token'>  
                                        <xsd:enumeration value='C#'/>  
                                        <xsd:enumeration value='VB'/>  
                                    </xsd:restriction>  
                                </xsd:simpleType>  
                            </xsd:attribute>  
                        </xsd:extension>  
                    </xsd:simpleContent>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Element("Root").Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
Invalid Attribute /Root/@Lang  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Xml.Linq.XElement" /> da convalidare.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> che specifica la sottostruttura da convalidare.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> rispetto al quale convalidare.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> per un evento che si verifica quando il visualizzatore incontra errori di convalida. Se <see langword="null" />, genera un'eccezione in base agli errori di convalida.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> che indica se popolare l'infoset dopo la convalida dello schema (PSVI).</param>
        <summary>Convalida che una sottostruttura <see cref="T:System.Xml.Linq.XElement" /> è conforme a un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> specificato e a un <see cref="T:System.Xml.Schema.XmlSchemaSet" /> popolando facoltativamente la struttura ad albero XML con l'infoset dopo la convalida dello schema (PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare questo metodo per convalidare che una sottostruttura ad albero (con un <xref:System.Xml.Linq.XElement> nella radice del sottoalbero) conforme a uno schema. In genere possibile utilizzare questo metodo quando è stata modificata una sottostruttura ad albero e si desidera assicurarsi che sia ancora conforme al relativo schema. È possibile convalidare l'intero documento, ma sia necessario meno tempo di elaborazione per convalidare solo una sottostruttura ad albero.  
  
 Se `addSchemaInfo` è `true`, questo metodo popola la struttura ad albero XML con i post-schema-validation infoset (PSVI).  
  
 Esistono due passaggi per popolare l'albero XML con il PSVI.  
  
 Prima di tutto un'annotazione viene aggiunto a tutti i nodi dell'albero in modo che è ora possibile chiamare <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> su un elemento o attributo nell'albero.  
  
 In secondo luogo, gli elementi predefiniti e gli attributi definiti nello schema XSD vengono aggiunti all'albero XML. Chiamando uno del <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodi, è possibile determinare se è stato aggiunto un elemento specifico o un attributo da XSD come un elemento o attributo predefinito.  
  
 Se si passa `null` per `validationEventHandler`, quindi questo metodo genera un'eccezione in base agli errori di convalida. Avvisi di convalida non genererà un'eccezione.  
  
 Per convalidare un sottoalbero, si utilizza un'istanza di <xref:System.Xml.Schema.XmlSchemaObject>. È possibile ottenere questa istanza in vari modi. Un modo semplice consiste nel modo seguente:  
  
1.  Verificare che un documento conforme a uno schema.  
  
2.  Aggiungi post-schema-validation infoset (PSVI) chiamando il <xref:System.Xml.Schema.Extensions.Validate%2A> metodo di estensione.  
  
3.  Chiamare il <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> metodo di estensione per recuperare un oggetto che implementa <xref:System.Xml.Schema.IXmlSchemaInfo>. Dall'oggetto recuperato, è possibile ottenere un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XElement>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Se si verifica un' <xref:System.Xml.Schema.XmlSchemaObject> per un <xref:System.Xml.Linq.XAttribute>, il tipo sarà <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Dopo aver creato un'istanza di un <xref:System.Xml.Schema.XmlSchemaObject>, è possibile usare questo metodo per convalidare una sottostruttura ad albero...  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                        <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:simpleContent>  
                                    <xsd:extension base='xsd:string'>  
                                        <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                    </xsd:extension>  
                                </xsd:simpleContent>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>c1</Child1>  
            <Child2>c2</Child2>  
        </Root>  
  
    Dim doc2 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>content1</Child1>  
            <Child3>content1</Child3>  
        </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Eccezione generata per gli errori di convalida XSD (XML Schema Definition Language).</exception>
      </Docs>
    </Member>
  </Members>
</Type>