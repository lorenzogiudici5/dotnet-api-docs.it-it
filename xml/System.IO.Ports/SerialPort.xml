<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="edb46f25768209ef7558903ea96c655667e2e21a" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31781043" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una risorsa di porta seriale.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa classe per controllare una risorsa del file della porta seriale. Questa classe fornisce i/o sincrono e basato su eventi, accesso agli stati di blocco e interruzione e l'accesso alle proprietà del driver seriale. Inoltre, la funzionalità di questa classe può essere incluso in un interno <xref:System.IO.Stream> oggetto, accessibile tramite il <xref:System.IO.Ports.SerialPort.BaseStream%2A> , proprietà e passato alle classi che eseguono il wrapping o utilizzano i flussi.  
  
 Il <xref:System.IO.Ports.SerialPort> classe supporta le codifiche seguenti: <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>e qualsiasi codifica definita in mscorlib. dll in cui la tabella codici è minore di 50000 o è 54936.  È possibile utilizzare codifiche alternative, ma è necessario utilizzare il <xref:System.IO.Ports.SerialPort.ReadByte%2A> o <xref:System.IO.Ports.SerialPort.Write%2A> metodo ed eseguire manualmente la codifica.  
  
 Utilizzare il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per recuperare le porte valide per il computer corrente.  
  
 Se un <xref:System.IO.Ports.SerialPort> oggetto viene bloccato durante un'operazione di lettura, non interrompere il thread. In alternativa, chiudere la base del flusso o eliminare il <xref:System.IO.Ports.SerialPort> oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Entrambi i computer devono essere in esecuzione il programma per ottenere la funzionalità completa di questo esempio.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore utilizza valori predefiniti delle proprietà quando è stata specificata alcuna. Ad esempio, il <xref:System.IO.Ports.SerialPort.DataBits%2A> proprietà valore predefinito è 8, il <xref:System.IO.Ports.SerialPort.Parity%2A> valore predefinito di proprietà di `None` valore di enumerazione, il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà valore predefinito è 1 e il nome predefinito della porta di COM1.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interfaccia per un contenitore.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando l'oggetto <see cref="T:System.ComponentModel.IContainer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore utilizza valori predefiniti delle proprietà quando è stata specificata alcuna. Ad esempio, il <xref:System.IO.Ports.SerialPort.DataBits%2A> proprietà valore predefinito è 8, il <xref:System.IO.Ports.SerialPort.Parity%2A> valore predefinito di proprietà di `None` valore di enumerazione, il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà valore predefinito è 1 e il nome predefinito della porta di COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta e la velocità in baud specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta e la velocità di trasmissione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud e il bit di parità specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud e il bit di parità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valore dei bit di dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud, il bit di parità e i bit di dati specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud, il bit di parità e i bit di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valore dei bit di dati.</param>
        <param name="stopBits">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud, il bit di parità, i bit di dati e il bit di stop specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud, il bit di parità, i bit di dati e il bit di stop.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.IO.Stream" /> sottostante per un oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Un oggetto <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per operazioni dei / o asincrone esplicite o per passare il <xref:System.IO.Ports.SerialPort> l'oggetto in un <xref:System.IO.Stream> classe wrapper, ad esempio <xref:System.IO.StreamWriter>.  
  
 Qualsiasi porta seriale aperta <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà restituisce un oggetto che deriva dalla classe astratta <xref:System.IO.Stream> classe, implementa leggere e scrivere metodi mediante i prototipi di ereditare il <xref:System.IO.Stream> classe: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>, e <xref:System.IO.Stream.WriteByte%2A>. Questi metodi possono essere utili quando si passa una risorsa seriale inclusa in un <xref:System.IO.Stream> classe wrapper.  
  
 A causa dell'inaccessibilità il wrapping dell'handle di file, il <xref:System.IO.Stream.Length%2A> e <xref:System.IO.Stream.Position%2A> non sono supportate le proprietà e <xref:System.IO.Stream.Seek%2A> e <xref:System.IO.Stream.SetLength%2A> metodi non sono supportati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso si trova in un'applicazione .NET Compact Framework ed è stato chiamato uno dei seguenti metodi:  
  
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
 .NET Compact Framework non supporta il modello asincrono con flussi di base.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la velocità in baud della porta seriale.</summary>
        <value>Velocità in baud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Velocità in baud deve essere supportata dal driver seriale dell'utente. Il valore predefinito è 9600 bit al secondo (bps).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.IO.Ports.SerialPort.BaudRate%2A> proprietà `9600`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La velocità in baud è minore o uguale a zero oppure è maggiore della velocità massima in baud consentita per il dispositivo.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo stato del segnale di interruzione.</summary>
        <value>
          <see langword="true" /> se la porta si trova in uno stato di interruzione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato del segnale di interruzione si verifica quando una trasmissione viene sospesa e la riga si trova in stato di interruzione (minimo, alcun bit di stop) fino al rilascio. Per immettere uno stato di interruzione, impostare questa proprietà su `true`. Se la porta è già in stato di interruzione, impostando questa proprietà nuovamente su `true` non generare un'eccezione. Non è possibile scrivere il <xref:System.IO.Ports.SerialPort> oggetto durante <xref:System.IO.Ports.SerialPort.BreakState%2A> è `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte di dati nel buffer di ricezione.</summary>
        <value>Numero di byte di dati nel buffer di ricezione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buffer di ricezione include del driver seriale buffer di ricezione nonché il buffer interno nel <xref:System.IO.Ports.SerialPort> oggetto stesso.  
  
 Perché il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> rappresenta una proprietà sia il <xref:System.IO.Ports.SerialPort> buffer e il buffer creato da Windows, può restituire un valore maggiore di <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà che rappresenta solo il buffer creato da Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta non è aperta.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte di dati nel buffer di invio.</summary>
        <value>Numero di byte di dati nel buffer di invio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buffer di invio include del driver seriale buffer di invio nonché il buffer interno nel <xref:System.IO.Ports.SerialPort> oggetto stesso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato della linea di rilevamento portante (CD, Carrier Detect).</summary>
        <value>
          <see langword="true" /> se la portante viene rilevata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata per monitorare lo stato della riga di rilevamento del vettore per una porta. Nessun gestore telefonico indica in genere che il destinatario ha riagganciato e il vettore è stato eliminato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude la connessione alla porta, imposta la proprietà <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> su <see langword="false" /> ed elimina l'oggetto interno <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo chiude il <xref:System.IO.Ports.SerialPort> dell'oggetto e di ricezione e buffer di trasmissione. Questo metodo chiama il <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> metodo che richiama il metodo protetto <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> metodo con il `disposing` parametro impostato su `true`.  
  
 La procedura consigliata per qualsiasi applicazione è in attesa per un periodo di tempo dopo la chiamata di <xref:System.IO.Ports.SerialPort.Close%2A> metodo prima di chiamare il <xref:System.IO.Ports.SerialPort.Open%2A> (metodo), come la porta potrebbe non essere chiusa immediatamente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato della linea CTS (Clear-to-Send).</summary>
        <value>
          <see langword="true" /> se la linea CTS viene rilevata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La riga di Clear-to-Send (CTS) viene utilizzata nella richiesta di trasmissione e la cancellazione di inviare la sincronizzazione di hardware (RTS/CTS). La linea CTS viene eseguita una query tramite una porta prima dell'invio di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza standard dei bit di dati per byte.</summary>
        <value>Lunghezza dei bit di dati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'intervallo di valori per questa proprietà è compreso tra 5 e 8. Il valore predefinito è 8.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore dei bit di dati è minore di 5 o maggiore di 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che i dati sono stati ricevuti tramite una porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi di dati possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialData> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato anche se un carattere Eof viene ricevuto, indipendentemente dal numero di byte nel buffer di input interno e il valore di <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> proprietà.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordine e potrebbe verificarsi un leggero ritardo tra quando il flusso sottostante segnala l'errore e quando viene eseguito il gestore dell'evento. Un solo gestore eventi è possibile eseguire contemporaneamente.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> non garantito che l'evento generato per ogni byte ricevuto. Utilizzare il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà per determinare la quantità di dati viene lasciato per poter essere letto nel buffer.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato in un thread secondario quando vengono ricevuti dati di <xref:System.IO.Ports.SerialPort> oggetto. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio elementi dell'interfaccia utente, potrebbe generare un'eccezione di threading. Se è necessario modificare gli elementi di principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, richieste di modifica con <xref:System.Windows.Forms.Control.Invoke%2A>, che verrà eseguita l'operazione sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Questo esempio viene aggiunto un <xref:System.IO.Ports.SerialDataReceivedEventHandler> a <xref:System.IO.Ports.SerialPort.DataReceived> per leggere i dati disponibili ricevuti sulla porta COM1. Si noti che per testare questo codice è necessario disporre di hardware, associata alla porta COM1 che verrà inviato alcun dato.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina i dati dal buffer di ricezione del driver seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è equivalente al codice Visual Basic seguente: `MSComm1.InBufferCount = 0`. Cancella il buffer di ricezione, ma non influisce sui buffer di trasmissione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se i byte null vengono ignorati quando vengono trasmessi tra la porta e il buffer di ricezione.</summary>
        <value>
          <see langword="true" /> se i byte null vengono ignorati; in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, questo valore deve essere impostato su `false`, soprattutto per le trasmissioni binarie.  Impostando questa proprietà su `true` può causare risultati imprevisti per byte con codifica UTF32 e UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina i dati dal buffer di trasmissione del driver seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è equivalente al codice Visual Basic seguente: `MSComm1.OutBufferCount = 0`. Cancella il buffer di trasmissione, ma non influisce sui buffer di ricezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.Ports.SerialPort" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.ComponentModel.Component.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo. <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.Ports.SerialPort.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.Ports.SerialPort.Dispose%2A> con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.Ports.SerialPort> fa riferimento. Il metodo richiama il metodo <xref:System.ComponentModel.Component.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 Questo metodo scarica e chiude l'oggetto flusso <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see cref="M:System.ComponentModel.Component.Dispose" />. Per ulteriori informazioni su come implementare <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato del segnale DSR (Data Set Ready).</summary>
        <value>
          <see langword="true" /> se alla porta viene inviato un segnale DSR; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene usata nella sincronizzazione Data Set Ready/Data Terminal Ready DSR/DTR (). Il segnale DSR Data Set Ready () è in genere inviato tramite un modem a una porta per indicare che è pronto per la trasmissione dei dati o la ricezione dei dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che abilita il segnale DTR (Data Terminal Ready) durante una comunicazione seriale.</summary>
        <value>
          <see langword="true" /> per attivare il segnale DTR; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DTR Data Terminal Ready () è abilitato in genere durante la sincronizzazione software XON/XOFF e Request to Send/Clear per inviare la sincronizzazione di hardware (RTS/CTS) e le comunicazioni modem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la codifica dei byte per la conversione del testo prima e dopo la trasmissione.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" />. Il valore predefinito è <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.IO.Ports.SerialPort.Encoding" /> è stata impostata su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.IO.Ports.SerialPort.Encoding" /> è stata impostata su una codifica diversa da <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, una delle codifiche a byte singolo di Windows o una delle codifiche a byte doppio di Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che si è verificato un errore con una porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventi di errore possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialError> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordine e potrebbe verificarsi un leggero ritardo tra quando il flusso sottostante segnala l'errore e che è possibile che il gestore dell'evento viene eseguito. Un solo gestore eventi è possibile eseguire contemporaneamente.  
  
 Se si verifica un errore di parità byte finale di un flusso, verrà aggiunto un ulteriore byte nel buffer di input con un valore di 126.  
  
 Il <xref:System.IO.Ports.SerialPort.ErrorReceived> evento viene generato in un thread secondario quando viene ricevuto un errore dal <xref:System.IO.Ports.SerialPort> oggetto. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio elementi dell'interfaccia utente, potrebbe generare un'eccezione di threading. Se è necessario modificare gli elementi di principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, richieste di modifica con <xref:System.Windows.Forms.Control.Invoke%2A>, che verrà eseguita l'operazione sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice di nomi di porta seriale per il computer corrente.</summary>
        <returns>Matrice di nomi di porta seriale per il computer corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei nomi di porta restituito da <xref:System.IO.Ports.SerialPort.GetPortNames%2A> non è specificato.  
  
 Utilizzare il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per eseguire una query nel computer corrente per un elenco di nomi di porta seriale valida. Ad esempio, è possibile utilizzare questo metodo per determinare se COM1 e COM2 sono porte seriali valide per il computer corrente.  
  
 I nomi di porta vengono ottenuti dal Registro di sistema (ad esempio, chiave HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM.). Se il Registro di sistema contiene dati non aggiornati o errati in caso contrario il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo restituirà dati non corretti.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per visualizzare i nomi di porta seriale per la console.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Impossibile eseguire una query nei nomi delle porte seriali.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il protocollo di sincronizzazione per la trasmissione dei dati tramite la porta seriale usando un valore di <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.Ports.Handshake" />. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene utilizzata la sincronizzazione, il dispositivo è connesso al <xref:System.IO.Ports.SerialPort> oggetto viene richiesto di arrestare l'invio dei dati quando è presente almeno (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) byte nel buffer. Il dispositivo viene richiesto di riprendere l'invio dei dati quando sono presenti 1024 byte o meno nel buffer. Se il dispositivo invia i dati in blocchi più grandi di 1024 byte, questo può causare un overflow del buffer.  
  
 Se il <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> e <xref:System.IO.Ports.SerialPort.CtsHolding%2A> è impostato su `false`, il carattere XOff non verrà inviato. Se <xref:System.IO.Ports.SerialPort.CtsHolding%2A> viene quindi impostato su `true`, più dati da inviare prima che il carattere XOff verrà inviato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore passato non è un valore valido nell'enumerazione <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Indica che non deve verificarsi alcun timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore viene utilizzato con il <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> e <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica lo stato aperto o chiuso dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>
          <see langword="true" /> se la porta seriale è aperta; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.IsOpen%2A> tiene traccia delle proprietà se la porta è aperta per l'utilizzo dal chiamante, non se la porta viene aperta da qualsiasi applicazione nel computer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> passato è una stringa vuota ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore usato per interpretare la fine di una chiamata ai metodi <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> e <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Valore che rappresenta la fine di una riga. Il valore predefinito è un avanzamento riga, <see cref="P:System.Environment.NewLine" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà determina il valore (byte) definisce la fine di una riga per il <xref:System.IO.Ports.SerialPort.ReadLine%2A> e <xref:System.IO.Ports.SerialPort.WriteLine%2A> metodi. Per impostazione predefinita è il valore di fine della riga <xref:System.Environment.NewLine%2A>. È necessario modificare questa su un valore diverso se il dispositivo seriale particolare che si lavora con utilizza un valore diverso per lo stesso scopo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore della proprietà è vuoto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore della proprietà è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apre una nuova connessione su porta seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Può esistere una sola connessione aperta per <xref:System.IO.Ports.SerialPort> oggetto.  
  
 La procedura consigliata per qualsiasi applicazione è in attesa per un periodo di tempo dopo la chiamata di <xref:System.IO.Ports.SerialPort.Close%2A> metodo prima di chiamare il <xref:System.IO.Ports.SerialPort.Open%2A> (metodo), come la porta potrebbe non essere chiusa immediatamente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso alla porta viene negato.  
  
 \- oppure -  
  
 Il processo corrente o un altro processo del sistema già dispone della porta COM specificata aperta da un'istanza di <see cref="T:System.IO.Ports.SerialPort" /> o nel codice non gestito.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più proprietà di questa istanza non sono valide. Ad esempio, la proprietà <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> o <see cref="P:System.IO.Ports.SerialPort.Handshake" /> non ha un valore valido, la proprietà <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> è minore o uguale a zero, la proprietà <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> o <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> è minore di zero e non è <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome della porta non inizia con "COM".  
  
 \- oppure -  
  
 Il tipo di file della porta non è supportato.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata nell'istanza corrente di <see cref="T:System.IO.Ports.SerialPort" /> è già aperta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il protocollo di controllo della parità.</summary>
        <value>Uno dei valori di enumerazione che rappresenta il protocollo di controllo della parità. Il valore predefinito è <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parità è una routine di controllo degli errori in cui il numero di 1 deve essere sempre lo stesso, ovvero pari o dispari, per ogni gruppo di bit che viene trasmesso senza errori. Parità nelle comunicazioni a-modem, è spesso uno dei parametri che devono essere concordati dalle parti di invio e ricezione inserisce prima dell'inizio della trasmissione può richiedere.  
  
 Se si verifica un errore di parità byte finale di un flusso, verrà aggiunto un ulteriore byte nel buffer di input con un valore di 126.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.Parity" /> passato non è un valore valido dell'enumerazione <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il byte che sostituisce i byte non validi in un flusso di dati quando si verifica un errore di parità.</summary>
        <value>Byte che sostituisce i byte non validi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore è impostato per il carattere null, viene disabilitata la sostituzione della parità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che si è verificato un evento segnale non di dati sulla porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifica del pin seriale eventi possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialPinChange> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati. Come parte dell'evento, il nuovo valore del pin è impostato.  
  
 Il <xref:System.IO.Ports.SerialPort.PinChanged> evento viene generato quando un <xref:System.IO.Ports.SerialPort> oggetto immette il <xref:System.IO.Ports.SerialPort.BreakState%2A>, ma non quando la porta chiusa la <xref:System.IO.Ports.SerialPort.BreakState%2A>. Questo comportamento non si applica ad altri valori di <xref:System.IO.Ports.SerialPinChange> enumerazione.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordine e potrebbe verificarsi un leggero ritardo tra quando il flusso sottostante segnala l'errore e quando viene eseguito il gestore dell'evento. Un solo gestore eventi è possibile eseguire contemporaneamente.  
  
 Il <xref:System.IO.Ports.SerialPort.PinChanged> evento viene generato in un thread secondario. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio elementi dell'interfaccia utente, potrebbe generare un'eccezione di threading. Se è necessario modificare gli elementi di principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, richieste di modifica con <xref:System.Windows.Forms.Control.Invoke%2A>, che verrà eseguita l'operazione sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la porta per le comunicazioni, incluse, ma non solo, tutte le porte COM disponibili.</summary>
        <value>Porta di comunicazione. L'impostazione predefinita è COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un elenco di nomi di porta validi può essere ottenuto utilizzando la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su un valore con lunghezza zero.  
  
 oppure  
  
 La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su un valore che inizia con "\\\\".  
  
 oppure  
  
 Il nome della porta non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata è aperta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte in cui scrivere l'input.</param>
        <param name="offset">Offset in <c>buffer</c> in corrispondenza del quale scrivere i byte.</param>
        <param name="count">Numero massimo di byte da leggere. Se <c>count</c> è maggiore del numero di byte nel buffer di input, vengono letti meno byte.</param>
        <summary>Legge un numero di byte dal buffer di input <see cref="T:System.IO.Ports.SerialPort" /> e li scrive in una matrice di byte con l'offset specificato.</summary>
        <returns>Numero di byte letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
 Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti byte da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
 Il <xref:System.IO.Ports.SerialPort.Read%2A> metodo non blocca altre operazioni quando il numero di byte letti è uguale a `count` ma sono disponibili ancora letti i byte sulla porta seriale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il buffer passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Non sono disponibili byte per la lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri in cui scrivere l'input.</param>
        <param name="offset">Offset in <c>buffer</c> in corrispondenza del quale scrivere i caratteri.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se <c>count</c> è maggiore del numero di caratteri nel buffer di input, vengono letti meno caratteri.</param>
        <summary>Legge un numero di caratteri dal buffer di input <see cref="T:System.IO.Ports.SerialPort" /> e li scrive in una matrice di caratteri in corrispondenza di un offset specificato.</summary>
        <returns>Numero di caratteri letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per la lettura di caratteri dalla porta seriale.  
  
 Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
 Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile che una discordanza il numero di caratteri disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti caratteri da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
 Il <xref:System.IO.Ports.SerialPort.Read%2A> metodo non blocca altre operazioni quando il numero di byte letti è uguale a `count` ma sono disponibili ancora letti i byte sulla porta seriale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del buffer.  
  
 \- oppure -  
  
 <paramref name="count" /> è 1 ed è presente un carattere surrogato nel buffer.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">Non sono disponibili caratteri per la lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione del buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Dimensioni del buffer, in byte. Il valore predefinito è 4096; il valore massimo è quello di intero positivo o 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà ignora qualsiasi valore inferiore a 4096.  
  
 Perché il <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà rappresenta solo il buffer creato da Windows, può restituire un valore minore di <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà che rappresenta entrambi il <xref:System.IO.Ports.SerialPort> buffer e il buffer creato da Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> impostato è minore o uguale a zero.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> è stata impostata mentre il flusso era aperto.</exception>
        <exception cref="T:System.IO.IOException">La proprietà <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> è stata impostata su un intero dispari.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge in modo sincrono un byte dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Byte, cast su un oggetto <see cref="T:System.Int32" /> o -1 se è stata letta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge un byte.  
  
 Prestare attenzione quando si utilizza <xref:System.IO.Ports.SerialPort.ReadByte%2A> e <xref:System.IO.Ports.SerialPort.ReadChar%2A> insieme. Il passaggio tra la lettura dei byte e lettura di caratteri può provocare la lettura dei dati aggiuntivi e/o altri comportamenti imprevisti. Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti byte da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
 \- oppure -  
  
 Non sono stati letti byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge in modo sincrono un carattere dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Carattere letto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge un carattere completo in base alla codifica.  
  
 Prestare attenzione quando si utilizza <xref:System.IO.Ports.SerialPort.ReadByte%2A> e <xref:System.IO.Ports.SerialPort.ReadChar%2A> insieme. Il passaggio tra la lettura dei byte e lettura di caratteri può provocare la lettura dei dati aggiuntivi e/o altri comportamenti imprevisti. Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti byte da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
 \- oppure -  
  
 Nessun carattere disponibile nel periodo di timeout specificato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i byte disponibili immediatamente, in base alla codifica, sia nel flusso che nel buffer di input dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Contenuto del flusso e del buffer di input dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il contenuto del flusso e il buffer interno del <xref:System.IO.Ports.SerialPort> oggetto sotto forma di stringa. Questo metodo non utilizza un timeout. Si noti che questo metodo può lasciare finali byte di apertura nel buffer interno, che rende il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> valore maggiore di zero.  
  
 Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati, ma è contenuto l'oggetto di flusso di <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> proprietà non. Pertanto, il <xref:System.IO.Ports.SerialPort> oggetto e l'oggetto flusso potrebbero essere diversi per il numero di byte che sono disponibili per la lettura. Quando byte memorizzati nel buffer il <xref:System.IO.Ports.SerialPort> oggetto, il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà include i byte nel relativo valore; tuttavia, questi potrebbero non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge fino al valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" /> nel buffer di input.</summary>
        <returns>Contenuto del buffer di input fino alla prima occorrenza di un valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che sebbene questo metodo non restituisce il <xref:System.IO.Ports.SerialPort.NewLine%2A> valore, il <xref:System.IO.Ports.SerialPort.NewLine%2A> il valore viene rimosso dal buffer di input.  
  
 Per impostazione predefinita, il <xref:System.IO.Ports.SerialPort.ReadLine%2A> metodo verrà bloccato fino alla ricezione di una riga. Se questo comportamento è indesiderato, impostare il <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> su qualsiasi valore diverso da zero per imporre il <xref:System.IO.Ports.SerialPort.ReadLine%2A> metodo consente di generare un <xref:System.TimeoutException> se una riga non è disponibile sulla porta.  
  
 Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti byte da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
 \- oppure -  
  
 Non sono stati letti byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di millisecondi prima del timeout quando un'operazione di lettura non viene completata.</summary>
        <value>Numero di millisecondi prima del timeout quando un'operazione di lettura non viene completata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di timeout di lettura è stato originariamente impostato su 500 millisecondi nell'API di comunicazione Win32. Questa proprietà consente di impostare questo valore. Il timeout può essere impostato su qualsiasi valore maggiore di zero o impostato su <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, nel qual caso si verifica alcun timeout. Il valore predefinito è <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
> [!NOTE]
>  Gli utenti dell'interfaccia non gestita `COMMTIMEOUTS` struttura prevedibile impostare il valore di timeout su zero per sopprimere i timeout. Per eliminare i timeout con il <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> proprietà, tuttavia, è necessario specificare <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Questa proprietà non influisce il <xref:System.IO.Stream.BeginRead%2A> il flusso restituito dal metodo di <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di timeout di lettura è minore di zero e diverso da <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valore che indica dove termina l'operazione di lettura.</param>
        <summary>Legge una stringa fino al parametro <paramref name="value" /> specificato nel buffer di input.</summary>
        <returns>Contenuto del buffer di input fino al parametro <paramref name="value" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge una stringa fino specificato `value`. Quando la stringa restituita non include il `value`, `value` viene rimosso dal buffer di input.  
  
 Se è necessario passare dalla lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non è possibile una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti byte da leggere, ma potrebbe non essere accessibili per il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza del parametro <paramref name="value" /> è 0.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di byte nel buffer di input interno prima che si verifichi un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />.</summary>
        <value>Numero di byte nel buffer di input interno prima che venga generato un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />. Il valore predefinito è 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato anche se un <xref:System.IO.Ports.SerialData.Eof> carattere viene ricevuto, indipendentemente dal numero di byte nel buffer di input interno e il valore di <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> è minore o uguale a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il segnale RTS (Request to Send) è abilitato durante la comunicazione seriale.</summary>
        <value>
          <see langword="true" /> per attivare RTS; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La richiesta di trasmettere segnale RTS () in genere viene utilizzata nella richiesta di trasmissione e la cancellazione di inviare la sincronizzazione di hardware (RTS/CTS).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il valore della proprietà <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> viene impostato o recuperato mentre la proprietà <see cref="P:System.IO.Ports.SerialPort.Handshake" /> è impostata sul valore <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> o <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero standard dei bit di stop per byte.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito per la proprietà <xref:System.IO.Ports.SerialPort.StopBits%2A> è <xref:System.IO.Ports.StopBits.One>.  
  
 Il <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> valore non è supportato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà `One`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <see cref="P:System.IO.Ports.SerialPort.StopBits" /> è <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive i dati nel buffer di output della porta seriale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="str">To be added.</param>
        <summary>Scrive sulla porta seriale la stringa specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si desidera scrivere una stringa come output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostato su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> mentre è in attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita, <xref:System.IO.Ports.SerialPort> utilizza <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 come (char) 63 o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="text" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte che contiene i dati da scrivere sulla porta.</param>
        <param name="offset">Offset dei byte in base zero nel parametro <c>buffer</c> da cui iniziare a copiare i byte nella porta.</param>
        <param name="count">Numero di byte da scrivere.</param>
        <summary>Scrive sulla porta un numero specificato di byte sulla porta seriale usando i dati di un buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si desidera scrivere in un buffer di byte per creare l'output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostato su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> mentre è in attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita, <xref:System.IO.Ports.SerialPort> utilizza <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 come (char) 63 o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri che contiene i dati da scrivere sulla porta.</param>
        <param name="offset">Offset dei byte in base zero nel parametro <c>buffer</c> da cui iniziare a copiare i byte nella porta.</param>
        <param name="count">Numero di caratteri da scrivere.</param>
        <summary>Scrive sulla porta seriale un numero specificato di caratteri usando i dati di un buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si desidera scrivere un buffer di caratteri per creare l'output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostato su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> mentre è in attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita, <xref:System.IO.Ports.SerialPort> utilizza <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 come (char) 63 o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> a <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione del buffer di output della porta seriale.</summary>
        <value>Dimensione del buffer di output. Il valore predefinito è 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> proprietà ignora qualsiasi valore inferiore a 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è minore o uguale a zero.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è stata impostata mentre il flusso era aperto.</exception>
        <exception cref="T:System.IO.IOException">La proprietà <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è stata impostata su un intero dispari.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="str">To be added.</param>
        <summary>Scrive la stringa specificata e il valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" /> nel buffer di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se sono presenti troppi byte nel buffer di input e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostato su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> mentre è in attesa per il dispositivo sia pronto per accettare più dati.  
  
 L'output scritto include la <xref:System.IO.Ports.SerialPort.NewLine%2A> stringa.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="text" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">Il metodo <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> non è stato in grado di scrivere nel flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di millisecondi prima del timeout quando un'operazione di scrittura non viene completata.</summary>
        <value>Numero di millisecondi prima dello scadere di un timeout. Il valore predefinito è <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di timeout di scrittura è stato originariamente impostato su 500 millisecondi nell'API di comunicazione Win32. Questa proprietà consente di impostare questo valore. Il timeout può essere impostato su qualsiasi valore maggiore di zero o impostato su <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, nel qual caso si verifica alcun timeout. Il valore predefinito è <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
> [!NOTE]
>  Gli utenti dell'interfaccia non gestita `COMMTIMEOUTS` struttura prevedibile impostare il valore di timeout su zero per sopprimere i timeout. Per eliminare i timeout con il <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> proprietà, tuttavia, è necessario specificare <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Questa proprietà non influisce il <xref:System.IO.Stream.BeginWrite%2A> il flusso restituito dal metodo di <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe consente l'utilizzo di due utenti di chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice fa parte di un esempio di codice fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
 \- oppure -  
  
 Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> è minore di zero e diverso da <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>