<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0d59d268cffda70d3f8a591609547cdc12b4bcff" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49134761" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una risorsa di porta seriale.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa classe per controllare una risorsa di file della porta seriale. Questa classe fornisce i/o sincrono e basato su eventi, accesso agli stati di blocco e interruzione e l'accesso alle proprietà del driver seriale. Inoltre, la funzionalità di questa classe può essere incluso in interna <xref:System.IO.Stream> oggetto, accessibile tramite il <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà e passati alle classi di cui eseguire il wrapping o usano i flussi.  
  
 Il <xref:System.IO.Ports.SerialPort> classe supporta le codifiche seguenti: <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>e qualsiasi codifica definita in mscorlib. dll in cui la tabella codici è minore di 50000 o la tabella codici è 54936.  È possibile utilizzare codifiche alternative, ma è necessario usare il <xref:System.IO.Ports.SerialPort.ReadByte%2A> o <xref:System.IO.Ports.SerialPort.Write%2A> metodo ed eseguire la codifica manualmente.  
  
 Si utilizza il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per recuperare le porte valide per il computer corrente.  
  
 Se un <xref:System.IO.Ports.SerialPort> oggetto viene bloccato durante un'operazione di lettura, non interrompere il thread. In alternativa, chiudere la base streaming o eliminare il <xref:System.IO.Ports.SerialPort> oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Entrambi i computer devono essere in esecuzione il programma per ottenere la funzionalità completa di questo esempio.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore utilizza valori predefiniti delle proprietà quando è stato specificato nessuno. Ad esempio, il <xref:System.IO.Ports.SerialPort.DataBits%2A> proprietà il valore predefinito è 8, il <xref:System.IO.Ports.SerialPort.Parity%2A> proprietà valore predefinito è la `None` il valore di enumerazione, il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà il valore predefinito è 1 e il nome predefinito della porta di COM1.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interfaccia per un contenitore.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando l'oggetto <see cref="T:System.ComponentModel.IContainer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore utilizza valori predefiniti delle proprietà quando è stato specificato nessuno. Ad esempio, il <xref:System.IO.Ports.SerialPort.DataBits%2A> proprietà il valore predefinito è 8, il <xref:System.IO.Ports.SerialPort.Parity%2A> proprietà valore predefinito è la `None` il valore di enumerazione, il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà il valore predefinito è 1 e il nome predefinito della porta di COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta e la velocità in baud specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta e la velocità in baud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud e il bit di parità specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud e il bit di parità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valore dei bit di dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud, il bit di parità e i bit di dati specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud, il bit di parità e i bit di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Porta da usare, ad esempio COM1.</param>
        <param name="baudRate">Velocità in baud.</param>
        <param name="parity">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valore dei bit di dati.</param>
        <param name="stopBits">Uno dei valori di <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Ports.SerialPort" /> usando il nome della porta, la velocità in baud, il bit di parità, i bit di dati e il bit di stop specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per creare una nuova istanza di <xref:System.IO.Ports.SerialPort> classe quando si desidera specificare il nome della porta, la velocità in baud, il bit di parità, i bit di dati e il bit di stop.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossibile trovare o aprire la porta specificata.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.IO.Stream" /> sottostante per un oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Un oggetto <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per le operazioni dei / o asincrone esplicitare o passare il <xref:System.IO.Ports.SerialPort> dell'oggetto a un <xref:System.IO.Stream> classe wrapper, ad esempio <xref:System.IO.StreamWriter>.  
  
 Qualsiasi porta seriale aperta <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà restituisce un oggetto che deriva dalla classe astratta <xref:System.IO.Stream> classi, implementa leggere e scrivere i metodi utilizzando i prototipi ereditati dalle <xref:System.IO.Stream> classe: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>, e <xref:System.IO.Stream.WriteByte%2A>. Questi metodi possono essere utili quando si passa una risorsa seriale sottoposta a wrapping da un <xref:System.IO.Stream> classe wrapper.  
  
 A causa della non accessibilità il wrapping dell'handle di file, il <xref:System.IO.Stream.Length%2A> e <xref:System.IO.Stream.Position%2A> non sono supportate le proprietà e il <xref:System.IO.Stream.Seek%2A> e <xref:System.IO.Stream.SetLength%2A> metodi non sono supportati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso si trova in un'applicazione .NET Compact Framework ed è stato chiamato uno dei seguenti metodi: 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
.NET Compact Framework non supporta il modello asincrono con flussi di base.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la velocità in baud della porta seriale.</summary>
        <value>Velocità in baud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La velocità in baud deve essere supportata dal driver seriale dell'utente. Il valore predefinito è 9600 bit al secondo (bps).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.IO.Ports.SerialPort.BaudRate%2A> proprietà `9600`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La velocità in baud è minore o uguale a zero oppure è maggiore della velocità massima in baud consentita per il dispositivo.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo stato del segnale di interruzione.</summary>
        <value>
          <see langword="true" /> se la porta si trova in uno stato di interruzione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato del segnale di interruzione si verifica quando viene sospesa una trasmissione e la riga viene inserita in uno stato di interruzione (minimo, nessun bit di stop) fino al rilascio. Per entrare in uno stato di interruzione, impostare questa proprietà su `true`. Se la porta è già in stato di interruzione, impostando questa proprietà di nuovo `true` non genera un'eccezione. Non è possibile scrivere per il <xref:System.IO.Ports.SerialPort> oggetto durante <xref:System.IO.Ports.SerialPort.BreakState%2A> è `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte di dati nel buffer di ricezione.</summary>
        <value>Numero di byte di dati nel buffer di ricezione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buffer di ricezione include del driver seriale buffer di ricezione nonché il buffer interno nel <xref:System.IO.Ports.SerialPort> oggetto stesso.  
  
 Perché il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà rappresenta sia il <xref:System.IO.Ports.SerialPort> buffer e il buffer creato Windows, può restituire un valore superiore al valore di <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà, che rappresenta solo il buffer creato Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta non è aperta.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte di dati nel buffer di invio.</summary>
        <value>Numero di byte di dati nel buffer di invio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buffer di invio include del driver seriale buffer di invio nonché il buffer interno nel <xref:System.IO.Ports.SerialPort> oggetto stesso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato della linea di rilevamento portante (CD, Carrier Detect).</summary>
        <value>
          <see langword="true" /> se la portante viene rilevata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata per monitorare lo stato della riga di rilevamento del vettore per una porta. Nessun gestore telefonico in genere indica che il destinatario ha riagganciato e il vettore è stato eliminato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude la connessione alla porta, imposta la proprietà <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> su <see langword="false" /> ed elimina l'oggetto interno <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo chiude il <xref:System.IO.Ports.SerialPort> dell'oggetto e Cancella di ricezione e trasmissione buffer. Questo metodo chiama il <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> metodo, che richiama il metodo protetto <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> metodo con il `disposing` parametro impostato su `true`.  
  
 Le procedure consigliate per qualsiasi applicazione sono in attesa per un determinato intervallo di tempo dopo la chiamata di <xref:System.IO.Ports.SerialPort.Close%2A> metodo prima di chiamare il <xref:System.IO.Ports.SerialPort.Open%2A> metodo, come la porta potrebbe non essere chiusa immediatamente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato della linea CTS (Clear-to-Send).</summary>
        <value>
          <see langword="true" /> se la linea CTS viene rilevata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La riga di Clear-to-Send (CTS) viene utilizzata nella richiesta di trasmissione o deselezionare per inviare la sincronizzazione di hardware RTS/CTS (). La linea CTS viene eseguita una query tramite una porta prima che i dati vengono inviati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza standard dei bit di dati per byte.</summary>
        <value>Lunghezza dei bit di dati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'intervallo di valori per questa proprietà è compreso tra 5 e 8. Il valore predefinito è 8.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore dei bit di dati è minore di 5 o maggiore di 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che i dati sono stati ricevuti tramite una porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi di dati possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialData> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato anche se viene ricevuto un carattere Eof, indipendentemente dal numero di byte nel buffer di input interno e il valore della <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> proprietà.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordinati e potrebbe esserci un leggero ritardo tra quando il flusso sottostante segnala l'errore e quando viene eseguito il gestore dell'evento. Un solo gestore eventi può eseguire contemporaneamente.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento non è garantito che venga generato per ogni byte ricevuti. Usare il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà per determinare la quantità di dati viene lasciata per poter essere letto nel buffer.  
  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato in un thread secondario quando vengono ricevuti dati dal <xref:System.IO.Ports.SerialPort> oggetto. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio gli elementi dell'interfaccia utente, è stato possibile generare un'eccezione di threading. Se è necessario modificare alcuni elementi nel principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, le richieste di modifica post usando <xref:System.Windows.Forms.Control.Invoke%2A>, che si occuperà sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Questo esempio viene aggiunto un <xref:System.IO.Ports.SerialDataReceivedEventHandler> a <xref:System.IO.Ports.SerialPort.DataReceived> per leggere tutti i dati disponibili ricevuti sulla porta COM1. Si noti che per testare questo codice è necessario disporre di hardware collegato a COM1 che verrà inviato alcun dato.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina i dati dal buffer di ricezione del driver seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è equivalente al codice Visual Basic seguente: `MSComm1.InBufferCount = 0`. Cancella il buffer di ricezione, ma non influisce sul buffer di trasmissione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se i byte null vengono ignorati quando vengono trasmessi tra la porta e il buffer di ricezione.</summary>
        <value>
          <see langword="true" /> se i byte null vengono ignorati; in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore deve essere impostato in genere `false`, soprattutto per le trasmissioni binarie.  Impostando questa proprietà su `true` può causare risultati imprevisti per UTF32 - e byte con codifica UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina i dati dal buffer di trasmissione del driver seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è equivalente al codice Visual Basic seguente: `MSComm1.OutBufferCount = 0`. Cancella il buffer di trasmissione, ma non influisce sul buffer di ricezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.Ports.SerialPort" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico <xref:System.ComponentModel.Component.Dispose%2A> metodo e <xref:System.Object.Finalize%2A> (metodo). <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.Ports.SerialPort.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.Ports.SerialPort.Dispose%2A> con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.Ports.SerialPort> fa riferimento. Il metodo richiama il metodo <xref:System.ComponentModel.Component.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 Questo metodo scarica e chiude l'oggetto flusso <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <block subset="none" type="overrides">
          <para>Il metodo 
            <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see cref="M:System.ComponentModel.Component.Dispose" />. Per altre informazioni su come implementare <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Per altre informazioni sulle <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato del segnale DSR (Data Set Ready).</summary>
        <value>
          <see langword="true" /> se alla porta viene inviato un segnale DSR; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene utilizzata nell'handshake di Set di dati pronti/Data Terminal Ready (DSR/DTR). Il Set di dati pronti segnale DSR () viene in genere inviato tramite un modem a una porta per indicare che è pronto per la trasmissione dei dati o la ricezione dei dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è chiuso. Questa situazione può essere dovuta al fatto che il metodo <see cref="M:System.IO.Ports.SerialPort.Open" /> non è stato chiamato o che è stato chiamato il metodo <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che abilita il segnale DTR (Data Terminal Ready) durante una comunicazione seriale.</summary>
        <value>
          <see langword="true" /> per attivare il segnale DTR; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DTR Data Terminal Ready () è abilitato in genere durante la sincronizzazione di software XON/XOFF e Request to Send/Clear per inviare la sincronizzazione di hardware RTS/CTS () e le comunicazioni di modem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la codifica dei byte per la conversione del testo prima e dopo la trasmissione.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" />. Il valore predefinito è <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.IO.Ports.SerialPort.Encoding" /> è stata impostata su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.IO.Ports.SerialPort.Encoding" /> è stata impostata su una codifica diversa da <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, una delle codifiche a byte singolo di Windows o una delle codifiche a byte doppio di Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che si è verificato un errore con una porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi di errore possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialError> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordinati e potrebbe esserci un leggero ritardo tra quando il flusso sottostante segnala l'errore ed è possibile che il gestore eventi viene eseguito. Un solo gestore eventi può eseguire contemporaneamente.  
  
 Se si verifica un errore di parità in byte finale di un flusso, un byte extra verrà aggiunto al buffer di input con un valore di 126.  
  
 Il <xref:System.IO.Ports.SerialPort.ErrorReceived> evento viene generato in un thread secondario quando viene ricevuto da un errore di <xref:System.IO.Ports.SerialPort> oggetto. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio gli elementi dell'interfaccia utente, è stato possibile generare un'eccezione di threading. Se è necessario modificare alcuni elementi nel principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, le richieste di modifica post usando <xref:System.Windows.Forms.Control.Invoke%2A>, che si occuperà sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice di nomi di porta seriale per il computer corrente.</summary>
        <returns>Matrice di nomi di porta seriale per il computer corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei nomi delle porte restituiti da <xref:System.IO.Ports.SerialPort.GetPortNames%2A> non è specificato.  
  
 Usare il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per eseguire una query nel computer corrente per un elenco di nomi delle porte seriali valido. Ad esempio, è possibile usare questo metodo per determinare se COM1 e COM2 porte seriali valide per il computer corrente.  
  
 I nomi delle porte vengono ottenuti dal Registro di sistema (ad esempio, chiave HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM.). Se il Registro di sistema contiene dati non aggiornati o errati in caso contrario il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo restituirà dati non corretti.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metodo per visualizzare i nomi delle porte seriali nella console.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Impossibile eseguire una query nei nomi delle porte seriali.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il protocollo di sincronizzazione per la trasmissione dei dati tramite la porta seriale usando un valore di <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.Ports.Handshake" />. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene utilizzata la sincronizzazione, il dispositivo è connesso al <xref:System.IO.Ports.SerialPort> oggetto viene richiesto di arrestare l'invio di dati quando è presente almeno (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) byte nel buffer. Il dispositivo è indicato per iniziare a inviare nuovamente i dati quando sono presenti un massimo di 1024 byte nel buffer. Se il dispositivo invia i dati in blocchi di dimensioni superiori a 1024 byte, ciò potrebbe causare un overflow del buffer.  
  
 Se il <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> e <xref:System.IO.Ports.SerialPort.CtsHolding%2A> è impostata su `false`, non verrà inviato il carattere XOff. Se <xref:System.IO.Ports.SerialPort.CtsHolding%2A> viene quindi impostato su `true`, più dati da inviare prima che il carattere XOff verrà inviato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore passato non è un valore valido nell'enumerazione <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Indica che non deve verificarsi alcun timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore viene usato con il <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> e <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica lo stato aperto o chiuso dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>
          <see langword="true" /> se la porta seriale è aperta; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.IsOpen%2A> tiene traccia delle proprietà se la porta sia aperta per l'utilizzo dal chiamante, non controlla se la porta sia aperta per qualsiasi applicazione nel computer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> passato è una stringa vuota ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore usato per interpretare la fine di una chiamata ai metodi <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> e <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Valore che rappresenta la fine di una riga. Il valore predefinito è un avanzamento riga, <see cref="P:System.Environment.NewLine" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà determina quale valore (byte) definisce la fine di una riga per il <xref:System.IO.Ports.SerialPort.ReadLine%2A> e <xref:System.IO.Ports.SerialPort.WriteLine%2A> metodi. Per impostazione predefinita è il valore end-of-line <xref:System.Environment.NewLine%2A>. È necessario modificare questa su un valore diverso se il dispositivo seriale particolare che si lavora con Usa un valore diverso per lo stesso scopo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore della proprietà è vuoto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore della proprietà è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apre una nuova connessione su porta seriale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Può esistere una sola connessione aperta per <xref:System.IO.Ports.SerialPort> oggetto.  
  
 Le procedure consigliate per qualsiasi applicazione sono in attesa per un determinato intervallo di tempo dopo la chiamata di <xref:System.IO.Ports.SerialPort.Close%2A> metodo prima di chiamare il <xref:System.IO.Ports.SerialPort.Open%2A> metodo, come la porta potrebbe non essere chiusa immediatamente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso alla porta viene negato.  
  
\- oppure - 
Il processo corrente o un altro processo del sistema già dispone della porta COM specificata aperta da un'istanza di <see cref="T:System.IO.Ports.SerialPort" /> o nel codice non gestito.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più proprietà di questa istanza non sono valide. Ad esempio, la proprietà <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> o <see cref="P:System.IO.Ports.SerialPort.Handshake" /> non ha un valore valido, la proprietà <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> è minore o uguale a zero, la proprietà <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> o <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> è minore di zero e non è <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome della porta non inizia con "COM".  
  
\- oppure - 
Il tipo di file della porta non è supportato.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata nell'istanza corrente di <see cref="T:System.IO.Ports.SerialPort" /> è già aperta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il protocollo di controllo della parità.</summary>
        <value>Uno dei valori di enumerazione che rappresenta il protocollo di controllo della parità. Il valore predefinito è <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parità è una procedura di controllo degli errori in cui il numero di 1 deve essere sempre lo stesso, ovvero pari o dispari, ovvero per ogni gruppo di bit che viene trasmesso senza errori. Parità nelle comunicazioni a-modem, è spesso uno dei parametri che devono essere concordati parti inviando e ricevendo posizionare le parti possa rendere la trasmissione.  
  
 Se si verifica un errore di parità in byte finale di un flusso, un byte extra verrà aggiunto al buffer di input con un valore di 126.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.Parity" /> passato non è un valore valido dell'enumerazione <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il byte che sostituisce i byte non validi in un flusso di dati quando si verifica un errore di parità.</summary>
        <value>Byte che sostituisce i byte non validi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore è impostato sul carattere null, viene disabilitata la sostituzione della parità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che si è verificato un evento segnale non di dati sulla porta rappresentata dall'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifica del pin seriale eventi possono essere causati da uno qualsiasi degli elementi di <xref:System.IO.Ports.SerialPinChange> enumerazione. Poiché il sistema operativo determina se generare l'evento o No, non tutti gli errori di parità possono essere segnalati. Come parte dell'evento, il nuovo valore del pin è impostato.  
  
 Il <xref:System.IO.Ports.SerialPort.PinChanged> evento viene generato quando un <xref:System.IO.Ports.SerialPort> entra in oggetto il <xref:System.IO.Ports.SerialPort.BreakState%2A>, ma non quando la porta viene chiuso il <xref:System.IO.Ports.SerialPort.BreakState%2A>. Questo comportamento non si applica ad altri valori di <xref:System.IO.Ports.SerialPinChange> enumerazione.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, e <xref:System.IO.Ports.SerialPort.ErrorReceived> gli eventi possono essere chiamati ordinati e potrebbe esserci un leggero ritardo tra quando il flusso sottostante segnala l'errore e quando viene eseguito il gestore dell'evento. Un solo gestore eventi può eseguire contemporaneamente.  
  
 Il <xref:System.IO.Ports.SerialPort.PinChanged> evento viene generato in un thread secondario. Poiché questo evento viene generato in un thread secondario e non il thread principale, il tentativo di modificare alcuni elementi nel thread principale, ad esempio gli elementi dell'interfaccia utente, è stato possibile generare un'eccezione di threading. Se è necessario modificare alcuni elementi nel principale <xref:System.Windows.Forms.Form> o <xref:System.Windows.Forms.Control>, le richieste di modifica post usando <xref:System.Windows.Forms.Control.Invoke%2A>, che si occuperà sul thread appropriato.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la porta per le comunicazioni, incluse, ma non solo, tutte le porte COM disponibili.</summary>
        <value>Porta di comunicazione. L'impostazione predefinita è COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile ottenere un elenco di nomi di porta valido usando il <xref:System.IO.Ports.SerialPort.GetPortNames%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su un valore con lunghezza zero.  
  
oppure 
La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su un valore che inizia con "\\\\".  
  
oppure 
Il nome della porta non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.IO.Ports.SerialPort.PortName" /> è stata impostata su <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata è aperta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte in cui scrivere l'input.</param>
        <param name="offset">Offset in <c>buffer</c> in corrispondenza del quale scrivere i byte.</param>
        <param name="count">Numero massimo di byte da leggere. Se <c>count</c> è maggiore del numero di byte nel buffer di input, vengono letti meno byte.</param>
        <summary>Legge un numero di byte dal buffer di input <see cref="T:System.IO.Ports.SerialPort" /> e li scrive in una matrice di byte con l'offset specificato.</summary>
        <returns>Numero di byte letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
 Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che non ci sono byte da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
 Il <xref:System.IO.Ports.SerialPort.Read%2A> metodo non blocca altre operazioni quando il numero di byte letti è uguale a `count` ma sono disponibili ancora letti byte sulla porta seriale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il buffer passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Non sono disponibili byte per la lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri in cui scrivere l'input.</param>
        <param name="offset">Offset in <c>buffer</c> in corrispondenza del quale scrivere i caratteri.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se <c>count</c> è maggiore del numero di caratteri nel buffer di input, vengono letti meno caratteri.</param>
        <summary>Legge un numero di caratteri dal buffer di input <see cref="T:System.IO.Ports.SerialPort" /> e li scrive in una matrice di caratteri in corrispondenza di un offset specificato.</summary>
        <returns>Numero di caratteri letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per la lettura di caratteri dalla porta seriale.  
  
 Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
 Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di caratteri disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che sono presenti caratteri da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
 Il <xref:System.IO.Ports.SerialPort.Read%2A> metodo non blocca altre operazioni quando il numero di byte letti è uguale a `count` ma sono disponibili ancora letti byte sulla porta seriale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del buffer.  
  
\- oppure - 
 <paramref name="count" /> è 1 ed è presente un carattere surrogato nel buffer.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">Non sono disponibili caratteri per la lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione del buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Dimensioni del buffer, in byte. Il valore predefinito è 4096; il valore massimo è quello di intero positivo o 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà ignora qualsiasi valore inferiore a 4096.  
  
 Poiché il <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> proprietà rappresenta solo il buffer creato Windows, può restituire un valore minore rispetto al <xref:System.IO.Ports.SerialPort.BytesToRead%2A> che rappresenta entrambi il <xref:System.IO.Ports.SerialPort> buffer e il buffer creato Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> impostato è minore o uguale a zero.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> è stata impostata mentre il flusso era aperto.</exception>
        <exception cref="T:System.IO.IOException">La proprietà <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> è stata impostata su un intero dispari.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge in modo sincrono un byte dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Byte, cast su un oggetto <see cref="T:System.Int32" /> o -1 se è stata letta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge un byte.  
  
 Prestare attenzione quando si usa <xref:System.IO.Ports.SerialPort.ReadByte%2A> e <xref:System.IO.Ports.SerialPort.ReadChar%2A> tra loro. Il passaggio tra la lettura dei byte e la lettura dei caratteri può causare dati aggiuntivi da leggere e/o altri comportamenti imprevisti. Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che non ci sono byte da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
\- oppure - 
Non sono stati letti byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge in modo sincrono un carattere dal buffer di input <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Carattere letto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge un carattere di completamento in base alla codifica.  
  
 Prestare attenzione quando si usa <xref:System.IO.Ports.SerialPort.ReadByte%2A> e <xref:System.IO.Ports.SerialPort.ReadChar%2A> tra loro. Il passaggio tra la lettura dei byte e la lettura dei caratteri può causare dati aggiuntivi da leggere e/o altri comportamenti imprevisti. Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che non ci sono byte da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
\- oppure - 
Nessun carattere disponibile nel periodo di timeout specificato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i byte disponibili immediatamente, in base alla codifica, sia nel flusso che nel buffer di input dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Contenuto del flusso e del buffer di input dell'oggetto <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il contenuto del flusso e del buffer interno del <xref:System.IO.Ports.SerialPort> oggetto sotto forma di stringa. Questo metodo non usa un timeout. Si noti che questo metodo è possibile lasciare finali byte di apertura nel buffer interno, che rende il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> valore maggiore di zero.  
  
 Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati, ma l'oggetto flusso specificato nel <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> proprietà non esiste. Pertanto, il <xref:System.IO.Ports.SerialPort> oggetto e l'oggetto flusso potrebbe essere diverso per il numero di byte che sono disponibili per la lettura. Quando vengono memorizzati nel buffer byte per il <xref:System.IO.Ports.SerialPort> oggetti, il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà include i byte nel relativo valore; tuttavia, questi byte potrebbero non essere accessibili al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge fino al valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" /> nel buffer di input.</summary>
        <returns>Contenuto del buffer di input fino alla prima occorrenza di un valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che sebbene questo metodo non restituisce il <xref:System.IO.Ports.SerialPort.NewLine%2A> valore, il <xref:System.IO.Ports.SerialPort.NewLine%2A> valore viene rimosso dal buffer di input.  
  
 Per impostazione predefinita, il <xref:System.IO.Ports.SerialPort.ReadLine%2A> metodo si blocca fino a quando non viene ricevuta una riga. Se questo comportamento è indesiderato, impostare il <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> impostandola su qualsiasi valore diverso da zero per forzare il <xref:System.IO.Ports.SerialPort.ReadLine%2A> metodo consente di generare un <xref:System.TimeoutException> se una riga non è disponibile sulla porta.  
  
 Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che non ci sono byte da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.  
  
\- oppure - 
Non sono stati letti byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di millisecondi prima del timeout quando un'operazione di lettura non viene completata.</summary>
        <value>Numero di millisecondi prima del timeout quando un'operazione di lettura non viene completata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di timeout di lettura è stato originariamente impostato su 500 millisecondi nell'API di comunicazione Win32. Questa proprietà consente di impostare questo valore. Il timeout può essere impostato su qualsiasi valore maggiore di zero o impostato su <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, nel qual caso si verifica alcun timeout. Il valore predefinito è <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
> [!NOTE]
>  Gli utenti dell'interfaccia non gestita `COMMTIMEOUTS` struttura prevedibile impostare il valore di timeout su zero per disattivare i timeout. Per eliminare i timeout con i <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> proprietà, tuttavia, è necessario specificare <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Questa proprietà influisce il <xref:System.IO.Stream.BeginRead%2A> del flusso restituito dal metodo di <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di timeout di lettura è minore di zero e diverso da <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valore che indica dove termina l'operazione di lettura.</param>
        <summary>Legge una stringa fino al parametro <paramref name="value" /> specificato nel buffer di input.</summary>
        <returns>Contenuto del buffer di input fino al parametro <paramref name="value" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge una stringa fino specificato `value`. Anche se la stringa restituita non include il `value`, il `value` viene rimosso dal buffer di input.  
  
 Se è necessario passare tra la lettura di testo e la lettura dei dati binari dal flusso, selezionare un protocollo che definisce il limite tra testo e dati binari, ad esempio la lettura dei byte e decodifica i dati manualmente.  
  
> [!NOTE]
>  Poiché il <xref:System.IO.Ports.SerialPort> classe memorizza nel buffer di dati e il flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà non esiste, potrebbe essere una discordanza il numero di byte disponibile per la lettura.  Il <xref:System.IO.Ports.SerialPort.BytesToRead%2A> proprietà può indicare che non ci sono byte da leggere, ma potrebbe non essere accessibile al flusso di contenuti nel <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà perché sono stati memorizzati per il <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza del parametro <paramref name="value" /> è 0.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di byte nel buffer di input interno prima che si verifichi un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />.</summary>
        <value>Numero di byte nel buffer di input interno prima che venga generato un evento <see cref="E:System.IO.Ports.SerialPort.DataReceived" />. Il valore predefinito è 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.DataReceived> evento viene generato anche se un' <xref:System.IO.Ports.SerialData.Eof> carattere viene ricevuto, indipendentemente dal numero di byte nel buffer di input interno e il valore della <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> è minore o uguale a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il segnale RTS (Request to Send) è abilitato durante la comunicazione seriale.</summary>
        <value>
          <see langword="true" /> per attivare RTS; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La richiesta al segnale di trasmissione (RTS) viene generalmente utilizzata nella richiesta di trasmissione o deselezionare per inviare la sincronizzazione di hardware RTS/CTS ().  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il valore della proprietà <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> viene impostato o recuperato mentre la proprietà <see cref="P:System.IO.Ports.SerialPort.Handshake" /> è impostata sul valore <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> o <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero standard dei bit di stop per byte.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito per la proprietà <xref:System.IO.Ports.SerialPort.StopBits%2A> è <xref:System.IO.Ports.StopBits.One>.  
  
 Il <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> valore non è supportato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.IO.Ports.SerialPort.StopBits%2A> proprietà `One`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <see cref="P:System.IO.Ports.SerialPort.StopBits" /> è <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive i dati nel buffer di output della porta seriale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Stringa per l'output.</param>
        <param name="str">Stringa per l'output.</param>
        <summary>Scrive sulla porta seriale la stringa specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si vuole scrivere una stringa come output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> durante l'attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita <xref:System.IO.Ports.SerialPort> Usa <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 caratteri come 63 (char) o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> al <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="text" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte che contiene i dati da scrivere sulla porta.</param>
        <param name="offset">Offset dei byte in base zero nel parametro <c>buffer</c> da cui iniziare a copiare i byte nella porta.</param>
        <param name="count">Numero di byte da scrivere.</param>
        <summary>Scrive sulla porta un numero specificato di byte sulla porta seriale usando i dati di un buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si desidera scrivere in un buffer di byte per creare l'output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> durante l'attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita <xref:System.IO.Ports.SerialPort> Usa <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 caratteri come 63 (char) o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> al <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri che contiene i dati da scrivere sulla porta.</param>
        <param name="offset">Offset dei byte in base zero nel parametro <c>buffer</c> da cui iniziare a copiare i byte nella porta.</param>
        <param name="count">Numero di caratteri da scrivere.</param>
        <summary>Scrive sulla porta seriale un numero specificato di caratteri usando i dati di un buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando si desidera scrivere un buffer di caratteri per creare l'output a una porta seriale.  
  
 Se sono presenti troppi byte nel buffer di output e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> durante l'attesa per il dispositivo sia pronto per accettare più dati.  
  
 Per impostazione predefinita <xref:System.IO.Ports.SerialPort> Usa <xref:System.Text.ASCIIEncoding> per codificare i caratteri. <xref:System.Text.ASCIIEncoding> codifica di tutti i caratteri maggiori di 127 caratteri come 63 (char) o '?'. Per supportare caratteri aggiuntivi in tale intervallo, impostare <xref:System.IO.Ports.SerialPort.Encoding%2A> al <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, o <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di <paramref name="buffer" /> passato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="offset" /> o <paramref name="count" /> si trova al di fuori dell'area di validità del parametro <paramref name="buffer" /> passato. <paramref name="offset" /> o <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> più <paramref name="count" /> è maggiore della lunghezza del parametro <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'operazione non è stata completata prima dello scadere del periodo di timeout.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione del buffer di output della porta seriale.</summary>
        <value>Dimensione del buffer di output. Il valore predefinito è 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> proprietà ignora i valori inferiori a 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è minore o uguale a zero.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è stata impostata mentre il flusso era aperto.</exception>
        <exception cref="T:System.IO.IOException">La proprietà <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> è stata impostata su un intero dispari.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Stringa da scrivere nel buffer di output.</param>
        <param name="str">Stringa da scrivere nel buffer di output.</param>
        <summary>Scrive la stringa specificata e il valore di <see cref="P:System.IO.Ports.SerialPort.NewLine" /> nel buffer di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se sono presenti troppi byte nel buffer di input e <xref:System.IO.Ports.SerialPort.Handshake%2A> è impostata su <xref:System.IO.Ports.Handshake.XOnXOff> il <xref:System.IO.Ports.SerialPort> oggetto può generare un <xref:System.ServiceProcess.TimeoutException> durante l'attesa per il dispositivo sia pronto per accettare più dati.  
  
 Include l'output scritto il <xref:System.IO.Ports.SerialPort.NewLine%2A> stringa.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="text" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La porta specificata non è aperta.</exception>
        <exception cref="T:System.TimeoutException">Il metodo <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> non è stato in grado di scrivere nel flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di millisecondi prima del timeout quando un'operazione di scrittura non viene completata.</summary>
        <value>Numero di millisecondi prima dello scadere di un timeout. Il valore predefinito è <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di timeout di scrittura originariamente è stato impostato su 500 millisecondi nell'API di comunicazione Win32. Questa proprietà consente di impostare questo valore. Il timeout può essere impostato su qualsiasi valore maggiore di zero o impostato su <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, nel qual caso si verifica alcun timeout. Il valore predefinito è <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
> [!NOTE]
>  Gli utenti dell'interfaccia non gestita `COMMTIMEOUTS` struttura prevedibile impostare il valore di timeout su zero per disattivare i timeout. Per eliminare i timeout con i <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> proprietà, tuttavia, è necessario specificare <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Questa proprietà influisce il <xref:System.IO.Stream.BeginWrite%2A> del flusso restituito dal metodo di <xref:System.IO.Ports.SerialPort.BaseStream%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.Ports.SerialPort> classe per consentire agli due utenti entrare in chat da due computer separati connessi tramite un cavo null modem. In questo esempio, gli utenti vengono richiesto per le impostazioni della porta e un nome utente prima di chat. Questo esempio di codice è parte di un esempio più esaustivo fornito per il <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La porta è in uno stato non valido.  
  
\- oppure - 
Un tentativo di impostare lo stato di una porta sottostante non è riuscito. Ad esempio, i parametri passati da questo oggetto <see cref="T:System.IO.Ports.SerialPort" /> non sono validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> è minore di zero e diverso da <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>