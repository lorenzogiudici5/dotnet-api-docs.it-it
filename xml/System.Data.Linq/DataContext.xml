<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="614bf8b628b9e044f43fb12a554abe74af90df70" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174262" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta il punto di ingresso principale per il framework LINQ to SQL.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Linq.DataContext> è l'origine di tutte le entità mappate su una connessione di database. Tiene traccia delle modifiche apportate a tutte le entità recuperate e gestisce una "cache delle identità" che garantisce che le entità recuperate più di una volta sono rappresentate da utilizzando la stessa istanza dell'oggetto.  
  
 In generale, un <xref:System.Data.Linq.DataContext> istanza è progettata per l'ultimo di una "unità di lavoro" tuttavia l'applicazione definisce questo periodo. Oggetto <xref:System.Data.Linq.DataContext> è semplice e non è dispendioso da creare. Una tipica [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] applicazione crea <xref:System.Data.Linq.DataContext> istanze nell'ambito del metodo o come membro di classi di breve durate che rappresentano un insieme logico di relative operazioni di database.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Linq.DataContext" />. La stringa di connessione utilizzata può essere una stringa di connessione ADO.NET. È inoltre possibile specificare un nome file per un file di SQL Server Express o SQL Server Compact.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">La connessione usata da [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Linq.DataContext" /> facendo riferimento alla connessione usata da [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Data.Linq.DataContext> apre e chiude una connessione al database in base alle esigenze se si specifica una connessione chiusa o una stringa di connessione. In generale, non si mai chiamare `Dispose` su un <xref:System.Data.Linq.DataContext>. Se si specifica una connessione aperta, il <xref:System.Data.Linq.DataContext> non verrà chiusa. Pertanto, non creare un'istanza di un <xref:System.Data.Linq.DataContext> con una connessione aperta a meno che non si dispone di un buon motivo per eseguire questa operazione. In un <xref:System.Transactions> transazione, un <xref:System.Data.Linq.DataContext> non aprire o chiudere una connessione per impedire la promozione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Connessione utilizzata da .NET Framework.</param>
        <param name="mapping">Origine per il mapping.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Linq.DataContext" /> facendo riferimento a una connessione e a un'origine del mapping.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Questo argomento può corrispondere ai seguenti elementi: Il nome di un file in cui si trova un database SQL Server Express.  Il nome di un server in cui è presente un database. In tal caso, il provider utilizza il database predefinito per un utente.  Stringa di connessione completa. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] passa la stringa al provider senza apportare alcuna modifica.</param>
        <param name="mapping">Origine per il mapping.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Linq.DataContext" /> facendo riferimento a un'origine file e a un'origine mapping.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">To be added.</param>
        <param name="connectionString">To be added.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Linq.DataContext" /> facendo riferimento a un'origine file.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di oggetti che hanno provocato conflitti di concorrenza quando è stato chiamato <see cref="M:System.Data.Linq.DataContext.SubmitChanges" />.</summary>
        <value>Raccolta di oggetti che hanno provocato conflitti di concorrenza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'esempio seguente mostra come può essere scorso la raccolta per recuperare informazioni sui conflitti.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che aumenta il periodo di timeout per le query che in caso contrario scadrebbero durante il periodo di timeout predefinito.</summary>
        <value>Valore integer che aumenta il periodo di timeout per le query che in caso contrario scadrebbero durante il periodo di timeout predefinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà ottiene o imposta il timeout del comando utilizzato per eseguire comandi generati (`IDbCommands`). Per ulteriori informazioni, vedere <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Quando questa proprietà non è impostata, il valore predefinito di <xref:System.Data.IDbCommand.CommandTimeout%2A> utilizzato per l'esecuzione di comandi di query. Il valore predefinito viene impostato dal provider di archiviazione. Si noti che alcuni provider possono generare eccezioni se questo valore è impostato su un valore diverso da zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la connessione utilizzata dal framework.</summary>
        <value>Connessione utilizzata dal framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questa proprietà per l'interoperabilità con codice ADO.NET relazionale.  
  
 La connessione restituita verrà chiusa a meno che non è stato aperto in modo esplicito dall'utente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un database nel server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome del database è derivato tramite l'algoritmo seguente:  
  
1. Se un database viene identificato nella stringa di connessione, viene utilizzato il relativo nome.  
1. Se un <xref:System.Data.Linq.Mapping.DatabaseAttribute> attributo è presente, il relativo <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> proprietà viene utilizzata come nome del database.  
1. Se non vi è alcun tag di database nella stringa di connessione e un oggetto fortemente tipizzato <xref:System.Data.Linq.DataContext> viene utilizzato un database con lo stesso nome di <xref:System.Data.Linq.DataContext> eredita classe viene creata.  
1. Se un debole tipizzato <xref:System.Data.Linq.DataContext> viene utilizzata, viene generata un'eccezione.  
1. Se il <xref:System.Data.Linq.DataContext> è stato creato utilizzando un nome di file, viene creato il database che corrisponde al nome file.  
     
  
## Examples  
 Il codice seguente viene illustrato come impostare un database temporaneo e quindi rimuoverlo.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo di elementi contenuti nell'insieme restituito.</typeparam>
        <param name="instance">Istanza della chiamata al metodo (l'oggetto corrente).</param>
        <param name="methodInfo">
          <see cref="T:System.Reflection.MethodInfo" /> che identifica il metodo CLR corrispondente a un metodo di database.</param>
        <param name="parameters">Matrice di parametri da passare al comando.</param>
        <summary>Esegue la funzione di database con valori di tabella associata al metodo CLR specificato.</summary>
        <returns>Insieme di valori risultanti restituiti dalla query eseguita sul database.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> metodo viene utilizzato nel codice generato automaticamente e funge da proxy per le funzioni di database.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se il database associato può essere aperto.</summary>
        <returns>
          <see langword="true" /> se il database specificato può essere aperto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza la connessione nel <xref:System.Data.Linq.DataContext.Connection%2A> proprietà per tentare di aprire il database associato.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzato questo metodo per determinare se esiste già un database.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se ritardare il caricamento delle relazioni uno-a-molti o uno-a-uno.</summary>
        <value>
          <see langword="true" /> se il caricamento posticipato è abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il codice che accede a una di queste relazioni null viene restituito se la relazione uno a uno e viene restituita una raccolta vuota se è uno-a-molti. Le relazioni possono comunque essere riempite impostando il <xref:System.Data.Linq.DataContext.LoadOptions%2A> proprietà.  
  
 Lo scenario principale per questa proprietà è che consente di estrarre una parte del modello a oggetti e inviarlo (ad esempio, per un servizio Web).  
  
> [!NOTE]
>  Se questa proprietà è impostata su `false` dopo l'esecuzione di una query, viene generata un'eccezione. Vedere il **modalità valide** sezione riportata di seguito per ulteriori informazioni.  
  
## <a name="valid-modes"></a>Modalità valide  
 Il caricamento posticipato richiede rilevamento degli oggetti. Solo le tre modalità seguenti sono valide:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> viene ignorato e considerato `false`. Questo comportamento corrisponde a una proprietà di sola lettura <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Questa situazione corrisponde a un <xref:System.Data.Linq.DataContext> che consente agli utenti di caricare un oggetto grafico utilizzando <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> direttive, ma non abilita il caricamento posticipato.  
  
-   Sono impostati entrambi su `true`. Questa è l'impostazione predefinita.  
  
 I flag non possono essere modificati dopo l'esecuzione di una query. Eventuali modifiche apportate dopo l'esecuzione della prima query che utilizza l'oggetto <xref:System.Data.Linq.DataContext> genera un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina il database associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza la connessione nel <xref:System.Data.Linq.DataContext.Connection%2A> proprietà per identificare il database da eliminare.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eliminare un database che è stato creato temporaneamente.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate dalla classe <see cref="T:System.Data.Linq.DataContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite utilizzate dalla classe <see cref="T:System.Data.Linq.DataContext" /> ed eventualmente rilascia la risorsa gestita.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Comando SQL da eseguire.</param>
        <param name="parameters">Matrice di parametri da passare al comando. Si noti il comportamento seguente: se il numero di oggetti nella matrice è inferiore al numero più elevato identificato nella stringa di comando, viene generata un'eccezione.  Se la matrice contiene oggetti ai quali non viene fatto riferimento nella stringa di comando, non viene generata alcuna eccezione.  Se uno dei parametri è null, viene convertito in <see langword="DBNull.Value" />.</param>
        <summary>Esegue comandi SQL direttamente nel database.</summary>
        <returns>Numero di righe modificate dal comando eseguito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un meccanismo pass-through per i casi in cui [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] risulta particolarmente adatto per un determinato scenario.  
  
 La sintassi per il comando è quasi identico alla sintassi utilizzata per creare un ADO.NET `DataCommand`. L'unica differenza è in modalità con cui i parametri vengono specificati. In particolare, si specificano parametri includendoli tra parentesi graffe ({…}) e li si enumerano a partire da 0. Il parametro è associato all'oggetto ugualmente numerato nella matrice di parametri.  
  
 `ExecuteQuery` e `ExecuteCommand` consentono di specificare un numero variabile di argomenti per la sostituzione dei parametri. Ad esempio, è possibile specificare i parametri per chiamare il metodo ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Inoltre, un altro esempio:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Nell'esempio seguente viene aperta una connessione e passa a un database SQL `UPDATE` comando al motore di SQL.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Entità da eliminare.</param>
        <summary>Viene eseguito nei metodi di override di eliminazione per ridelegare a [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] l'attività di generazione ed esecuzione di SQL dinamico per le operazioni di eliminazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Entità da inserire.</param>
        <summary>Viene eseguito nei metodi di override di inserimento per ridelegare a [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] l'attività di generazione ed esecuzione di SQL dinamico per le operazioni di inserimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente le considerazioni seguenti:  
  
-   Poiché il metodo contiene un modificatore protetto, il suo utilizzo richiede la creazione di sottoclassi <xref:System.Data.Linq.DataContext>.  
  
-   Viene generata un'eccezione se questa operazione non viene chiamata all'interno di un <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operazione. Non deve essere chiamato come operazione autonoma all'esterno dell'ambito di un <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operazione. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> stesso chiama metodi di override se sono implementati e i metodi precedenti sono destinati a essere chiamato all'interno di metodi di override.  
  
-   È responsabilità dello sviluppatore per passare l'entità corretta. L'implementazione verifica che l'entità di tipo passato è stato registrato. Tuttavia, è responsabilità dello sviluppatore di mantenere l'ordine o passare due volte la stessa entità.  
  
-   È responsabilità dello sviluppatore per richiamare l'API dinamica corretta. Ad esempio, nel `Update` solo metodo di override di <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> metodo può essere chiamato. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] non rileva né verifica se il metodo dinamico richiamato corrisponde all'operazione applicabile. I risultati sono indefiniti se viene chiamato un metodo non applicabile (ad esempio, la chiamata <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> per un oggetto da aggiornare).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Entità da aggiornare.</param>
        <summary>Viene eseguito nei metodi di override di aggiornamento per ridelegare a [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] l'attività di generazione ed esecuzione di SQL dinamico per le operazioni di aggiornamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Istanza della chiamata al metodo (l'oggetto corrente).</param>
        <param name="methodInfo">Identifica il metodo CLR corrispondente a un metodo di database.</param>
        <param name="parameters">Matrice di parametri da passare al comando.</param>
        <summary>Esegue la stored procedure di database o la funzione scalare associata al metodo CLR specificato.</summary>
        <returns>Risultato (valore restituito e parametri di output) dell'esecuzione del metodo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> metodo viene utilizzato nel codice generato automaticamente e funge da proxy per le funzioni di database.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Tipo di <see cref="T:System.Collections.Generic.IEnumerable`1" /> da restituire.  L'algoritmo per la ricerca delle colonne corrispondenti nel risultato della query nei campi o nelle proprietà dell'oggetto funziona come segue:  Se un campo o una proprietà viene mappata a uno specifico nome di colonna, il nome di colonna sarà incluso nel set di risultati.  Se non viene mappato un campo o una proprietà, nel set di risultati è prevista una colonna con lo stesso nome del campo o della proprietà.  Il confronto viene eseguito cercando prima una corrispondenza con distinzione tra maiuscole e minuscole. Se tale corrispondenza non viene trovata, viene eseguita una ricerca successiva di una corrispondenza senza distinzione tra maiuscole e minuscole.  La query deve restituire tutti i campi e le proprietà registrati dell'oggetto (tranne quelli caricati su base posticipata) quando si verificano tutte le condizioni seguenti:  <c>T</c> è un'entità registrata in modo esplicito da <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> è <see langword="true" />.  L'entità contiene una chiave primaria.  In caso contrario, viene generata un'eccezione.</param>
        <param name="query">Query SQL da eseguire.</param>
        <param name="parameters">Matrice di parametri da passare al comando. Si noti il comportamento seguente: se il numero di oggetti nella matrice è inferiore al numero più elevato identificato nella stringa di comando, viene generata un'eccezione.  Se la matrice contiene oggetti ai quali non viene fatto riferimento nella stringa di comando, non viene generata alcuna eccezione.  Se un parametro è <see langword="null" />, viene convertito in <see langword="DBNull.Value" />.</param>
        <summary>Esegue query SQL direttamente nel database.</summary>
        <returns>Insieme di oggetti <see cref="T:System.Collections.Generic.IEnumerable`1" /> restituiti dalla query.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo di elementi contenuti nell'insieme restituito.</typeparam>
        <param name="query">Query SQL da eseguire.</param>
        <param name="parameters">Matrice di parametri da passare al comando. Si noti il comportamento seguente: se il numero di oggetti nella matrice è inferiore al numero più elevato identificato nella stringa di comando, viene generata un'eccezione.  Se la matrice contiene oggetti ai quali non viene fatto riferimento nella stringa di comando, non viene generata alcuna eccezione.  Se un parametro è null, viene convertito in <see langword="DBNull.Value" />.</param>
        <summary>Esegue query SQL direttamente nel database e restituisce oggetti.</summary>
        <returns>Insieme di oggetti restituiti dalla query.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un meccanismo pass-through per i casi in cui [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] non fornisce per un determinato scenario.  
  
 L'algoritmo per le colonne corrispondenti nel risultato della query a campi e proprietà nell'oggetto funziona nel modo seguente:  
  
-   Se un campo o una proprietà viene mappata a un determinato nome di colonna, nel set di risultati è previsto tale nome.  
  
-   Se non viene mappato un campo o una proprietà, nel set di risultati è prevista una colonna con lo stesso nome del campo o della proprietà.  
  
-   Il confronto viene eseguito con la prima ricerca per trovare una corrispondenza tra maiuscole e minuscole. Se tale corrispondenza non viene trovato, viene eseguita una ricerca successiva per trovare una corrispondenza tra maiuscole e minuscole.  
  
-   La query deve restituire tutti i campi rilevati e delle proprietà dell'oggetto (tranne quelli soggetti a caricamento posticipato) quando le condizioni seguenti sono vere:  
  
    -   Se `<T>` un'entità in modo esplicito tiene traccia di <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled è true.  
  
    -   L'entità contiene una chiave primaria.  
  
     In caso contrario, viene generata un'eccezione.  
  
-   In tutti gli altri casi, la query può recuperare solo un sottoinsieme dei campi di rilevamento e proprietà per l'oggetto.  
  
 Il seguente frammento di codice c# viene illustrato un utilizzo di questo metodo:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 In Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene gli oggetti modificati monitorati mediante <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <returns>Il set di oggetti viene restituito come tre raccolte di sola lettura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente le considerazioni seguenti:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> potrebbe avere effetti collaterali, ad esempio inferenza delle insert e operazioni che vengono in genere eseguite al momento dell'eliminazione <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Ad esempio, gli oggetti utilizzati nelle operazioni seguenti è possono creare operazioni dedotte corrispondenti nell'elenco seguente:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> per <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> assegnazione di null (probabilmente a causa di <xref:System.Data.Linq.EntitySet%601.Remove%2A> a <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Il set non può essere ordinato in base ai vincoli di chiave esterna.  
  
-   Non sono disponibili i valori generati dal database (ad esempio, i valori di chiavi primari ed esterni, timestamp e così via). Tali informazioni richiedono l'esecuzione del comando di database e forse la propagazione delle informazioni recuperate (ad esempio, chiave esterna dalla chiave primaria).  
  
-   Il set di oggetti modificati viene calcolato al momento della chiamata. Le chiamate successive a <xref:System.Data.Linq.DataContext.SubmitChanges%2A> può produrre un set diverso se vengono apportate modifiche aggiuntive.  
  
 Output quando è stata apportata alcuna modifica viene visualizzata come indicato di seguito:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Query da cui devono essere recuperate le informazioni sul comando SQL.</param>
        <summary>Ottiene le informazioni sui comandi SQL generati da [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</summary>
        <returns>Oggetto contenente le informazioni sul comando richieste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è solo un getter e non influisce sulla <xref:System.Data.Linq.DataContext> stato.  
  
 Tenere presente le considerazioni seguenti:  
  
-   L'argomento deve essere non null. In caso contrario, viene generata un'eccezione di argomento null.  
  
-   Le eccezioni di conversione di query normali generate durante [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] applicare l'esecuzione di query per una query che non può essere convertita.  
  
-   Viene restituito solo il primo comando di query. In particolare, i comandi aggiuntivi che vengono utilizzati per il caricamento eager (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) non sono inclusi.  
  
-   <xref:System.Data.Linq.DataContext> tiene traccia delle operazioni eseguite dall'utente con il comando. Ad esempio, di non vengono rilevati e non influiscono sui risultati dell'esecuzione del comando restituito <xref:System.Data.Linq.DataContext> stato.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo degli oggetti da restituire.</param>
        <summary>Restituisce una raccolta di oggetti di un determinato tipo, dove il tipo viene definito dal parametro <paramref name="type" />.</summary>
        <returns>Raccolta degli oggetti definiti dal parametro <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di una versione con tipizzazione di <xref:System.Data.Linq.DataContext.GetTable%2A>. È importante disporre di una versione con tipizzazione perché è una pratica comune relativamente per costruire le query in modo dinamico. Sarebbe scomodo forzare l'applicazione per usare la reflection per chiamare il metodo generico corretto.  
  
 Se è presente alcuna raccolta per un determinato tipo, viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Tipo degli oggetti da restituire.</typeparam>
        <summary>Restituisce una raccolta di oggetti di un determinato tipo, dove il tipo viene definito dal parametro <paramref name="TEntity" />.</summary>
        <returns>Raccolta degli oggetti definiti dal parametro <paramref name="TEntity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è il punto di ingresso principale per l'esecuzione di query. Quando un oggetto fortemente tipizzato <xref:System.Data.Linq.DataContext> viene creata, nuove proprietà generate incapsulano le chiamate a questo metodo. Ad esempio, un `Customers` generata proprietà che restituisce `GetTable<Customer>`.  
  
 Se è presente alcuna raccolta per un determinato tipo, viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Data.Linq.DataLoadOptions" /> associato a <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <value>Opzioni di caricamento di prelettura relative ai dati correlati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà ottiene o imposta le opzioni che consentono di definire il comportamento di caricamento in background per i membri di caricamento posticipato e l'appartenenza di raccolte correlate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la destinazione in cui scrivere la query o il comando SQL.</summary>
        <value>Oggetto <see cref="T:System.IO.TextReader" /> da utilizzare per scrivere il comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `null` per disabilitare la registrazione dei comandi.  
  
   
  
## Examples  
 L'esempio seguente mostra il codice SQL generato nella finestra della console prima di visualizzare i risultati della query.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Data.Linq.Mapping.MetaModel" /> sul quale è basato il mapping.</summary>
        <value>Il mapping tra un database e oggetti del dominio.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il rilevamento oggetti è abilitato.</summary>
        <value>
          <see langword="true" /> se il rilevamento dell'oggetto è abilitato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostando questa proprietà su `false` migliora le prestazioni in fase di recupero, poiché esistono meno elementi da registrare.  
  
 Viene generata un'eccezione:  
  
-   Se la proprietà è impostata su `false` dopo l'esecuzione di una query.  
  
     Per ulteriori informazioni, vedere la sezione modalità valide in <xref:System.Data.Linq.DataContext>.  
  
-   Se la proprietà è impostata su `false` e <xref:System.Data.Linq.DataContext.SubmitChanges%2A> viene chiamato.  
  
 Se <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> è `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> viene ignorata e trattata `false`. In questo caso, il <xref:System.Data.Linq.DataContext> è di sola lettura.  
  
 Se <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> è `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> è `false`. In questo caso, <xref:System.Data.Linq.DataContext> consente di caricare un oggetto grafico utilizzando <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> direttive, ma non abilita il caricamento posticipato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna lo stato dell'oggetto utilizzando i dati nel database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile dopo un errore di concorrenza ottimistica per portare gli elementi in uno stato per un altro tentativo. Aggiorna lo stato dei campi primitivi e le proprietà sugli oggetti.  
  
> [!NOTE]
>  Se si trova in un oggetto di *molti* verrà impostato sul lato di una relazione uno-a-molti, la chiave esterna per l'oggetto e il puntatore all'oggetto per l'altro lato della relazione verrà impostato sul nuovo valore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Valore che specifica la modalità di gestione dei conflitti di concorrenza ottimistica.</param>
        <param name="entities">Insieme di entità da aggiornare.</param>
        <summary>Aggiorna una raccolta di oggetti entità secondo la modalità specificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Valore che specifica la modalità di gestione dei conflitti di concorrenza ottimistica.</param>
        <param name="entity">Oggetto da aggiornare.</param>
        <summary>Aggiorna un oggetto entità secondo la modalità specificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Valore che specifica la modalità di gestione dei conflitti di concorrenza ottimistica.</param>
        <param name="entities">Matrice di oggetti dell'entità da aggiornare.</param>
        <summary>Aggiorna una matrice di oggetti entità secondo la modalità specificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il set di oggetti modificati da inserire, aggiornare o eliminare ed esegue i comandi adatti per implementare le modifiche al database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se metodi di override sono presenti per insert, update o delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> esegue questi metodi invece il valore predefinito [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] comandi.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Avvia una transazione ed eseguirà il rollback se si verifica un'eccezione mentre <xref:System.Data.Linq.DataContext.SubmitChanges%2A> è in esecuzione. Tuttavia, questo non rollback delle modifiche in memoria o rilevati tramite il <xref:System.Data.Linq.DataContext>; tali modifiche saranno necessario eseguire il rollback manualmente. È possibile iniziare con una nuova istanza di <xref:System.Data.Linq.DataContext> se le modifiche in memoria verranno ignorati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Calcola il set di oggetti modificati da inserire, aggiornare o eliminare ed esegue i comandi adatti per implementare le modifiche al database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se metodi di override sono presenti per insert, update o delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> esegue questi metodi invece il valore predefinito [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] comandi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Azione da intraprendere se l'invio ha esito negativo. Gli argomenti validi sono i seguenti:  <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Invia le modifiche apportate agli oggetti recuperati nel database sottostante e specifica l'azione da intraprendere se l'invio ha esito negativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modalità di errore predefinita è <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una transazione locale per [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] da usare per accedere al database.</summary>
        <value>Oggetto transazione utilizzato da <see cref="T:System.Data.Linq.DataContext" /> durante l'esecuzione di query e comandi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo scenario principale per questa proprietà è l'interoperabilità con relazionale [!INCLUDE[vstecado](~/includes/vstecado-md.md)] codice. Ad esempio, utilizzare questa proprietà quando si scrivono `Create` / `Update` / `Delete` metodi per impostare il `Transaction` proprietà ADO `Command` oggetto.  
  
 Tenere presente quanto segue:  
  
-   Se questa proprietà non è stata impostata in modo esplicito, il metodo get restituisce null.  
  
-   Se il codice è in esecuzione un <xref:System.Transactions.Transaction> contesto, l'impostazione di questa proprietà genera un'eccezione.  
  
-   Se questa proprietà è set e un nuovo <xref:System.Transactions.Transaction> è aperto, viene generata un'eccezione quando viene eseguito una query o aggiornamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un oggetto <see cref="T:System.Data.IDataReader" /> esistente in oggetti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni riga di <xref:System.Data.IDataReader> viene convertito in un oggetto nel <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Descrizione: Questo metodo viene utilizzato per convertire un oggetto esistente <xref:System.Data.Common.DbDataReader> agli oggetti. Ogni riga di <xref:System.Data.Common.DbDataReader> viene convertito in un oggetto nel <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Parametri generici:**  
  
 `T`: Vedere <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Parametri:**  
  
 `Query`: Vedere la descrizione comando sotto <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: Vedere la descrizione per i parametri in <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Tipo restituito:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: raccolta di oggetti restituiti dalla conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Elemento <see cref="T:System.Data.IDataReader" /> da convertire.</param>
        <summary>Converte un oggetto <see cref="T:System.Data.Common.DbDataReader" /> esistente in oggetti.</summary>
        <returns>Elenco di oggetti restituiti dalla conversione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Tipo di <see cref="T:System.Collections.Generic.IEnumerable`1" /> da restituire.  L'algoritmo per la ricerca delle colonne corrispondenti nel risultato nei campi e nelle proprietà dell'oggetto funziona come segue:  Se un campo o una proprietà viene mappata a uno specifico nome di colonna, il nome di colonna sarà incluso nel set di risultati.  Se non viene mappato un campo o una proprietà, nel set di risultati è prevista una colonna con lo stesso nome del campo o della proprietà.  Il confronto viene eseguito cercando prima una corrispondenza con distinzione tra maiuscole e minuscole. Se tale corrispondenza non viene trovata, viene eseguita una ricerca successiva di una corrispondenza senza distinzione tra maiuscole e minuscole.  La query deve restituire tutti i campi e le proprietà registrati dell'oggetto (tranne quelli caricati su base posticipata) quando si verificano tutte le condizioni seguenti:  <c>T</c> è un'entità registrata in modo esplicito da <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> è <see langword="true" />.  L'entità contiene una chiave primaria.  In caso contrario, viene generata un'eccezione.</param>
        <param name="reader">Elemento <see cref="T:System.Data.IDataReader" /> da convertire.</param>
        <summary>Converte un oggetto <see cref="T:System.Data.Common.DbDataReader" /> esistente in oggetti.</summary>
        <returns>Elenco di oggetti restituiti dalla conversione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo di <see cref="T:System.Collections.Generic.IEnumerable`1" /> da restituire.</typeparam>
        <param name="reader">Elemento <see cref="T:System.Data.IDataReader" /> da convertire.</param>
        <summary>Converte un oggetto <see cref="T:System.Data.Common.DbDataReader" /> esistente in oggetti.</summary>
        <returns>Insieme di oggetti restituiti dalla conversione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>