<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c57f0353db36ebb5cdb2d073606dea6ba98b965" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51900447" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="2c6af-101">Contiene metodi statici per la rappresentazione di contratti di programma quali precondizioni, postcondizioni e invarianti dell'oggetto.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2c6af-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-102">Le classi del contratto di codice consentono di specificare precondizioni, postcondizioni e invarianti dell'oggetto nel codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="2c6af-103">Le precondizioni sono requisiti da soddisfare quando si accede a un metodo o a una proprietà.</span><span class="sxs-lookup"><span data-stu-id="2c6af-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="2c6af-104">Le postcondizioni descrivono le aspettative al momento dell'uscita dal codice del metodo o della proprietà.</span><span class="sxs-lookup"><span data-stu-id="2c6af-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="2c6af-105">Le invarianti dell'oggetto descrivono lo stato previsto per una classe che non presenta alcun problema di condizione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="2c6af-106">Per altre informazioni sulle precondizioni, postcondizioni e invarianti dell'oggetto, vedere [contratti di codice](~/docs/framework/debug-trace-profile/code-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="2c6af-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="2c6af-107">Per gli strumenti e le istruzioni dettagliate per l'uso dei contratti di codice, vedere [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461)(Contratti di codice) nel sito Web MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="2c6af-107">For tools and detailed instructions for using code contracts, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2c6af-108">È necessario utilizzare un rewriter binario per inserire l'imposizione di contratti in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="2c6af-109">In caso contrario, i contratti, ad esempio il <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> metodo possono essere eseguito solo in modo statico e non genereranno eccezioni durante la fase di esecuzione se un contratto viene violato.</span><span class="sxs-lookup"><span data-stu-id="2c6af-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="2c6af-110">È possibile scaricare il rewriter binario CCRewrite dal [contratti di codice](https://go.microsoft.com/fwlink/?LinkId=152461) sul sito DevLabs Web di MSDN.</span><span class="sxs-lookup"><span data-stu-id="2c6af-110">You can download the binary rewriter CCRewrite from [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="2c6af-111">CCRewrite dotato di un componente aggiuntivo di Visual Studio che consente di attivare l'imposizione di contratti in fase di esecuzione dal progetto **proprietà** pagina.</span><span class="sxs-lookup"><span data-stu-id="2c6af-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="2c6af-112">Il rewriter binario e il componente aggiuntivo di Visual Studio non vengono forniti con [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] o il SDK di Windows.</span><span class="sxs-lookup"><span data-stu-id="2c6af-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-113">Nelle build di debug, esegue un test della fase di esecuzione per una condizione specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-113">In debug builds, performs a run-time test for a specified condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-114">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-114">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-115">Controlla una condizione. Se la condizione è <see langword="false" />, seguono i criteri di escalation impostati per l'analizzatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-116">I criteri di escalation dei blocchi predefiniti sono per notificare il debugger collegato un errore di contratto o per visualizzare un **Assert** finestra di dialogo se non è collegato un debugger.</span><span class="sxs-lookup"><span data-stu-id="2c6af-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="2c6af-117">Facoltativamente, l'analizzatore in modo che venga generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-118">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-118">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-119">Messaggio da visualizzare se la condizione non è soddisfatta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-119">A message to display if the condition is not met.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-120">Controlla una condizione. Se la condizione è <see langword="false" />, seguono i criteri di escalation impostati dall'analizzatore e viene visualizzato un messaggio specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-121">I criteri di escalation dei blocchi predefiniti sono per notificare il debugger collegato un errore di contratto o per visualizzare un **Assert** finestra di dialogo se non è collegato un debugger.</span><span class="sxs-lookup"><span data-stu-id="2c6af-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="2c6af-122">Facoltativamente, l'analizzatore in modo che venga generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="2c6af-123">Il `userMessage` parametro viene passato all'output del debugger.</span><span class="sxs-lookup"><span data-stu-id="2c6af-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="2c6af-124">Se `userMessage` non è una costante stringa letterale, strumenti potrebbero non essere in grado di leggerlo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-125">Indica agli strumenti di analisi del codice di presumere che una condizione sia <see langword="true" />, anche se non è possibile provare staticamente che sia sempre <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-126">Espressione condizionale da presumere che sia <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-126">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-127">Indica agli strumenti di analisi del codice di presumere che la condizione specificata sia <see langword="true" />, anche se non è possibile provare staticamente che sia sempre <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-128">In fase di esecuzione con questo metodo equivale all'uso di <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2c6af-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-129">Espressione condizionale da presumere che sia <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-129">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-130">Messaggio da inserire se l'ipotesi ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-130">The message to post if the assumption fails.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-131">Indica agli strumenti di analisi del codice di presumere che una condizione sia <see langword="true" />, anche se non è possibile provare staticamente che sia sempre <see langword="true" />. Viene visualizzato un messaggio se l'ipotesi non riesce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-132">Se `userMessage` non è una costante stringa letterale, il contratto non può essere riconosciuto dagli strumenti.</span><span class="sxs-lookup"><span data-stu-id="2c6af-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="2c6af-133">In fase di esecuzione con questo metodo equivale all'uso di <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2c6af-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-134">Si verifica quando un contratto ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-134">Occurs when a contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-135">Le informazioni relative a questo evento vengono fornite dall'oggetto <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> che viene passato al gestore eventi.</span><span class="sxs-lookup"><span data-stu-id="2c6af-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="2c6af-136">Questo evento di notifica a un ambiente di applicazione gestita, ad esempio un interprete interattivo o un host di browser Web che un contratto non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="2c6af-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="2c6af-137">Prima di procedere, generato un evento in grado di gestire un'applicazione come ritiene opportuno.</span><span class="sxs-lookup"><span data-stu-id="2c6af-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="2c6af-138">Ad esempio, se viene eseguito codice in un framework di test, è possibile registrare un errore di test e quindi terminare il test.</span><span class="sxs-lookup"><span data-stu-id="2c6af-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="2c6af-139">L'implementazione predefinita del <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> nella libreria di classi .NET Framework consiste nel chiamare ogni gestore che viene registrato con il <xref:System.Diagnostics.Contracts.Contract.ContractFailed> evento.</span><span class="sxs-lookup"><span data-stu-id="2c6af-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="2c6af-140">Le eccezioni generate dai gestori vengono ignorate, mentre ogni gestore di è possibile indicare se l'errore viene gestito tramite una chiamata di <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> metodo per gli argomenti dell'evento.</span><span class="sxs-lookup"><span data-stu-id="2c6af-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="2c6af-141">Se un gestore imposta l'errore come gestito, il metodo restituisce `null` e viene eseguita alcuna azione ulteriore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="2c6af-142">In alternativa, è possono chiamare i gestori di <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> metodo per indicare il codice per la rimozione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="2c6af-143">In tal caso, viene generata un'eccezione dopo aver eseguito tutti i gestori.</span><span class="sxs-lookup"><span data-stu-id="2c6af-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2c6af-144">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2c6af-145">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-146">Contrassegna la fine della sezione del contratto quando i contratti di un metodo contengono solo precondizioni nel formato <see langword="if" />-<see langword="then" />-<see langword="throw" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-147">Gran parte del codice contiene già la convalida dei parametri nel formato `if` - `then` - `throw` codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="2c6af-148">Gli strumenti dei contratti riconoscono `if` - `then` - `throw` istruzioni come precondizioni quando le istruzioni vengono visualizzati per primi all'interno di un metodo e l'intero set di istruzioni è seguito da un esplicita<xref:System.Diagnostics.Contracts.Contract> chiamata di metodo, ad esempio un <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, o <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c6af-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="2c6af-149">Quando `if` - `then` - `throw` vengono visualizzate le istruzioni in questo formato, gli strumenti dei contratti riconoscono come legacy-istruzioni require.</span><span class="sxs-lookup"><span data-stu-id="2c6af-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="2c6af-150">Il <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form viene usato solo se nessun altro contratto segue il `if` - `then` - `throw` sequenze, ma ancora devono essere contrassegnati come legacy-richiede.</span><span class="sxs-lookup"><span data-stu-id="2c6af-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-151">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-151">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-152">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-152">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="2c6af-153">L'espressione potrebbe includere i valori <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> e <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-154">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-154">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-155">Il `condition` parametro specifica una postcondizione che dovrà essere `true` quando la proprietà o metodo contenitore restituisce normalmente.</span><span class="sxs-lookup"><span data-stu-id="2c6af-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="2c6af-156">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-157">È necessario usare il rewriter binario (disponibile all'indirizzo [contratti di codice](https://go.microsoft.com/fwlink/?LinkId=152461) sul sito DevLabs Web di MSDN) per l'applicazione in fase di esecuzione di questo postcondizione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-157">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c6af-158">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metodo per assicurarsi che venga restituito un valore previsto.</span><span class="sxs-lookup"><span data-stu-id="2c6af-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="2c6af-159">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-160">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-160">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="2c6af-161">L'espressione potrebbe includere i valori <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> e <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-162">Messaggio da visualizzare se l'espressione non è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-162">The message to display if the expression is not <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-163">Specifica un contratto di postcondizione per una condizione di uscita fornita e un messaggio da visualizzare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-164">Il `condition` parametro specifica una postcondizione che dovrà essere `true` quando la proprietà o metodo contenitore restituisce normalmente.</span><span class="sxs-lookup"><span data-stu-id="2c6af-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="2c6af-165">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-166">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-167">È necessario usare il rewriter binario (disponibile all'indirizzo [contratti di codice](https://go.microsoft.com/fwlink/?LinkId=152461) sul sito DevLabs Web di MSDN) per l'applicazione in fase di esecuzione di questo postcondizione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-167">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="2c6af-168">Se `userMessage` non è una costante stringa letterale, il contratto non può essere riconosciuto dagli strumenti.</span><span class="sxs-lookup"><span data-stu-id="2c6af-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-169">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="2c6af-170">Tipo di eccezione che richiama il controllo di postcondizione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-170">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="2c6af-171">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-171">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-172">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-173">Il `condition` parametro specifica una postcondizione che deve essere `true` quando la proprietà o metodo contenitore termina in modo anomalo e un'eccezione di tipo `TException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="2c6af-174">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-175">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-176">È necessario usare il rewriter binario per l'applicazione in fase di esecuzione di questo postcondizione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="2c6af-177">Tipo di eccezione che richiama il controllo di postcondizione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-177">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="2c6af-178">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-178">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-179">Messaggio da visualizzare se l'espressione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-179">The message to display if the expression is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-180">Specifica un contratto di postcondizione e un messaggio da visualizzare se la condizione è <see langword="false" /> per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-181">Il `condition` parametro specifica una postcondizione che deve essere `true` quando la proprietà o metodo contenitore termina in modo anomalo e un'eccezione di tipo `TException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="2c6af-182">Il `message` parametro specifica un messaggio da visualizzare se la condizione è `false`.</span><span class="sxs-lookup"><span data-stu-id="2c6af-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="2c6af-183">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-184">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-185">È necessario usare il rewriter binario per l'applicazione in fase di esecuzione di questo postcondizione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="2c6af-186">Se `userMessage` non è una costante stringa letterale, il contratto non può essere riconosciuto dagli strumenti.</span><span class="sxs-lookup"><span data-stu-id="2c6af-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="2c6af-187">Primo valore intero da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-187">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="2c6af-188">Un ulteriore valore dell'ultimo intero da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-188">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="2c6af-189">Funzione da valutare per un valore dell'Integer nell'intervallo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-189">The function to evaluate for any value of the integer in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-190">Determina se un test specificato è true per qualsiasi Integer all'interno di un intervallo di Integer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-190">Determines whether a specified test is true for any integer within a range of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-191">
            <see langword="true" /> se <paramref name="predicate" /> restituisce <see langword="true" /> per qualsiasi Integer a partire da <paramref name="fromInclusive" /> fino a <paramref name="toExclusive" /> - 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-191">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-192">Il `toExclusive` parametro è uno più di tipo integer per facilitare l'uso della lunghezza di un intervallo di interi a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="2c6af-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="2c6af-193">Ad esempio, si imposterebbe a 5 per i numeri interi da 0 a 4.</span><span class="sxs-lookup"><span data-stu-id="2c6af-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2c6af-194">
            <paramref name="predicate" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-194">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2c6af-195">
            <paramref name="toExclusive" /> è minore di <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-195">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="2c6af-196">Il tipo di contenuto in <c>raccolta</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-196">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="2c6af-197">Raccolta da cui ottenere elementi di tipo <c>T</c> da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="2c6af-198">Funzione da valutare per un elemento della <c>raccolta</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-198">The function to evaluate for an element in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-199">Determina se un elemento all'interno di una raccolta di elementi esiste all'interno di una funzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-199">Determines whether an element within a collection of elements exists within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-200">
            <see langword="true" /> solo se <paramref name="predicate" /> restituisce <see langword="true" /> per un elemento di tipo <paramref name="T" /> in <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-200">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2c6af-201">
            <paramref name="collection" /> o <paramref name="predicate" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-201">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="2c6af-202">Primo valore intero da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-202">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="2c6af-203">Un ulteriore valore dell'ultimo intero da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-203">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="2c6af-204">Funzione da valutare per l'esistenza degli Integer nell'intervallo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-204">The function to evaluate for the existence of the integers in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-205">Determina se una particolare condizione è valida per tutti gli Integer in un intervallo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-205">Determines whether a particular condition is valid for all integers in a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-206">
            <see langword="true" /> se <paramref name="predicate" /> restituisce <see langword="true" /> per tutti gli Integer a partire da <paramref name="fromInclusive" /> fino a <paramref name="toExclusive" /> - 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-206">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-207">Il `toExclusive` parametro è uno più di tipo integer per facilitare l'uso della lunghezza di un intervallo di interi a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="2c6af-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="2c6af-208">Ad esempio, si imposterebbe a 5 per i numeri interi da 0 a 4.</span><span class="sxs-lookup"><span data-stu-id="2c6af-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c6af-209">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodo per determinare se una matrice contiene un elemento null.</span><span class="sxs-lookup"><span data-stu-id="2c6af-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2c6af-210">
            <paramref name="predicate" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-210">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2c6af-211">
            <paramref name="toExclusive" /> è minore di <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-211">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="2c6af-212">Il tipo di contenuto in <c>raccolta</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-212">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="2c6af-213">Raccolta da cui ottenere elementi di tipo <c>T</c> da passare a <c>predicato</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="2c6af-214">Funzione da valutare per l'esistenza di tutti gli elementi della <c>raccolta</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-215">Determina se tutti gli elementi all'interno di una raccolta esistono all'interno di una funzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-215">Determines whether all the elements in a collection exist within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-216">
            <see langword="true" /> se e solo se <paramref name="predicate" /> restituisce <see langword="true" /> per tutti gli elementi di tipo <paramref name="T" /> in <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-216">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2c6af-217">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodo per determinare se una raccolta ha un elemento null.</span><span class="sxs-lookup"><span data-stu-id="2c6af-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2c6af-218">
            <paramref name="collection" /> o <paramref name="predicate" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-218">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-219">Specifica un contratto per un metodo o una proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-219">Specifies a contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-220">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-220">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-221">Specifica un contratto invariante per il metodo o la proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-221">Specifies an invariant contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> i contratti sono contenuti all'interno di un metodo che è identificato dal <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> dell'attributo; in genere, il metodo è denominato `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="2c6af-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="2c6af-223">Questo contratto può essere specificato solo in un metodo invariante dedicato che è dichiarato in una classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="2c6af-224">Se il metodo non è bloccato, deve fare riferimento solo ai membri protetti, non i membri privati, in modo che le sottoclassi possono assicurarsi di mantenere le invarianti.</span><span class="sxs-lookup"><span data-stu-id="2c6af-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="2c6af-225">Il presente contratto non viene esposto al client. Pertanto, può fare riferimento a membri che sono meno visibili il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-226">È necessario usare il rewriter binario per l'applicazione in fase di esecuzione di questo invariante.</span><span class="sxs-lookup"><span data-stu-id="2c6af-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="2c6af-227">Gli invarianti vengono definiti in modo condizionale in base alla presenza del `CONTRACTS FULL` simbolo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="2c6af-228">Durante il controllo in fase di esecuzione, le invarianti vengono controllate alla fine di ogni metodo pubblico.</span><span class="sxs-lookup"><span data-stu-id="2c6af-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="2c6af-229">Se un'invariante menziona un metodo pubblico nella stessa classe, il controllo dell'invariante che avverrebbe normalmente alla fine del metodo pubblico è disabilitato e viene controllato solo alla fine della chiamata al metodo più esterna a tale classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="2c6af-230">Ciò avviene anche se la classe viene immessa di nuovo a causa di una chiamata a un metodo in un'altra classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-231">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-231">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-232">Messaggio da visualizzare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-232">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-233">Specifica un contratto invariante per la proprietà o il metodo contenitore e visualizza un messaggio se la condizione per il contratto ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> i contratti sono contenuti all'interno di un metodo che è identificato dal <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> dell'attributo; in genere, il metodo è denominato `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="2c6af-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="2c6af-235">Questo contratto può essere specificato solo in un metodo invariante dedicato che è dichiarato in una classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="2c6af-236">Il presente contratto non viene esposto al client. Pertanto, può fare riferimento a membri che sono meno visibili il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-237">È necessario usare il rewriter binario per l'applicazione in fase di esecuzione di questo invariante.</span><span class="sxs-lookup"><span data-stu-id="2c6af-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="2c6af-238">Gli invarianti vengono definiti in modo condizionale nel `CONTRACTS FULL` simbolo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="2c6af-239">Durante il controllo in fase di esecuzione, le invarianti vengono controllate alla fine di ogni metodo pubblico.</span><span class="sxs-lookup"><span data-stu-id="2c6af-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="2c6af-240">Se un'invariante menziona un metodo pubblico nella stessa classe, il controllo dell'invariante che avverrebbe normalmente alla fine del metodo pubblico è disabilitato e viene controllato solo alla fine della chiamata al metodo più esterna a tale classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="2c6af-241">Ciò avviene anche se la classe viene immessa di nuovo a causa di una chiamata a un metodo in un'altra classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="2c6af-242">Tipo di valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-242">The type of value.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="2c6af-243">Valore da rappresentare (campo o parametro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-243">The value to represent (field or parameter).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-244">Rappresenta i valori come se fossero all'inizio di un metodo o di una proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-244">Represents values as they were at the start of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-245">Valore del parametro o del campo all'inizio di un metodo o di una proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-245">The value of the parameter or field at the start of a method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-246">Questo metodo può essere utilizzato solo nell'espressione condizionale per i <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contratto.</span><span class="sxs-lookup"><span data-stu-id="2c6af-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c6af-247">L'esempio seguente illustra l'uso del <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metodo per assicurarsi che il conteggio è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="2c6af-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="2c6af-248">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2c6af-249">Specifica un contratto di precondizione per un metodo o una proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-249">Specifies a precondition contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-250">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-250">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-251">Specifica un contratto di precondizione per il metodo o la proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-251">Specifies a precondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="2c6af-252">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-253">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-254">Usare questo metodo anziché il <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> metodo quando la compatibilità con le versioni precedenti non forza la generazione di una particolare eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="2c6af-255">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-255">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-256">Messaggio da visualizzare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-256">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-257">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e visualizza un messaggio se la condizione per il contratto ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="2c6af-258">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-259">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-260">Usare questo metodo anziché il <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metodo quando la compatibilità con le versioni precedenti non forza la generazione di una particolare eccezione.</span><span class="sxs-lookup"><span data-stu-id="2c6af-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="2c6af-261">Eccezione da generare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-261">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="2c6af-262">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-262">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-263">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e genera un'eccezione se la condizione per il contratto ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2c6af-264">È necessario attivare controllo per l'uso in fase di esecuzione di <xref:System.Diagnostics.Contracts.Contract.Requires%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2c6af-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="2c6af-265">Se il controllo di runtime è disattivato, il processo verrà terminato.</span><span class="sxs-lookup"><span data-stu-id="2c6af-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="2c6af-266">Per ottenere gli strumenti per il controllo di runtime, vedere [contratti di codice](https://go.microsoft.com/fwlink/?LinkId=152461) sul sito DevLabs Web di MSDN.</span><span class="sxs-lookup"><span data-stu-id="2c6af-266">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="2c6af-267">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-268">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-269">Usare questo metodo anziché il <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> metodo quando si desidera generare un'eccezione se la condizione preliminare ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="2c6af-270">Eccezione da generare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-270">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="2c6af-271">Espressione condizionale da sottoporre a test.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-271">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="2c6af-272">Messaggio da visualizzare se la condizione è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-272">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-273">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e genera un'eccezione con il messaggio fornito se la condizione per il contratto ha esito negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="2c6af-274">È necessario attivare controllo per l'uso in fase di esecuzione di <xref:System.Diagnostics.Contracts.Contract.Requires%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2c6af-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="2c6af-275">Se il controllo di runtime è disattivato, il processo verrà terminato.</span><span class="sxs-lookup"><span data-stu-id="2c6af-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="2c6af-276">Per ottenere gli strumenti per il controllo di runtime, vedere [contratti di codice](https://go.microsoft.com/fwlink/?LinkId=152461) sul sito DevLabs Web di MSDN.</span><span class="sxs-lookup"><span data-stu-id="2c6af-276">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="2c6af-277">Questa chiamata al metodo deve trovarsi all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</span><span class="sxs-lookup"><span data-stu-id="2c6af-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="2c6af-278">Questo contratto viene esposto al client. di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="2c6af-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="2c6af-279">Usare questo metodo anziché il <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metodo quando si desidera generare un'eccezione se la condizione preliminare ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="2c6af-280">Tipo di valore restituito del metodo o della proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-280">Type of return value of the enclosing method or property.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="2c6af-281">Rappresenta il valore restituito di un metodo o di una proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-281">Represents the return value of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-282">Valore restituito del metodo o della proprietà contenitore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-282">Return value of the enclosing method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-283">Questo metodo può essere utilizzato solo nell'espressione condizionale per i <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contratto.</span><span class="sxs-lookup"><span data-stu-id="2c6af-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c6af-284">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Contracts.Contract.Result%2A> metodo per specificare un valore restituito previsto.</span><span class="sxs-lookup"><span data-stu-id="2c6af-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="2c6af-285">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="2c6af-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn :  -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="2c6af-286">Tipo del parametro <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-286">The type of the <see langword="out" /> parameter.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="2c6af-287">Parametro <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-287">The <see langword="out" /> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2c6af-288">Rappresenta il valore finale (output) di un parametro <see langword="out" /> in caso di restituzione da un metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2c6af-289">Valore di output del parametro <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2c6af-289">The output value of the <see langword="out" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c6af-290">Questo metodo può essere utilizzato solo nell'espressione condizionale per i <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contratto.</span><span class="sxs-lookup"><span data-stu-id="2c6af-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="2c6af-291">Come per il metodo <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, è possibile omettere il parametro di tipo generico quando il compilatore è in grado di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="2c6af-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="2c6af-292">Il rewriter del contratto sostituisce la chiamata al metodo con il valore del parametro `out`.</span><span class="sxs-lookup"><span data-stu-id="2c6af-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="2c6af-293">Il metodo <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> può essere visualizzato solo nelle postcondizioni.</span><span class="sxs-lookup"><span data-stu-id="2c6af-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="2c6af-294">L'argomento del metodo deve essere un parametro `out` o un campo del parametro `out` di una struttura.</span><span class="sxs-lookup"><span data-stu-id="2c6af-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="2c6af-295">Quest'ultimo è utile anche in caso di riferimento a campi nella postcondizione di un costruttore della struttura.</span><span class="sxs-lookup"><span data-stu-id="2c6af-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>