<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Contract.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac518ccddeb7c646934cfcc1b40673135a0998cbc53.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18ccddeb7c646934cfcc1b40673135a0998cbc53</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</source>
          <target state="translated">Contiene metodi statici per la rappresentazione di contratti di programma quali precondizioni, postcondizioni e invarianti dell'oggetto.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</source>
          <target state="translated">Le classi del contratto di codice consentono di specificare precondizioni, postcondizioni e invarianti dell'oggetto nel codice.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Preconditions are requirements that must be met when entering a method or property.</source>
          <target state="translated">Le precondizioni sono requisiti da soddisfare quando si accede a un metodo o a una proprietà.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Postconditions describe expectations at the time the method or property code exits.</source>
          <target state="translated">Le postcondizioni descrivono le aspettative al momento dell'uscita dal codice del metodo o della proprietà.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Object invariants describe the expected state for a class that has no condition problems.</source>
          <target state="translated">Le invarianti dell'oggetto descrivono lo stato previsto per una classe che non presenta alcun problema di condizione.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>For more information about preconditions, postconditions, and object invariants, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](~/docs/framework/debug-trace-profile/code-contracts.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle precondizioni, postcondizioni e invarianti dell'oggetto, vedere <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](~/docs/framework/debug-trace-profile/code-contracts.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>For tools and detailed instructions for using code contracts, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Per gli strumenti e le istruzioni dettagliate per l'uso dei contratti di codice, vedere <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept>(Contratti di codice) nel sito Web MSDN DevLabs.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>You must use a binary rewriter to insert run-time enforcement of contracts.</source>
          <target state="translated">È necessario utilizzare un rewriter binario per inserire l'imposizione di contratti in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Otherwise, contracts such as the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType&gt;</ph> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</source>
          <target state="translated">In caso contrario, i contratti, ad esempio il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType&gt;</ph> metodo può essere verificata solo in modo statico e non genereranno eccezioni in fase di esecuzione se un contratto viene violato.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>You can download the binary rewriter CCRewrite from <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">È possibile scaricare il rewriter binario CCRewrite da <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> nel sito DevLabs Web di MSDN.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> page.</source>
          <target state="translated">CCRewrite dotato di un componente aggiuntivo di Visual Studio che consente di attivare l'imposizione di runtime del contratto dal progetto <bpt id="p1">**</bpt>proprietà<ept id="p1">**</ept> pagina.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>The binary rewriter and the Visual Studio add-in do not ship with <ph id="ph1">[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]</ph> or the Windows SDK.</source>
          <target state="translated">Il rewriter binario e il componente aggiuntivo di Visual Studio non vengono forniti con <ph id="ph1">[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]</ph> o il SDK di Windows.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>In debug builds, performs a run-time test for a specified condition.</source>
          <target state="translated">Nelle build di debug, esegue un test della fase di esecuzione per una condizione specificata.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>Checks for a condition; if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>, follows the escalation policy set for the analyzer.</source>
          <target state="translated">Controlla una condizione. Se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>, seguono i criteri di escalation impostati per l'analizzatore.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>The default escalation policy is to notify the attached debugger about a contract failure or to display an <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> dialog box if a debugger is not attached.</source>
          <target state="translated">I criteri di escalation dei blocchi predefiniti sono di notificare il debugger collegato un errore di contratto o di visualizzare un <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> la finestra di dialogo se non è collegato un debugger.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>Optionally, the analyzer can be instructed to throw an exception.</source>
          <target state="translated">Facoltativamente, è possibile indicare l'analizzatore per generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>A message to display if the condition is not met.</source>
          <target state="translated">Messaggio da visualizzare se la condizione non è soddisfatta.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>Checks for a condition; if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>, follows the escalation policy set by the analyzer and displays the specified message.</source>
          <target state="translated">Controlla una condizione. Se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>, seguono i criteri di escalation impostati dall'analizzatore e viene visualizzato un messaggio specificato.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The default escalation policy is to notify the attached debugger about a contract failure or to display an <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> dialog box if a debugger is not attached.</source>
          <target state="translated">I criteri di escalation dei blocchi predefiniti sono di notificare il debugger collegato un errore di contratto o di visualizzare un <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> la finestra di dialogo se non è collegato un debugger.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>Optionally, the analyzer can be instructed to throw an exception.</source>
          <target state="translated">Facoltativamente, è possibile indicare l'analizzatore per generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The <ph id="ph1">`userMessage`</ph> parameter is passed to the debugger output.</source>
          <target state="translated">Il <ph id="ph1">`userMessage`</ph> parametro viene passato all'output del debugger.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, tools may not be able to read it.</source>
          <target state="translated">Se <ph id="ph1">`userMessage`</ph> non è una stringa costante letterale, strumenti potrebbero non essere in grado di leggerlo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Instructs code analysis tools to assume that a condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Indica agli strumenti di analisi del codice di presumere che una condizione sia <ph id="ph1">&lt;see langword="true" /&gt;</ph>, anche se non è possibile provare staticamente che sia sempre <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>The conditional expression to assume <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Espressione condizionale da presumere che sia <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>Instructs code analysis tools to assume that the specified condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Indica agli strumenti di analisi del codice di presumere che la condizione specificata sia <ph id="ph1">&lt;see langword="true" /&gt;</ph>, anche se non è possibile provare staticamente che sia sempre <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>At run time, using this method is equivalent to using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29&gt;</ph> method.</source>
          <target state="translated">In fase di esecuzione, questo metodo equivale all'utilizzo di <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>The conditional expression to assume <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Espressione condizionale da presumere che sia <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>The message to post if the assumption fails.</source>
          <target state="translated">Messaggio da inserire se l'ipotesi ha esito negativo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>Instructs code analysis tools to assume that a condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and displays a message if the assumption fails.</source>
          <target state="translated">Indica agli strumenti di analisi del codice di presumere che una condizione sia <ph id="ph1">&lt;see langword="true" /&gt;</ph>, anche se non è possibile provare staticamente che sia sempre <ph id="ph2">&lt;see langword="true" /&gt;</ph>. Viene visualizzato un messaggio se l'ipotesi non riesce.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Se <ph id="ph1">`userMessage`</ph> non è una costante stringa letterale, il contratto non può essere compresa da strumenti.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>At run time, using this method is equivalent to using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">In fase di esecuzione, questo metodo equivale all'utilizzo di <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Occurs when a contract fails.</source>
          <target state="translated">Si verifica quando un contratto ha esito negativo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>The event information for this event is supplied by the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType&gt;</ph> object that is passed to the event handler.</source>
          <target state="translated">Le informazioni relative a questo evento vengono fornite dall'oggetto <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType&gt;</ph> che viene passato al gestore eventi.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</source>
          <target state="translated">Questo evento di notifica a un ambiente di applicazione gestita, ad esempio un interprete interattivo o un host del browser Web che un contratto non è riuscita.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Before doing so, it will raise an event that an application can handle as it sees fit.</source>
          <target state="translated">Prima di procedere, verrà generato un evento che un'applicazione può gestire in maniera appropriata.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>For example, if code is being run in a testing framework, you can log a test failure and then end the test.</source>
          <target state="translated">Ad esempio, se viene eseguito codice in un framework di test, si può accedere un errore del test e quindi terminare il test.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A&gt;</ph> method in the .NET Framework class library is to call each handler that is registered with the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.ContractFailed&gt;</ph> event.</source>
          <target state="translated">L'implementazione predefinita del <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A&gt;</ph> nella libreria di classi .NET Framework consiste nel chiamare ogni gestore registrato con il <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.ContractFailed&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A&gt;</ph> method for the event arguments.</source>
          <target state="translated">Le eccezioni generate dai gestori eventi vengono ignorate, mentre ogni gestore può indicare se l'errore viene gestito mediante la chiamata di <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A&gt;</ph> metodo per gli argomenti dell'evento.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>If any handler sets the failure as handled, the method returns <ph id="ph1">`null`</ph> and no further action is taken.</source>
          <target state="translated">Se un gestore imposta l'errore come gestito, il metodo restituisce <ph id="ph1">`null`</ph> e non viene eseguita alcuna azione ulteriore.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Alternatively, handlers can call the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A&gt;</ph> method to instruct the code to unwind.</source>
          <target state="translated">In alternativa, è possano chiamare i gestori di <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A&gt;</ph> metodo per indicare il codice per la rimozione.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>In that case, an exception is thrown after all handlers have executed.</source>
          <target state="translated">In tal caso, viene generata un'eccezione dopo aver eseguito tutti i gestori.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>Marks the end of the contract section when a method's contracts contain only preconditions in the <ph id="ph1">&lt;see langword="if" /&gt;</ph><ph id="ph2">-</ph><ph id="ph3">&lt;see langword="then" /&gt;</ph><ph id="ph4">-</ph><ph id="ph5">&lt;see langword="throw" /&gt;</ph> form.</source>
          <target state="translated">Contrassegna la fine della sezione del contratto quando i contratti di un metodo contengono solo precondizioni nel formato <ph id="ph1">&lt;see langword="if" /&gt;</ph><ph id="ph2">-</ph><ph id="ph3">&lt;see langword="then" /&gt;</ph><ph id="ph4">-</ph><ph id="ph5">&lt;see langword="throw" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>Most code already contains some parameter validation in the form of <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> code.</source>
          <target state="translated">Gran parte del codice contiene già la convalida dei parametri sotto forma di <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> codice.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>The contract tools recognize <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> method call, such as a <ph id="ph7">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, or <ph id="ph10">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph>.</source>
          <target state="translated">Gli strumenti dei contratti riconoscono <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> istruzioni come precondizioni quando le istruzioni vengono visualizzate prima all'interno di un metodo e l'intero set di istruzioni è seguito da un esplicita<ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> chiamata al metodo, ad esempio un <ph id="ph7">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, o <ph id="ph10">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>When <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> statements appear in this form, the contract tools recognize them as legacy-require statements.</source>
          <target state="translated">Quando <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> istruzioni vengono visualizzate in questo modulo, gli strumenti dei contratti riconoscono come legacy-richiedono istruzioni.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> form is used only if no other contracts follow the <ph id="ph2">`if`</ph><ph id="ph3">-</ph><ph id="ph4">`then`</ph><ph id="ph5">-</ph><ph id="ph6">`throw`</ph> sequences, but they should still be tagged as legacy-requires.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> modulo viene utilizzato solo se nessun altro contratto segue il <ph id="ph2">`if`</ph> <ph id="ph3">-</ph> <ph id="ph4">`then`</ph> <ph id="ph5">-</ph> <ph id="ph6">`throw`</ph> sequenze, ma ancora devono essere contrassegnate come legacy-richiede.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a postcondition contract for the enclosing method or property.</source>
          <target state="translated">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The expression may include <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph> values.</source>
          <target state="translated">L'espressione potrebbe includere i valori <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /&gt;</ph> e <ph id="ph3">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>Specifies a postcondition contract for the enclosing method or property.</source>
          <target state="translated">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property returns normally.</source>
          <target state="translated">Il <ph id="ph1">`condition`</ph> parametro specifica una postcondizione che dovrà essere <ph id="ph2">`true`</ph> quando la proprietà o un metodo contenitore restituisce normalmente.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>You must use the binary rewriter (available at <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</source>
          <target state="translated">È necessario utilizzare il rewriter binario (disponibile all'indirizzo <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> nel sito DevLabs Web di MSDN) per l'applicazione in fase di esecuzione di questa postcondizione.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> method to ensure that an expected value is returned.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> metodo per assicurarsi che venga restituito un valore previsto.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The expression may include <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph> values.</source>
          <target state="translated">L'espressione potrebbe includere i valori <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The message to display if the expression is not <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Messaggio da visualizzare se l'espressione non è <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Specifica un contratto di postcondizione per una condizione di uscita fornita e un messaggio da visualizzare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property returns normally.</source>
          <target state="translated">Il <ph id="ph1">`condition`</ph> parametro specifica una postcondizione che dovrà essere <ph id="ph2">`true`</ph> quando la proprietà o un metodo contenitore restituisce normalmente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>You must use the binary rewriter (available at <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</source>
          <target state="translated">È necessario utilizzare il rewriter binario (disponibile all'indirizzo <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> nel sito DevLabs Web di MSDN) per l'applicazione in fase di esecuzione di questa postcondizione.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Se <ph id="ph1">`userMessage`</ph> non è una costante stringa letterale, il contratto non può essere compresa da strumenti.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</source>
          <target state="translated">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The type of exception that invokes the postcondition check.</source>
          <target state="translated">Tipo di eccezione che richiama il controllo di postcondizione.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</source>
          <target state="translated">Specifica un contratto di postcondizione per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property terminates abnormally and an exception of type <ph id="ph3">`TException`</ph> is thrown.</source>
          <target state="translated">Il <ph id="ph1">`condition`</ph> parametro specifica una postcondizione che dovrà essere <ph id="ph2">`true`</ph> quando la proprietà o un metodo contenitore termina in modo anomalo e un'eccezione di tipo <ph id="ph3">`TException`</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>You must use the binary rewriter for run-time enforcement of this postcondition.</source>
          <target state="translated">È necessario utilizzare il rewriter binario per l'applicazione in fase di esecuzione di questa postcondizione.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The type of exception that invokes the postcondition check.</source>
          <target state="translated">Tipo di eccezione che richiama il controllo di postcondizione.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The message to display if the expression is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Messaggio da visualizzare se l'espressione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>Specifies a postcondition contract and a message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph> for the enclosing method or property, based on the provided exception and condition.</source>
          <target state="translated">Specifica un contratto di postcondizione e un messaggio da visualizzare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph> per il metodo o la proprietà contenitore in base all'eccezione e alla condizione fornite.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property terminates abnormally and an exception of type <ph id="ph3">`TException`</ph> is thrown.</source>
          <target state="translated">Il <ph id="ph1">`condition`</ph> parametro specifica una postcondizione che dovrà essere <ph id="ph2">`true`</ph> quando la proprietà o un metodo contenitore termina in modo anomalo e un'eccezione di tipo <ph id="ph3">`TException`</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The <ph id="ph1">`message`</ph> parameter specifies a message to display if the condition is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`message`</ph> parametro specifica un messaggio da visualizzare se la condizione è <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>You must use the binary rewriter for run-time enforcement of this postcondition.</source>
          <target state="translated">È necessario utilizzare il rewriter binario per l'applicazione in fase di esecuzione di questa postcondizione.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Se <ph id="ph1">`userMessage`</ph> non è una costante stringa letterale, il contratto non può essere compresa da strumenti.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The first integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Primo valore intero da passare a <bpt id="p1">&lt;c&gt;</bpt>predicato<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>One more than the last integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Un ulteriore valore dell'ultimo intero da passare a <bpt id="p1">&lt;c&gt;</bpt>predicato<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The function to evaluate for any value of the integer in the specified range.</source>
          <target state="translated">Funzione da valutare per un valore dell'Integer nell'intervallo specificato.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>Determines whether a specified test is true for any integer within a range of integers.</source>
          <target state="translated">Determina se un test specificato è true per qualsiasi Integer all'interno di un intervallo di Integer.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for any integer starting from <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> to <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph> per qualsiasi Integer a partire da <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> fino a <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The <ph id="ph1">`toExclusive`</ph> parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</source>
          <target state="translated">Il <ph id="ph1">`toExclusive`</ph> parametro è uno oltre l'ultimo valore integer per facilitare l'uso della lunghezza di un intervallo di valori integer a partire da 0.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>For example, it would be set to 5 for integers 0 through 4.</source>
          <target state="translated">Ad esempio, verrà impostata su 5 per numeri interi da 0 a 4.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> è minore di <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The type that is contained in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo di contenuto in <bpt id="p1">&lt;c&gt;</bpt>raccolta<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The collection from which elements of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> will be drawn to pass to <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Raccolta da cui ottenere elementi di tipo <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> da passare a <bpt id="p2">&lt;c&gt;</bpt>predicato<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The function to evaluate for an element in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Funzione da valutare per un elemento della <bpt id="p1">&lt;c&gt;</bpt>raccolta<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>Determines whether an element within a collection of elements exists within a function.</source>
          <target state="translated">Determina se un elemento all'interno di una raccolta di elementi esiste all'interno di una funzione.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if and only if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for any element of type <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> solo se <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph> per un elemento di tipo <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> o <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The first integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Primo valore intero da passare a <bpt id="p1">&lt;c&gt;</bpt>predicato<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>One more than the last integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Un ulteriore valore dell'ultimo intero da passare a <bpt id="p1">&lt;c&gt;</bpt>predicato<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The function to evaluate for the existence of the integers in the specified range.</source>
          <target state="translated">Funzione da valutare per l'esistenza degli Integer nell'intervallo specificato.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>Determines whether a particular condition is valid for all integers in a specified range.</source>
          <target state="translated">Determina se una particolare condizione è valida per tutti gli Integer in un intervallo specificato.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for all integers starting from <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> to <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph> per tutti gli Integer a partire da <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> fino a <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The <ph id="ph1">`toExclusive`</ph> parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</source>
          <target state="translated">Il <ph id="ph1">`toExclusive`</ph> parametro è uno oltre l'ultimo valore integer per facilitare l'uso della lunghezza di un intervallo di valori integer a partire da 0.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>For example, it would be set to 5 for integers 0 through 4.</source>
          <target state="translated">Ad esempio, verrà impostata su 5 per numeri interi da 0 a 4.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> method to determine whether an array has a null element.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> metodo per determinare se una matrice contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> è minore di <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The type that is contained in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo di contenuto in <bpt id="p1">&lt;c&gt;</bpt>raccolta<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The collection from which elements of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> will be drawn to pass to <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Raccolta da cui ottenere elementi di tipo <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> da passare a <bpt id="p2">&lt;c&gt;</bpt>predicato<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The function to evaluate for the existence of all the elements in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Funzione da valutare per l'esistenza di tutti gli elementi della <bpt id="p1">&lt;c&gt;</bpt>raccolta<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>Determines whether all the elements in a collection exist within a function.</source>
          <target state="translated">Determina se tutti gli elementi all'interno di una raccolta esistono all'interno di una funzione.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if and only if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for all elements of type <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se e solo se <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph> per tutti gli elementi di tipo <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> method to determine whether a collection has a null element.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> metodo per determinare se una raccolta include un elemento null.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> o <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a contract for an enclosing method or property.</source>
          <target state="translated">Specifica un contratto per un metodo o una proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>Specifies an invariant contract for the enclosing method or property.</source>
          <target state="translated">Specifica un contratto invariante per il metodo o la proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> contracts are contained within a method that is identified by the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute; typically, the method is named <ph id="ph3">`ObjectInvariant`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> i contratti sono contenuti all'interno di un metodo che è identificato dal <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attributo; in genere, il metodo è denominato <ph id="ph3">`ObjectInvariant`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This contract can be specified only in a dedicated invariant method that is declared on a class.</source>
          <target state="translated">Questo contratto può essere specificato solo in un metodo invariante dedicato che è dichiarato in una classe.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</source>
          <target state="translated">Se il metodo non è sealed, deve fare riferimento solo a membri protetti, non i membri privati, in modo che le sottoclassi possono assicurarsi di mantenere le invarianti.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</source>
          <target state="translated">Il presente contratto non è esposta ai client; Pertanto, può fare riferimento a membri che sono meno visibili del metodo contenitore.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>You must use the binary rewriter for run-time enforcement of this invariant.</source>
          <target state="translated">È necessario utilizzare il rewriter binario per l'applicazione in fase di esecuzione di questa invariante.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>Invariants are conditionally defined based on the presence of the <ph id="ph1">`CONTRACTS FULL`</ph> symbol.</source>
          <target state="translated">Le invarianti vengono definite in modo condizionale in base alla presenza del <ph id="ph1">`CONTRACTS FULL`</ph> simbolo.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>During run-time checking, invariants are checked at the end of each public method.</source>
          <target state="translated">Durante il controllo in fase di esecuzione, le invarianti vengono controllate alla fine di ogni metodo pubblico.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</source>
          <target state="translated">Se un'invariante menziona un metodo pubblico della stessa classe, il controllo dell'invariante che avverrebbe normalmente alla fine di tale metodo è disabilitato e viene controllato solo alla fine della chiamata al metodo esterno a tale classe.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This also happens if the class is re-entered because of a call to a method on another class.</source>
          <target state="translated">Ciò avviene anche se la classe viene immessa di nuovo a causa di una chiamata a un metodo in un'altra classe.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Messaggio da visualizzare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</source>
          <target state="translated">Specifica un contratto invariante per la proprietà o il metodo contenitore e visualizza un messaggio se la condizione per il contratto ha esito negativo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> contracts are contained within a method that is identified by the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute; typically, the method is named <ph id="ph3">`ObjectInvariant`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> i contratti sono contenuti all'interno di un metodo che è identificato dal <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attributo; in genere, il metodo è denominato <ph id="ph3">`ObjectInvariant`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This contract can be specified only in a dedicated invariant method that is declared on a class.</source>
          <target state="translated">Questo contratto può essere specificato solo in un metodo invariante dedicato che è dichiarato in una classe.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</source>
          <target state="translated">Il presente contratto non è esposta ai client; Pertanto, può fare riferimento a membri che sono meno visibili del metodo contenitore.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>You must use the binary rewriter for run-time enforcement of this invariant.</source>
          <target state="translated">È necessario utilizzare il rewriter binario per l'applicazione in fase di esecuzione di questa invariante.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>Invariants are conditionally defined on the <ph id="ph1">`CONTRACTS FULL`</ph> symbol.</source>
          <target state="translated">Le invarianti vengono definite in modo condizionale nel <ph id="ph1">`CONTRACTS FULL`</ph> simbolo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>During run-time checking, invariants are checked at the end of each public method.</source>
          <target state="translated">Durante il controllo in fase di esecuzione, le invarianti vengono controllate alla fine di ogni metodo pubblico.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</source>
          <target state="translated">Se un'invariante menziona un metodo pubblico della stessa classe, il controllo dell'invariante che avverrebbe normalmente alla fine di tale metodo è disabilitato e viene controllato solo alla fine della chiamata al metodo esterno a tale classe.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This also happens if the class is re-entered because of a call to a method on another class.</source>
          <target state="translated">Ciò avviene anche se la classe viene immessa di nuovo a causa di una chiamata a un metodo in un'altra classe.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The type of value.</source>
          <target state="translated">Tipo di valore.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The value to represent (field or parameter).</source>
          <target state="translated">Valore da rappresentare (campo o parametro).</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>Represents values as they were at the start of a method or property.</source>
          <target state="translated">Rappresenta i valori come se fossero all'inizio di un metodo o di una proprietà.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The value of the parameter or field at the start of a method or property.</source>
          <target state="translated">Valore del parametro o del campo all'inizio di un metodo o di una proprietà.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Questo metodo può essere utilizzato solo nell'espressione condizionale per il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contratto.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The following example shows the use of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method to ensure that a count has been updated.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> metodo per assicurarsi che sia stato aggiornato un conteggio.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a precondition contract for an enclosing method or property.</source>
          <target state="translated">Specifica un contratto di precondizione per un metodo o una proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>Specifies a precondition contract for the enclosing method or property.</source>
          <target state="translated">Specifica un contratto di precondizione per il metodo o la proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method when backward compatibility does not force you to throw a particular exception.</source>
          <target state="translated">Utilizzare questo metodo anziché il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> metodo quando non è possibile generare una particolare eccezione forza la compatibilità con le versioni precedenti.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Messaggio da visualizzare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</source>
          <target state="translated">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e visualizza un messaggio se la condizione per il contratto ha esito negativo.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method when backward compatibility does not force you to throw a particular exception.</source>
          <target state="translated">Utilizzare questo metodo anziché il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> metodo quando non è possibile generare una particolare eccezione forza la compatibilità con le versioni precedenti.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>The exception to throw if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Eccezione da generare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</source>
          <target state="translated">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e genera un'eccezione se la condizione per il contratto ha esito negativo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>You must turn on run-time checking to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> method.</source>
          <target state="translated">In fase di esecuzione per utilizzare il controllo è necessario attivare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>If run-time checking is turned off, the process will be terminated.</source>
          <target state="translated">Se il controllo in fase di esecuzione è disattivato, il processo verrà terminato.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>To obtain the tools for runtime checking, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Per ottenere gli strumenti per il controllo di runtime, vedere <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> nel sito DevLabs Web di MSDN.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method when you want to throw an exception if the precondition fails.</source>
          <target state="translated">Utilizzare questo metodo anziché il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> metodo quando si desidera generare un'eccezione se la condizione preliminare non riesce.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The exception to throw if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Eccezione da generare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Espressione condizionale da sottoporre a test.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Messaggio da visualizzare se la condizione è <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</source>
          <target state="translated">Specifica un contratto di precondizione per la proprietà o il metodo contenitore e genera un'eccezione con il messaggio fornito se la condizione per il contratto ha esito negativo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>You must turn on run-time checking to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> method.</source>
          <target state="translated">In fase di esecuzione per utilizzare il controllo è necessario attivare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>If run-time checking is turned off, the process will be terminated.</source>
          <target state="translated">Se il controllo in fase di esecuzione è disattivato, il processo verrà terminato.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>To obtain the tools for runtime checking, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Per ottenere gli strumenti per il controllo di runtime, vedere <bpt id="p1">[</bpt>contratti di codice<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> nel sito DevLabs Web di MSDN.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Questa chiamata al metodo deve essere all'inizio di un metodo o proprietà, prima di qualsiasi altro codice.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Questo contratto viene esposto ai client; di conseguenza, è necessario solo i membri di riferimento che sono visibili almeno quanto il metodo contenitore.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method when you want to throw an exception if the precondition fails.</source>
          <target state="translated">Utilizzare questo metodo anziché il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> metodo quando si desidera generare un'eccezione se la condizione preliminare non riesce.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Type of return value of the enclosing method or property.</source>
          <target state="translated">Tipo di valore restituito del metodo o della proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Represents the return value of a method or property.</source>
          <target state="translated">Rappresenta il valore restituito di un metodo o di una proprietà.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Return value of the enclosing method or property.</source>
          <target state="translated">Valore restituito del metodo o della proprietà contenitore.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Questo metodo può essere utilizzato solo nell'espressione condizionale per il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contratto.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Result%2A&gt;</ph> method to specify an expected return value.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Result%2A&gt;</ph> per specificare un valore restituito previsto.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The type of the <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Tipo del parametro <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Parametro <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>Represents the final (output) value of an <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter when returning from a method.</source>
          <target state="translated">Rappresenta il valore finale (output) di un parametro <ph id="ph1">&lt;see langword="out" /&gt;</ph> in caso di restituzione da un metodo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The output value of the <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Valore di output del parametro <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Questo metodo può essere utilizzato solo nell'espressione condizionale per il <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contratto.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>As with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</source>
          <target state="translated">Come per il metodo <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph>, è possibile omettere il parametro di tipo generico quando il compilatore è in grado di dedurre il tipo.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The contract rewriter replaces the method call with the value of the <ph id="ph1">`out`</ph> parameter.</source>
          <target state="translated">Il rewriter del contratto sostituisce la chiamata al metodo con il valore del parametro <ph id="ph1">`out`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method may appear only in postconditions.</source>
          <target state="translated">Il metodo <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> può essere visualizzato solo nelle postcondizioni.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The argument to the method must be an <ph id="ph1">`out`</ph> parameter or a field of a structure <ph id="ph2">`out`</ph> parameter.</source>
          <target state="translated">L'argomento del metodo deve essere un parametro <ph id="ph1">`out`</ph> o un campo del parametro <ph id="ph2">`out`</ph> di una struttura.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The latter is also useful when referring to fields in the postcondition of a structure constructor.</source>
          <target state="translated">Quest'ultimo è utile anche in caso di riferimento a campi nella postcondizione di un costruttore della struttura.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>