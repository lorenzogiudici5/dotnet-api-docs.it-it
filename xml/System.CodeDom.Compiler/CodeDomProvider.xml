<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b3fe8ac8c3068a185bfb6aea6297c55816857d7" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52918422" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una classe base per le implementazioni di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />. Questa classe è astratta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.CodeDom.Compiler.CodeDomProvider> può essere utilizzato per creare e recuperare le istanze di generatori di codice e compilatori di codice. È possibile utilizzare i generatori di codice per generare codice in un linguaggio particolare e i compilatori di codice per compilare codice in assembly.  
  
> [!NOTE]
>  Nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], i metodi resi disponibili in Generatore di codice e il compilatore di codice sono disponibili direttamente dal provider di codice. Non è necessario chiamare <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> o <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> per accedere a metodi e i metodi sono contrassegnati come obsoleti. Questo vale per preesistente, nonché nuove implementazioni di provider di codice.  
  
 Oggetto <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione fornisce in genere codice interfacce di compilazione di codice e/o di generazione per la generazione di codice e la gestione della compilazione per un unico linguaggio di programmazione. Alcuni linguaggi sono supportati da <xref:System.CodeDom.Compiler.CodeDomProvider> implementazioni fornite con il [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Questi linguaggi includono C#, Visual Basic, C++ e JScript. I produttori di compilatori o gli sviluppatori possono implementare il <xref:System.CodeDom.Compiler.ICodeGenerator> e <xref:System.CodeDom.Compiler.ICodeCompiler> interfacce e fornire un <xref:System.CodeDom.Compiler.CodeDomProvider> che estende il supporto CodeDOM per altri linguaggi di programmazione.  
  
 Il [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nella configurazione del computer (Machine. config) fornisce un meccanismo per gli sviluppatori e i fornitori di compilatori aggiungere impostazioni di configurazione aggiuntive <xref:System.CodeDom.Compiler.CodeDomProvider>implementazioni.  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider> classe fornisce metodi statici per individuare ed enumerare i <xref:System.CodeDom.Compiler.CodeDomProvider> implementazioni in un computer. Il <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> metodo restituisce le impostazioni per tutti i <xref:System.CodeDom.Compiler.CodeDomProvider> implementazioni in un computer. Il <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> metodo restituisce le impostazioni per uno specifico <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione, in base al nome del linguaggio di programmazione. Il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> metodo restituisce un'istanza di un <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per una lingua specifica.  
  
 Per altre informazioni dettagliate sulle impostazioni del provider del linguaggio nel file di configurazione, vedere [Schema delle impostazioni Provider di linguaggio e compilatore](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Questa classe esegue una richiesta di collegamento e una richiesta di ereditarietà a livello di classe. Oggetto <xref:System.Security.SecurityException> viene generata un'eccezione se il chiamante immediato o la classe derivata non dispone dell'autorizzazione di attendibilità. Per informazioni dettagliate sui requisiti di sicurezza, vedere [linking](~/docs/framework/misc/link-demands.md) e [richieste di ereditarietà](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 Il programma di esempio seguente può generare e compilare codice sorgente basato su un modello CodeDOM di un programma che visualizza "Hello World" utilizzando il <xref:System.Console> classe. Viene fornita un'interfaccia utente di Windows Form. L'utente può selezionare la destinazione tra i diversi linguaggio di programmazione: c#, Visual Basic e JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per un'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <block subset="none" type="overrides">
      <para>Nelle versioni 1.0 e 1.1 di .NET Framework, i provider di codice sono costituiti da implementazioni di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, e <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], il <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, e <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> metodi sono obsoleti e i metodi della <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> e <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> sono direttamente disponibili nel <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe. È necessario eseguire l'override di questi metodi nell'implementazione del provider di codice e non chiamare i metodi di base.</para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> che indica le impostazioni per la compilazione.</param>
        <param name="compilationUnits">Matrice di tipo <see cref="T:System.CodeDom.CodeCompileUnit" /> che indica il codice da compilare.</param>
        <summary>Compila un assembly in base alle strutture ad albero <see cref="N:System.CodeDom" /> contenute nella matrice di oggetti <see cref="T:System.CodeDom.CodeCompileUnit" /> specificata utilizzando le impostazioni del compilatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.CompilerResults" /> che indica i risultati della compilazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> metodo per la compatibilità con i provider preesistenti che utilizzano i compilatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non utilizza un compilatore di codice.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> che indica le impostazioni per la compilazione.</param>
        <param name="fileNames">Matrice dei nomi dei file da compilare.</param>
        <summary>Compila un assembly dal codice sorgente contenuto nei file specificati, utilizzando le impostazioni del compilatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.CompilerResults" /> che indica i risultati della compilazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> metodo per la compatibilità con i provider preesistenti che utilizzano i compilatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non utilizza un compilatore di codice.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> che indica le impostazioni del compilatore per la compilazione.</param>
        <param name="sources">Matrice di stringhe del codice sorgente da compilare.</param>
        <summary>Compila un assembly dalla matrice di stringhe specificata contenente il codice sorgente utilizzando le impostazioni del compilatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.CompilerResults" /> che indica i risultati della compilazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeCompiler> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> metodo per la compatibilità con i provider preesistenti che utilizzano i compilatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non utilizza un compilatore di codice.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo compilatore di codice.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> che può essere utilizzato per compilare rappresentazioni del codice sorgente basate su <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è obsoleto nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L'alternativa consigliata consiste nel chiamare il <xref:System.CodeDom.Compiler.ICodeCompiler> metodi che sono direttamente disponibili nel provider di codice.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], è consigliabile implementare la <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> membri nel <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe e generano un <see cref="T:System.NotSupportedException" /> quando viene chiamato questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa per la quale deve essere creato un identificatore di escape.</param>
        <summary>Crea un identificatore di escape per il valore specificato.</summary>
        <returns>Identificatore di escape per il valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> i test se l'identificatore in conflitto con riservate o parole chiave del linguaggio e in caso affermativo, restituisce un nome equivalente con la formattazione del codice di escape specifiche della lingua. Si fa riferimento a un identificatore di escape. Il carattere di escape contiene lo stesso `value` ma dispone di formattazione del codice di escape aggiunti per distinguere l'identificatore dalla parola chiave. Nei due esempi di implementazione di `value` con "@" o che raggruppano i `value` con "[" e "]".  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo generatore di codice.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo generatore di codice.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> che può essere utilizzato per generare rappresentazioni del codice sorgente basate su <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è obsoleto nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L'alternativa consigliata consiste nel chiamare il <xref:System.CodeDom.Compiler.ICodeGenerator> metodi che sono direttamente disponibili nel <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], è consigliabile implementare la <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> membri nel <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe e generano un <see cref="T:System.NotSupportedException" /> quando viene chiamato questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">Oggetto <see cref="T:System.IO.TextWriter" /> da utilizzare per l'output.</param>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo generatore di codice utilizzando per l'output l'oggetto <see cref="T:System.IO.TextWriter" /> specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> che può essere utilizzato per generare rappresentazioni del codice sorgente basate su <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa l'oggetto specificato <xref:System.IO.TextWriter> per l'output. Questo metodo supporta più la generazione di codice ottimizzato in modo incrementale aggiorna il codice sorgente.  
  
> [!NOTE]
>  L'implementazione della classe base chiama il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo, che è obsoleto nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] e i risultati un <xref:System.NotSupportedException> se un <xref:System.CodeDom.Compiler.ICodeGenerator> oggetto non viene restituito.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome file da utilizzare per l'output.</param>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo generatore di codice utilizzando per l'output il nome file specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> che può essere utilizzato per generare rappresentazioni del codice sorgente basate su <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il nome file specificato per l'output.  
  
> [!NOTE]
>  L'implementazione della classe base chiama il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo, che è obsoleto nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] e i risultati un <xref:System.NotSupportedException> se un <xref:System.CodeDom.Compiler.ICodeGenerator> oggetto non viene restituito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo parser di codice.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.ICodeParser" /> che può essere utilizzato per analizzare il codice sorgente. L'implementazione di base restituisce sempre <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un'istanza della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> per il linguaggio specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nome di linguaggio.</param>
        <summary>Ottiene un'istanza della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> per il linguaggio specificato.</summary>
        <returns>Provider CodeDOM implementato per il nome di linguaggio specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo è più comunemente utilizzato per creare un'istanza di un provider di codice in un'applicazione in grado di utilizzare uno dei diversi provider. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Consente di specificare in fase di esecuzione il provider di codice che si desidera creare un'istanza. Se si conosce in fase di progettazione codice che deve essere utilizzato provider, è necessario creare un'istanza di tale provider di codice anziché utilizzare il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> (metodo).  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> metodo restituisce un <xref:System.CodeDom.Compiler.CodeDomProvider> istanza per un nome di linguaggio specifico di; è simile alla chiamata di <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo con il tipo di provider del linguaggio. Usare <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> quando si desidera individuare in modo dinamico un'implementazione di provider configurato per un nome di linguaggio.  
  
 Se più di un'implementazione di provider è configurata per il nome della lingua <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> restituisce un'istanza del provider per l'ultimo elemento di configurazione corrispondente.  
  
 Usare il <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> overload del metodo quando si desidera che un'implementazione del provider del linguaggio specifico. Ad esempio, usare il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> metodo per ottenere un'istanza del provider che supporta il nome della lingua `"CSharp"`; utilizzare il <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> overload del metodo per ottenere un'istanza del provider in modo specifico per il <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implementazione. È consigliabile usare il [\], CultureInfo, oggetto\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5b%5D%29?displayProperty=nameWithType > metodo se si dispone di più provider di codice per una lingua e si desidera creare un'istanza di un provider di codice specifici.  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> metodo controlla se almeno un'implementazione del provider supporta un linguaggio specifico. È possibile convalidare un nome di linguaggio usando <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> prima di passarlo a <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Se si passa un nome di lingua non supportata da <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> viene generata un'eccezione.  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> metodo può essere utilizzato per determinare tutte <xref:System.CodeDom.Compiler.CodeDomProvider> implementazioni in un computer, incluse quelle aggiuntive fornite da sviluppatori e i fornitori di compilatori che sono identificati il [ &lt;System. CodeDom &gt; Elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nel file di configurazione del computer (Machine. config).  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> metodo restituisce un'istanza di un <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per una lingua specifica.  
  
 I nomi del linguaggio sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio di codice seguente determina il <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per una lingua di input e consente di visualizzare le impostazioni configurate per il provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> non è associato a un provider configurato nel computer.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="language" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">Nome di linguaggio.</param>
        <param name="providerOptions">Insieme di opzioni del provider del file di configurazione.</param>
        <summary>Ottiene un'istanza di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> per le opzioni della lingua e del provider specificate.</summary>
        <returns>Provider CodeDOM implementato per il nome di linguaggio indicato e per le opzioni specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo è più comunemente utilizzato per creare un'istanza di un provider di codice in un'applicazione in grado di utilizzare uno dei diversi provider. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> Consente di specificare in fase di esecuzione la versione del provider di codice che si desidera creare un'istanza. Se si conosce in fase di progettazione codice che deve essere utilizzato provider, è necessario creare un'istanza di tale provider di codice invece di usare il <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> (metodo).  
  
 Usare <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> quando si desidera trovare un'implementazione del provider configurato in modo dinamico per una lingua specifica e le opzioni. I nomi del linguaggio sono tra maiuscole e minuscole. Per informazioni sulle opzioni di provider supportati, vedere la documentazione specifica del provider CodeDOM.  
  
 Per informazioni sulla convalida di un provider e la chiamata di un provider se più di un'implementazione di provider è configurata per il nome della lingua, vedere la sezione Osservazioni del <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un'istanza di un provider tramite il `providerOptions` parametro.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa per la quale deve essere generato un identificatore valido.</param>
        <summary>Crea un identificatore valido per il valore specificato.</summary>
        <returns>Identificatore valido per il valore specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> verifica se l'identificatore in conflitto con riservate o parole chiave del linguaggio, e in tal caso, tenta di restituire un identificatore valido. nome che non sia in conflitto. In genere l'identificatore restituito sia solo lievemente modificato per contraddistinguere l'identificatore dalla parola chiave; ad esempio, il nome potrebbe essere preceduto dal carattere di sottolineatura ("_").  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'estensione del nome file predefinita da utilizzare per i file di origine nel linguaggio corrente.</summary>
        <value>Estensione del nome file corrispondente all'estensione dei file di origine del linguaggio corrente. L'implementazione di base restituisce sempre <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene utilizzata per i generatori di codice e compilatori di codice per indicare quali estensioni di file devono essere generate o utilizzate.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'istanza di <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. L'esempio visualizza il nome del provider, hash predefinito e codice di estensione di file per la nuova istanza del provider.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">Oggetto <see cref="T:System.CodeDom.CodeCompileUnit" /> per il quale deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per l'unità di compilazione CodeDOM (Code Document Object Model) specificata e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> metodo per generare codice per un'applicazione "Hello World" da un <xref:System.CodeDom.CodeCompileUnit>. In questo esempio fa parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">Oggetto <see cref="T:System.CodeDom.CodeExpression" /> che indica l'espressione per la quale deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per l'espressione CodeDOM (Code Document Object Model) specificata e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">Oggetto <see cref="T:System.CodeDom.CodeTypeMember" /> che indica il membro per il quale deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per la dichiarazione di membro CodeDOM (Code Document Object Model) specificata e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementazione della classe base genera un <xref:System.NotImplementedException>. Vedere <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> per la documentazione che descrive un'implementazione di questo metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> metodo come implementato dal <xref:Microsoft.CSharp.CSharpCodeProvider> e <xref:Microsoft.VisualBasic.VBCodeProvider> classi.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Il metodo non viene sottoposto a override in una classe derivata.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Oggetto <see cref="T:System.CodeDom.CodeNamespace" /> che indica lo spazio dei nomi per il quale deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per lo spazio dei nomi CodeDOM (Code Document Object Model) specificato e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">Oggetto <see cref="T:System.CodeDom.CodeStatement" /> contenente gli elementi CodeDOM per i quali deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per l'istruzione CodeDOM (Code Document Object Model) specificata e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">Oggetto <see cref="T:System.CodeDom.CodeTypeDeclaration" /> che indica il tipo per il quale deve essere generato il codice.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> a cui viene inviato il codice di output.</param>
        <param name="options">Oggetto <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> che indica le opzioni da utilizzare per la generazione del codice.</param>
        <summary>Genera il codice per la dichiarazione di tipo CodeDOM (Code Document Object Model) specificata e lo invia al writer di testo indicato utilizzando le opzioni selezionate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce le impostazioni di configurazione del compilatore e del provider del linguaggio per il computer.</summary>
        <returns>Una matrice di tipo <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> che rappresenta le impostazioni di tutte le implementazioni di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> metodo per enumerare le impostazioni del provider del linguaggio in un computer.  
  
> [!NOTE]
>  Nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], il provider di linguaggi predefiniti forniti da .NET Framework non incluse nel [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) configurazione del compilatore sezione e non può essere rimosso, pertanto questo metodo restituisce informazioni sui provider predefiniti ed eventuali specificato nel file di configurazione.  
  
   
  
## Examples  
 Esempio di codice seguente enumera i provider del linguaggio nel computer e vengono visualizzate le impostazioni di configurazione e del compilatore per ogni provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nome di linguaggio.</param>
        <summary>Restituisce le impostazioni di configurazione del compilatore e del provider del linguaggio per il linguaggio specificato.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> in cui sono inserite le impostazioni dell'implementazione della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nella configurazione della macchina file contiene le impostazioni di configurazione del compilatore e del provider del linguaggio per ogni <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione nel computer. Per informazioni sui file di configurazione di computer, vedere la sezione file di configurazione macchina in [configurazione delle app](~/docs/framework/configure-apps/index.md). Il <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Cerca in ogni elemento di configurazione del provider per il nome della lingua specificata. L'oggetto restituito <xref:System.CodeDom.Compiler.CompilerInfo> istanza contiene le impostazioni di lingua configurate del provider e del compilatore.  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> metodo controlla se almeno un'implementazione del provider supporta un linguaggio specifico. È possibile convalidare un nome di linguaggio usando <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> prima di passarlo a <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Ciò impedisce la generazione di un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> quando si accede di <xref:System.CodeDom.Compiler.CompilerInfo> istanza per il nome di lingua non supportata.  
  
 Se più di un'implementazione di provider è configurata per il nome di lingua di input, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> restituisce le impostazioni dal provider corrispondente ultimo elemento di configurazione.  
  
 I nomi del linguaggio sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio di codice seguente determina il <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per una lingua di input e consente di visualizzare le impostazioni configurate per il provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="language" /> non è associato a un provider configurato nel computer.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">L'elemento <paramref name="language" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di oggetto per il quale recuperare un convertitore di tipi.</param>
        <summary>Ottiene un <see cref="T:System.ComponentModel.TypeConverter" /> per il tipo di dati specificato.</summary>
        <returns>Un <see cref="T:System.ComponentModel.TypeConverter" /> per il tipo specificato oppure <see langword="null" /> se non è possibile trovare un <see cref="T:System.ComponentModel.TypeConverter" /> per il tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe derivata può eseguire l'override di questo metodo per fornire tipi di convertitori di tipi specifici per i tipi di dati specifico.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">Estensione di file.</param>
        <summary>Restituisce un nome di linguaggio associato all'estensione di file specificata, in base alle impostazioni nella sezione di configurazione del compilatore <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <returns>Nome di linguaggio associato all'estensione di file, in base alle impostazioni di configurazione del compilatore <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nella configurazione del computer (Machine. config) contiene le impostazioni di configurazione del compilatore e del provider del linguaggio per ogni <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione di computer. Il <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> Cerca in ogni elemento di configurazione del provider per l'estensione del nome file specificato.  
  
 Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> metodo controlla se l'implementazione di almeno un provider supporta un'estensione di file specifico. È possibile convalidare un'estensione di file mediante <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> prima di passarlo a <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Ciò impedisce <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> generi un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> per un'estensione del nome file non è supportato.  
  
 Se un'implementazione del provider supporta l'estensione del nome file di input e più linguaggi supportati sono configurate per i provider, quindi <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> restituisce il primo nome di linguaggio per tale provider. Se più di un'implementazione di provider è configurata per l'estensione del nome file di input, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> restituisce il nome della lingua dall'ultimo provider corrisponda elemento di configurazione.  
  
 I nomi di lingua e le estensioni di file sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio di codice seguente determina il <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per un'estensione del nome file di input e consente di visualizzare le impostazioni configurate per il provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="extension" /> non è associato a un provider configurato nel computer.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">L'elemento <paramref name="extension" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">Oggetto <see cref="T:System.CodeDom.CodeTypeReference" /> che indica il tipo da restituire.</param>
        <summary>Ottiene il tipo indicato dall'oggetto <see cref="T:System.CodeDom.CodeTypeReference" /> specificato.</summary>
        <returns>Rappresentazione testo del tipo specificato, formattata per il linguaggio in cui viene generato il codice dal generatore di codice. In Visual Basic ad esempio se si passa un oggetto <see cref="T:System.CodeDom.CodeTypeReference" /> per il tipo <see cref="T:System.Int32" /> viene restituito "Integer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">Estensione di file.</param>
        <summary>Verifica se un'estensione di file è associata a un'implementazione della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurata nel computer.</summary>
        <returns>
          <see langword="true" /> se un'implementazione di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> è configurata per l'estensione di file specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nella configurazione del computer (Machine. config) contiene le impostazioni di configurazione del compilatore e del provider del linguaggio per ogni <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione di computer. Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Cerca in elementi di configurazione del provider per l'estensione del nome file specificato.  
  
 Estensioni di file sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio di codice seguente determina il <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per un'estensione del nome file di input e consente di visualizzare le impostazioni configurate per il provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="extension" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">Nome di linguaggio.</param>
        <summary>Verifica se per un linguaggio è configurata un'implementazione della classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> nel computer.</summary>
        <returns>
          <see langword="true" /> se un'implementazione di <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> è configurata per il linguaggio specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [ &lt;System. CodeDom&gt; elemento](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) nella configurazione del computer (Machine. config) contiene le impostazioni di configurazione del compilatore e del provider del linguaggio per ogni <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione di computer. Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Cerca in elementi di configurazione del provider per il nome della lingua specificata.  
  
 I nomi del linguaggio sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio di codice seguente determina il <xref:System.CodeDom.Compiler.CodeDomProvider> implementazione per una lingua di input e consente di visualizzare le impostazioni configurate per il provider del linguaggio. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="language" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schema di impostazioni del compilatore e del provider di linguaggi</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui verificare la validità come identificatore.</param>
        <summary>Restituisce un valore che indica se il valore specificato rappresenta un identificatore valido per il linguaggio corrente.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è un identificatore valido, in caso contrario <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo verifica se un identificatore è valido. Il <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> metodo è specifico del provider. Gli identificatori che sono validi per un provider potrebbero non essere validi per gli altri provider. Se `value` contiene caratteri di fuori dell'intervallo di caratteri ASCII, controllare l'identificatore per tutte le lingue che può essere usato per compilare il codice.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> in una classe derivata, il metodo restituisca la progettazione <see langword="true" /> solo se il valore conforme alle regole della lingua e non in conflitto con una parola chiave.  
  
Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un identificatore delle funzionalità del linguaggio.</summary>
        <value>Oggetto <see cref="T:System.CodeDom.Compiler.LanguageOptions" /> che indica speciali funzionalità del linguaggio.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">Oggetto <see cref="T:System.IO.TextReader" /> utilizzato per leggere il codice da analizzare.</param>
        <summary>Compila il codice letto dal flusso di testo specificato in un oggetto <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Oggetto <see cref="T:System.CodeDom.CodeCompileUnit" /> che contiene una rappresentazione del codice analizzato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeParser> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeParser> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un parser nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> metodo per la compatibilità con i provider preesistenti che utilizzano i parser di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non utilizza un parser di codice.</para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Oggetto <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> che indica il tipo di supporto per la generazione di codice da verificare.</param>
        <param name="supports">Oggetto <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> che indica il tipo di supporto per la generazione di codice da verificare.</param>
        <summary>Restituisce un valore che indica se viene fornito il supporto per la generazione di codice specificato.</summary>
        <returns>
          <see langword="true" /> se viene fornito il supporto specificato per la generazione di codice, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere chiamato con numerosi <xref:System.CodeDom.Compiler.GeneratorSupport> flag in una sola volta da testare per una gamma di funzionalità a far parte di un set di flag di funzionalità appropriate insieme a un file binario `OR` operatore (&#124;).  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo metodo viene fornito per il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione restituito dal <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> metodo del provider. Nella versione 2.0, questo metodo può essere chiamato direttamente sul provider di codice anche se non vengono sostituiti dal provider di codice. Se il provider di codice non esegue l'override di questo metodo, il <xref:System.CodeDom.Compiler.ICodeGenerator> implementazione viene chiamata dalla classe di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Né questo metodo né il metodo <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> vengono sottoposti a override in una classe derivata.</exception>
        <block subset="none" type="overrides">
          <para>Se si esegue l'override di questo metodo, è necessario non chiamare il metodo della classe di base corrispondente. Il metodo di classe di base crea un generatore di nella classe derivata utilizzando l'obsoleto <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> metodo per la compatibilità con i provider preesistenti che usano i generatori di codice. Il metodo della classe base chiama quindi il metodo equivalente <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementazione per eseguire questa funzione. Si otterrà un <see cref="T:System.NotImplementedException" /> se si chiama il metodo di classe di base da un provider di codice che non usa un generatore di codice.</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>