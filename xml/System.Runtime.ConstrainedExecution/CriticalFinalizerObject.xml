<Type Name="CriticalFinalizerObject" FullName="System.Runtime.ConstrainedExecution.CriticalFinalizerObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1d2facb08d43ad654cb2b085fefa826d0c99cd7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30478045" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalFinalizerObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalFinalizerObject abstract" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Assicura che tutto il codice di finalizzazione nelle classi derivate sia contrassegnato come critico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dalla <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe in modo implicito vengono considerati come un'area a esecuzione vincolata (CER).  Questo richiede il codice del finalizzatore deve chiamare solo il codice con un contratto di affidabilità. Per ulteriori informazioni su CER, vedere il <xref:System.Runtime.ConstrainedExecution> dello spazio dei nomi.  
  
 Nelle classi derivate dal <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> (classe), common language runtime (CLR) garantisce che tutto il codice di finalizzazione critica avrà la possibilità di esecuzione, purché il finalizzatore segue le regole per una CER, anche in situazioni in cui il Common Language Runtime forzatamente scaricato il dominio applicazione o si interrompe un thread. Se un finalizzatore viola le regole per una CER, potrebbe non eseguire correttamente. Inoltre, CLR consente di stabilire un ordine debole tra finalizzatori normali e: per gli oggetti recuperati tramite garbage collection contemporaneamente, tutti i finalizzatori non critici vengono chiamati prima di qualsiasi dei finalizzatori. Ad esempio, una classe, ad esempio <xref:System.IO.FileStream>, che contiene i dati di <xref:System.Runtime.InteropServices.SafeHandle> classe che deriva da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, può essere eseguito un finalizzatore standard per cancellare i dati memorizzati nel buffer.  
  
 Nella maggior parte dei casi, non è necessario scrivere le classi che derivano dalla <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe. La libreria di classi .NET Framework fornisce due classi, <xref:System.Runtime.InteropServices.SafeHandle> e <xref:System.Runtime.InteropServices.CriticalHandle>, che forniscono funzionalità di finalizzazione critica per le risorse di handle. Inoltre, .NET Framework fornisce un set di classi prescritte derivate dal <xref:System.Runtime.InteropServices.SafeHandle> classe e questo set si trova nel <xref:Microsoft.Win32.SafeHandles> dello spazio dei nomi. Queste classi sono progettate per fornire funzionalità comuni per il supporto di handle di file e sistema operativo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe finalizzazione critica per l'input standard e i flussi di output. Il <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, derivata dal <xref:System.Runtime.InteropServices.SafeHandle> classe, viene passato al flusso di dati di <xref:System.IO.FileStream> costruttore.  
  
 [!code-csharp[SafeHandle.SafeFileHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle.SafeFileHandle/CS/program.cs#1)]
 [!code-vb[SafeHandle.SafeFileHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle.SafeFileHandle/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalFinalizerObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalFinalizerObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione per chiamare codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalFinalizerObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalFinalizerObject ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dalla classe <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il finalizzatore per i tipi che derivano da <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> è data la possibilità di eseguire e non verrà interrotto, presupponendo che il finalizzatore correttamente segue le regole per un'area a esecuzione vincolata (CER).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>