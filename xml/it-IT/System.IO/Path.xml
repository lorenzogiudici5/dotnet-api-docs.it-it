<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Path.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c0ef473bd6615db5908afedacb6564d0e78685953.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0ef473bd6615db5908afedacb6564d0e78685953</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Performs operations on <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> instances that contain file or directory path information.</source>
          <target state="translated">Esegue operazioni sulle istanze <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> che contengono informazioni sul percorso di file o directory.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>These operations are performed in a cross-platform manner.</source>
          <target state="translated">Le operazioni vengono eseguite su più piattaforme.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path is a string that provides the location of a file or directory.</source>
          <target state="translated">Un percorso è una stringa che fornisce la posizione di un file o directory.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</source>
          <target state="translated">Un percorso non è necessariamente punta a una posizione sul disco. ad esempio, potrebbe eseguire il mapping di un percorso in una posizione in memoria o su un dispositivo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The exact format of a path is determined by the current platform.</source>
          <target state="translated">Il formato esatto di un percorso è determinato dalla piattaforma corrente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</source>
          <target state="translated">In alcuni sistemi, ad esempio, un percorso può iniziare con una lettera di unità o volume, mentre l'elemento non è presente in altri sistemi.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</source>
          <target state="translated">In alcuni sistemi, i percorsi di file possono contenere le estensioni che indicano il tipo di informazioni archiviate nel file.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</source>
          <target state="translated">Il formato di un'estensione di file è dipendente dalla piattaforma. ad esempio, alcuni sistemi di limitano le estensioni a tre caratteri e non altre.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</source>
          <target state="translated">La piattaforma corrente determina anche il set di caratteri utilizzato per separare gli elementi di un percorso e il set di caratteri che non può essere utilizzato quando si specificano i percorsi.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because of these differences, the fields of the <ph id="ph1">`Path`</ph> class as well as the exact behavior of some members of the <ph id="ph2">`Path`</ph> class are platform-dependent.</source>
          <target state="translated">A causa di tali differenze, i campi del <ph id="ph1">`Path`</ph> classe nonché il comportamento di alcuni membri della <ph id="ph2">`Path`</ph> classe dipendono dalla piattaforma.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path can contain absolute or relative location information.</source>
          <target state="translated">Un percorso può contenere informazioni sul percorso assoluto o relativo.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</source>
          <target state="translated">Percorsi assoluti completamente specificano un percorso: il file o directory può essere identificata indipendentemente dalla posizione corrente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</source>
          <target state="translated">I percorsi relativi specificano un percorso parziale: il percorso corrente viene utilizzato come punto di partenza per l'individuazione di un file specificato con un percorso relativo.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>To determine the current directory, call <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per determinare la directory corrente, chiamare <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Most members of the <ph id="ph1">`Path`</ph> class do not interact with the file system and do not verify the existence of the file specified by a path string.</source>
          <target state="translated">La maggior parte dei membri del <ph id="ph1">`Path`</ph> classe non interagiscono con il file system e non verifica l'esistenza del file specificato da una stringa di percorso.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> class members that modify a path string, such as <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, have no effect on names of files in the file system.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> modificano una stringa di percorso, ad esempio i membri di classe <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, non hanno alcun effetto sui nomi dei file nel file system.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> members do, however, validate the contents of a specified path string, and throw an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> i membri, tuttavia, convalidare il contenuto di una stringa di percorso specificato e genera un <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> eccezione se la stringa contiene caratteri non validi nelle stringhe di percorso, come definito nei caratteri restituiti dal <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</source>
          <target state="translated">Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere le virgolette ("), minore di (<ph id="ph1">\&lt;</ph>), maggiore di (&gt;), barra verticale (&amp;#124;), backspace (\b), null (\0) e i caratteri Unicode 16 a 18 e 20 e 25.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The members of the <ph id="ph1">`Path`</ph> class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</source>
          <target state="translated">I membri del <ph id="ph1">`Path`</ph> classe consentono di eseguire rapidamente e facilmente operazioni comuni, ad esempio consentono di determinare se un'estensione di file fa parte di un percorso e combinare due stringhe in un nome di percorso.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>All members of the <ph id="ph1">`Path`</ph> class are static and can therefore be called without having an instance of a path.</source>
          <target state="translated">Tutti i membri del <ph id="ph1">`Path`</ph> classe sono statica e possono quindi essere chiamati senza un'istanza di un percorso.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">I membri che accettano un percorso come una stringa di input, che il percorso deve essere corretto o viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">Ad esempio, se un percorso completo inizia con uno spazio, il percorso non viene ritagliato in metodi della classe.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">Pertanto, il percorso sia valido e viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">Analogamente, un percorso o una combinazione di percorsi non può essere completo due volte.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">Ad esempio, "c:\temp c:\windows" genera anche un'eccezione nella maggior parte dei casi.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">Verificare che i percorsi siano ben formati quando si utilizzano i metodi che accettano una stringa di percorso.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">Nei membri che accettano un percorso, il percorso può fare riferimento a un file o solo una directory.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">Il percorso specificato può anche fare riferimento a un percorso relativo o un percorso UNC Universal Naming Convention () per un nome di server e la condivisione.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">Ad esempio, le condizioni seguenti sono percorsi accettabili:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in c# o "c:\MyDir\MyFile.txt" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir" in c# o "c:\MyDir" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">"MyDir<ph id="ph1">\\</ph>\MySubdir" in c# o "MyDir\MySubDir" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in c#, o "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</source>
          <target state="translated">Perché tutte queste operazioni vengono eseguite su stringhe, non è possibile verificare che i risultati sono validi in tutti gli scenari.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> method parses a string that you pass to it and returns the extension from that string.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> metodo analizza una stringa che vengono passati e restituisce l'estensione da tale stringa.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>However, this does not mean that a file with that extension exists on the disk.</source>
          <target state="translated">Tuttavia, ciò non significa che un file con estensione esista sul disco.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The following code example demonstrates some of the main members of the <ph id="ph1">`Path`</ph> class.</source>
          <target state="translated">Esempio di codice seguente vengono illustrati alcuni dei membri principali del <ph id="ph1">`Path`</ph> classe.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Fornisce un carattere alternativo specifico della piattaforma usato per separare i livelli di directory in una stringa di percorso che riflette un'organizzazione di file system gerarchica.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Il carattere archiviato in questo campo non può essere <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>This field can be set to the same value as <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Questo campo può essere impostato sullo stesso valore di <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source><ph id="ph1">`AltDirectorySeparatorChar`</ph> and <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">`AltDirectorySeparatorChar`</ph> e <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> sono entrambi validi per separare i livelli di directory in una stringa di percorso.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</source>
          <target state="translated">Il valore di questo campo è una barra ('/') nei sistemi operativi Windows, UNIX e Macintosh.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The following code example demonstrates a use of the <ph id="ph1">`AltDirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un utilizzo del <ph id="ph1">`AltDirectorySeparatorChar`</ph> campo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path information to modify.</source>
          <target state="translated">Informazioni sul percorso da modificare.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path cannot contain any of the characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Il percorso non può contenere i caratteri definiti in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The new extension (with or without a leading period).</source>
          <target state="translated">Nuova estensione, con o senza un punto iniziale.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> to remove an existing extension from <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per rimuovere un'estensione esistente da <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Changes the extension of a path string.</source>
          <target state="translated">Cambia l'estensione di una stringa di percorso.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The modified path information.</source>
          <target state="translated">Informazioni sul percorso modificato.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>On Windows-based desktop platforms, if <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string (""), the path information is returned unmodified.</source>
          <target state="translated">Nelle piattaforme desktop basate su Windows, se <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una stringa vuota (""), le informazioni sul percorso verranno restituite immutate.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the returned string contains the specified path with its extension removed.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, la stringa restituita conterrà il percorso specificato senza estensione.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> has no extension, and <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the returned path string contains <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> appended to the end of <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="path" /&gt;</ph> non ha estensione e <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> non è <ph id="ph3">&lt;see langword="null" /&gt;</ph>, la stringa di percorso restituita conterrà <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> alla fine di <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If neither <ph id="ph1">`path`</ph> nor <ph id="ph2">`extension`</ph> contains a period (.), <ph id="ph3">`ChangeExtension`</ph> adds the period.</source>
          <target state="translated">Se non si specifica <ph id="ph1">`path`</ph> né <ph id="ph2">`extension`</ph> contiene un punto (.), <ph id="ph3">`ChangeExtension`</ph> aggiunge il periodo.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The <ph id="ph1">`extension`</ph> parameter can contain multiple periods and any valid path characters, and can be any length.</source>
          <target state="translated">Il <ph id="ph1">`extension`</ph> parametro può contenere più periodi e i caratteri di percorso valido e può essere qualsiasi lunghezza.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is <ph id="ph2">`null`</ph>, the returned string contains the contents of <ph id="ph3">`path`</ph> with the last period and all characters following it removed.</source>
          <target state="translated">Se <ph id="ph1">`extension`</ph> è <ph id="ph2">`null`</ph>, la stringa restituita conterrà il contenuto di <ph id="ph3">`path`</ph> con l'ultimo periodo e tutti i caratteri successivi viene rimosso.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is an empty string, the returned path string contains the contents of <ph id="ph2">`path`</ph> with any characters following the last period removed.</source>
          <target state="translated">Se <ph id="ph1">`extension`</ph> è una stringa vuota, la stringa di percorso restituita contiene il contenuto di <ph id="ph2">`path`</ph> con i caratteri successivi all'ultimo punto rimosso.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> does not have an extension and <ph id="ph2">`extension`</ph> is not <ph id="ph3">`null`</ph>, the returned string contains <ph id="ph4">`path`</ph> followed by <ph id="ph5">`extension`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> non dispone di un'estensione e <ph id="ph2">`extension`</ph> non <ph id="ph3">`null`</ph>, la stringa restituita conterrà <ph id="ph4">`path`</ph> seguito da <ph id="ph5">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is not <ph id="ph2">`null`</ph> and does not contain a leading period, the period is added.</source>
          <target state="translated">Se <ph id="ph1">`extension`</ph> non <ph id="ph2">`null`</ph> e non contiene un punto iniziale, quest ' ultimo viene aggiunto.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> contains a multiple extension separated by multiple periods, the returned string contains the contents of <ph id="ph2">`path`</ph> with the last period and all characters following it replaced by <ph id="ph3">`extension`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> contiene un'estensione multipla separata da più punti, la stringa restituita conterrà il contenuto di <ph id="ph2">`path`</ph> con l'ultimo periodo e tutti i caratteri successivi viene sostituito da <ph id="ph3">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is "\Dir1\examples\pathtests.csx.txt" and <ph id="ph2">`extension`</ph> is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`path`</ph> è "\Dir1\examples\pathtests.csx.txt" e <ph id="ph2">`extension`</ph> è "cs", il percorso modificato è "\Dir1\examples\pathtests.csx.cs".</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>It is not possible to verify that the returned results are valid in all scenarios.</source>
          <target state="translated">Non è possibile verificare che i risultati restituiti sono validi in tutti gli scenari.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is empty, <ph id="ph2">`extension`</ph> is appended.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`path`</ph> è vuoto, <ph id="ph2">`extension`</ph> viene aggiunto.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`ChangeExtension`</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un utilizzo del <ph id="ph1">`ChangeExtension`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Combines strings into a path.</source>
          <target state="translated">Combina stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>An array of parts of the path.</source>
          <target state="translated">Matrice di parti del percorso.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Combines an array of strings into a path.</source>
          <target state="translated">Combina una matrice di stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The combined paths.</source>
          <target state="translated">Percorsi combinati.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source><ph id="ph1">`paths`</ph> should be an array of the parts of the path to combine.</source>
          <target state="translated"><ph id="ph1">`paths`</ph> deve essere una matrice delle parti del percorso da combinare.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</source>
          <target state="translated">Se uno dei percorsi successivi è un percorso assoluto, l'operazione di combinazione Reimposta a partire da quel percorso assoluto, eliminando tutti i percorsi combinati precedenti.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Stringhe di lunghezza zero vengono omessi dal percorso combinato.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">I parametri non vengono analizzati se contengono spazi vuoti.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il <ph id="ph1">`Combine`</ph> (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Ad esempio, mentre <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Di conseguenza viene interpretato correttamente dal <ph id="ph1">`Combine`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The following example combines an array of strings into a path.</source>
          <target state="translated">Nell'esempio seguente combina una matrice di stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array contains one or more of the invalid characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Una delle stringhe nella matrice contiene almeno un carattere non valido definito in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Una delle stringhe nella matrice è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Primo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Secondo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Combines two strings into a path.</source>
          <target state="translated">Combina due stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Percorsi combinati.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If one of the specified paths is a zero-length string, this method returns the other path.</source>
          <target state="translated">Se uno dei percorsi specificati è una stringa di lunghezza zero, il metodo restituirà solo l'altro percorso.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contains an absolute path, this method returns <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contiene un percorso assoluto, il metodo restituisce <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Se <ph id="ph1">`path1`</ph> non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> viene aggiunto al <ph id="ph6">`path1`</ph> prima della concatenazione.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> non include una radice (ad esempio, se <ph id="ph2">`path2`</ph> non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> include una directory radice, <ph id="ph2">`path2`</ph> viene restituito.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">I parametri non vengono analizzati se contengono spazi vuoti.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph> instead of returning only <ph id="ph5">`path2`</ph>.</source>
          <target state="translated">Pertanto, se <ph id="ph1">`path2`</ph> include uno spazio vuoto (ad esempio, "\file.txt"), il <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> metodo aggiunge <ph id="ph3">`path2`</ph> a <ph id="ph4">`path1`</ph> anziché restituire solo <ph id="ph5">`path2`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il <ph id="ph1">`Combine`</ph> (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Ad esempio, mentre <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Di conseguenza viene interpretato correttamente dal <ph id="ph1">`Combine`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`Combine`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo di <ph id="ph1">`Combine`</ph> metodo in una piattaforma desktop basati su Windows.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contiene uno o più caratteri non validi definiti in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Primo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Secondo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Terzo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Combines three strings into a path.</source>
          <target state="translated">Combina tre stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Percorsi combinati.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").</source>
          <target state="translated"><ph id="ph1">`path1`</ph> deve essere un percorso assoluto (ad esempio, "d:\archives" o "<ph id="ph2">\\</ph>\archives\public").</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> or <ph id="ph2">`path3`</ph> is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> o <ph id="ph2">`path3`</ph> è anche un percorso assoluto, la combinazione operazione Elimina combinati precedentemente tutti i percorsi e reimposta il percorso assoluto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Stringhe di lunghezza zero vengono omessi dal percorso combinato.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Se <ph id="ph1">`path1`</ph> non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> viene aggiunto al <ph id="ph6">`path1`</ph> prima della concatenazione.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> non include una radice (ad esempio, se <ph id="ph2">`path2`</ph> non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> include una directory radice, <ph id="ph2">`path2`</ph> viene restituito.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">I parametri non vengono analizzati se contengono spazi vuoti.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Pertanto, se <ph id="ph1">`path2`</ph> include uno spazio vuoto (ad esempio, "\file.txt"), il <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> metodo aggiunge <ph id="ph3">`path2`</ph> a <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il <ph id="ph1">`Combine`</ph> (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Ad esempio, mentre <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Di conseguenza viene interpretato correttamente dal <ph id="ph1">`Combine`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The following example combines three paths.</source>
          <target state="translated">Nell'esempio seguente combina tre percorsi.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contiene uno o più dei caratteri non validi definiti in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Primo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Secondo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Terzo percorso da combinare.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The fourth path to combine.</source>
          <target state="translated">Quarto percorso da combinare.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Combines four strings into a path.</source>
          <target state="translated">Combina quattro stringhe in un percorso.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Percorsi combinati.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated"><ph id="ph1">`path1`</ph> deve essere un percorso assoluto (ad esempio, "d:\archives" o "<ph id="ph2">\\</ph>\archives\public"). Se uno dei percorsi successivi è anche un percorso assoluto, l'operazione di combinazione ignora tutti i percorsi precedentemente combinati e reimposta il percorso assoluto.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Stringhe di lunghezza zero vengono omessi dal percorso combinato.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Se <ph id="ph1">`path1`</ph> non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> viene aggiunto al <ph id="ph6">`path1`</ph> prima della concatenazione.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> non include una radice (ad esempio, se <ph id="ph2">`path2`</ph> non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Se <ph id="ph1">`path2`</ph> include una directory radice, <ph id="ph2">`path2`</ph> viene restituito.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">I parametri non vengono analizzati se contengono spazi vuoti.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Pertanto, se <ph id="ph1">`path2`</ph> include uno spazio vuoto (ad esempio, "\file.txt"), il <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> metodo aggiunge <ph id="ph3">`path2`</ph> a <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il <ph id="ph1">`Combine`</ph> (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Ad esempio, mentre <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Di conseguenza viene interpretato correttamente dal <ph id="ph1">`Combine`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The following example combines four paths.</source>
          <target state="translated">Nell'esempio seguente combina quattro percorsi.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> o <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contiene uno o più dei caratteri non validi definiti in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> o <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Fornisce un carattere specifico della piattaforma usato per separare i livelli di directory in una stringa di percorso che riflette un'organizzazione di file system gerarchica.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Il carattere archiviato in questo campo non può essere <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> and <ph id="ph2">`DirectorySeparatorChar`</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> e <ph id="ph2">`DirectorySeparatorChar`</ph> sono entrambi validi per separare i livelli di directory in una stringa di percorso.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`DirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`DirectorySeparatorChar`</ph> campo.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The path of a file or directory.</source>
          <target state="translated">Percorso di un file o di una directory.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns the directory information for the specified path string.</source>
          <target state="translated">Restituisce le informazioni sulla directory per la stringa di percorso specificata.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Directory information for <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if <ph id="ph3">&lt;paramref name="path" /&gt;</ph> denotes a root directory or is null.</source>
          <target state="translated">Informazioni sulla directory per <ph id="ph1">&lt;paramref name="path" /&gt;</ph> o <ph id="ph2">&lt;see langword="null" /&gt;</ph> se <ph id="ph3">&lt;paramref name="path" /&gt;</ph> indica una directory radice o è Null.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> does not contain directory information.</source>
          <target state="translated">Restituisce <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> se <ph id="ph2">&lt;paramref name="path" /&gt;</ph> non contiene informazioni sulla directory.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In most cases, the string returned by this method consists of all characters in the path up to but not including the last <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Nella maggior parte dei casi, la stringa restituita da questo metodo è costituito da tutti i caratteri del percorso fino all'ultimo escluso <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> o <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>If the path consists of a root directory, such as "c:<ph id="ph1">\\</ph>", null is returned.</source>
          <target state="translated">Se il percorso costituito da una directory radice, ad esempio "c:<ph id="ph1">\\</ph>", viene restituito null.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Note that this method does not support paths using "file:".</source>
          <target state="translated">Si noti che questo metodo non supporta percorsi utilizzando "file:".</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Because the returned path does not include the <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passing the returned path back into the <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will result in the truncation of one folder level per subsequent call on the result string.</source>
          <target state="translated">Poiché il percorso restituito non include il <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> o <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passando il percorso restituito nuovamente il <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> metodo comporterà il troncamento di una cartella di livello superiore per la chiamata successiva nella stringa di risultato.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will return "C:\Directory\SubDirectory".</source>
          <target state="translated">Ad esempio, passando il percorso "C:\Directory\SubDirectory\test.txt" nel <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> metodo verrà restituito "C:\Directory\SubDirectory".</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Passing that string, "C:\Directory\SubDirectory", into <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> will result in "C:\Directory".</source>
          <target state="translated">Passare la stringa "C:\Directory\SubDirectory", in <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> verrà generato "C:\Directory".</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetDirectoryName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo di <ph id="ph1">`GetDirectoryName`</ph> metodo in una piattaforma desktop basati su Windows.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter contains invalid characters, is empty, or contains only white spaces.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene caratteri non validi, è vuoto o contiene solo spazi vuoti.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione della classe di base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is longer than the system-defined maximum length.</source>
          <target state="translated">La lunghezza del parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è maggiore della lunghezza massima definita nel sistema.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The path string from which to get the extension.</source>
          <target state="translated">Stringa di percorso dalla quale ottenere l'estensione.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>Returns the extension of the specified path string.</source>
          <target state="translated">Restituisce l'estensione della stringa di percorso specificata.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of the specified path (including the period "."), or <ph id="ph1">&lt;see langword="null" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Estensione del percorso specificato, incluso il punto ("."), oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> oppure <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not have extension information, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="path" /&gt;</ph> non include informazioni sull'estensione, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> restituisce <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of <ph id="ph1">`path`</ph> is obtained by searching <ph id="ph2">`path`</ph> for a period (.), starting with the last character in path and continuing toward the start of path.</source>
          <target state="translated">L'estensione di <ph id="ph1">`path`</ph> viene ottenuto eseguendo una ricerca <ph id="ph2">`path`</ph> per un punto (.), a partire dall'ultimo carattere del percorso e risalendo verso l'inizio del percorso.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If a period is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> character, the returned string contains the period and the characters after it; otherwise, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> is returned.</source>
          <target state="translated">Se si trova un punto prima un <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> o <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> carattere, la stringa restituita conterrà il periodo di e i caratteri dopo di esso; in caso contrario, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> viene restituito.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetExtension`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo di <ph id="ph1">`GetExtension`</ph> metodo in una piattaforma desktop basati su Windows.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The path string from which to obtain the file name and extension.</source>
          <target state="translated">Stringa di percorso dalla quale ottenere il nome del file e l'estensione.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>Returns the file name and extension of the specified path string.</source>
          <target state="translated">Restituisce il nome del file e l'estensione della stringa di percorso specificata.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The characters after the last directory character in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Caratteri successivi all'ultimo carattere di directory in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If the last character of <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a directory or volume separator character, this method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Se l'ultimo carattere di <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è un separatore di directory o di volumi, questo metodo restituisce <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, questo metodo restituisce <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The returned value is <ph id="ph1">`null`</ph> if the file path is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Il valore restituito è <ph id="ph1">`null`</ph> se il percorso del file <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The separator characters used to determine the start of the file name are <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Il carattere separatore usato per determinare l'inizio del nome del file sono <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The following code example demonstrates the behavior of the <ph id="ph1">`GetFileName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento del <ph id="ph1">`GetFileName`</ph> metodo in una piattaforma desktop basati su Windows.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The path of the file.</source>
          <target state="translated">Percorso del file.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>Returns the file name of the specified path string without the extension.</source>
          <target state="translated">Restituisce il nome del file della stringa di percorso specificata senza estensione.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The string returned by <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus the last period (.) and all characters following it.</source>
          <target state="translated">Stringa restituita da <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, senza l'ultimo punto (.) e tutti i caratteri che lo seguono.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Questo metodo non verifica che il nome file o il percorso esista.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetFileNameWithoutExtension`</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un utilizzo del <ph id="ph1">`GetFileNameWithoutExtension`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory for which to obtain absolute path information.</source>
          <target state="translated">File o directory per cui ottenere informazioni relative al percorso assoluto.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Returns the absolute path for the specified path string.</source>
          <target state="translated">Restituisce il percorso assoluto della stringa di percorso specificata.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The fully qualified location of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:\MyFile.txt".</source>
          <target state="translated">Percorso completo di <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, ad esempio "C:\MyFile.txt".</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The absolute path includes all information required to locate a file or directory on a system.</source>
          <target state="translated">Il percorso assoluto include tutte le informazioni necessarie per individuare un file o directory in un sistema.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory specified by <ph id="ph1">`path`</ph> is not required to exist.</source>
          <target state="translated">Il file o directory specificata da <ph id="ph1">`path`</ph> non deve necessariamente esistere.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, if c:\temp\newdir is the current directory, calling <ph id="ph1">`GetFullPath`</ph> on a file name such as test.txt returns c:\temp\newdir\test.txt.</source>
          <target state="translated">Ad esempio, se c:\temp\newdir è la directory corrente, la chiamata <ph id="ph1">`GetFullPath`</ph> in un file di nome, ad esempio test.txt restituisce c:\temp\newdir\test.txt.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file need not exist.</source>
          <target state="translated">Il file non deve esistere.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>However, if <ph id="ph1">`path`</ph> does exist, the caller must have permission to obtain path information for <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Tuttavia, se <ph id="ph1">`path`</ph> esiste, il chiamante deve disporre dell'autorizzazione per ottenere informazioni sul percorso di <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Note that unlike most members of the <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> class, this method accesses the file system.</source>
          <target state="translated">Si noti che, contrariamente alla maggior parte dei membri del <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> (classe), questo metodo accede al file system.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>This method uses current directory and current volume information to fully qualify <ph id="ph1">`path`</ph>.</source>
          <target state="translated">Questo metodo utilizza directory corrente e le informazioni di volume corrente per qualificare completamente <ph id="ph1">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you specify a file name only in <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> returns the fully qualified path of the current directory.</source>
          <target state="translated">Se si specifica un file solo in nome <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> restituisce il percorso completo della directory corrente.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you pass in a short file name, it is expanded to a long file name.</source>
          <target state="translated">Se si passa un nome file breve, viene espanso in un nome di file lunghi.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</source>
          <target state="translated">Se un percorso non contiene caratteri significativi non è consentito a meno che non contiene uno o più "."caratteri seguiti da un numero qualsiasi di spazi, quindi, verrà analizzato come"."o"...".</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The following code example demonstrates the <ph id="ph1">`GetFullPath`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">`GetFullPath`</ph> metodo in una piattaforma desktop basati su Windows.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The system could not retrieve the absolute path.</source>
          <target state="translated">Il sistema non è riuscito a recuperare il percorso assoluto.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Il chiamante non ha le autorizzazioni richieste.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon (":") that is not part of a volume identifier (for example, "c:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene due punti (":") che non fanno parte di un identificatore di volume (ad esempio "c:<ph id="ph2">\\</ph>").</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>for access to the path.</source>
          <target state="translated">Per accedere al percorso.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>Gets an array containing the characters that are not allowed in file names.</source>
          <target state="translated">Ottiene una matrice contenente i caratteri non consentiti nei nomi di file.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>An array containing the characters that are not allowed in file names.</source>
          <target state="translated">Matrice contenente i caratteri non consentiti nei nomi di file.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Il set completo di caratteri non validi può variare dal file system.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (<ph id="ph1">\&lt;</ph>), maggiore di (&gt;), barra verticale (&amp;#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metodo per recuperare i caratteri non validi.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>Gets an array containing the characters that are not allowed in path names.</source>
          <target state="translated">Ottiene una matrice contenente i caratteri non consentiti nei nomi di percorso.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>An array containing the characters that are not allowed in path names.</source>
          <target state="translated">Matrice contenente i caratteri non consentiti nei nomi di percorso.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Il set completo di caratteri non validi può variare dal file system.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (<ph id="ph1">\&lt;</ph>), maggiore di (&gt;), barra verticale (&amp;#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metodo per recuperare i caratteri non validi.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The path from which to obtain root directory information.</source>
          <target state="translated">Percorso dal quale ottenere informazioni sulla directory radice.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Gets the root directory information of the specified path.</source>
          <target state="translated">Ottiene la directory radice del percorso specificato.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The root directory of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:<ph id="ph2">\\</ph>", or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if <ph id="ph4">&lt;paramref name="path" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>, or an empty string if <ph id="ph6">&lt;paramref name="path" /&gt;</ph> does not contain root directory information.</source>
          <target state="translated">La directory radice di <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, ad esempio "C:<ph id="ph2">\\</ph>" oppure <ph id="ph3">&lt;see langword="null" /&gt;</ph> se <ph id="ph4">&lt;paramref name="path" /&gt;</ph> è <ph id="ph5">&lt;see langword="null" /&gt;</ph> oppure una stringa vuota se <ph id="ph6">&lt;paramref name="path" /&gt;</ph> non contiene informazioni sulla directory radice.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Questo metodo non verifica che il nome file o il percorso esista.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Possible patterns for the string returned by this method are as follows:</source>
          <target state="translated">Di seguito sono riportati i motivi possibili per la stringa restituita da questo metodo:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>An empty string (<ph id="ph1">`path`</ph> specified a relative path on the current drive or volume).</source>
          <target state="translated">Una stringa vuota (<ph id="ph1">`path`</ph> specificato un percorso relativo in un volume o l'unità corrente).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"/" (<ph id="ph1">`path`</ph> specified an absolute path on the current drive).</source>
          <target state="translated">"/" (<ph id="ph1">`path`</ph> ha specificato un percorso assoluto nell'unità corrente).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:" (<ph id="ph1">`path`</ph> specified a relative path on a drive, where X represents a drive or volume letter).</source>
          <target state="translated">"X" (<ph id="ph1">`path`</ph> specificato un percorso relativo in un'unità, dove X rappresenta una lettera di unità o volume).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:/" (<ph id="ph1">`path`</ph> specified an absolute path on a given drive).</source>
          <target state="translated">"X /" (<ph id="ph1">`path`</ph> specificato un percorso assoluto in una determinata unità).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</source>
          <target state="translated">"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (un percorso UNC).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetPathRoot`</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un utilizzo del <ph id="ph1">`GetPathRoot`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> was passed to <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> è stato passato a <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>Returns a random folder name or file name.</source>
          <target state="translated">Restituisce un nome casuale di cartella o di file.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>A random folder name or file name.</source>
          <target state="translated">Nome casuale di cartella o di file.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> metodo restituisce una stringa casuale crittograficamente sicura che può essere utilizzata come nome di una cartella o un nome file.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>Unlike <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> does not create a file.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> non crea un file.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>When the security of your file system is paramount, this method should be used instead of <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</source>
          <target state="translated">Quando la sicurezza del file system è fondamentale, questo metodo deve essere utilizzato al posto di <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The following example show output from the <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente mostra l'output di <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</source>
          <target state="translated">Crea un file temporaneo a zero byte con nome univoco sul disco e restituisce il percorso intero di quel file.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>The full path of the temporary file.</source>
          <target state="translated">Percorso completo del file temporaneo.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>This method creates a temporary file with a .TMP file extension.</source>
          <target state="translated">Questo metodo crea un file temporaneo con una. Estensione di file TMP.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The temporary file is created within the user’s temporary folder, which is the path returned by the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Il file temporaneo viene creato nella cartella temporanea dell'utente, che è il percorso restituito dal <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if it is used to create more than 65535 files without deleting previous temporary files.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> metodo genererà un' <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> se viene utilizzato per creare più di 65535 file senza eliminare i file temporanei precedenti.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if no unique temporary file name is available.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> metodo genererà un' <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> se non è disponibile alcun nome file temporaneo univoco.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>To resolve this error, delete all unneeded temporary files.</source>
          <target state="translated">Per risolvere questo errore, eliminare tutti i file temporanei non necessari.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>An I/O error occurs, such as no unique temporary file name is available.</source>
          <target state="translated">Si verifica un errore I/O, ad esempio non è disponibile alcun nome univoco del file temporaneo.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oppure -</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>This method was unable to create a temporary file.</source>
          <target state="translated">Il metodo non consente la creazione di un file temporaneo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>for writing to the temporary directory.</source>
          <target state="translated">per la scrittura alla directory temporanea.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>Returns the path of the current user's temporary folder.</source>
          <target state="translated">Restituisce il percorso della cartella temporanea dell'utente corrente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The path to the temporary folder, ending with a backslash.</source>
          <target state="translated">Percorso alla cartella temporanea che termina con una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This method checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Questo metodo verifica l'esistenza delle variabili di ambiente nell'ordine seguente e utilizza il primo percorso trovato:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TMP environment variable.</source>
          <target state="translated">Il percorso specificato dalla variabile di ambiente TMP.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TEMP environment variable.</source>
          <target state="translated">Il percorso specificato dalla variabile di ambiente TEMP.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the USERPROFILE environment variable.</source>
          <target state="translated">Il percorso specificato dalla variabile di ambiente USERPROFILE.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The Windows directory.</source>
          <target state="translated">La directory di Windows.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The following code shows how to call the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Nel codice seguente viene illustrato come chiamare il metodo <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This example produces output similar to the following.</source>
          <target state="translated">In questo esempio restituisce un output simile al seguente.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Il chiamante non ha le autorizzazioni richieste.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>for unrestricted access to environment variables.</source>
          <target state="translated">per l'accesso illimitato alle variabili di ambiente.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The path to search for an extension.</source>
          <target state="translated">Percorso in cui cercare un'estensione.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Determines whether a path includes a file name extension.</source>
          <target state="translated">Determina se un percorso include un'estensione di nome di file.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the characters that follow the last directory separator (<ph id="ph2">\\</ph>\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se i caratteri che seguono l'ultimo separatore di directory (<ph id="ph2">\\</ph>\ o /) o di volume (:) nel percorso includono un punto (.) seguito da uno o più caratteri; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Starting from the end of <ph id="ph1">`path`</ph>, this method searches for a period (.) followed by at least one character.</source>
          <target state="translated">A partire dalla fine di <ph id="ph1">`path`</ph>, questo metodo cerca un punto (.) seguito da almeno un carattere.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>If this pattern is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> character is encountered, this method returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Se questo modello si trova prima un <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, o <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> viene rilevato carattere, questo metodo restituisce <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The following code example demonstrates the use of the <ph id="ph1">`HasExtension`</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`HasExtension`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.IO.Path.InvalidPathChars">
          <source>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> class.</source>
          <target state="translated">Fornisce una matrice di caratteri specifici della piattaforma che non possono essere usati negli argomenti della stringa di percorso passati ai membri della classe <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Il set completo di caratteri non validi può variare dal file system.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (<ph id="ph1">\&lt;</ph>), maggiore di (&gt;), barra verticale (&amp;#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>Do not use <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> if you think your code might execute in the same application domain as untrusted code.</source>
          <target state="translated">Non utilizzare <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> se si ritiene che il codice possa essere eseguito nello stesso dominio applicazione come codice non attendibile.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> is an array, so its elements can be overwritten.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> è una matrice, pertanto i relativi elementi possono essere sovrascritti.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>If untrusted code overwrites elements of <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, it might cause your code to malfunction in ways that could be exploited.</source>
          <target state="translated">Se il codice non attendibile sovrascrive gli elementi di <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, potrebbe verificarsi del codice in modo tale che può essere sfruttata.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The following code example demonstrates the use of the <ph id="ph1">`InvalidPathChars`</ph> property.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`InvalidPathChars`</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The path to test.</source>
          <target state="translated">Percorso da testare.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>Gets a value indicating whether the specified path string contains a root.</source>
          <target state="translated">Ottiene un valore che indica se la stringa di percorso specificata contiene una directory radice.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contains a root; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contiene un percorso radice, in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the first character is a directory separator character such as "<ph id="ph3">\\</ph>", or if the path starts with a drive letter and colon (:).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> restituisce <ph id="ph2">`true`</ph> se il primo carattere è un carattere separatore di directory, ad esempio "<ph id="ph3">\\</ph>", o se il percorso deve iniziare con una lettera di unità e i due punti (:).</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For example, it returns <ph id="ph1">`true`</ph> for <ph id="ph2">`path`</ph> strings such as "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", or "C:MyDir".</source>
          <target state="translated">Ad esempio, viene restituito <ph id="ph1">`true`</ph> per <ph id="ph2">`path`</ph> stringhe, ad esempio "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "c:<ph id="ph5">\\</ph>\MyDir", o "C:MyDir".</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>It returns <ph id="ph1">`false`</ph> for <ph id="ph2">`path`</ph> strings such as "MyDir".</source>
          <target state="translated">Restituisce <ph id="ph1">`false`</ph> per <ph id="ph2">`path`</ph> stringhe, ad esempio "MyDir".</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Questo metodo non verifica che il nome file o il percorso esista.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco delle attività dei / o comuni, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The following code example demonstrates how the <ph id="ph1">`IsPathRooted`</ph> method can be used to test three strings.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come la <ph id="ph1">`IsPathRooted`</ph> metodo può essere utilizzato per testare tre stringhe.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o più dei caratteri non validi definiti nel metodo <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.IO.Path.PathSeparator">
          <source>A platform-specific separator character used to separate path strings in environment variables.</source>
          <target state="translated">Carattere separatore specifico della piattaforma, usato per separare le stringhe di percorso nelle variabili di ambiente.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</source>
          <target state="translated">Nelle piattaforme desktop basate su Windows, il valore di questo campo è il punto e virgola (;) per impostazione predefinita, ma potrebbe variare in altre piattaforme.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>The following code example demonstrates the use of the <ph id="ph1">`PathSeparator`</ph> field.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`PathSeparator`</ph> campo.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>Provides a platform-specific volume separator character.</source>
          <target state="translated">Fornisce un carattere separatore di volume specifico della piattaforma.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</source>
          <target state="translated">Il valore di questo campo è di due punti (:) in Windows e Macintosh e una barra (/) nei sistemi operativi UNIX.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</source>
          <target state="translated">Ciò è particolarmente utile per l'analisi dei percorsi, ad esempio "c:\windows" o "Cartella MacVolume: System".</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`VolumeSeparatorChar`</ph> field.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`VolumeSeparatorChar`</ph> campo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>