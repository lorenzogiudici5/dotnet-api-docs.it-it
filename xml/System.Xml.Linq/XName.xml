<Type Name="XName" FullName="System.Xml.Linq.XName">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ce6054dd5fd86cfc02446e749add64e99d92093b" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51905790" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class XName : IEquatable&lt;System.Xml.Linq.XName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit XName extends System.Object implements class System.IEquatable`1&lt;class System.Xml.Linq.XName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XName" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XName&#xA;Implements IEquatable(Of XName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XName sealed : IEquatable&lt;System::Xml::Linq::XName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type XName = class&#xA;    interface IEquatable&lt;XName&gt;&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xml.Linq.XName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.Xml.Linq.NameSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un nome di un elemento o attributo XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi XML includono uno spazio dei nomi e nome locale. Oggetto *nome completo* è la combinazione dello spazio dei nomi e del nome locale.  
  
## <a name="creating-an-xname-object"></a>Creazione di un oggetto XName  
 <xref:System.Xml.Linq.XName> non contiene alcun costruttore pubblici. Al contrario, questa classe fornisce una conversione implicita da <xref:System.String> che consente di creare un <xref:System.Xml.Linq.XName>. La posizione più comune è usare tale conversione è durante la creazione di un elemento o attributo: il primo argomento per il <xref:System.Xml.Linq.XElement> costruttore è un <xref:System.Xml.Linq.XName>. Passando una stringa, sfruttare i vantaggi della conversione implicita. Il codice seguente crea un elemento con un nome che si trova in nessuno spazio dei nomi:  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
Console.WriteLine(root);  
```  
  
 In Visual Basic, è preferibile usare valori letterali XML:  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
Console.WriteLine(root)  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<ElementName>content</ElementName>  
```  
  
 Assegnazione di una stringa a un <xref:System.Xml.Linq.XName> utilizza la conversione implicita da <xref:System.String>.  
  
 L'esempio di Visual Basic crea il <xref:System.Xml.Linq.XElement> usando i valori letterali XML. Anche se vengono utilizzati valori letterali XML, un' <xref:System.Xml.Linq.XName> oggetto viene creato per il <xref:System.Xml.Linq.XElement>.  
  
 Inoltre, è possibile chiamare il <xref:System.Xml.Linq.XName.Get%2A> metodo per un <xref:System.Xml.Linq.XName> oggetto. Tuttavia, il metodo consigliato consiste nell'utilizzare la conversione implicita da stringa.  
  
## <a name="creating-an-xname-in-a-namespace"></a>Creazione di un oggetto XName in un Namespace  
 Come nel codice XML, un <xref:System.Xml.Linq.XName> può essere in uno spazio dei nomi, o può essere in nessuno spazio dei nomi.  
  
 Per c#, l'approccio consigliato per la creazione di un' <xref:System.Xml.Linq.XName> in uno spazio dei nomi consiste nel dichiarare il <xref:System.Xml.Linq.XNamespace> dell'oggetto, quindi usare l'override dell'operatore di addizione.  
  
 Per Visual Basic, l'approccio consigliato consiste nell'utilizzare i valori letterali XML e le dichiarazioni dello spazio dei nomi globale per creare codice XML in uno spazio dei nomi.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <ElementName>content</ElementName>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
## <a name="creating-an-xname-in-no-namespace"></a>Creazione di un oggetto XName in nessun Namespace  
 Il <xref:System.Xml.Linq.XName.Namespace%2A> proprietà di un <xref:System.Xml.Linq.XName> oggetto è garantito che non sia null. Se il <xref:System.Xml.Linq.XName> in nessuno spazio dei nomi, il <xref:System.Xml.Linq.XName.Namespace%2A> verrà impostata su <xref:System.Xml.Linq.XNamespace.None%2A>. Il codice seguente illustra questo processo:  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
if (root.Name.Namespace == XNamespace.None)  
    Console.WriteLine("The element is in no namespace.");  
else  
    Console.WriteLine("The element is in a namespace.");  
```  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
If (root.Name.Namespace Is XNamespace.None) Then  
    Console.WriteLine("The element is in no namespace.")  
Else  
    Console.WriteLine("The element is in a namespace.")  
End If  
```  
  
 Questo esempio produce il seguente output:  
  
```  
The element is in no namespace.  
```  
  
## <a name="using-expanded-names"></a>Usando nomi espansi  
 È anche possibile creare un <xref:System.Xml.Linq.XName> da un nome XML esteso nel formato `{namespace}localname`:  
  
```csharp  
XElement root = new XElement("{http://www.adventure-works.com}ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = New XElement("{http://www.adventure-works.com}ElementName", "content")  
Console.WriteLine(root)  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
 Tenere presente che la creazione di un' <xref:System.Xml.Linq.XName> tramite un nome espanso è meno efficiente rispetto alla creazione di un <xref:System.Xml.Linq.XNamespace> oggetto e l'uso dell'override dell'operatore di addizione. È anche meno efficiente rispetto all'importazione di uno spazio dei nomi globale e usando i valori letterali XML in Visual Basic.  
  
 Se si crea un <xref:System.Xml.Linq.XName> usando un nome espanso, LINQ to XML deve individuare l'istanza di uno spazio dei nomi atomizzato. Questa operazione deve essere ripetuta per ogni uso di un nome espanso. Questo tempo aggiuntivo è probabile che sia trascurabile quando si scrive le query LINQ. Tuttavia, potrebbe essere significativo durante la creazione di un albero XML di grandi dimensioni.  
  
## <a name="xname-objects-are-atomized"></a>Oggetti XName sono Atomizzati  
 <xref:System.Xml.Linq.XName> gli oggetti sono sicuramente possibile atomizzare; vale a dire, se due <xref:System.Xml.Linq.XName> oggetti hanno esattamente lo stesso spazio dei nomi e lo stesso nome locale, condivideranno la stessa istanza. Gli operatori di uguaglianza e confronto vengono anche forniti in modo esplicito per questo scopo.  
  
 Tra gli altri vantaggi, questa funzionalità consente un'esecuzione più rapida delle query. Quando si filtrando il nome di elementi o attributi, i confronti espressi nei predicati di usano il confronto dell'identità, non confrontare i valori. È molto più veloce per determinare che due riferimenti si riferiscono effettivamente allo stesso oggetto anziché confrontare due stringhe.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xName.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">L'oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare con l'oggetto <see cref="T:System.Xml.Linq.XName" /> corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato è uguale a <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato è uguale all'oggetto <see cref="T:System.Xml.Linq.XName" /> corrente; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per due <xref:System.Xml.Linq.XName> oggetti siano uguali, si deve avere lo stesso nome espanso.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Get">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Xml.Linq.XName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce gli overload che consentono di creare un <xref:System.Xml.Linq.XName> da un nome XML espanso. È possibile creare un <xref:System.Xml.Linq.XName> da una stringa nel formato `{namespace}localname`, o da uno spazio dei nomi e un nome locale specificati separatamente.  
  
 Un modo molto più comune e più semplice per creare un <xref:System.Xml.Linq.XName> consiste nell'usare la conversione implicita da stringa. Per creare un nome che si trova in uno spazio dei nomi, l'approccio comune consiste nell'utilizzare l'overload dell'operatore di addizione che è possibile combinare un <xref:System.Xml.Linq.XNamespace> oggetto e una stringa.  
  
 Per altre informazioni ed esempi, vedere [procedura: creare un documento con spazi dei nomi (c#) (LINQ to XML)](https://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c).  
  
 Per altre informazioni sull'uso degli spazi dei nomi in Visual Basic, vedere [spazi dei nomi in Visual Basic (LINQ to XML)](https://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc).  
  
 In quanto <xref:System.Xml.Linq.XName> atomizzati oggetti, se è presente <xref:System.Xml.Linq.XName> esattamente con lo stesso nome, la variabile assegnata farà riferimento a un esistente <xref:System.Xml.Linq.XName>. Se non sono già <xref:System.Xml.Linq.XName>, un nuovo uno verrà creato e inizializzato.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member Get : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">
          <see cref="T:System.String" /> che contiene un nome XML esteso nel formato <c>{namespace}localname</c>.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Xml.Linq.XName" /> da un nome esteso.</summary>
        <returns>Oggetto <see cref="T:System.Xml.Linq.XName" /> costruito da un nome esteso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo contiene gli overload che consentono di creare un <xref:System.Xml.Linq.XName>. È possibile crearla da un nome XML esteso nel formato `{namespace}localname`, o da uno spazio dei nomi e un nome locale specificati separatamente.  
  
 Un modo molto più comune e più semplice per creare un <xref:System.Xml.Linq.XName> consiste nell'usare la conversione implicita da stringa.  
  
 In quanto <xref:System.Xml.Linq.XName> atomizzate, se è presente <xref:System.Xml.Linq.XName> esattamente con lo stesso nome, la variabile assegnata farà riferimento a un esistente <xref:System.Xml.Linq.XName>. Se non sono già <xref:System.Xml.Linq.XName>, un nuovo uno verrà creato e inizializzato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo metodo.  
  
```csharp  
XName name = XName.Get("{http://www.adventure-works.com}Root");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred approach for specifying the XName in the  
// constructor of XElement.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string localName, string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string localName, string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (localName As String, namespaceName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ localName, System::String ^ namespaceName);" />
      <MemberSignature Language="F#" Value="static member Get : string * string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get (localName, namespaceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nome locale (non qualificato).</param>
        <param name="namespaceName">Uno spazio dei nomi XML.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Xml.Linq.XName" /> da un nome locale e uno spazio dei nomi.</summary>
        <returns>Oggetto <see cref="T:System.Xml.Linq.XName" /> creato dal nome locale e spazio dei nomi specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo contiene gli overload che consentono di creare un <xref:System.Xml.Linq.XName>. È possibile crearla da un nome XML esteso nel formato `{namespace}localname`, o da uno spazio dei nomi e un nome locale specificati separatamente.  
  
 Un modo molto più comune e più semplice per creare un <xref:System.Xml.Linq.XName> consiste nell'usare la conversione implicita da stringa.  
  
 In quanto <xref:System.Xml.Linq.XName> atomizzate, se è presente <xref:System.Xml.Linq.XName> esattamente con lo stesso nome, la variabile assegnata farà riferimento a un esistente <xref:System.Xml.Linq.XName>. Se non sono già <xref:System.Xml.Linq.XName>, un nuovo uno verrà creato e inizializzato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo metodo.  
  
```csharp  
XName name = XName.Get("Root", "http://www.adventure-works.com");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred form.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xName.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codice hash per l'oggetto <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>Oggetto <see cref="T:System.Int32" /> che contiene il codice hash per <see cref="T:System.Xml.Linq.XName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo serve come funzione hash per <xref:System.Xml.Linq.XName>. È possibile usare <xref:System.Xml.Linq.XName.GetHashCode%2A> in algoritmi di hash o in strutture di dati, ad esempio una tabella hash.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.Linq.XName.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la parte locale (non qualificata) del nome.</summary>
        <value>
          <see cref="T:System.String" /> che contiene la parte locale (non qualificata) del nome.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è garantito che non sia `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questa proprietà.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XName.Namespace" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNamespace Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Namespace As XNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNamespace ^ Namespace { System::Xml::Linq::XNamespace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : System.Xml.Linq.XNamespace" Usage="System.Xml.Linq.XName.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la parte dello spazio dei nomi del nome completo.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNamespace" /> che contiene la parte dello spazio dei nomi del nome.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.Xml.Linq.XName.Namespace%2A> non è `null`. Se un' <xref:System.Xml.Linq.XName> è in nessuno spazio dei nomi, questa proprietà restituisce <xref:System.Xml.Linq.XNamespace.None%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questa proprietà.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NamespaceName">
      <MemberSignature Language="C#" Value="public string NamespaceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.NamespaceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NamespaceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NamespaceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceName : string" Usage="System.Xml.Linq.XName.NamespaceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'URI del <see cref="T:System.Xml.Linq.XNamespace" /> per questo <see cref="T:System.Xml.Linq.XName" />.</summary>
        <value>URI del <see cref="T:System.Xml.Linq.XNamespace" /> per questo <see cref="T:System.Xml.Linq.XName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa è una proprietà per ottenere il nome dello spazio dei nomi da un <xref:System.Xml.Linq.XName>.  
  
   
  
## Examples  
 In questo esempio viene creato un elemento in uno spazio dei nomi e quindi stampa lo spazio dei nomi dell'elemento.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root.Name.NamespaceName);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name.NamespaceName)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare.</param>
        <param name="right">Secondo oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare.</param>
        <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Xml.Linq.XName" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'overload degli operatori `==` e `!=` sono inclusi per consentire confronti tra <xref:System.Xml.Linq.XName> e un `string`, ad esempio`element.Name == "SomeElementName"`. Gli operatori di uguaglianza di riferimenti predefiniti in c# richiedono un operando sia convertibile nel tipo di altro tramite solo le conversioni dei riferimenti. Questi operatori non considerano la conversione implicita da stringa a <xref:System.Xml.Linq.XName>.  
  
## Examples  
 L'esempio seguente mostra alcuni confronti tra <xref:System.Xml.Linq.XName> oggetti e le stringhe.  
  
```csharp  
XName xn;  
xn = XName.Get("Root");  
Console.WriteLine(xn == "Root");  
  
xn = XName.Get("Root", "http://www.adventure-works.com");  
Console.WriteLine(xn == "{http://www.adventure-works.com}Root");  
  
XElement root = new XElement("Root", "content");  
Console.WriteLine(root.Name == "Root");  
```  
  
```vb  
Dim xn As XName  
xn = XName.Get("Root")  
Console.WriteLine(xn = "Root")  
  
xn = XName.Get("Root", "http://www.adventure-works.com")  
Console.WriteLine(xn = "{http://www.adventure-works.com}Root")  
  
Dim root As XElement = New XElement("Root", "content")  
Console.WriteLine(root.Name = "Root")  
```  
  
 Questo esempio produce il seguente output:  
  
```  
True  
True  
True  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Xml.Linq.XName (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Xml.Linq.XName op_Implicit(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Xml::Linq::XName ^(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.op_Implicit expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">Stringa che contiene un nome XML esteso nel formato <c>{namespace}localname</c>.</param>
        <summary>Converte una stringa formattata come nome XML esteso (ovvero <c>{namespace}localname</c>) in un oggetto <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>Oggetto <see cref="T:System.Xml.Linq.XName" /> costruito da un nome esteso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa l'operatore implicito quando si crea un' <xref:System.Xml.Linq.XElement> o <xref:System.Xml.Linq.XAttribute> passando una stringa per il costruttore appropriato.  
  
## Examples  
 L'esempio seguente crea un <xref:System.Xml.Linq.XName> assegnandole una stringa, che richiama l'operatore di conversione implicita.  
  
```csharp  
XElement el = new XElement("{http://www.adventure-works.com}Root", "content");  
Console.WriteLine(el);  
  
// The preferred approach is to initialize an XNamespace object  
// and use the overload of the addition operator.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el As XElement = New XElement("{http://www.adventure-works.com}Root", "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach is to import a global namespace and   
        ' use an XML literal.  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="System.Xml.Linq.XName.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare.</param>
        <param name="right">Secondo oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare.</param>
        <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Xml.Linq.XName" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'overload degli operatori `==` e `!=` sono inclusi per consentire confronti tra <xref:System.Xml.Linq.XName> e una stringa, ad esempio`element.Name == "SomeElementName"`. Gli operatori di uguaglianza di riferimenti predefiniti in c# richiedono un operando sia convertibile nel tipo di altro tramite solo le conversioni dei riferimenti. Questi operatori non considerano la conversione implicita da stringa a <xref:System.Xml.Linq.XName>.  
  
## Examples  
 L'esempio c# seguente confronta un <xref:System.Xml.Linq.XName> oggetto da una stringa, che richiama questo operatore.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
  
Console.WriteLine(root.Name != "{http://www.adventure-works.com}Root");  
  
// the following is the preferred idiom  
Console.WriteLine(root.Name != aw + "Root");  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name <> "{http://www.adventure-works.com}Root")  
  
        ' the following is the preferred idiom  
        Console.WriteLine(root.Name <> GetXmlNamespace() + "Root")  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
False  
False  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;XName&gt;.Equals (System.Xml.Linq.XName other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(class System.Xml.Linq.XName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#IEquatable&lt;System#Xml#Linq#XName&gt;#Equals(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As XName) As Boolean Implements IEquatable(Of XName).Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(System::Xml::Linq::XName ^ other) = IEquatable&lt;System::Xml::Linq::XName ^&gt;::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto <see cref="T:System.Xml.Linq.XName" /> da confrontare con <see cref="T:System.Xml.Linq.XName" />.</param>
        <summary>Indica se l'oggetto <see cref="T:System.Xml.Linq.XName" /> corrente è uguale all'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Xml.Linq.XName" /> è uguale all'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato. In caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> da popolare con i dati.</param>
        <param name="context">Destinazione della serializzazione (vedere <see cref="T:System.Runtime.Serialization.StreamingContext" />).</param>
        <summary>Popola un oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con i dati richiesti per serializzare l'oggetto di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato internamente per serializzare oggetti grafici contenenti LINQ agli oggetti XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il nome XML esteso nel formato <c>{namespace}localname</c>.</summary>
        <returns>
          <see cref="T:System.String" /> che contiene il nome XML esteso nel formato <c>{namespace}localname</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene chiamato <xref:System.Console.WriteLine%2A>, passando un <xref:System.Xml.Linq.XName>. In questo modo, il <xref:System.Xml.Linq.XName.ToString%2A> metodo da chiamare.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
  </Members>
</Type>