<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6871af9cb7a08472c9ddb27a369b0e788d9f8e9e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39827167" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <TypeSignature Language="F#" Value="type XStreamingElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta gli elementi in un albero XML che supporta l'output del flusso posticipato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe consente di creare un albero XML che supporta l'output del flusso posticipato. Utilizzare questa classe per creare un albero XML in modo molto simile alla creazione di un albero XML usando <xref:System.Xml.Linq.XElement>. Tuttavia, vi è una differenza fondamentale. Quando si utilizza una query LINQ per specificare il contenuto durante la creazione di un file XML della struttura ad albero usando <xref:System.Xml.Linq.XElement>, la variabile di query viene iterata al momento della costruzione dell'albero XML e i risultati della query vengono aggiunti all'albero XML. Al contrario, quando si crea un albero XML usando <xref:System.Xml.Linq.XStreamingElement>, un riferimento alla variabile di query viene archiviato nell'albero XML senza in fase di iterazione. Le query vengono Iterate solo durante la serializzazione. In questo modo è possibile creare alberi XML più grandi mantenendo un footprint di memoria più piccolo.  
  
 Se si utilizza il flusso da un'origine di input, ad esempio un file di testo, quindi è possibile leggere un file di testo di dimensioni molto grandi e generare un documento XML di dimensioni molto grande mantenendo un footprint di memoria di piccole dimensioni.  
  
 Un altro scenario è che si dispone di un albero XML di grandi dimensioni che è stato caricato in memoria e si desidera creare una versione trasformata del documento. Se si crea un nuovo documento usando <xref:System.Xml.Linq.XElement>, avrai due strutture ad albero XML di grandi dimensioni in memoria dopo il completamento della trasformazione. Tuttavia, se si crea il nuovo albero XML usando <xref:System.Xml.Linq.XStreamingElement>, quindi verrà eliminato in modo efficace il working set a metà.  
  
 Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare. In questo modo il codice XML da serializzare. Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un albero XML di origine. Crea quindi una trasformazione dell'origine XML albero utilizzando <xref:System.Xml.Linq.XElement>. Questa trasformazione consente di creare un nuovo albero in memoria. Crea quindi una trasformazione dell'origine XML albero utilizzando <xref:System.Xml.Linq.XStreamingElement>. Questa trasformazione non esegue la query fino a quando l'albero trasformato viene serializzato nella console. L'utilizzo della memoria è inferiore.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 Uno degli approcci disponibili per l'elaborazione di un file di testo consiste nello scrivere un metodo di estensione che genera un flusso del file di testo, una riga alla volta, tramite il costrutto `yield return`. È quindi possibile scrivere una query LINQ che elabora il file di testo in modo posticipato lazy. Se si usa quindi il <xref:System.Xml.Linq.XStreamingElement> al flusso di output, è possibile creare una trasformazione del file di testo in formato XML che utilizza una quantità minima di memoria, indipendentemente dalle dimensioni del file di testo di origine.  
  
 Il file di testo seguente, People.txt, è l'origine di questo esempio.  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 Nel codice seguente è contenuto un metodo di estensione che genera il flusso delle righe del file di testo in modo posticipato.  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 A volte è necessario trasformare file XML di grandi dimensioni e scrivere l'applicazione in modo tale che il footprint di memoria dell'applicazione sia prevedibile. Se si tenta di popolare un albero XML con un file XML molto grande, l'uso della memoria sarà proporzionale alla dimensione del file (ovvero, eccessivo). Pertanto, è necessario usare una tecnica di flusso in sostituzione.  
  
 Determinati operatori di query standard, ad esempio <xref:System.Linq.Enumerable.OrderBy%2A>, scorrono l'origine, raccolgono tutti i dati, li ordinano e infine restituiscono il primo elemento nella sequenza. Si noti che se si usa un operatore di query che materializza l'origine prima di restituire il primo elemento, non verrà mantenuto un footprint di memoria ridotto per l'applicazione.  
  
 Anche se si usa la tecnica descritta in, se si tenta di assemblare un albero XML che contiene il documento trasformato, utilizzo della memoria potrebbe essere troppo elevato.  
  
 L'esempio seguente si basa sull'esempio in [procedura: Stream frammenti XML con accesso a informazioni di intestazione](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).  
  
 In questo esempio vengono usate le funzionalità di esecuzione posticipata di <xref:System.Xml.Linq.XStreamingElement> per generare il flusso di output.  
  
 Si noti che il metodo dell'asse personalizzato (`StreamCustomerItem`) è stato scritto in modo tale da prevedere un documento contenente elementi `Customer`, `Name` e `Item`, disposti come nel documento Source.xml seguente. Tuttavia, un'implementazione più affidabile convaliderebbe il documento di origine con uno schema XSD oppure verrebbe preparata per analizzare un documento non valido.  
  
 Il documento seguente, Source.xml, è il documento di origine:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 Il codice seguente contiene un metodo che usa un <xref:System.Xml.XmlReader> il flusso XML di origine. Usa <xref:System.Xml.Linq.XStreamingElement> per trasmettere il nuovo codice XML.  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato. Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.  
  
 Per informazioni dettagliate sul contenuto valido che può essere passato a questo costruttore, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">Oggetto <see cref="T:System.Xml.Linq.XName" /> che contiene il nome dell'elemento.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XElement" /> dall'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un elemento di flusso con nessun contenuto e non sono presenti attributi.  
  
 È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>. È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome dell'elemento.</param>
        <param name="content">Contenuto dell'elemento.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" /> con il nome e il contenuto specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un elemento di flusso con il contenuto specificato e attributi.  
  
 È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>. È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.  
  
 Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato. Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.  
  
 Per informazioni dettagliate sul contenuto valido che può essere passato a questo costruttore, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 Questo esempio Usa il file XML seguente, denominato Source. XML:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj[] -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome dell'elemento.</param>
        <param name="content">Contenuto dell'elemento.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" /> con il nome e il contenuto specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un elemento di flusso con il contenuto specificato e attributi.  
  
 È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>. È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.  
  
 Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato. Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.  
  
 Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 Questo esempio Usa il file XML seguente, denominato Source. XML:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Contenuto da aggiungere all'elemento di flusso.</param>
        <summary>Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore aggiunge il contenuto specificato e attributi per il <xref:System.Xml.Linq.XStreamingElement>. Sebbene sia spesso possibile costruire il <xref:System.Xml.Linq.XStreamingElement> in un'unica istruzione, è talvolta più pratico aggiungere contenuto all'elemento di flusso in modo incrementale.  
  
 Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato. Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.  
  
 Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Xml.Linq.XStreamingElement>. Aggiunge quindi due query all'elemento di flusso. Le query non vengono Iterate fino a quando non viene serializzato l'elemento di flusso.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj[] -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Contenuto da aggiungere all'elemento di flusso.</param>
        <summary>Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore aggiunge il contenuto specificato e attributi per il <xref:System.Xml.Linq.XStreamingElement>. Sebbene sia spesso possibile costruire il <xref:System.Xml.Linq.XStreamingElement> in un'unica istruzione, è talvolta più pratico aggiungere contenuto all'elemento di flusso in modo incrementale.  
  
 Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato. Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.  
  
 Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Xml.Linq.XStreamingElement>. Aggiunge quindi due query all'elemento di flusso. Le query non vengono Iterate fino a quando non viene serializzato l'elemento di flusso.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName with get, set" Usage="System.Xml.Linq.XStreamingElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome dell'elemento di flusso.</summary>
        <value>Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome di questo elemento di flusso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio crea un nuovo elemento di flusso e quindi stampato il nome dell'elemento.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 Questo esempio produce il seguente output:  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializzare questo elemento di flusso. L'output può essere salvato in un file oppure in un oggetto <see cref="T:System.Xml.XmlTextWriter" />, <see cref="T:System.IO.TextWriter" /> o <see cref="T:System.Xml.XmlWriter" />. Facoltativamente, è possibile disabilitare la formattazione (rientro).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xStreamingElement.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso in cui restituire l'oggetto <see cref="T:System.Xml.Linq.XDocument" />.</param>
        <summary>Restituisce l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" /> nell'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice XML serializzato verrà aumentato il rientro. Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente. Il comportamento di questo metodo è che gli spazi vuoti non significativi non verranno mantenuti.  
  
 Se si desidera controllare lo spazio vuoto, usare l'overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accetta <xref:System.Xml.Linq.SaveOptions> come parametro. Usare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> opzione per salvare il codice XML. Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.  
  
 Usare <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opzione se si desidera rimuovere le dichiarazioni dello spazio dei nomi duplicati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xStreamingElement.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">Oggetto <see cref="T:System.IO.TextWriter" /> in cui verrà scritto l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" />.</param>
        <summary>Serializzare questo elemento di flusso in un <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice XML serializzato verrà aumentato il rientro. Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente. Il comportamento di questo metodo è che lo spazio vuoto non significativo nodi dell'albero XML non verranno mantenuti.  
  
 Se si desidera controllare lo spazio vuoto, usare uno degli overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accettano <xref:System.Xml.Linq.SaveOptions> come parametro. Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Nell'esempio seguente crea un albero XML di origine, quindi crea un'istanza di un <xref:System.Xml.Linq.XStreamingElement> utilizzando una query sulla struttura XML di origine. Viene quindi scritto l'elemento di flusso in un <xref:System.IO.StringWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xStreamingElement.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Oggetto <see cref="T:System.String" /> che contiene il nome del file.</param>
        <summary>Serializzare questo elemento di flusso in un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice XML serializzato verrà aumentato il rientro. Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente. Il comportamento di questo metodo è che lo spazio vuoto non significativo nodi dell'albero XML non verranno mantenuti.  
  
 Se si desidera controllare lo spazio vuoto, usare uno degli overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accettano <xref:System.Xml.Linq.SaveOptions> come parametro. Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 L'esempio seguente crea un albero XML di streaming. Serializza quindi l'albero XML streaming in un file.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> in cui verrà scritto l'oggetto <see cref="T:System.Xml.Linq.XElement" />.</param>
        <summary>Serializzare questo elemento di flusso in un <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un <xref:System.Xml.Linq.XStreamingElement> e lo scrive in un <xref:System.Xml.XmlWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso in cui restituire l'oggetto <see cref="T:System.Xml.Linq.XDocument" />.</param>
        <param name="options">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento della formattazione.</param>
        <summary>Restituisce l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" /> nell'oggetto <see cref="T:System.IO.Stream" /> specificato, indicando facoltativamente il comportamento di formattazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita il `options` sono impostati su <xref:System.Xml.Linq.SaveOptions.None>. Questa opzione rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro.  
  
 Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`. Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.  
  
 Usare <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opzione se si desidera rimuovere le dichiarazioni dello spazio dei nomi duplicati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">Oggetto <see cref="T:System.IO.TextWriter" /> nel quale deve essere restituito il codice XML.</param>
        <param name="options">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento di formattazione.</param>
        <summary>Serializzare questo elemento di flusso in un <see cref="T:System.IO.TextWriter" />, disabilitando facoltativamente la formattazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`. Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.  
  
 Se si desidera salvare il codice XML rientrato, non specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`. In questo rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro. Si tratta del comportamento predefinito e il comportamento degli overload del <xref:System.Xml.Linq.XElement.Save%2A> metodi che non accettano `options` come parametro.  
  
 Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Nell'esempio seguente mostra due usi di questo metodo. Al primo uso consente di mantenere gli spazi vuoti. Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Oggetto <see cref="T:System.String" /> che contiene il nome del file.</param>
        <param name="options">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento della formattazione.</param>
        <summary>Serializzare questo elemento di flusso in un file, disabilitando facoltativamente la formattazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`. Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.  
  
 Se si desidera salvare il codice XML rientrato, non specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`. In questo rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro. Si tratta del comportamento predefinito e il comportamento degli overload del <xref:System.Xml.Linq.XElement.Save%2A> metodi che non accettano `options` come parametro.  
  
 Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Nell'esempio seguente mostra due usi di questo metodo. Al primo uso consente di mantenere gli spazi vuoti. Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il codice XML per questo elemento di flusso, disabilitando facoltativamente la formattazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare. In questo modo il codice XML da serializzare. Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xStreamingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice XML formattato (con rientro) per questo elemento di flusso.</summary>
        <returns>
          <see cref="T:System.String" /> contenente il codice XML con rientro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare. In questo modo il codice XML da serializzare. Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.  
  
   
  
## Examples  
 Nell'esempio seguente mostra due usi di <xref:System.Xml.Linq.XStreamingElement.ToString%2A>. Al primo uso consente di mantenere gli spazi vuoti. Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xStreamingElement.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento di formattazione.</param>
        <summary>Restituisce il codice XML per questo elemento di flusso, disabilitando facoltativamente la formattazione.</summary>
        <returns>
          <see cref="T:System.String" /> contenente il codice XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare. In questo modo il codice XML da serializzare. Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.  
  
   
  
## Examples  
 Nell'esempio seguente mostra due usi di <xref:System.Xml.Linq.XStreamingElement.ToString%2A>. Al primo uso consente di mantenere gli spazi vuoti. Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> in cui scriverà questo metodo.</param>
        <summary>Scrive questo elemento di flusso in un <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un albero XML usando <xref:System.Xml.Linq.XStreamingElement>. Viene quindi scritto l'elemento di flusso in un <xref:System.Xml.XmlWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 Questo esempio produce il seguente output:  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>