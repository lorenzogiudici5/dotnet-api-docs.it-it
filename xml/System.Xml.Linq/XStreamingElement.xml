<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6871af9cb7a08472c9ddb27a369b0e788d9f8e9e" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39827167" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <TypeSignature Language="F#" Value="type XStreamingElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="a1504-101">Rappresenta gli elementi in un albero XML che supporta l'output del flusso posticipato.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1504-101">Represents elements in an XML tree that supports deferred streaming output.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-102">Questa classe consente di creare un albero XML che supporta l'output del flusso posticipato.</span><span class="sxs-lookup"><span data-stu-id="a1504-102">This class allows you to create an XML tree that supports deferred streaming output.</span></span> <span data-ttu-id="a1504-103">Utilizzare questa classe per creare un albero XML in modo molto simile alla creazione di un albero XML usando <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-103">You use this class to create an XML tree in a very similar fashion to creating an XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="a1504-104">Tuttavia, vi è una differenza fondamentale.</span><span class="sxs-lookup"><span data-stu-id="a1504-104">However, there is a fundamental difference.</span></span> <span data-ttu-id="a1504-105">Quando si utilizza una query LINQ per specificare il contenuto durante la creazione di un file XML della struttura ad albero usando <xref:System.Xml.Linq.XElement>, la variabile di query viene iterata al momento della costruzione dell'albero XML e i risultati della query vengono aggiunti all'albero XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-105">When you use a LINQ query to specify content when creating an XML tree using <xref:System.Xml.Linq.XElement>, the query variable is iterated at the time of construction of the XML tree, and the results of the query are added to the XML tree.</span></span> <span data-ttu-id="a1504-106">Al contrario, quando si crea un albero XML usando <xref:System.Xml.Linq.XStreamingElement>, un riferimento alla variabile di query viene archiviato nell'albero XML senza in fase di iterazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-106">In contrast, when you create an XML tree using <xref:System.Xml.Linq.XStreamingElement>, a reference to the query variable is stored in the XML tree without being iterated.</span></span> <span data-ttu-id="a1504-107">Le query vengono Iterate solo durante la serializzazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-107">Queries are iterated only upon serialization.</span></span> <span data-ttu-id="a1504-108">In questo modo è possibile creare alberi XML più grandi mantenendo un footprint di memoria più piccolo.</span><span class="sxs-lookup"><span data-stu-id="a1504-108">This allows you to create larger XML trees while maintaining a smaller memory footprint.</span></span>  
  
 <span data-ttu-id="a1504-109">Se si utilizza il flusso da un'origine di input, ad esempio un file di testo, quindi è possibile leggere un file di testo di dimensioni molto grandi e generare un documento XML di dimensioni molto grande mantenendo un footprint di memoria di piccole dimensioni.</span><span class="sxs-lookup"><span data-stu-id="a1504-109">If you are streaming from an input source, such as a text file, then you can read a very large text file, and generate a very large XML document while maintaining a small memory footprint.</span></span>  
  
 <span data-ttu-id="a1504-110">Un altro scenario è che si dispone di un albero XML di grandi dimensioni che è stato caricato in memoria e si desidera creare una versione trasformata del documento.</span><span class="sxs-lookup"><span data-stu-id="a1504-110">Another scenario is that you have a large XML tree that has been loaded into memory, and you want to create a transformed version of the document.</span></span> <span data-ttu-id="a1504-111">Se si crea un nuovo documento usando <xref:System.Xml.Linq.XElement>, avrai due strutture ad albero XML di grandi dimensioni in memoria dopo il completamento della trasformazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-111">If you create a new document using <xref:System.Xml.Linq.XElement>, then you will have two large XML trees in memory upon completion of the transformation.</span></span> <span data-ttu-id="a1504-112">Tuttavia, se si crea il nuovo albero XML usando <xref:System.Xml.Linq.XStreamingElement>, quindi verrà eliminato in modo efficace il working set a metà.</span><span class="sxs-lookup"><span data-stu-id="a1504-112">However, if you create the new XML tree using <xref:System.Xml.Linq.XStreamingElement>, then your working set will be effectively cut in half.</span></span>  
  
 <span data-ttu-id="a1504-113">Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare.</span><span class="sxs-lookup"><span data-stu-id="a1504-113">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="a1504-114">In questo modo il codice XML da serializzare.</span><span class="sxs-lookup"><span data-stu-id="a1504-114">This causes the XML to be serialized.</span></span> <span data-ttu-id="a1504-115">Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.</span><span class="sxs-lookup"><span data-stu-id="a1504-115">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-116">L'esempio seguente crea innanzitutto un albero XML di origine.</span><span class="sxs-lookup"><span data-stu-id="a1504-116">The following example first creates a source XML tree.</span></span> <span data-ttu-id="a1504-117">Crea quindi una trasformazione dell'origine XML albero utilizzando <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-117">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="a1504-118">Questa trasformazione consente di creare un nuovo albero in memoria.</span><span class="sxs-lookup"><span data-stu-id="a1504-118">This transform creates a new tree in memory.</span></span> <span data-ttu-id="a1504-119">Crea quindi una trasformazione dell'origine XML albero utilizzando <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-119">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-120">Questa trasformazione non esegue la query fino a quando l'albero trasformato viene serializzato nella console.</span><span class="sxs-lookup"><span data-stu-id="a1504-120">This transform doesn't execute the query until the transformed tree is serialized to the console.</span></span> <span data-ttu-id="a1504-121">L'utilizzo della memoria è inferiore.</span><span class="sxs-lookup"><span data-stu-id="a1504-121">Its memory usage is less.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 <span data-ttu-id="a1504-122">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-122">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 <span data-ttu-id="a1504-123">Uno degli approcci disponibili per l'elaborazione di un file di testo consiste nello scrivere un metodo di estensione che genera un flusso del file di testo, una riga alla volta, tramite il costrutto `yield return`.</span><span class="sxs-lookup"><span data-stu-id="a1504-123">One approach to processing a text file is to write an extension method that streams the text file a line at a time using the `yield return` construct.</span></span> <span data-ttu-id="a1504-124">È quindi possibile scrivere una query LINQ che elabora il file di testo in modo posticipato lazy.</span><span class="sxs-lookup"><span data-stu-id="a1504-124">You then can write a LINQ query that processes the text file in a lazy deferred fashion.</span></span> <span data-ttu-id="a1504-125">Se si usa quindi il <xref:System.Xml.Linq.XStreamingElement> al flusso di output, è possibile creare una trasformazione del file di testo in formato XML che utilizza una quantità minima di memoria, indipendentemente dalle dimensioni del file di testo di origine.</span><span class="sxs-lookup"><span data-stu-id="a1504-125">If you then use the <xref:System.Xml.Linq.XStreamingElement> to stream output, you then can create a transform from the text file to XML that uses a minimal amount of memory, regardless of the size of the source text file.</span></span>  
  
 <span data-ttu-id="a1504-126">Il file di testo seguente, People.txt, è l'origine di questo esempio.</span><span class="sxs-lookup"><span data-stu-id="a1504-126">The following text file, People.txt, is the source for this example.</span></span>  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 <span data-ttu-id="a1504-127">Nel codice seguente è contenuto un metodo di estensione che genera il flusso delle righe del file di testo in modo posticipato.</span><span class="sxs-lookup"><span data-stu-id="a1504-127">The following code contains an extension method that streams the lines of the text file in a deferred fashion.</span></span>  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="a1504-128">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 <span data-ttu-id="a1504-129">A volte è necessario trasformare file XML di grandi dimensioni e scrivere l'applicazione in modo tale che il footprint di memoria dell'applicazione sia prevedibile.</span><span class="sxs-lookup"><span data-stu-id="a1504-129">Sometimes you have to transform large XML files, and write your application so that the memory footprint of the application is predictable.</span></span> <span data-ttu-id="a1504-130">Se si tenta di popolare un albero XML con un file XML molto grande, l'uso della memoria sarà proporzionale alla dimensione del file (ovvero, eccessivo).</span><span class="sxs-lookup"><span data-stu-id="a1504-130">If you try to populate an XML tree with a very large XML file, your memory usage will be proportional to the size of the file (that is, excessive).</span></span> <span data-ttu-id="a1504-131">Pertanto, è necessario usare una tecnica di flusso in sostituzione.</span><span class="sxs-lookup"><span data-stu-id="a1504-131">Therefore, you should use a streaming technique instead.</span></span>  
  
 <span data-ttu-id="a1504-132">Determinati operatori di query standard, ad esempio <xref:System.Linq.Enumerable.OrderBy%2A>, scorrono l'origine, raccolgono tutti i dati, li ordinano e infine restituiscono il primo elemento nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="a1504-132">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="a1504-133">Si noti che se si usa un operatore di query che materializza l'origine prima di restituire il primo elemento, non verrà mantenuto un footprint di memoria ridotto per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-133">Note that if you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint for your application.</span></span>  
  
 <span data-ttu-id="a1504-134">Anche se si usa la tecnica descritta in, se si tenta di assemblare un albero XML che contiene il documento trasformato, utilizzo della memoria potrebbe essere troppo elevato.</span><span class="sxs-lookup"><span data-stu-id="a1504-134">Even if you use the technique described in , if you try to assemble an XML tree that contains the transformed document, memory usage may be too great.</span></span>  
  
 <span data-ttu-id="a1504-135">L'esempio seguente si basa sull'esempio in [procedura: Stream frammenti XML con accesso a informazioni di intestazione](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span><span class="sxs-lookup"><span data-stu-id="a1504-135">The following example builds on the example in [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="a1504-136">In questo esempio vengono usate le funzionalità di esecuzione posticipata di <xref:System.Xml.Linq.XStreamingElement> per generare il flusso di output.</span><span class="sxs-lookup"><span data-stu-id="a1504-136">This example uses the deferred execution capabilities of <xref:System.Xml.Linq.XStreamingElement> to stream the output.</span></span>  
  
 <span data-ttu-id="a1504-137">Si noti che il metodo dell'asse personalizzato (`StreamCustomerItem`) è stato scritto in modo tale da prevedere un documento contenente elementi `Customer`, `Name` e `Item`, disposti come nel documento Source.xml seguente.</span><span class="sxs-lookup"><span data-stu-id="a1504-137">Note that the custom axis (`StreamCustomerItem`) is specifically written so that it expects a document that has `Customer`, `Name`, and `Item` elements, and that those elements will be arranged as in the following Source.xml document.</span></span> <span data-ttu-id="a1504-138">Tuttavia, un'implementazione più affidabile convaliderebbe il documento di origine con uno schema XSD oppure verrebbe preparata per analizzare un documento non valido.</span><span class="sxs-lookup"><span data-stu-id="a1504-138">A more robust implementation, however, would either validate the source document with an XSD, or would be prepared to parse an invalid document.</span></span>  
  
 <span data-ttu-id="a1504-139">Il documento seguente, Source.xml, è il documento di origine:</span><span class="sxs-lookup"><span data-stu-id="a1504-139">The following is the source document, Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 <span data-ttu-id="a1504-140">Il codice seguente contiene un metodo che usa un <xref:System.Xml.XmlReader> il flusso XML di origine.</span><span class="sxs-lookup"><span data-stu-id="a1504-140">The following code contains a method that uses an <xref:System.Xml.XmlReader> to stream the source XML.</span></span> <span data-ttu-id="a1504-141">Usa <xref:System.Xml.Linq.XStreamingElement> per trasmettere il nuovo codice XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-141">It uses <xref:System.Xml.Linq.XStreamingElement> to stream the new XML.</span></span>  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 <span data-ttu-id="a1504-142">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-142">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1504-143">Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-143">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-144">Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato.</span><span class="sxs-lookup"><span data-stu-id="a1504-144">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="a1504-145">Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-145">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="a1504-146">Per informazioni dettagliate sul contenuto valido che può essere passato a questo costruttore, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="a1504-146">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1504-147">Oggetto <see cref="T:System.Xml.Linq.XName" /> che contiene il nome dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-147">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-148">Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XElement" /> dall'oggetto <see cref="T:System.Xml.Linq.XName" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from the specified <see cref="T:System.Xml.Linq.XName" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-149">Questo costruttore crea un elemento di flusso con nessun contenuto e non sono presenti attributi.</span><span class="sxs-lookup"><span data-stu-id="a1504-149">This constructor creates a streaming element with no content and no attributes.</span></span>  
  
 <span data-ttu-id="a1504-150">È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-150">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="a1504-151">È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-151">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="a1504-152">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-152">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1504-153">Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-153">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span>
          </span>
        </param>
        <param name="content">
          <span data-ttu-id="a1504-154">Contenuto dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-154">The contents of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-155">Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" /> con il nome e il contenuto specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-155">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-156">Questo costruttore crea un elemento di flusso con il contenuto specificato e attributi.</span><span class="sxs-lookup"><span data-stu-id="a1504-156">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="a1504-157">È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-157">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="a1504-158">È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-158">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="a1504-159">Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato.</span><span class="sxs-lookup"><span data-stu-id="a1504-159">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="a1504-160">Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-160">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="a1504-161">Per informazioni dettagliate sul contenuto valido che può essere passato a questo costruttore, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="a1504-161">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-162">Questo esempio Usa il file XML seguente, denominato Source. XML:</span><span class="sxs-lookup"><span data-stu-id="a1504-162">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj[] -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1504-163">Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-163">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span>
          </span>
        </param>
        <param name="content">
          <span data-ttu-id="a1504-164">Contenuto dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-164">The contents of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-165">Inizializza una nuova istanza della classe <see cref="T:System.Xml.Linq.XStreamingElement" /> con il nome e il contenuto specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-165">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-166">Questo costruttore crea un elemento di flusso con il contenuto specificato e attributi.</span><span class="sxs-lookup"><span data-stu-id="a1504-166">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="a1504-167">È una conversione implicita da stringa a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-167">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="a1504-168">È tipico di utilizzo di questo costruttore per specificare una stringa come parametro anziché creare un nuovo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="a1504-168">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="a1504-169">Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato.</span><span class="sxs-lookup"><span data-stu-id="a1504-169">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="a1504-170">Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-170">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="a1504-171">Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="a1504-171">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-172">Questo esempio Usa il file XML seguente, denominato Source. XML:</span><span class="sxs-lookup"><span data-stu-id="a1504-172">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1504-173">Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-173">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="a1504-174">Contenuto da aggiungere all'elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-174">Content to be added to the streaming element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-175">Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-175">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-176">Il costruttore aggiunge il contenuto specificato e attributi per il <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-176">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-177">Sebbene sia spesso possibile costruire il <xref:System.Xml.Linq.XStreamingElement> in un'unica istruzione, è talvolta più pratico aggiungere contenuto all'elemento di flusso in modo incrementale.</span><span class="sxs-lookup"><span data-stu-id="a1504-177">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="a1504-178">Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato.</span><span class="sxs-lookup"><span data-stu-id="a1504-178">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="a1504-179">Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-179">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="a1504-180">Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="a1504-180">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-181">L'esempio seguente crea un nuovo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-181">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-182">Aggiunge quindi due query all'elemento di flusso.</span><span class="sxs-lookup"><span data-stu-id="a1504-182">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="a1504-183">Le query non vengono Iterate fino a quando non viene serializzato l'elemento di flusso.</span><span class="sxs-lookup"><span data-stu-id="a1504-183">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="a1504-184">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-184">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj[] -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="a1504-185">Contenuto da aggiungere all'elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-185">Content to be added to the streaming element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-186">Aggiunge il contenuto specificato come figlio a <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-186">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-187">Il costruttore aggiunge il contenuto specificato e attributi per il <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-187">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-188">Sebbene sia spesso possibile costruire il <xref:System.Xml.Linq.XStreamingElement> in un'unica istruzione, è talvolta più pratico aggiungere contenuto all'elemento di flusso in modo incrementale.</span><span class="sxs-lookup"><span data-stu-id="a1504-188">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="a1504-189">Le query non vengono scorse finché il <xref:System.Xml.Linq.XStreamingElement> viene serializzato.</span><span class="sxs-lookup"><span data-stu-id="a1504-189">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="a1504-190">Questo è in contrasto con le query per il contenuto per un <xref:System.Xml.Linq.XElement>, in cui le query vengono Iterate al momento della costruzione del nuovo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-190">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="a1504-191">Per informazioni dettagliate sul contenuto valido che può essere passato a questa funzione, vedere [valida contenuto di oggetti XElement e XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="a1504-191">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-192">L'esempio seguente crea un nuovo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-192">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-193">Aggiunge quindi due query all'elemento di flusso.</span><span class="sxs-lookup"><span data-stu-id="a1504-193">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="a1504-194">Le query non vengono Iterate fino a quando non viene serializzato l'elemento di flusso.</span><span class="sxs-lookup"><span data-stu-id="a1504-194">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="a1504-195">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-195">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName with get, set" Usage="System.Xml.Linq.XStreamingElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a1504-196">Ottiene o imposta il nome dell'elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-196">Gets or sets the name of this streaming element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a1504-197">Oggetto <see cref="T:System.Xml.Linq.XName" /> contenente il nome di questo elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-197">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of this streaming element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a1504-198">In questo esempio crea un nuovo elemento di flusso e quindi stampato il nome dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="a1504-198">This example creates a new streaming element, and then prints the name of the element.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 <span data-ttu-id="a1504-199">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-199">This example produces the following output:</span></span>  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1504-200">Serializzare questo elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-200">Serialize this streaming element.</span>
          </span>
          <span data-ttu-id="a1504-201">L'output può essere salvato in un file oppure in un oggetto <see cref="T:System.Xml.XmlTextWriter" />, <see cref="T:System.IO.TextWriter" /> o <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-201">The output can be saved to a file, an <see cref="T:System.Xml.XmlTextWriter" />, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
          <span data-ttu-id="a1504-202">Facoltativamente, è possibile disabilitare la formattazione (rientro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-202">Optionally, formatting (indenting) can be disabled.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xStreamingElement.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="a1504-203">Flusso in cui restituire l'oggetto <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-203">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-204">Restituisce l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" /> nell'oggetto <see cref="T:System.IO.Stream" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-204">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-205">Il codice XML serializzato verrà aumentato il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-205">The serialized XML will be indented.</span></span> <span data-ttu-id="a1504-206">Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente.</span><span class="sxs-lookup"><span data-stu-id="a1504-206">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="a1504-207">Il comportamento di questo metodo è che gli spazi vuoti non significativi non verranno mantenuti.</span><span class="sxs-lookup"><span data-stu-id="a1504-207">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="a1504-208">Se si desidera controllare lo spazio vuoto, usare l'overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accetta <xref:System.Xml.Linq.SaveOptions> come parametro.</span><span class="sxs-lookup"><span data-stu-id="a1504-208">If you want to control white space, use the overload of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="a1504-209">Usare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> opzione per salvare il codice XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-209">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="a1504-210">Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-210">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="a1504-211">Usare <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opzione se si desidera rimuovere le dichiarazioni dello spazio dei nomi duplicati.</span><span class="sxs-lookup"><span data-stu-id="a1504-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xStreamingElement.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="a1504-212">Oggetto <see cref="T:System.IO.TextWriter" /> in cui verrà scritto l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-212">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XStreamingElement" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-213">Serializzare questo elemento di flusso in un <see cref="T:System.IO.TextWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-213">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-214">Il codice XML serializzato verrà aumentato il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-214">The serialized XML will be indented.</span></span> <span data-ttu-id="a1504-215">Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente.</span><span class="sxs-lookup"><span data-stu-id="a1504-215">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="a1504-216">Il comportamento di questo metodo è che lo spazio vuoto non significativo nodi dell'albero XML non verranno mantenuti.</span><span class="sxs-lookup"><span data-stu-id="a1504-216">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="a1504-217">Se si desidera controllare lo spazio vuoto, usare uno degli overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accettano <xref:System.Xml.Linq.SaveOptions> come parametro.</span><span class="sxs-lookup"><span data-stu-id="a1504-217">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="a1504-218">Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="a1504-218">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-219">Nell'esempio seguente crea un albero XML di origine, quindi crea un'istanza di un <xref:System.Xml.Linq.XStreamingElement> utilizzando una query sulla struttura XML di origine.</span><span class="sxs-lookup"><span data-stu-id="a1504-219">The following example creates a source XML tree, then instantiates an <xref:System.Xml.Linq.XStreamingElement> using a query on the source XML tree.</span></span> <span data-ttu-id="a1504-220">Viene quindi scritto l'elemento di flusso in un <xref:System.IO.StringWriter>.</span><span class="sxs-lookup"><span data-stu-id="a1504-220">It then writes the streaming element to a <xref:System.IO.StringWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="a1504-221">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-221">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xStreamingElement.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="a1504-222">Oggetto <see cref="T:System.String" /> che contiene il nome del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-222">A <see cref="T:System.String" /> that contains the name of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-223">Serializzare questo elemento di flusso in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-223">Serialize this streaming element to a file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-224">Il codice XML serializzato verrà aumentato il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-224">The serialized XML will be indented.</span></span> <span data-ttu-id="a1504-225">Verranno rimossi tutti gli spazi vuoti non significativi e verrà aggiunto uno spazio vuoto aggiuntivo in modo che il codice XML rientrato correttamente.</span><span class="sxs-lookup"><span data-stu-id="a1504-225">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="a1504-226">Il comportamento di questo metodo è che lo spazio vuoto non significativo nodi dell'albero XML non verranno mantenuti.</span><span class="sxs-lookup"><span data-stu-id="a1504-226">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="a1504-227">Se si desidera controllare lo spazio vuoto, usare uno degli overload del <xref:System.Xml.Linq.XStreamingElement.Save%2A> che accettano <xref:System.Xml.Linq.SaveOptions> come parametro.</span><span class="sxs-lookup"><span data-stu-id="a1504-227">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="a1504-228">Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="a1504-228">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-229">L'esempio seguente crea un albero XML di streaming.</span><span class="sxs-lookup"><span data-stu-id="a1504-229">The following example creates a streaming XML tree.</span></span> <span data-ttu-id="a1504-230">Serializza quindi l'albero XML streaming in un file.</span><span class="sxs-lookup"><span data-stu-id="a1504-230">It then serializes the streaming XML tree to a file.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="a1504-231">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-231">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="a1504-232">Oggetto <see cref="T:System.Xml.XmlWriter" /> in cui verrà scritto l'oggetto <see cref="T:System.Xml.Linq.XElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-232">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-233">Serializzare questo elemento di flusso in un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-233">Serialize this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a1504-234">L'esempio seguente crea un <xref:System.Xml.Linq.XStreamingElement> e lo scrive in un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="a1504-234">The following example creates an <xref:System.Xml.Linq.XStreamingElement> and writes it to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="a1504-235">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-235">This example produces the following output:</span></span>  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="a1504-236">Flusso in cui restituire l'oggetto <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-236">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="a1504-237">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento della formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-237">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-238">Restituisce l'oggetto <see cref="T:System.Xml.Linq.XStreamingElement" /> nell'oggetto <see cref="T:System.IO.Stream" /> specificato, indicando facoltativamente il comportamento di formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-238">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-239">Per impostazione predefinita il `options` sono impostati su <xref:System.Xml.Linq.SaveOptions.None>.</span><span class="sxs-lookup"><span data-stu-id="a1504-239">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="a1504-240">Questa opzione rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-240">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="a1504-241">Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`.</span><span class="sxs-lookup"><span data-stu-id="a1504-241">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="a1504-242">Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-242">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="a1504-243">Usare <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opzione se si desidera rimuovere le dichiarazioni dello spazio dei nomi duplicati.</span><span class="sxs-lookup"><span data-stu-id="a1504-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="a1504-244">Oggetto <see cref="T:System.IO.TextWriter" /> nel quale deve essere restituito il codice XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-244">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="a1504-245">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento di formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-245">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-246">Serializzare questo elemento di flusso in un <see cref="T:System.IO.TextWriter" />, disabilitando facoltativamente la formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-246">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-247">Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`.</span><span class="sxs-lookup"><span data-stu-id="a1504-247">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="a1504-248">Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-248">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="a1504-249">Se si desidera salvare il codice XML rientrato, non specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`.</span><span class="sxs-lookup"><span data-stu-id="a1504-249">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="a1504-250">In questo rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-250">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="a1504-251">Si tratta del comportamento predefinito e il comportamento degli overload del <xref:System.Xml.Linq.XElement.Save%2A> metodi che non accettano `options` come parametro.</span><span class="sxs-lookup"><span data-stu-id="a1504-251">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="a1504-252">Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="a1504-252">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-253">Nell'esempio seguente mostra due usi di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="a1504-253">The following example shows two uses of this method.</span></span> <span data-ttu-id="a1504-254">Al primo uso consente di mantenere gli spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="a1504-254">The first use preserves white space.</span></span> <span data-ttu-id="a1504-255">Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-255">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="a1504-256">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-256">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="a1504-257">Oggetto <see cref="T:System.String" /> che contiene il nome del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-257">A <see cref="T:System.String" /> that contains the name of the file.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="a1504-258">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento della formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-258">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-259">Serializzare questo elemento di flusso in un file, disabilitando facoltativamente la formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-259">Serialize this streaming element to a file, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-260">Se si desidera salvare il codice XML, specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`.</span><span class="sxs-lookup"><span data-stu-id="a1504-260">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="a1504-261">Ciò causerà il writer scrivere tutti gli spazi vuoti esattamente come rappresentato nell'albero XML.</span><span class="sxs-lookup"><span data-stu-id="a1504-261">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="a1504-262">Se si desidera salvare il codice XML rientrato, non specificare il <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag per `options`.</span><span class="sxs-lookup"><span data-stu-id="a1504-262">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="a1504-263">In questo rimuoverà tutti gli spazi vuoti non significativi estranei e aggiungere gli spazi vuoti non significativi appropriato in modo che il codice XML sia correttamente il rientro.</span><span class="sxs-lookup"><span data-stu-id="a1504-263">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="a1504-264">Si tratta del comportamento predefinito e il comportamento degli overload del <xref:System.Xml.Linq.XElement.Save%2A> metodi che non accettano `options` come parametro.</span><span class="sxs-lookup"><span data-stu-id="a1504-264">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="a1504-265">Per altre informazioni, vedere [conservare lo spazio vuoto durante il caricamento o l'analisi XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) e [conservare gli spazi vuoti durante la serializzazione](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="a1504-265">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-266">Nell'esempio seguente mostra due usi di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="a1504-266">The following example shows two uses of this method.</span></span> <span data-ttu-id="a1504-267">Al primo uso consente di mantenere gli spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="a1504-267">The first use preserves white space.</span></span> <span data-ttu-id="a1504-268">Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-268">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 <span data-ttu-id="a1504-269">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-269">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1504-270">Restituisce il codice XML per questo elemento di flusso, disabilitando facoltativamente la formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-270">Returns the XML for this streaming element, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-271">Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare.</span><span class="sxs-lookup"><span data-stu-id="a1504-271">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="a1504-272">In questo modo il codice XML da serializzare.</span><span class="sxs-lookup"><span data-stu-id="a1504-272">This causes the XML to be serialized.</span></span> <span data-ttu-id="a1504-273">Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.</span><span class="sxs-lookup"><span data-stu-id="a1504-273">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xStreamingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a1504-274">Restituisce il codice XML formattato (con rientro) per questo elemento di flusso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-274">Returns the formatted (indented) XML for this streaming element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1504-275">
            <see cref="T:System.String" /> contenente il codice XML con rientro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-275">A <see cref="T:System.String" /> containing the indented XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-276">Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare.</span><span class="sxs-lookup"><span data-stu-id="a1504-276">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="a1504-277">In questo modo il codice XML da serializzare.</span><span class="sxs-lookup"><span data-stu-id="a1504-277">This causes the XML to be serialized.</span></span> <span data-ttu-id="a1504-278">Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.</span><span class="sxs-lookup"><span data-stu-id="a1504-278">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-279">Nell'esempio seguente mostra due usi di <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1504-279">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="a1504-280">Al primo uso consente di mantenere gli spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="a1504-280">The first use preserves white space.</span></span> <span data-ttu-id="a1504-281">Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-281">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="a1504-282">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-282">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xStreamingElement.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="a1504-283">Oggetto <see cref="T:System.Xml.Linq.SaveOptions" /> che specifica il comportamento di formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-283">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-284">Restituisce il codice XML per questo elemento di flusso, disabilitando facoltativamente la formattazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-284">Returns the XML for this streaming element, optionally disabling formatting.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1504-285">
            <see cref="T:System.String" /> contenente il codice XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-285">A <see cref="T:System.String" /> containing the XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1504-286">Si noti che durante il debug di un programma che usa <xref:System.Xml.Linq.XStreamingElement>, fa in modo che la visualizzazione del valore di un oggetto relativo <xref:System.Xml.Linq.XStreamingElement.ToString%2A> metodo da chiamare.</span><span class="sxs-lookup"><span data-stu-id="a1504-286">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="a1504-287">In questo modo il codice XML da serializzare.</span><span class="sxs-lookup"><span data-stu-id="a1504-287">This causes the XML to be serialized.</span></span> <span data-ttu-id="a1504-288">Se la semantica della query elemento di streaming in modo che l'elemento di flusso può essere trasmesso solo una volta, ciò potrebbe causare un comportamento indesiderato nell'esperienza di debug.</span><span class="sxs-lookup"><span data-stu-id="a1504-288">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1504-289">Nell'esempio seguente mostra due usi di <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1504-289">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="a1504-290">Al primo uso consente di mantenere gli spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="a1504-290">The first use preserves white space.</span></span> <span data-ttu-id="a1504-291">Il secondo serializza il <xref:System.Xml.Linq.XStreamingElement> con formattazione.</span><span class="sxs-lookup"><span data-stu-id="a1504-291">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="a1504-292">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-292">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="a1504-293">Oggetto <see cref="T:System.Xml.XmlWriter" /> in cui scriverà questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-293">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1504-294">Scrive questo elemento di flusso in un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1504-294">Writes this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a1504-295">L'esempio seguente crea un albero XML usando <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="a1504-295">The following example creates an XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="a1504-296">Viene quindi scritto l'elemento di flusso in un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="a1504-296">It then writes the streaming element to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="a1504-297">Questo esempio produce il seguente output:</span><span class="sxs-lookup"><span data-stu-id="a1504-297">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>