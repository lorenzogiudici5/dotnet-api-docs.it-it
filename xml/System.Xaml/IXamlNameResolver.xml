<Type Name="IXamlNameResolver" FullName="System.Xaml.IXamlNameResolver">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="667f1314cf421526dbdde15bf44a215978170d3b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30719615" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IXamlNameResolver" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IXamlNameResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.IXamlNameResolver" />
  <TypeSignature Language="VB.NET" Value="Public Interface IXamlNameResolver" />
  <TypeSignature Language="C++ CLI" Value="public interface class IXamlNameResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Descrive un servizio che può restituire oggetti specificati in base al nome XAML o in alternativa restituire un token che posticipa la risoluzione dei nomi. Il servizio può inoltre restituire un set enumerabile di tutti gli oggetti denominati presenti nel NameScope XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa interfaccia non è per l'implementazione esterna di scenari XAML tipici perché è un servizio. Questo servizio consente le estensioni di markup e convertitori di tipi di risolvere nomi XAML per gli altri oggetti dalla stessa origine XAML mentre sono ancora in una rappresentazione del nodo XAML. Il servizio può essere utilizzato per risolvere i riferimenti in avanti per qualsiasi meccanismo che si basa sui nomi XAML per l'accesso non lineare per la produzione XAML circostante. Per ulteriori informazioni, vedere [convertitori di tipi ed estensioni di Markup per XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  
  
 Convertitori di tipi ed estensioni di markup possono eseguire query per <xref:System.Xaml.IXamlNameResolver> come servizio nel contesto del servizio fornito da un writer di oggetti XAML, quando il writer di oggetti XAML richiama il comportamento di conversione di valori. Per ulteriori informazioni, vedere [convertitori di tipi ed estensioni di Markup per XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md) e [contesti di servizio disponibili per convertitori di tipi ed estensioni di Markup](~/docs/framework/xaml-services/service-contexts-available-to-type-converters-and-markup-extensions.md).  
  
 Questo servizio espone un'API che è possibile posticipare la risoluzione dei nomi. La metafora implementata dal servizio è che i nomi che non possono essere risolto in un primo passaggio in un grafico del nome dell'oggetto parziale devono essere archiviati e utilizzati per creare il token di correzione. Il comportamento predefinito, tali nomi vengono inviati a un altro tentativo di risoluzione in un secondo passaggio. Nel secondo passaggio, il grafico complessivo del nome dell'oggetto è stato completato e sono in grado di risolvere tutti i token di correzione.  
  
> [!NOTE]
>  Anche se sono consentiti da una particolare implementazione, i riferimenti in avanti in XAML inevitabilmente avere conseguenze sulle prestazioni. Come procedura consigliata per la produzione XAML, evitare i riferimenti in avanti quando possibile.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.INameScopeDictionary" />
    <altmember cref="T:System.Windows.NameScope" />
  </Docs>
  <Members>
    <Member MemberName="GetAllNamesAndValuesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetAllNamesAndValuesInScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetAllNamesAndValuesInScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetAllNamesAndValuesInScope" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllNamesAndValuesInScope () As IEnumerable(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetAllNamesAndValuesInScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un set enumerabile di tutti gli oggetti denominati nel NameScope XAML.</summary>
        <returns>Set enumerabile di oggetti <see cref="T:System.Collections.Generic.KeyValuePair`2" />. Per ogni oggetto <see cref="T:System.Collections.Generic.KeyValuePair`2" />, il componente <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> è una stringa e il componente <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" /> è l'oggetto che utilizza il nome <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> nel NameScope XAML.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFixupToken">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto che può correggere alcuni modelli di markup che producono riferimenti in avanti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFixupToken">
      <MemberSignature Language="C#" Value="public object GetFixupToken (System.Collections.Generic.IEnumerable&lt;string&gt; names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFixupToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFixupToken (names As IEnumerable(Of String)) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFixupToken(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="names">Insieme di nomi che rappresentano possibili riferimenti in avanti.</param>
        <summary>Restituisce un oggetto che può correggere alcuni modelli di markup che producono riferimenti in avanti.</summary>
        <returns>Oggetto che fornisce un token per il comportamento di ricerca da valutare in un secondo momento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I provider di servizi interno esistenti che sono disponibili nei contesti dello schema per le estensioni di markup e convertitori di tipi è possono implementare questo servizio. Tuttavia, restituiscono un tipo interno in grado di elaborare solo i writer XAML esistenti che funzionano sotto il contesto dello schema XAML predefinito.  
  
 Quando tutti i nomi di cui viene fatto riferimenti in avanti sono risolvibili, il codice utente viene chiamato per ogni nome nell'elenco di analisi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFixupToken">
      <MemberSignature Language="C#" Value="public object GetFixupToken (System.Collections.Generic.IEnumerable&lt;string&gt; names, bool canAssignDirectly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFixupToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; names, bool canAssignDirectly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFixupToken (names As IEnumerable(Of String), canAssignDirectly As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFixupToken(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ names, bool canAssignDirectly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="canAssignDirectly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="names">Insieme di nomi che rappresentano possibili riferimenti in avanti.</param>
        <param name="canAssignDirectly">
          <see langword="true" /> per assegnare immediatamente il riferimento di nome risolto alla proprietà di destinazione. <see langword="false" /> per chiamare il codice utente per una nuova analisi. Il comportamento predefinito è <see langword="false" />.</param>
        <summary>Restituisce un oggetto che può correggere alcuni modelli di markup che producono riferimenti in avanti.</summary>
        <returns>Oggetto che fornisce un token per il comportamento di ricerca da valutare in un secondo momento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I provider di servizi interno esistenti che sono disponibili nei contesti dello schema per le estensioni di markup e convertitori di tipi implementano questo servizio. Tuttavia, restituiscono un tipo interno che può essere elaborato solo per i writer XAML esistenti che funzionano sotto il contesto dello schema XAML predefinito.  
  
 Se `canAssignDirectly` è `false`, quando tutti i nomi di cui viene fatto riferimenti in avanti sono risolvibili, il codice utente viene chiamato per ogni nome nell'elenco di analisi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixupTokenAvailable">
      <MemberSignature Language="C#" Value="public bool IsFixupTokenAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixupTokenAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.IXamlNameResolver.IsFixupTokenAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixupTokenAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixupTokenAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che determina se la chiamata a <see cref="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" /> è disponibile per risolvere un nome in un token per la risoluzione in avanti.</summary>
        <value>
          <see langword="true" /> se <see cref="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" /> è disponibile come un'implementazione che restituisce un token utile per la risoluzione in avanti; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `false` quando <xref:System.Xaml.IXamlNameResolver.GetFixupToken%2A> non restituisce un token perché un <xref:System.Xaml.Schema.XamlValueConverter%601> è coinvolto nel secondo passaggio su un token esistente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNameScopeInitializationComplete">
      <MemberSignature Language="C#" Value="event EventHandler OnNameScopeInitializationComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler OnNameScopeInitializationComplete" />
      <MemberSignature Language="DocId" Value="E:System.Xaml.IXamlNameResolver.OnNameScopeInitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Event OnNameScopeInitializationComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ OnNameScopeInitializationComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un processore XAML ha registrato tutti i nomi relativi al NameScope XAML sottostante.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resolve">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Risolve un oggetto da un riferimento del nome.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public object Resolve (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Resolve(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.Resolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resolve (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Resolve(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Riferimento del nome da risolvere.</param>
        <summary>Risolve un oggetto da un riferimento del nome.</summary>
        <returns>Oggetto risolto o null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene restituito un valore come `null`, potrebbe esistere un riferimento in avanti. Le implementazioni che prevede di supportare i riferimenti in avanti possono utilizzare il `FixupToken` schema tramite il <xref:System.Xaml.IXamlNameResolver.GetFixupToken%2A> e <xref:System.Xaml.IXamlNameResolver.IsFixupTokenAvailable%2A> API.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.INameScope.FindName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public object Resolve (string name, out bool isFullyInitialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Resolve(string name, [out] bool&amp; isFullyInitialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.Resolve(System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resolve (name As String, ByRef isFullyInitialized As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Resolve(System::String ^ name, [Runtime::InteropServices::Out] bool % isFullyInitialized);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="isFullyInitialized" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Riferimento del nome da risolvere.</param>
        <param name="isFullyInitialized">Quando questo metodo restituisce il risultato, <see langword="true" /> se l'oggetto restituito presenta dipendenze nei riferimenti non risolti; in caso contrario, <see langword="false" />.</param>
        <summary>Risolve un oggetto da un riferimento del nome e fornisce un valore di rilevamento che riporta se l'oggetto viene inizializzato completamente ai fini degli oggetti grafici.</summary>
        <returns>Oggetto che fornisce un token per il comportamento di ricerca da valutare in un secondo momento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>