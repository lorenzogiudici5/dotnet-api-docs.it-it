<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5bc7b7a2907aab3912eeac3fba27db4bf120c40" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52217095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una classe base per specificare il comportamento dinamico in fase di esecuzione. Questa classe deve essere ereditata; non è possibile crearne direttamente un'istanza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `DynamicObject` classe consente di definire quali operazioni possono essere eseguite su oggetti dinamici e come eseguire queste operazioni. Ad esempio, è possibile definire cosa accade quando si tenta di ottenere o impostare una proprietà dell'oggetto, chiamare un metodo o eseguire operazioni matematiche standard, ad esempio addizioni e moltiplicazioni.  
  
 Questa classe può essere utile se si desidera creare un protocollo più pratico per una libreria. Ad esempio, se gli utenti della libreria sono necessario utilizzare una sintassi simile `Scriptobj.SetProperty("Count", 1)`, è possibile fornire la possibilità di usare sintassi molto più semplice, ad esempio `scriptobj.Count = 1`.  
  
 È possibile creare direttamente un'istanza di `DynamicObject` classe. Per implementare il comportamento dinamico, è possibile ereditare il `DynamicObject` classe ed eseguire l'override dei metodi necessari. Ad esempio, se è necessario solo le operazioni per l'impostazione e recupero delle proprietà, è possibile eseguire l'override solo il <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi.  
  
 In c#, per abilitare il comportamento dinamico per le istanze delle classi derivate dal `DynamicObject` (classe), è necessario usare il `dynamic` (parola chiave). Per altre informazioni, vedere [Uso del tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic, operazioni dinamiche sono supportate dall'associazione tardiva. Per altre informazioni, vedere [associazione anticipata e tardiva](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 Esempio di codice seguente viene illustrato come creare un'istanza di una classe derivata dal `DynamicObject` classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 È anche possibile aggiungere i propri membri alle classi derivate dal `DynamicObject` classe. Se la classe definisce le proprietà ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo), dynamic language runtime (DLR) prima di tutto viene utilizzato lo strumento di associazione di linguaggio per cercare una definizione di una proprietà nella classe statica. Se è presente nessuna di tali proprietà, DLR chiama il <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo).  
  
 Il `DynamicObject` classe implementa l'interfaccia DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, che consente di condividere le istanze del `DynamicObject` classe tra i linguaggi che supportano il modello di interoperabilità DLR. Ad esempio, è possibile creare un'istanza di `DynamicObject` classe in c# e quindi passarla a una funzione di IronPython. Per altre informazioni, vedere [Dynamic Language Runtime Overview](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Se si dispone di uno scenario semplice in cui è necessario un oggetto che può solo aggiungere e rimuovere membri in fase di esecuzione, ma che non è necessario definire operazioni specifiche e non dispone di membri statici, utilizzare il <xref:System.Dynamic.ExpandoObject> classe.  
>   
>  Se si dispone di uno scenario più avanzato in cui è necessario definire come gli oggetti dinamici partecipano il protocollo di interoperabilità, oppure è necessario gestire la memorizzazione nella cache di DLR invio dinamico veloce, creare la propria implementazione del <xref:System.Dynamic.IDynamicMetaObjectProvider> interfaccia.  
  
   
  
## Examples  
 Si supponga di voler fornire una sintassi alternativa per l'accesso ai valori in un dizionario, in modo che anziché la scrittura `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), è possibile scrivere `sampleDictionary.Text = "Sample text"`. Inoltre, si desidera che questa sintassi tra maiuscole e minuscole, in modo che `sampleDictionary.Text` equivale a `sampleDictionary.text`.  
  
 L'esempio di codice seguente illustra il `DynamicDictionary` classe che deriva dal `DynamicObject` classe. Il `DynamicDictionary` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per supportare la nuova sintassi. Fornisce inoltre un `Count` contiene proprietà, che mostra quanti proprietà dinamiche del dizionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Per altri esempi, vedere [Creating Wrappers with DynamicObject](https://go.microsoft.com/fwlink/?LinkId=169008) sul blog di C#-domande frequenti.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Consente ai tipi derivati di creare una nuova istanza del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile creare direttamente un'istanza di <xref:System.Dynamic.DynamicObject> classe. Per implementare il comportamento dinamico, è necessario ereditare il <xref:System.Dynamic.DynamicObject> classe ed eseguire l'override dei metodi necessari.  
  
 In c#, per abilitare il comportamento dinamico per le istanze delle classi derivate dal <xref:System.Dynamic.DynamicObject> (classe), è necessario usare il `dynamic` (parola chiave). Per altre informazioni, vedere [Uso del tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic, operazioni dinamiche sono supportate dall'associazione tardiva. Per altre informazioni, vedere [associazione anticipata e tardiva](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un'istanza delle classi che derivano dal <xref:System.Dynamic.DynamicObject> classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'enumerazione di tutti i nomi di membro dinamici.</summary>
        <returns>Sequenza che contiene nomi dei membri dinamici.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è disponibile solo a scopo di debug.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Espressione che rappresenta l'oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> da inviare ai metodi virtuali dinamici.</param>
        <summary>Fornisce un oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> che invia ai metodi virtuali dinamici. L'oggetto può essere incapsulato all'interno di un altro oggetto <see cref="T:System.Dynamic.DynamicMetaObject" /> per fornire il comportamento personalizzato per singole azioni. Questo metodo supporta l'infrastruttura DLR (Dynamic Language Runtime) per gli implementatori del linguaggio e non è destinato all'utilizzo direttamente dal codice.</summary>
        <returns>Oggetto di tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione binaria. La proprietà <c>binder.Operation</c> restituisce un oggetto <see cref="T:System.Linq.Expressions.ExpressionType" />. Ad esempio, per l'istruzione <c>sum = first + second</c>,dove <c>first</c> e <c>second</c> sono derivati dalla classe <see langword="DynamicObject" />,<c>binder.Operation</c> restituisce <c>ExpressionType.Add</c>.</param>
        <param name="arg">Operando destro per l'operazione binaria. Ad esempio, per l'istruzione <c>sum = first + second</c>, dove <c>first</c> e <c>second</c> sono derivati dalla classe <see langword="DynamicObject" />,<paramref name="arg" /> è uguale a <c>second</c>.</param>
        <param name="result">Risultato dell'operazione binaria.</param>
        <summary>Fornisce l'implementazione per le operazioni binarie. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quali l'aggiunta e la moltiplicazione.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite operazioni binarie per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Questo metodo viene chiamato quando si dispone di operazioni binarie, ad esempio addizione o moltiplicazione. Ad esempio, se il <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> è sottoposto a override, viene richiamato automaticamente, ad esempio le istruzioni `sum = first + second` o `multiply = first*second`, dove `first` è derivato dal `DynamicObject` classe.  
  
 È possibile ottenere informazioni sul tipo di operazione binaria usando il `Operation` proprietà del `binder` parametro.  
  
 Se l'oggetto dinamico viene usato solo in c# e Visual Basic, il `binder.Operation` proprietà può avere uno dei seguenti valori dal <xref:System.Linq.Expressions.ExpressionType> enumerazione. In altri linguaggi, ad esempio IronPython o IronRuby, tuttavia, si possono avere altri valori.
  
|Valore|Descrizione|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Un'operazione di addizione senza controllo dell'overflow, per operandi numerici.|`a + b`|`a + b`|  
|`AddAssign`|Un'operazione di assegnazione composta di addizione senza controllo dell'overflow, per operandi numerici.|`a += b`|Non supportato.|  
|`And`|Bit per bit `AND` operazione.|`a & b`|`a And b`|  
|`AndAssign`|Bit per bit `AND` operazione di assegnazione composta.|`a &= b`|Non supportato.|  
|`Divide`|Un'operazione di divisione aritmetica.|`a / b`|`a / b`|  
|`DivideAssign`|Un'operazione di assegnazione composta di divisione aritmetica.|`a /= b`|Non supportato.|  
|`ExclusiveOr`|Bit per bit `XOR` operazione.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Bit per bit `XOR` operazione di assegnazione composta.|`a ^= b`|Non supportato.|  
|`GreaterThan`|Confronto "maggiore di".|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Confronto "maggiore o uguale a".|`a >= b`|Non supportato.|  
|`LeftShift`|Un'operazione di spostamento a sinistra bit per bit.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Un'operazione di assegnazione composta di spostamento a sinistra bit per bit.|`a <<= b`|Non supportato.|  
|`LessThan`|Confronto "minore di".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Confronto "minore o uguale a".|`a <= b`|Non supportato.|  
|`Modulo`|Un'operazione di resto aritmetico.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Un'operazione di assegnazione composta di resto aritmetico.|`a %= b`|Non supportato.|  
|`Multiply`|Un'operazione di moltiplicazione senza controllo dell'overflow, per operandi numerici.|`a * b`|`a * b`|  
|`MultiplyAssign`|Un'operazione di assegnazione composta di moltiplicazione senza controllo dell'overflow, per operandi numerici.|`a *= b`|Non supportato.|  
|`NotEqual`|Un confronto di disuguaglianza.|`a != b`|`a <> b`|  
|`Or`|Bit per bit o logica `OR` operazione.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Bit per bit o logica `OR` assegnazione composta.|`a &#124;= b`|Non supportato.|  
|`Power`|Un'operazione matematica dell'elevamento di un numero a potenza.|Non supportato.|`a ^ b`|  
|`RightShift`|Un'operazione di spostamento a destra bit per bit.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Un'operazione di assegnazione composta di spostamento a destra bit per bit.|`a >>= b`|Non supportato.|  
|`Subtract`|Un'operazione di sottrazione senza controllo dell'overflow, per operandi numerici.|`a - b`|`a - b`|  
|`SubtractAssign`|Un'operazione di assegnazione composta di sottrazione senza controllo dell'overflow, per operandi numerici.|`a -= b`|Non supportato.|  
  
> [!NOTE]
>  Per implementare `OrElse` (`a || b`) e `AndAlso` (`a && b`) operazioni per gli oggetti dinamici in c#, si può essere utile implementare entrambi i <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metodo e il <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> (metodo).  
>   
>  Il `OrElse` operazione è costituita da unari `IsTrue` operazione e il file binario `Or` operazione. Il `Or` operazione viene eseguita solo se il risultato del `IsTrue` operazione `false`.  
>   
>  Il `AndAlso` operazione è costituita da unari `IsFalse` operazione e il file binario `And` operazione. Il `And` operazione viene eseguita solo se il risultato del `IsFalse` operazione `false`.  
  
   
  
## Examples  
 Si supponga che sia necessaria una struttura di dati per archiviare le rappresentazioni testuali e numeriche di numeri e si vuole definire operazioni matematiche di base quali l'addizione e sottrazione per questo tipo di dati.  
  
 L'esempio di codice seguente illustra il `DynamicNumber` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` esegue l'override di <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metodo per consentire operazioni matematiche. Viene anche eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso agli elementi.  
  
 In questo esempio, sono supportate solo le operazioni di addizione e sottrazione. Se si prova a scrivere un'istruzione come `resultNumber = firstNumber*secondNumber`, viene generata un'eccezione in fase di esecuzione.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione di conversione. La proprietà <c>binder.Type</c> specifica il tipo in cui deve essere convertito l'oggetto. Ad esempio, per l'istruzione <c>(String)sampleObject</c> in C# (<c>CType(sampleObject, Type)</c> in Visual Basic), dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> restituisce il tipo <see cref="T:System.String" />. La proprietà <c>binder.Explicit</c> specifica informazioni sul tipo di conversione effettuato. Restituisce <see langword="true" /> per la conversione esplicita e <see langword="false" /> per la conversione implicita.</param>
        <param name="result">Tipo di risultato dell'operazione di conversione dei tipi.</param>
        <summary>Fornisce l'implementazione per le operazioni di conversione dei tipi. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni che eseguono la conversione di un oggetto da un tipo a un altro.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come deve essere eseguita una conversione del tipo per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 In c#, se viene eseguito l'override di questo metodo, si viene automaticamente richiamato quando si dispone di una conversione esplicita o implicita, come illustrato nell'esempio di codice seguente.  
  
 In Visual Basic, è supportata solo la conversione esplicita. Se si esegue l'override di questo metodo, la chiamata avviene tramite il <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> o <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> funzioni.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Si supponga che sia necessaria una struttura di dati per archiviare le rappresentazioni testuali e numeriche di numeri e si desidera definire le conversioni di questa struttura di dati per le stringhe e numeri interi.  
  
 L'esempio di codice seguente illustra il `DynamicNumber` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` esegue l'override di <xref:System.Dynamic.DynamicObject.TryConvert%2A> metodo per consentire la conversione del tipo. Viene anche eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso agli elementi di dati.  
  
 In questo esempio, è supportata solo la conversione in stringhe e numeri interi. Se si prova a convertire un oggetto in qualsiasi altro tipo, viene generata un'eccezione in fase di esecuzione.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione di inizializzazione.</param>
        <param name="args">Argomenti passati all'oggetto durante l'inizializzazione. Ad esempio, per l'operazione <c>new SampleType(100)</c>, dove <c>SampleType</c> è il tipo derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> è uguale a 100.</param>
        <param name="result">Risultato dell'inizializzazione.</param>
        <summary>Fornisce l'implementazione per le operazioni che creano una nuova istanza di un oggetto dinamico. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare il modo in cui deve essere inizializzata una nuova istanza dell'oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Compilatori Visual Basic e c# non generano mai il codice per usare questo metodo perché non supportano i tipi di prima classe. Questo metodo viene utilizzato per i linguaggi che supportano l'inizializzazione di oggetti dinamici utilizzando la seguente sintassi `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione di eliminazione.</param>
        <param name="indexes">Indici da eliminare.</param>
        <summary>Fornisce l'implementazione per operazioni che eliminano un oggetto in base all'indice. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come deve essere eliminato un valore che contiene un indice specificato. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Compilatori Visual Basic e c# non generano mai il codice per usare questo metodo perché non supportano questo tipo di operazione. Questo metodo è destinato ai linguaggi che supportano la sintassi per l'eliminazione di oggetti in base all'indice, ad esempio `del sampleObject[1,2]` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione di eliminazione.</param>
        <summary>Fornisce l'implementazione per operazioni che eliminano un membro di un oggetto. Questo metodo non può essere utilizzato in C# o in Visual Basic.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come un membro dell'oggetto deve essere eliminato. Quando questo metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Compilatori Visual Basic e c# non generano mai il codice per usare questo metodo perché non supportano questo tipo di operazione. Questo metodo viene utilizzato per i linguaggi che supportano la sintassi per l'eliminazione di membri, ad esempio `del sampleObject.SampleMember` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione.</param>
        <param name="indexes">Indici utilizzati nell'operazione. Ad esempio, per l'operazione <c>sampleObject[3]</c> in C# (<c>sampleObject(3)</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see langword="DynamicObject" />, <c>indexes[0]</c> è uguale a 3.</param>
        <param name="result">Risultato dell'operazione di indicizzazione.</param>
        <summary>Fornisce l'implementazione per operazioni che ottengono un valore in base all'indice. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni di indicizzazione.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata eccezione di runtime.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come ottenere un valore in base all'indice devono essere eseguite per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata eccezione di runtime.  
  
 Se viene eseguito l'override di questo metodo, viene richiamato automaticamente quando si esegue un'operazione quale `sampleObject[3]` in c# o `sampleObject(3)` in Visual Basic, in cui `sampleObject` è derivato dal <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Si supponga che si desidera creare un oggetto in cui le proprietà possono essere accessibili tramite i nomi, ad esempio `Property0`, `Property1`e così via, o in base all'indice, in modo che, ad esempio `sampleObject.Property0` equivale a `sampleObject[0]` in c# o `sampleObject(0)` in Visual Basic.  
  
 L'esempio di codice seguente illustra il `SampleDynamicObject` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. Il `SampleDynamicObject` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore. `SampleDynamicObject` esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> e <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metodi per abilitare l'accesso in base all'indice. Viene eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso in base al nome di proprietà.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'oggetto che ha chiamato l'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro su cui viene eseguita l'operazione dinamica. Ad esempio, per l'istruzione <c>Console.WriteLine(sampleObject.SampleProperty)</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleProperty". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
        <param name="result">Risultato dell'operazione get. Ad esempio, se il metodo viene chiamato per una proprietà, è possibile assegnare il valore della proprietà a <paramref name="result" />.</param>
        <summary>Fornisce l'implementazione per operazioni che ottengono valori dei membri. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale l'acquisizione di un valore per una proprietà.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata eccezione di runtime.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite le operazioni che ottengono i valori del membro per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata eccezione di runtime.  
  
 Questo metodo viene chiamato quando si dispone di istruzioni, ad esempio `Console.WriteLine(sampleObject.SampleProperty)`, dove `sampleObject` è un'istanza della classe derivata dal <xref:System.Dynamic.DynamicObject> classe.  
  
 È anche possibile aggiungere i propri membri alle classi derivate dal `DynamicObject` classe. Se la classe definisce le proprietà ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo), dynamic language runtime (DLR) prima di tutto viene utilizzato lo strumento di associazione di linguaggio per cercare una definizione di una proprietà nella classe statica. Se è presente nessuna di tali proprietà, DLR chiama il <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo).  
  
   
  
## Examples  
 Si supponga di voler fornire una sintassi alternativa per l'accesso ai valori in un dizionario, in modo che anziché la scrittura `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), è possibile scrivere `sampleDictionary.Text = "Sample text"`. Inoltre, questa sintassi deve essere tra maiuscole e minuscole, in modo che `sampleDictionary.Text` equivale a `sampleDictionary.text`.  
  
 L'esempio di codice seguente illustra il `DynamicDictionary` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. Il `DynamicDictionary` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per supportare la nuova sintassi. Fornisce inoltre un `Count` contiene proprietà, che mostra quanti proprietà dinamiche del dizionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione invoke.</param>
        <param name="args">Argomenti passati all'oggetto durante l'operazione invoke. Ad esempio, per l'operazione <c>sampleObject(100)</c>, dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> è uguale a 100.</param>
        <param name="result">Risultato della chiamata all'oggetto.</param>
        <summary>Fornisce l'implementazione per operazioni che richiamano un oggetto. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale il richiamo di un oggetto o un delegato.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite le operazioni che richiamano un oggetto per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata eccezione di runtime.  
  
 Se viene eseguito l'override di questo metodo, viene richiamato automaticamente quando si esegue un'operazione quale `sampleObject(100)`, dove `sampleObject` è derivato dal <xref:System.Dynamic.DynamicObject> classe.  
  
 L'operazione per richiamare un oggetto è supportato in c#, ma non in Visual Basic. Il compilatore Visual Basic non genera mai il codice per usare questo metodo e il linguaggio Visual Basic non supporta una sintassi come `sampleObject(100)`.  
  
   
  
## Examples  
 Si supponga che sia necessaria una struttura di dati per archiviare le rappresentazioni testuali e numeriche di numeri. Si desidera essere in grado di specificare il valore per ogni proprietà singolarmente e anche essere in grado di inizializzare tutte le proprietà in una singola istruzione.  
  
 L'esempio di codice seguente illustra il `DynamicNumber` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` esegue l'override di <xref:System.Dynamic.DynamicObject.TryInvoke%2A> metodo per abilitare l'inizializzazione di tutte le proprietà in una sola volta. Viene anche eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso alle proprietà degli oggetti singoli.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro su cui viene eseguita l'operazione dinamica. Ad esempio, per l'istruzione <c>sampleObject.SampleMethod(100)</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleMethod". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
        <param name="args">Argomenti passati al membro dell'oggetto durante l'operazione invoke. Ad esempio, per l'istruzione <c>sampleObject.SampleMethod(100)</c>, dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args [0]</c> è uguale a 100.</param>
        <param name="result">Risultato della chiamata al membro.</param>
        <summary>Fornisce l'implementazione per operazioni che richiamano un membro. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale la chiamata a un metodo.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite le operazioni che richiamano un membro dell'oggetto per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Se viene eseguito l'override di questo metodo, viene richiamato automaticamente quando si esegue un'operazione simile `sampleObject.SampleMethod(100)`, dove `sampleObject` è derivato dal `DynamicObject` classe.  
  
 È anche possibile aggiungere i propri metodi alle classi che derivano dal <xref:System.Dynamic.DynamicObject> classe. Ad esempio, se si esegue l'override di <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metodo, il sistema di invio dinamico innanzitutto tenta di determinare se il metodo specificato è presente nella classe. Se il metodo non viene trovato, viene usato il <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implementazione.  
  
 Questo metodo non supporta `ref` e `out` parametri. Tutti i parametri di `args` matrice vengono passati per valore.  
  
   
  
## Examples  
 Si supponga di voler fornire una sintassi alternativa per l'accesso ai valori in un dizionario, in modo che anziché la scrittura `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), è possibile scrivere `sampleDictionary.Text = "Sample text"`. Inoltre, si desidera essere in grado di chiamare tutti i metodi di dizionario standard in questo dizionario.  
  
 L'esempio di codice seguente illustra il `DynamicDictionary` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. Il `DynamicDictionary` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore. Viene eseguito l'override di <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metodo per supportare i metodi del <xref:System.Collections.Generic.Dictionary%602> classe ed esegue l'override la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per supportare la nuova sintassi. Fornisce inoltre un `Print` metodo, che stampa tutti i valori e le chiavi del dizionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione.</param>
        <param name="indexes">Indici utilizzati nell'operazione. Ad esempio, per l'operazione <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> è uguale a 3.</param>
        <param name="value">Valore da impostare per l'oggetto con l'indice specificato. Ad esempio, per l'operazione <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), dove <c>sampleObject</c> è derivato dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> è uguale a 10.</param>
        <summary>Fornisce l'implementazione per operazioni che impostano un valore in base all'indice. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni che accedono a oggetti in base a un indice specificato.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite le operazioni che accedono a un oggetto in base all'indice per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Se viene eseguito l'override di questo metodo, viene richiamato automaticamente quando si esegue un'operazione quale `sampleObject[3] = 10` in c# o `sampleObject(3) = 10` in Visual Basic, in cui `sampleObject` è derivato dal <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Si supponga che si desidera creare un oggetto in cui le proprietà possono essere accessibili tramite i nomi, ad esempio `Property0`, `Property1`e così via, o in base all'indice, in modo che, ad esempio `sampleObject.Property0` equivale a `sampleObject[0]` in c# o `sampleObject(0)` in Visual Basic.  
  
 L'esempio di codice seguente illustra il `SampleDynamicObject` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. Il `SampleDynamicObject` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore. `SampleDynamicObject` esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> e <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metodi per abilitare l'accesso in base all'indice. Viene eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso in base al nome di proprietà.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'oggetto che ha chiamato l'operazione dinamica. La proprietà <c>binder.Name</c> specifica il nome del membro a cui viene assegnato il valore. Ad esempio, per l'istruzione <c>sampleObject.SampleProperty = "Test"</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> restituisce "SampleProperty". La proprietà <c>binder.IgnoreCase</c> specifica se per il nome del membro viene applicata la distinzione tra maiuscole e minuscole.</param>
        <param name="value">Valore su cui impostare il membro. Ad esempio, per l'istruzione <c>sampleObject.SampleProperty = "Test"</c>, dove <c>sampleObject</c> è un'istanza della classe derivata dalla classe <see cref="T:System.Dynamic.DynamicObject" />, l'elemento <paramref name="value" /> è "Test".</param>
        <summary>Fornisce l'implementazione per operazioni che impostano valori dei membri. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale l'impostazione di un valore per una proprietà.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come devono essere eseguite le operazioni che impostano un valore a un membro di un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Questo metodo viene chiamato quando si dispone di istruzioni, ad esempio `sampleObject.SampleProperty = "Test"`, dove `sampleObject` è un'istanza della classe che deriva dal <xref:System.Dynamic.DynamicObject> classe.  
  
 È anche possibile aggiungere i propri membri alle classi derivate dal `DynamicObject` classe. Se la classe definisce le proprietà ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo), dynamic language runtime (DLR) prima di tutto viene utilizzato lo strumento di associazione di linguaggio per cercare una definizione di una proprietà nella classe statica. Se è presente nessuna di tali proprietà, DLR chiama il <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (metodo).  
  
   
  
## Examples  
 Si supponga di voler fornire una sintassi alternativa per l'accesso ai valori in un dizionario, in modo che anziché la scrittura `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), è possibile scrivere `sampleDictionary.Text = "Sample text"`. Inoltre, questa sintassi deve essere tra maiuscole e minuscole, in modo che `sampleDictionary.Text` equivale a `sampleDictionary.text`.  
  
 L'esempio di codice seguente illustra il `DynamicDictionary` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. Il `DynamicDictionary` classe contiene un oggetto del `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` in Visual Basic) per archiviare le coppie chiave-valore ed esegue l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per supportare la nuova sintassi. Fornisce inoltre un `Count` contiene proprietà, che mostra quanti proprietà dinamiche del dizionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornisce informazioni sull'operazione unaria. La proprietà <c>binder.Operation</c> restituisce un oggetto <see cref="T:System.Linq.Expressions.ExpressionType" />. Ad esempio, per l'istruzione <c>negativeNumber = -number</c>, dove <c>number</c> è derivato dalla classe <see langword="DynamicObject" />, <c>binder.Operation</c> restituisce "Negate".</param>
        <param name="result">Risultato dell'operazione unaria.</param>
        <summary>Fornisce l'implementazione per le operazioni unarie. Le classi derivate dalla classe <see cref="T:System.Dynamic.DynamicObject" /> possono eseguire l'override di questo metodo per specificare il comportamento dinamico per operazioni quale negazione, incremento o decremento.</summary>
        <returns>
          <see langword="true" /> se l'operazione riesce; in caso contrario, <see langword="false" />. Se questo metodo restituisce <see langword="false" />, il comportamento viene determinato dal gestore di associazione di runtime del linguaggio. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate dal <xref:System.Dynamic.DynamicObject> classe può eseguire l'override di questo metodo per specificare come operazioni unarie devono essere eseguite per un oggetto dinamico. Se il metodo non è sottoposto a override, il binder di runtime del linguaggio determina il comportamento. Nella maggior parte dei casi viene generata un'eccezione di runtime specifica del linguaggio.  
  
 Questo metodo viene chiamato quando si hanno operazioni unarie, ad esempio negazione, incremento o decremento. Ad esempio, se il <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> è sottoposto a override, questo metodo viene richiamato automaticamente, ad esempio le istruzioni `negativeNumber = -number`, dove `number` è derivato dal <xref:System.Dynamic.DynamicObject> classe.  
  
 È possibile ottenere informazioni sul tipo di operazione unaria usando il `Operation` proprietà del `binder` parametro.  
  
 Se l'oggetto dinamico viene usato solo in c# e Visual Basic, il `binder.Operation` proprietà può avere uno dei seguenti valori dal <xref:System.Linq.Expressions.ExpressionType> enumerazione. In altri linguaggi, ad esempio IronPython o IronRuby, tuttavia, si possono avere altri valori.
  
|Valore|Descrizione|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Un'operazione di decremento unaria.|`a--`|Non supportato.|  
|`Increment`|Un'operazione di incremento unaria.|`a++`|Non supportato.|  
|`Negate`|Negazione aritmetica.|`-a`|`-a`|  
|`Not`|Negazione logica.|`!a`|`Not a`|  
|`OnesComplement`|Un quelli complemento.|`~a`|Non supportato.|  
|`IsFalse`|Valore di una condizione false.|`a && b`|Non supportato.|  
|`IsTrue`|Un valore della condizione true.|`a &#124;&#124; b`|Non supportato.|  
|`UnaryPlus`|Un operatore più unario.|`+a`|`+a`|  
  
> [!NOTE]
>  Per implementare `OrElse` (`a || b`) e `AndAlso` (`a && b`) operazioni per gli oggetti dinamici in c#, si può essere utile implementare entrambi i <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metodo e il <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> (metodo).  
>   
>  Il `OrElse` operazione è costituita da unari `IsTrue` operazione e il file binario `Or` operazione. Il `Or` operazione viene eseguita solo se il risultato del `IsTrue` operazione `false`.  
>   
>  Il `AndAlso` operazione è costituita da unari `IsFalse` operazione e il file binario `And` operazione. Il `And` operazione viene eseguita solo se il risultato del `IsFalse` operazione `false`.  
  
   
  
## Examples  
 Si supponga che sia necessaria una struttura di dati per archiviare le rappresentazioni testuali e numeriche di numeri e si vuole definire un'operazione di negazione matematici per questo tipo di dati.  
  
 L'esempio di codice seguente illustra il `DynamicNumber` classe che deriva dal <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` esegue l'override di <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metodo per consentire l'operazione di negazione matematiche. Viene anche eseguito l'override di <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metodi per abilitare l'accesso agli elementi.  
  
 In questo esempio, è supportata solo l'operazione di negazione matematiche. Se si prova a scrivere un'istruzione come `negativeNumber = +number`, si verifica un'eccezione in fase di esecuzione.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>