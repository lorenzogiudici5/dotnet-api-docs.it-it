<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33ee2fd66fc05f288789835988a052f4e50d1055" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51877138" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa la funzionalità di derivazione della chiave basata su password, PBKDF2, usando un generatore di numeri pseudo-casuali basato su <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> accetta una password, un valore salt e un conteggio delle iterazioni e quindi genera le chiavi tramite chiamate al <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> (metodo).  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni sulla funzione PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chiavi di classe per creare due identici per il <xref:System.Security.Cryptography.TripleDES> classe.  Quindi crittografa e decrittografa alcuni dati utilizzando le chiavi.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Password usata per derivare la chiave.</param>
        <param name="salt">Salt della chiave usato per derivare la chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una password e un salt per derivare la chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del salt deve essere di 8 byte o superiori.  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni sulla funzione PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chiavi di classe per creare due identici per il <xref:System.Security.Cryptography.TripleDES> classe.  Quindi crittografa e decrittografa alcuni dati utilizzando le chiavi.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte o il conteggio delle iterazioni è inferiore a 1.</exception>
        <exception cref="T:System.ArgumentNullException">La password o il salt è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Password usata per derivare la chiave.</param>
        <param name="saltSize">Dimensione del salt casuale che la classe deve generare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando la password e la dimensione del salt per derivare la chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del salt deve essere di 8 byte o superiori.  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni sulla funzione PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte.</exception>
        <exception cref="T:System.ArgumentNullException">La password o il salt è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Password usata per derivare la chiave.</param>
        <param name="salt">Salt della chiave usato per derivare la chiave.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una password, il salt e il numero di iterazioni per derivare la chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del salt deve essere di 8 byte o più grande e il conteggio delle iterazioni deve essere maggiore di zero. Il numero minimo consigliato di iterazioni è 1000.  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni sulla funzione PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte o il conteggio delle iterazioni è inferiore a 1.</exception>
        <exception cref="T:System.ArgumentNullException">La password o il salt è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Password usata per derivare la chiave.</param>
        <param name="salt">Salt della chiave usato per derivare la chiave.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una password, il salt e il numero di iterazioni per derivare la chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del salt deve essere di 8 byte o più grande e il conteggio delle iterazioni deve essere maggiore di zero. Il numero minimo consigliato di iterazioni è 1000.  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni sulla funzione PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chiavi di classe per creare due identici per il <xref:System.Security.Cryptography.TripleDES> classe.  Quindi crittografa e decrittografa alcuni dati utilizzando le chiavi.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte o il conteggio delle iterazioni è inferiore a 1.</exception>
        <exception cref="T:System.ArgumentNullException">La password o il salt è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Password usata per derivare la chiave.</param>
        <param name="saltSize">Dimensione del salt casuale che la classe deve generare.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una password, la dimensione del salt e il numero di iterazioni per derivare la chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del salt deve essere di 8 byte o più grande e il conteggio delle iterazioni deve essere maggiore di zero. Il numero minimo consigliato di iterazioni è 1000.  
  
 RFC 2898 include metodi per la creazione di un vettore di chiave e inizializzazione (IV) da una password e un valore salt. È possibile usare una funzione di derivazione della chiave basata su password, PBKDF2 per derivare le chiavi con una funzione pseudocasuale che consenta di chiavi di lunghezza virtualmente illimitata da generare. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe può essere utilizzata per generare una chiave derivata da una chiave di base e altri parametri. In una funzione di derivazione della chiave basata su password, la chiave di base è una password e gli altri parametri sono un valore salt e un conteggio delle iterazioni.  
  
 Per altre informazioni su PBKDF2, vedere RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponibile nel [richiesta per il sito Web di commenti](https://go.microsoft.com/fwlink/?LinkID=37119). Per informazioni dettagliate, vedere sezione 5.2, "PBKDF2,".  
  
> [!IMPORTANT]
>  Mai come hardcoded una password all'interno del codice sorgente.  Le password a livello di codice possono essere recuperate da un assembly usando il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando un editor esadecimale, o semplicemente aprendo l'assembly in un editor di testo, ad esempio Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte o il conteggio delle iterazioni è inferiore a 1.</exception>
        <exception cref="T:System.ArgumentNullException">La password o il salt è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="iterations" /> non è compreso nell'intervallo consentito. Per questo parametro è richiesto un numero non negativo.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Password da usare per derivare la chiave.</param>
        <param name="salt">Salt della chiave da usare per derivare la chiave.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <param name="hashAlgorithm">Algoritmo hash da usare per derivare la chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando la password, il salt e il numero di iterazioni specificati e il nome dell'algoritmo hash per derivare la chiave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="saltSize" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">La <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> proprietà di <paramref name="hashAlgorithm" /> è <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Il nome dell'algoritmo hash non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Password da usare per derivare la chiave.</param>
        <param name="salt">Salt della chiave da usare per derivare la chiave.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <param name="hashAlgorithm">Algoritmo hash da usare per derivare la chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando la password, il salt e il numero di iterazioni specificati e il nome dell'algoritmo hash per derivare la chiave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> proprietà di <paramref name="hashAlgorithm" /> è <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Il nome dell'algoritmo hash non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Password da usare per derivare la chiave.</param>
        <param name="saltSize">Dimensione del salt casuale che la classe deve generare.</param>
        <param name="iterations">Numero di iterazioni per l'operazione.</param>
        <param name="hashAlgorithm">Algoritmo hash da usare per derivare la chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando la password, la dimensione del salt e il numero di iterazioni specificati e il nome dell'algoritmo hash per derivare la chiave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="saltSize" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">La <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> proprietà di <paramref name="hashAlgorithm" /> è <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Il nome dell'algoritmo hash non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">Nome dell'algoritmo per il quale derivare la chiave.</param>
        <param name="alghashname">Nome dell'algoritmo hash da usare per derivare la chiave.</param>
        <param name="keySize">Dimensione in bit della chiave da derivare.</param>
        <param name="rgbIV">Vettore di inizializzazione da usare per derivare la chiave.</param>
        <summary>Deriva una chiave di crittografia dall'oggetto <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
        <returns>Chiave derivata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa funzione è un wrapper per la funzione CryptoAPI CryptDeriveKey () e consente di offrire l'interoperabilità con applicazioni usando l'API di Crypto.  
  
 Se il `keySize` parametro è impostato su 0 bit, viene utilizzata la dimensione della chiave predefinita per l'algoritmo specificato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Il parametro <paramref name="keySize" /> non è corretto.  
  
oppure 
Non è possibile acquisire il provider del servizio di crittografia (CSP).  
  
oppure 
Il parametro <paramref name="algname" /> non corrisponde a un nome di algoritmo valido.  
  
oppure 
Il parametro <paramref name="alghashname" /> non corrisponde a un nome di algoritmo hash valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> e facoltativamente le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico `Dispose()` metodo e `Finalize` (metodo). `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. `Finalize` richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Security.Cryptography.Rfc2898DeriveBytes> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il metodo 
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" />, prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" />. Per altre informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Per altre informazioni sulle <see langword="Dispose" /> e <see langword="Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Numero di byte chiave pseudo-casuali da generare.</param>
        <summary>Restituisce la chiave pseudocasuale per questo oggetto.</summary>
        <returns>Matrice di byte riempita con byte chiave pseudo-casuali.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe implementa la funzionalità PBKDF2 usando un generatore di numeri pseudocasuali basato <xref:System.Security.Cryptography.HMACSHA1>. Il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe accetta una password, un valore salt e un conteggio delle iterazioni e quindi genera le chiavi tramite chiamate al <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> (metodo). Chiamate ripetute a questo metodo non genera la stessa chiave. invece, aggiunta di due chiamate la <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metodo con un `cb` come valore del parametro `20` equivale a chiamare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metodo una volta con un `cb` come valore del parametro `40`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metodo per ottenere la chiave per un'istanza di <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cb" /> non è compreso nell'intervallo consentito. Per questo parametro è richiesto un numero non negativo.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di iterazioni per l'operazione.</summary>
        <value>Numero di iterazioni per l'operazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conteggio delle iterazioni è il numero di volte in cui che viene eseguita un'operazione. Per questo metodo, il conteggio deve essere maggiore di zero. Il numero minimo consigliato di iterazioni è 1000.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> proprietà per visualizzare il numero di iterazioni usate nella generazione della chiave. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di iterazioni è inferiore a 1.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta lo stato dell'operazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato automaticamente se viene modificato il numero di iterazione o valore salt.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore del salt della chiave per l'operazione.</summary>
        <value>Valore del salt della chiave per l'operazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valore salt, un set casuale di byte, consente di eseguire la decrittografia non autorizzato di un messaggio più difficile. Un attacco con dizionario è un attacco in cui l'utente malintenzionato tenta di decrittografare un messaggio crittografato confrontando il valore crittografato con i valori crittografati calcolati in precedenza per le chiavi più probabile. Questo tipo di attacco è molto più difficile grazie all'introduzione di byte di salt o casuale, alla fine della password prima di derivazione della chiave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione del salt specificato è inferiore a 8 byte.</exception>
        <exception cref="T:System.ArgumentNullException">Il salt è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servizi crittografici</related>
      </Docs>
    </Member>
  </Members>
</Type>