<Type Name="HashAlgorithm" FullName="System.Security.Cryptography.HashAlgorithm">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b9b76797e6d798773a44e829bec18e894d93a53" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500705" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class HashAlgorithm : System.Security.Cryptography.ICryptoTransform" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit HashAlgorithm extends System.Object implements class System.IDisposable, class System.Security.Cryptography.ICryptoTransform" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.HashAlgorithm" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class HashAlgorithm&#xA;Implements ICryptoTransform" />
  <TypeSignature Language="C++ CLI" Value="public ref class HashAlgorithm abstract : System::Security::Cryptography::ICryptoTransform" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Cryptography.ICryptoTransform</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta la classe base dalla quale devono derivare tutte le implementazioni degli algoritmi hash di crittografia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le funzioni hash sono essenziali per la crittografia moderna. Queste funzioni eseguire il mapping di stringhe binarie di lunghezza arbitraria a piccole stringhe binarie di lunghezza fissa, noti come valori hash. Una funzione hash di crittografia ha la proprietà che è impossibile da trovare due input distinti con hash sullo stesso valore. Le funzioni hash vengono comunemente utilizzate con le firme digitali e l'integrità dei dati.  
  
 L'hash viene utilizzato come un valore univoco che rappresenta una grande quantità di dati di dimensione fissa. Gli hash di due set di dati devono corrispondere se corrispondano anche i dati corrispondenti. Piccole modifiche per il risultato di dati in grandi modifiche imprevisti nell'hash.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene calcolato il <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> hash di una matrice. In questo esempio presuppone che vi sia una matrice di byte predefinito `dataArray[]`. <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> è una classe derivata di <xref:System.Security.Cryptography.HashAlgorithm>.  
  
 [!code-cpp[Classic HashAlgorithm Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HashAlgorithm Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/CS/source.cs#1)]
 [!code-vb[Classic HashAlgorithm Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando si eredita dal <see cref="T:System.Security.Cryptography.HashAlgorithm" /> (classe), è necessario eseguire l'override dei seguenti membri: <see cref="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.Security.Cryptography.HashAlgorithm.HashFinal" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashAlgorithm ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashAlgorithm();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile creare un'istanza di una classe astratta. Il codice dell'applicazione crea una nuova istanza di una classe derivata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReuseTransform">
      <MemberSignature Language="C#" Value="public virtual bool CanReuseTransform { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReuseTransform" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.CanReuseTransform" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReuseTransform As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReuseTransform { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.CanReuseTransform</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile riutilizzare la trasformazione corrente.</summary>
        <value>Sempre <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTransformMultipleBlocks">
      <MemberSignature Language="C#" Value="public virtual bool CanTransformMultipleBlocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTransformMultipleBlocks" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTransformMultipleBlocks As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTransformMultipleBlocks { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.CanTransformMultipleBlocks</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se è possibile trasformare più blocchi.</summary>
        <value>
          <see langword="true" /> se è possibile trasformare più blocchi; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dalla classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è una semplice chiamata al <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo.  
  
 La chiamata `Dispose` le risorse utilizzate dalla <xref:System.Security.Cryptography.HashAlgorithm> classe riallocazione per altri scopi. Per ulteriori informazioni su `Dispose`, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ComputeHash">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il valore hash dei dati di input.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (buffer As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Input per il quale calcolare il codice hash.</param>
        <summary>Calcola il valore hash della matrice di byte specificata.</summary>
        <returns>Codice hash calcolato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene calcolato il <xref:System.Security.Cryptography.MD5> valore hash della stringa e restituisce l'hash come stringa in formato esadecimale di 32 caratteri.  La stringa hash creata da questo esempio di codice è compatibile con qualsiasi funzione hash MD5 (su qualsiasi piattaforma) che crea una stringa di formato esadecimale di 32 caratteri hash.  
  
 [!code-csharp[Security.Cryptography.MD5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Security.Cryptography.MD5/cs/example.cs#1)]
 [!code-vb[Security.Cryptography.MD5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Security.Cryptography.MD5/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (System.IO.Stream inputStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(class System.IO.Stream inputStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (inputStream As Stream) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(System::IO::Stream ^ inputStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inputStream">Input per il quale calcolare il codice hash.</param>
        <summary>Calcola il valore hash per l'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <returns>Codice hash calcolato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente calcola il <xref:System.Security.Cryptography.RIPEMD160> hash per tutti i file in una directory.  
  
 [!code-cpp[RIPEMD160#1](~/samples/snippets/cpp/VS_Snippets_CLR/RIPEMD160/CPP/ripemd160.cpp#1)]
 [!code-csharp[RIPEMD160#1](~/samples/snippets/csharp/VS_Snippets_CLR/RIPEMD160/CS/ripemd160.cs#1)]
 [!code-vb[RIPEMD160#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RIPEMD160/vb/ripemd160.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (buffer As Byte(), offset As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Input per il quale calcolare il codice hash.</param>
        <param name="offset">Offset nella matrice di byte dal quale iniziare a usare i dati.</param>
        <param name="count">Numero di byte nella matrice da usare come dati.</param>
        <summary>Calcola il valore hash dell'area specifica della matrice di byte specificata.</summary>
        <returns>Codice hash calcolato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" />è un valore non valido.  
  
 oppure  
  
 La lunghezza di <paramref name="buffer" /> non è valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> non è compreso nell'intervallo consentito. Per questo parametro è richiesto un numero non negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza dell'implementazione di un algoritmo hash.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.HashAlgorithm Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.HashAlgorithm Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::HashAlgorithm ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un'istanza dell'implementazione predefinita di un algoritmo hash.</summary>
        <returns>Nuova istanza di <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />, a meno che le impostazioni predefinite non siano state modificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, questo overload viene utilizzato il <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> implementazione di un algoritmo hash. Se si desidera specificare un'implementazione diversa, utilizzare il <xref:System.Security.Cryptography.HashAlgorithm.Create%28System.String%29> overload, che consente di specificare un nome di algoritmo, in alternativa. Il sistema di configurazione di crittografia definisce l'implementazione predefinita di <xref:System.Security.Cryptography.HashAlgorithm>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.HashAlgorithm Create (string hashName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.HashAlgorithm Create(string hashName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (hashName As String) As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::HashAlgorithm ^ Create(System::String ^ hashName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hashName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hashName">Implementazione dell'algoritmo hash da usare. La tabella seguente illustra i valori validi per il parametro <c>hashName</c> e gli algoritmi a cui eseguono il mapping.  
  
 <list type="table"><listheader><term> Valore del parametro  
  
 </term><description> Implementa  
  
 </description></listheader><item><term> SHA  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /></description></item><item><term> SHA1  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /></description></item><item><term> System.Security.Cryptography.SHA1  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /></description></item><item><term> System.Security.Cryptography.HashAlgorithm  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /></description></item><item><term> MD5  
  
 </term><description><see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /></description></item><item><term> System.Security.Cryptography.MD5  
  
 </term><description><see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /></description></item><item><term> SHA256  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA256Managed" /></description></item><item><term> SHA-256  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA256Managed" /></description></item><item><term> System.Security.Cryptography.SHA256  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA256Managed" /></description></item><item><term> SHA384  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA384Managed" /></description></item><item><term> SHA-384  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA384Managed" /></description></item><item><term> System.Security.Cryptography.SHA384  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA384Managed" /></description></item><item><term> SHA512  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA512Managed" /></description></item><item><term> SHA-512  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA512Managed" /></description></item><item><term> System.Security.Cryptography.SHA512  
  
 </term><description><see cref="T:System.Security.Cryptography.SHA512Managed" /></description></item></list></param>
        <summary>Crea un'istanza dell'implementazione specificata di un algoritmo hash.</summary>
        <returns>Una nuova istanza dell'algoritmo hash specificato o <see langword="null" /> se <paramref name="hashName" /> non è un algoritmo hash valido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo `Dispose` dopo aver terminato di utilizzare l'oggetto <xref:System.Security.Cryptography.HashAlgorithm>. Il metodo `Dispose` lascia l'oggetto <xref:System.Security.Cryptography.HashAlgorithm> in una condizione di inutilizzabilità. Dopo la chiamata `Dispose`, è necessario rilasciare tutti i riferimenti al <xref:System.Security.Cryptography.HashAlgorithm> in modo che il garbage collector può recuperare la memoria che di <xref:System.Security.Cryptography.HashAlgorithm> occupata.  
  
 Per ulteriori informazioni, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo `Dispose` prima di rilasciare l'ultimo riferimento a <xref:System.Security.Cryptography.HashAlgorithm>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Security.Cryptography.HashAlgorithm> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.Security.Cryptography.HashAlgorithm" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` (metodo) e `Finalize` metodo. `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. `Finalize` richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Security.Cryptography.HashAlgorithm> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" />, non fare riferimento a oggetti già eliminati in una precedente chiamata a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see langword="Dispose" /> e <see langword="Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Hash">
      <MemberSignature Language="C#" Value="public virtual byte[] Hash { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Hash" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.Hash" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Hash As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ Hash { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore del codice hash calcolato.</summary>
        <value>Valore corrente del codice hash calcolato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> proprietà è una matrice di byte; <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> proprietà è un valore che rappresentano i bit. Pertanto, il numero di elementi in <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> un ottavo della dimensione di <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">
          <see cref="F:System.Security.Cryptography.HashAlgorithm.HashValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected virtual void HashCore (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void HashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub HashCore (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void HashCore(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected abstract void HashCore (byte[] array, int ibStart, int cbSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void HashCore(unsigned int8[] array, int32 ibStart, int32 cbSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub HashCore (array As Byte(), ibStart As Integer, cbSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void HashCore(cli::array &lt;System::Byte&gt; ^ array, int ibStart, int cbSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="ibStart" Type="System.Int32" />
        <Parameter Name="cbSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Input per il quale calcolare il codice hash.</param>
        <param name="ibStart">Offset nella matrice di byte dal quale iniziare a usare i dati.</param>
        <param name="cbSize">Numero di byte nella matrice da usare come dati.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, indirizza i dati scritti nell'oggetto verso l'algoritmo hash per il calcolo dell'hash.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non viene chiamato dal codice dell'applicazione.  
  
 Questo metodo astratto esegue il calcolo dell'hash. Ogni operazione di scrittura per l'oggetto flusso crittografato passa i dati tramite questo metodo. Per ogni blocco di dati, questo metodo aggiorna lo stato dell'oggetto hash viene restituito un valore hash corretto alla fine del flusso di dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashFinal">
      <MemberSignature Language="C#" Value="protected abstract byte[] HashFinal ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashFinal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashFinal" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HashFinal () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::Byte&gt; ^ HashFinal();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, finalizza il calcolo hash una volta che gli ultimi dati sono stati elaborati dall'oggetto flusso crittografato.</summary>
        <returns>Codice hash calcolato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di finalizzare i calcoli parziali e restituisce il valore hash corretto per il flusso di dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashSize">
      <MemberSignature Language="C#" Value="public virtual int HashSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.HashSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la dimensione in bit del codice hash calcolato.</summary>
        <value>Dimensione in bit del codice hash calcolato.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashSizeValue">
      <MemberSignature Language="C#" Value="protected int HashSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 HashSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected HashSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int HashSizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta la dimensione in bit del codice hash calcolato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'algoritmo hash specifica le dimensioni del codice hash. Ad esempio, <xref:System.Security.Cryptography.SHA1> utilizza una dimensione di hash di 160 bit.  
  
 Questo campo è possibile accedere mediante il <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashValue">
      <MemberSignature Language="C#" Value="protected internal byte[] HashValue;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly unsigned int8[] HashValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.HashValue" />
      <MemberSignature Language="VB.NET" Value="Protected Friend HashValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::Byte&gt; ^ HashValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il valore del codice hash calcolato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo è possibile accedere mediante il <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public abstract void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza un'implementazione della classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBlockSize">
      <MemberSignature Language="C#" Value="public virtual int InputBlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InputBlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.InputBlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InputBlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InputBlockSize { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.InputBlockSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene la dimensione del blocco di input.</summary>
        <value>Dimensione del blocco di input.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A meno che non viene sottoposto a override, questa proprietà restituisce il valore 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputBlockSize">
      <MemberSignature Language="C#" Value="public virtual int OutputBlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputBlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.OutputBlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutputBlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutputBlockSize { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.OutputBlockSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene la dimensione del blocco di output.</summary>
        <value>Dimensione del blocco di output.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A meno che non viene sottoposto a override, questa proprietà restituisce il valore 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="protected int State;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 State" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.State" />
      <MemberSignature Language="VB.NET" Value="Protected State As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int State;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta lo stato del calcolo hash.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo viene utilizzato per impedire agli utenti di modificare la chiave di un algoritmo hash con chiave durante un'operazione di hash. Quando una modifica della chiave è legittima, il valore di questo campo è zero prima e dopo un'operazione di hash. Quando una modifica della chiave non è legittima, il valore di questo campo è diverso da zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformBlock">
      <MemberSignature Language="C#" Value="public int TransformBlock (byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 TransformBlock(unsigned int8[] inputBuffer, int32 inputOffset, int32 inputCount, unsigned int8[] outputBuffer, int32 outputOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformBlock (inputBuffer As Byte(), inputOffset As Integer, inputCount As Integer, outputBuffer As Byte(), outputOffset As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int TransformBlock(cli::array &lt;System::Byte&gt; ^ inputBuffer, int inputOffset, int inputCount, cli::array &lt;System::Byte&gt; ^ outputBuffer, int outputOffset);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputBuffer" Type="System.Byte[]" />
        <Parameter Name="inputOffset" Type="System.Int32" />
        <Parameter Name="inputCount" Type="System.Int32" />
        <Parameter Name="outputBuffer" Type="System.Byte[]" />
        <Parameter Name="outputOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inputBuffer">Input per il quale calcolare il codice hash.</param>
        <param name="inputOffset">Offset nella matrice di byte di input dal quale iniziare a usare i dati.</param>
        <param name="inputCount">Numero di byte nella matrice di byte di input da usare come dati.</param>
        <param name="outputBuffer">Copia della parte della matrice di input usata per calcolare il codice hash.</param>
        <param name="outputOffset">Offset nella matrice di byte di output dal quale iniziare a scrivere i dati.</param>
        <summary>Calcola il valore hash dell'area specifica della matrice di byte di input e copia una determinata area della matrice di byte di input nell'area specifica della matrice di byte di output.</summary>
        <returns>Numero di byte scritti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> metodo prima di chiamare il <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> metodo. È necessario chiamare sia metodi prima di recuperare il valore hash finale.  
  
 Per recuperare il valore hash finale dopo la chiamata di <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> (metodo), ottenere la matrice di byte all'interno di <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> proprietà.  
  
 La chiamata di <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> con diverse matrici di input e output i metodi restituiscono un <xref:System.IO.IOException>.  
  
   
  
## Examples  
 Utilizzo di esempi di codice seguente il <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> metodo con il <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> metodo per l'hashing di una stringa.  
  
 [!code-csharp[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/CS/sample.cs#1)]
 [!code-vb[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputCount" />utilizza un valore non valido.  
  
 oppure  
  
 La lunghezza di <paramref name="inputBuffer" />non è valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputBuffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inputOffset" /> non è compreso nell'intervallo consentito. Per questo parametro è richiesto un numero non negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformFinalBlock">
      <MemberSignature Language="C#" Value="public byte[] TransformFinalBlock (byte[] inputBuffer, int inputOffset, int inputCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] TransformFinalBlock(unsigned int8[] inputBuffer, int32 inputOffset, int32 inputCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformFinalBlock (inputBuffer As Byte(), inputOffset As Integer, inputCount As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ TransformFinalBlock(cli::array &lt;System::Byte&gt; ^ inputBuffer, int inputOffset, int inputCount);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputBuffer" Type="System.Byte[]" />
        <Parameter Name="inputOffset" Type="System.Int32" />
        <Parameter Name="inputCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inputBuffer">Input per il quale calcolare il codice hash.</param>
        <param name="inputOffset">Offset nella matrice di byte dal quale iniziare a usare i dati.</param>
        <param name="inputCount">Numero di byte nella matrice da usare come dati.</param>
        <summary>Calcola il valore hash dell'area specifica della matrice di byte specificata.</summary>
        <returns>Matrice che rappresenta una copia della parte di input per cui viene generato un hash.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> metodo dopo la chiamata di <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> metodo ma prima di recuperare il valore hash finale.  
  
 Si noti che il valore restituito di questo metodo non è il valore hash, ma solo una copia della parte con hash dei dati di input.  Per recuperare l'ultimo valore hash dopo la chiamata di <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> (metodo), la matrice di byte contenuta in get il <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> proprietà.  
  
   
  
## Examples  
 Utilizzo di esempi di codice seguente il <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> metodo con il <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> metodo per l'hashing di una stringa.  
  
 [!code-csharp[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/CS/sample.cs#1)]
 [!code-vb[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputCount" />utilizza un valore non valido.  
  
 oppure  
  
 La lunghezza dell'offset di <paramref name="inputBuffer" />non è valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputBuffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inputOffset" /> non è compreso nell'intervallo consentito. Per questo parametro è richiesto un numero non negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryComputeHash">
      <MemberSignature Language="C#" Value="public bool TryComputeHash (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryComputeHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TryComputeHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryComputeHash (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryComputeHash(ReadOnlySpan&lt;System::Byte&gt; source, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryHashFinal">
      <MemberSignature Language="C#" Value="protected virtual bool TryHashFinal (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryHashFinal(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TryHashFinal(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TryHashFinal (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TryHashFinal(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>