<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IncrementalHash.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac58b2e239864865d83ed8aa588b335299d1a4f81c1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b2e239864865d83ed8aa588b335299d1a4f81c1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.7.1,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.IncrementalHash">
          <source>Provides support for computing a hash or Hash-based Message Authentication Code (HMAC) value incrementally across several segments.</source>
          <target state="translated">Offre il supporto per il calcolo di un hash o di un codice HMAC (Hash-based Message Authentication Code) in modo incrementale su più segmenti.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>Gets the name of the algorithm being performed.</source>
          <target state="translated">Ottiene il nome dell'algoritmo in corso di esecuzione.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>HMAC algorithms are prepended with "HMAC" to distinguish them from an unkeyed digest.</source>
          <target state="translated">Agli algoritmi HMAC viene anteposto "HMAC" per distinguerli da un digest senza chiave.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>The name of the algorithm being performed.</source>
          <target state="translated">Nome dell'algoritmo in corso di esecuzione.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>The data to process.</source>
          <target state="translated">I dati da elaborare.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>Appends the specified data to the data already processed in the hash or HMAC.</source>
          <target state="translated">Aggiunge i dati specificati ai dati già elaborati nell'hash o in HMAC.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="data" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> è già stato eliminato.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The data to process.</source>
          <target state="translated">I dati da elaborare.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The offset into the byte array from which to begin using data.</source>
          <target state="translated">Offset nella matrice di byte dal quale iniziare a usare i dati.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to use from <bpt id="p1">&lt;c&gt;</bpt>data<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Numero di byte da usare da <bpt id="p1">&lt;c&gt;</bpt>data<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>Appends the specified number of bytes from the specified data, starting at the specified offset, to the data already processed in the hash or Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated">Aggiunge il numero di byte specificato dai dati specificati (a partire dall'offset specificato) ai dati già elaborati nell'hash o nel codice HMAC (Hash-based Message Authentication Code).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="data" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> o <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is larger than the length of <ph id="ph2">&lt;paramref name="data" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza di <ph id="ph2">&lt;paramref name="data" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the data length.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza dei dati.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> è già stato eliminato.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>The name of the hash algorithm to perform.</source>
          <target state="translated">Il nome dell'algoritmo hash da eseguire.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> for the specified algorithm.</source>
          <target state="translated">Crea <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> per l'algoritmo specificato.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> instance ready to compute the hash algorithm specified by <ph id="ph2">&lt;paramref name="hashAlgorithm" /&gt;</ph>.</source>
          <target state="translated">Un'istanza <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> pronta per il calcolo dell'algoritmo hash specificato da <ph id="ph2">&lt;paramref name="hashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string.</source>
          <target state="translated">è <ph id="ph1">&lt;see langword="null" /&gt;</ph> o una stringa vuota.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> is not a known hash algorithm.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> non è un algoritmo hash noto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The name of the hash algorithm to perform within the HMAC.</source>
          <target state="translated">Il nome dell'algoritmo hash da eseguire in HMAC.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The secret key for the HMAC.</source>
          <target state="translated">Chiave privata per HMAC.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The key can be of any length, but a key longer than the output size of the specified hash algorithm will be hashed to derive a correctly-sized key.</source>
          <target state="translated">Sebbene la chiave possa essere di qualsiasi lunghezza, per una chiave più lunga della dimensione di output dell'algoritmo hash verrà calcolato il codice hash per derivare una chiave della dimensione corretta.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>Therefore, the recommended size of the secret key is the output size of the specified hash algorithm.</source>
          <target state="translated">Per questa ragione, la dimensione consigliata della chiave privata corrisponde alla dimensione di output dell'algoritmo hash specificato.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> for the Hash-based Message Authentication Code (HMAC) algorithm using the specified hash algorithm and key.</source>
          <target state="translated">Crea un <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> per l'algoritmo HMAC (Hash-based Message Authentication Code) usando l'algoritmo hash e la chiave specificati.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>An instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> class ready to compute the specified hash algorithm.</source>
          <target state="translated">Un'istanza della classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> pronta per il calcolo dell'algoritmo hash specificato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string.</source>
          <target state="translated">è <ph id="ph1">&lt;see langword="null" /&gt;</ph> o una stringa vuota.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> is not a known hash algorithm.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> non è un algoritmo hash noto.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.Dispose">
          <source>Releases the resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> class.</source>
          <target state="translated">Rilascia le risorse usate dall'istanza corrente della classe <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /&gt;</ph> method,  and resets the object to its initial state.</source>
          <target state="translated">Recupera l'hash o il codice HMAC (Hash-based Message Authentication Code) per i dati accumulati da chiamate precedenti al metodo <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /&gt;</ph> e reimposta l'oggetto allo stato iniziale.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>The computed hash or HMAC.</source>
          <target state="translated">L'hash o HMAC calcolato.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> è già stato eliminato.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>