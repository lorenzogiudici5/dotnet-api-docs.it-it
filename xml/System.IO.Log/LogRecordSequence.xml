<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="330d85d921807042238a6dbb6d100c3f96cc1899" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30421695" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta una sequenza di record in un oggetto <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.Log.LogRecordSequence> fornisce un'implementazione dell'interfaccia della sequenza di record all'inizio di un log Common Log File System (CLFS). Oltre alle funzionalità standard orientate al record, fornisce un modello di criteri che consente di evitare condizioni di log pieno e il multiplexing dei client sullo stesso file fisico. Questa classe viene utilizzata insieme alla classe <xref:System.IO.Log.LogStore> che fornisce un'interfaccia per la modifica e la gestione diretta di un file di log CLFS. La relazione tra la classe <xref:System.IO.Log.LogStore> e la classe <xref:System.IO.Log.LogRecordSequence> è simile alla relazione tra un file del disco e un oggetto <xref:System.IO.FileStream>. Il file del disco fornisce l'archivio concreto e dispone di attributi quali la lunghezza e l'ora dell'ultimo accesso, mentre l'oggetto <xref:System.IO.FileStream> fornisce una visualizzazione del file che può essere utilizzata per operazioni di lettura o scrittura su di esso. Analogamente, la classe <xref:System.IO.Log.LogStore> dispone di attributi quali i criteri e una raccolta di extent del disco e la classe <xref:System.IO.Log.LogRecordSequence> fornisce un meccanismo orientato ai record per la lettura e la scrittura di dati.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare la classe <xref:System.IO.Log.LogRecordSequence>:  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> che deve utilizzare questa sequenza di record.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con l'archivio dei log specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto. In questo costruttore è impostato il valore predefinito 64. Il numero desiderato di buffer è impostato su 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logStore" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso e la modalità specificati. All'archivio viene assegnato l'accesso in lettura/scrittura e viene aperto con accesso in lettura condiviso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 <paramref name="path" /> contiene solo spazi vuoti.  
  
 oppure  
  
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> che deve utilizzare questa sequenza di record.</param>
        <param name="bufferSize">Dimensione desiderata del buffer in byte. La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</param>
        <param name="bufferCount">Numero desiderato di buffer.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con l'archivio di log, la dimensione del buffer per ogni record e il numero di buffer specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore se si desidera specificare valori per `bufferSize` e `bufferCount` e non si desidera utilizzare il valore predefinito di 64 per `bufferSize` e il valore 10 per `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="logStore" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
 oppure  
  
 <paramref name="bufferCount" /> è un valore negativo o zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso e condivisione specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso in lettura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 <paramref name="path" /> contiene solo spazi vuoti.  
  
 oppure  
  
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <param name="share">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso specificato.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il costruttore <xref:System.IO.Log.LogRecordSequence>:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 <paramref name="path" /> contiene solo spazi vuoti.  
  
 oppure  
  
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <param name="share">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</param>
        <param name="bufferSize">Dimensione desiderata del buffer in byte. La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</param>
        <param name="bufferCount">Numero desiderato di buffer.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio dei log, l'autorizzazione per i file, le modalità di accesso e condivisione, la dimensione del buffer e il numero di record specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso specificato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 <paramref name="path" /> contiene solo spazi vuoti.  
  
 oppure  
  
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Valore <see cref="T:System.IO.FileMode" /> valido che determina come aprire o creare l'archivio.</param>
        <param name="access">Valore <see cref="T:System.IO.FileAccess" /> valido che determina la modalità di accesso all'archivio dei log.</param>
        <param name="share">Valore <see cref="T:System.IO.FileShare" /> valido che determina come verrà condiviso tra i processi l'archivio dei log.</param>
        <param name="bufferSize">Dimensione desiderata del buffer in byte. La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</param>
        <param name="bufferCount">Numero desiderato di buffer.</param>
        <param name="fileSecurity">Valore <see cref="T:System.Security.AccessControl.FileSecurity" /> valido che specifica la sicurezza da impostare sull'archivio appena creato se l'archivio deve essere protetto.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il file specificato da <paramref name="path" /> non è valido.  
  
 oppure  
  
 Il nome del file dell'archivio dei log specificato non è valido.  
  
 oppure  
  
 <paramref name="mode" /> presenta il valore <see cref="F:System.IO.FileMode.CreateNew" /> e non può essere utilizzato senza accesso in scrittura.  
  
 oppure  
  
 <paramref name="mode" /> presenta il valore <see cref="F:System.IO.FileMode.OpenOrCreate" /> e non può essere utilizzato senza accesso in scrittura.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o più argomenti non sono compresi nell'intervallo.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è possibile trovare il file specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Non è possibile accedere al file specificato da <paramref name="path" /> poiché il file è attualmente utilizzato da un altro processo.  
  
 oppure  
  
 Non è possibile creare il file specificato da <paramref name="path" /> perché il file o la directory esiste già.  
  
 oppure  
  
 Impossibile associare l'handle di registro al pool di thread.  
  
 oppure  
  
 Il formato del file di log o la versione specificata non è valida.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Specifica il nuovo <see cref="T:System.IO.Log.SequenceNumber" /> di base per il log. Deve essere compreso tra il numero di sequenza di base corrente e l'ultimo numero di sequenza del log inclusi.</param>
        <summary>Sposta in avanti il numero di sequenza di base del log. Questo metodo non può essere ereditato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene spesso utilizzato con l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per liberare spazio in un record. L'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> indica che la coda della sequenza (ovvero il numero di sequenza di base) deve essere spostata in avanti per liberare spazio. Il recupero dello spazio può essere ottenuto scrivendo aree di riavvio mediante il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> o troncando il log e utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> per spostare in avanti il numero di sequenza di base di un log a quello specificato dal parametro `newBaseSequenceNumber`. Il codice riportato nella sezione relativa agli esempi illustra la seconda possibilità.  
  
 Si noti che la chiamata a questo metodo corrisponde all'impostazione di un nuovo numero di sequenza di base utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, con la differenza che nessun record di riavvio viene scritto nel log.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> con l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per liberare spazio in una sequenza del log.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> non è valido per questa sequenza.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.  
  
 oppure  
  
 <paramref name="newBaseSequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.InvalidOperationException">Nel log specificato non esistono extent. Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un record di log in <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.Append%2A>:  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <summary>Scrive un record di log in <see cref="T:System.IO.Log.LogRecordSequence" />. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene dimostrato come utilizzare questo metodo per aggiungere un record di log alla sequenza.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <summary>Aggiunge un record di log a <see cref="T:System.IO.Log.IRecordSequence" />. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <summary>Accoda un record di log a <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <summary>Accoda un record di log a <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di sequenza del primo record valido dell'oggetto <see cref="T:System.IO.Log.LogRecordSequence" /> corrente.</summary>
        <value>Numero di sequenza più basso corrispondente a un record valido nell'interfaccia <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Il valore di questa proprietà può essere modificato chiamando il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> o il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> in un ciclo.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'operazione di accodamento asincrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione di accodamento asincrona. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione di accodamento asincrona. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione di accodamento asincrona. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione di accodamento asincrona. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numero di sequenza dell'ultimo record che deve essere scritto. Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando lo scaricamento è stato completato.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di scaricamento asincrono da altre richieste.</param>
        <summary>Avvia un'operazione di scaricamento asincrono, utilizzando spazio precedentemente riservato nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di scaricamento asincrono che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita dal metodo corrente al metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> per garantire che lo scaricamento venga completato e le risorse vengano liberate in modo appropriato. Se si verifica un errore durante un'operazione di scaricamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> non viene chiamato con il valore <xref:System.IAsyncResult> restituito da questo metodo.  
  
 La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.LogRecordSequence> siano scritti in modo durevole.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, comportano la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> non è valido per questa sequenza.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</exception>
        <exception cref="T:System.InvalidOperationException">Nel log specificato non esistono extent. Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'operazione asincrona di prenotazione e accodamento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione asincrona di prenotazione e accodamento. Questo metodo non può essere ereditato.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Avvia un'operazione asincrona di prenotazione e accodamento. Questo metodo non può essere ereditato.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizia un'operazione asincrona di scrittura dell'area di riavvio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Segmenti della matrice di byte che verranno concatenati e aggiunti come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservation">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</param>
        <summary>Avvia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato. Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> non è valido per questa sequenza.  
  
 oppure  
  
 Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservation" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più parametri sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.  
  
 oppure  
  
 <paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservationCollection">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</param>
        <summary>Avvia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato. Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> non è valido per questa sequenza.  
  
 oppure  
  
 Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservationCollection" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più parametri sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.  
  
 oppure  
  
 <paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.IO.Log.ReservationCollection" />. Questo metodo non può essere ereditato.</summary>
        <returns>Oggetto <see cref="T:System.IO.Log.ReservationCollection" /> appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le prenotazioni possono essere eseguite in due modalità come illustrato negli esempi riportati di seguito. È possibile adottare le pratiche negli esempi per un'elaborazione affidabile. Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse utilizzate dal componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio viene illustrato come utilizzare <xref:System.IO.Log.LogRecordSequence.Dispose%2A> per rilasciare le risorse:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione di accodamento asincrona. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> non è valido.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> è stato già chiamato per questa operazione asincrona.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione di scaricamento asincrono. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, risultano visibili quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> non è valido.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> è stato già chiamato per questa operazione asincrona.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione asincrona di prenotazione e accodamento. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> non è valido.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> è stato già chiamato per questa operazione asincrona.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione asincrona di scrittura dell'area di riavvio. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record del log scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> è stato già chiamato per questa operazione asincrona.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive i record aggiunti in modo durevole.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantisce la scrittura di tutti i record aggiunti. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.LogRecordSequence> siano stati scritti in modo durevole.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante lo scaricamento dei dati.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.NotSupportedException">Operazione non supportata.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.InvalidOperationException">Nel log specificato non esistono extent. Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numero di sequenza dell'ultimo record che deve essere scritto. Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</param>
        <summary>Garantisce che tutti i record aggiunti fino al record con il numero di sequenza specificato incluso siano stati scritti in modo durevole. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a questo metodo garantisce che tutti i record con numeri di sequenza fino al numero di sequenza specificato incluso siano stati scritti in modo durevole.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> non è valido per questa sequenza.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</exception>
        <exception cref="T:System.InvalidOperationException">Nel log specificato non esistono extent. Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di sequenza maggiore dell'ultimo record aggiunto.</summary>
        <value>Numero di sequenza maggiore dell'ultimo record accodato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà  contiene un numero di sequenza maggiore del numero di sequenza dell'ultimo record accodato. I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Tutti gli altri numeri di sequenza non sono validi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.IO.Log.LogStore" /> che contiene i dati per questa sequenza di record. Questo metodo non può essere ereditato.</summary>
        <value>Oggetto <see cref="T:System.IO.Log.LogStore" /> che contiene i dati per questa sequenza di record.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.LogStore%2A> per aggiungere extent.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la dimensione massima di un record che può essere aggiunto alla sequenza.</summary>
        <value>Dimensione massima di un record che può essere aggiunto alla sequenza.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numero di sequenza del primo record in cui viene avviata la lettura.</param>
        <param name="logRecordEnum">Valore <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valido che specifica la direzione di lettura, ovvero in avanti o indietro, dei record da una classe <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Restituisce una raccolta enumerabile di record inclusi nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>raccolta enumerabile di record inclusi nella sequenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce una raccolta enumerabile dei record inclusi nella sequenza. L'ordine dei record enumerati dipende dal valore del parametro `logRecordEnum`.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in un ciclo:  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> non è valido per questa sequenza.  
  
 oppure  
  
 <paramref name="logRecordEnum" /> non è valido.  
  
 oppure  
  
 L'elemento specificato non è stato trovato nella raccolta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.  
  
 -oppure–  
  
 La dimensione del buffer utilizzata per scrivere il record di log è maggiore della dimensione del buffer utilizzata per leggerlo.  
  
 oppure  
  
 La sequenza di record è danneggiata.  
  
 oppure  
  
 Il formato del file di log o la versione specificata non è valida.  
  
 oppure  
  
 Il record è scritto con una versione incompatibile della sequenza di record.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è valida perché l'enumerazione non è stata avviata. È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile delle aree di riavvio contenute nella sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>raccolta enumerabile delle aree di riavvio nella sequenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le aree di riavvio sono enumerate in ordine inverso, ovvero dal numero di sequenza più alto a quello più basso. Vengono enumerate soltanto le aree di riavvio con numeri di sequenza compresi tra l'ultimo numero di sequenza e il numero di sequenza di base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.  
  
 -oppure–  
  
 La dimensione del buffer utilizzata per scrivere il record di log è maggiore della dimensione del buffer utilizzata per leggerlo.  
  
 oppure  
  
 La sequenza di record è danneggiata.  
  
 oppure  
  
 Il formato del file di log o la versione specificata non è valida.  
  
 oppure  
  
 Il record è scritto con una versione incompatibile della sequenza di record.</exception>
        <exception cref="T:System.InvalidOperationException">L'operazione non è valida perché l'enumerazione non è stata avviata. È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.  
  
 -oppure–  
  
 L'enumerazione è stata terminata.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea automaticamente una sola prenotazione e accoda un record alla sequenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">Classe <see cref="T:System.IO.Log.ReservationCollection" /> che contiene la raccolta in cui effettuare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <summary>Crea automaticamente una sola prenotazione e accoda un record alla sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare tale metodo per creare prenotazioni. Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservations" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="userRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <summary>Crea automaticamente una sola prenotazione e accoda un record alla sequenza. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.NotSupportedException">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero totale di byte che sono stati riservati.</summary>
        <value>Dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di sequenza dell'area di riavvio più vicina alla fine del log.</summary>
        <value>Numero di sequenza dell'area di riavvio più vicina alla fine del log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 Utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>, è possibile rimuovere l'area di riavvio scritta più recentemente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno.</summary>
        <value>
          <see langword="true" /> se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di questa proprietà è `true` e un'operazione <xref:System.IO.Log.LogRecordSequence.Append%2A> non riesce per mancanza di spazio sufficiente nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare la proprietà <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>:  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Nuovo ultimo numero di sequenza contenuto in <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
 Deve riferirsi a un record attualmente valido contenuto nel log.</param>
        <summary>Imposta l'ultimo record contenuto in <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di sequenza specificato deve essere maggiore del numero di sequenza di base.  
  
 Quando questo metodo viene completato, tutti i record che erano stati precedentemente aggiunti con numeri di sequenza maggiori del numero di sequenza specificato sono inaccessibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> non è valido per questa sequenza.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.  
  
 oppure  
  
 <paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 È stata raggiunta la fine del log.  
  
 oppure  
  
 Il formato del file di log o la versione specificata non è valida.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Segnala l'esigenza di spostare la coda della sequenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento può essere generato quando si verifica una condizione di spazio insufficiente nella sequenza di record. Quando viene generato questo evento, la coda della sequenza (ovvero il numero di sequenza di base) viene spostata in avanti per liberare spazio.  
  
 L'evento può essere generato in qualsiasi momento in cui la sequenza di record decide che è necessario liberare spazio, per una qualsiasi ragione. Ad esempio, il motore dei criteri CLFS può decidere di generare l'evento quando determina che le code di due client di log che condividono lo stesso file di log sono troppo distanti. Il recupero dello spazio può essere effettuato scrivendo aree di riavvio o troncando il log e utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> per il recupero dello spazio. Il codice riportato nella sezione relativa agli esempi illustra la seconda possibilità.  
  
 È inoltre possibile chiamare il metodo <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> all'esterno dell'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per recuperare spazio. Un'area di riavvio è simile a un checkpoint in altri sistemi di elaborazione di log. La chiamata di questo metodo indica che l'applicazione considera tutti i record precedenti prima dell'area di riavvio come completi e utilizzabili per successive aggiunte di record. Analogamente agli altri record, per poter funzionare, il record scritto da questo metodo richiede spazio disponibile effettivo nel log.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned>:  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Segmento di matrice che verrà concatenato e aggiunto come record.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più argomenti sono <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> e aggiorna il numero di sequenza di base. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> e aggiorna il numero di sequenza di base. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSeqNum">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservationCollection">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <summary>Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base. Questo metodo non può essere ereditato.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> non è valido per questa sequenza.  
  
 oppure  
  
 Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.  
  
 oppure  
  
 Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.  
  
 oppure  
  
 <paramref name="reservationCollection" /> non è stato creato da questa sequenza di record.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più parametri sono <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una coda o base di archivio nuova o esistente del log attivo non è valida.  
  
 oppure  
  
 <paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.IO.IOException">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.  
  
 oppure  
  
 Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
  </Members>
</Type>