<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="81dc4-101">Rappresenta una sequenza di record in un oggetto <see cref="T:System.IO.Log.LogStore" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-101">Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-102">La classe <xref:System.IO.Log.LogRecordSequence> fornisce un'implementazione dell'interfaccia della sequenza di record all'inizio di un log Common Log File System (CLFS).</span><span class="sxs-lookup"><span data-stu-id="81dc4-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="81dc4-103">Oltre alle funzionalità standard orientate al record, fornisce un modello di criteri che consente di evitare condizioni di log pieno e il multiplexing dei client sullo stesso file fisico.</span><span class="sxs-lookup"><span data-stu-id="81dc4-103">In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</span></span> <span data-ttu-id="81dc4-104">Questa classe viene utilizzata insieme alla classe <xref:System.IO.Log.LogStore> che fornisce un'interfaccia per la modifica e la gestione diretta di un file di log CLFS.</span><span class="sxs-lookup"><span data-stu-id="81dc4-104">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="81dc4-105">La relazione tra la classe <xref:System.IO.Log.LogStore> e la classe <xref:System.IO.Log.LogRecordSequence> è simile alla relazione tra un file del disco e un oggetto <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-105">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="81dc4-106">Il file del disco fornisce l'archivio concreto e dispone di attributi quali la lunghezza e l'ora dell'ultimo accesso, mentre l'oggetto <xref:System.IO.FileStream> fornisce una visualizzazione del file che può essere utilizzata per operazioni di lettura o scrittura su di esso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-106">The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="81dc4-107">Analogamente, la classe <xref:System.IO.Log.LogStore> dispone di attributi quali i criteri e una raccolta di extent del disco e la classe <xref:System.IO.Log.LogRecordSequence> fornisce un meccanismo orientato ai record per la lettura e la scrittura di dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-107">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-108">In questo esempio viene illustrato come utilizzare la classe <xref:System.IO.Log.LogRecordSequence>:</span><span class="sxs-lookup"><span data-stu-id="81dc4-108">This example shows how to use the <xref:System.IO.Log.LogRecordSequence> class:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-109">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-109">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="81dc4-110"><see cref="T:System.IO.Log.LogStore" /> che deve utilizzare questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-110">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <summary><span data-ttu-id="81dc4-111">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con l'archivio dei log specificato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-111">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-112">La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-112">The buffer size determines the maximum size of the record that can be appended or read.</span></span> <span data-ttu-id="81dc4-113">In questo costruttore è impostato il valore predefinito 64.</span><span class="sxs-lookup"><span data-stu-id="81dc4-113">In this constructor, a default value of 64 is set.</span></span> <span data-ttu-id="81dc4-114">Il numero desiderato di buffer è impostato su 10.</span><span class="sxs-lookup"><span data-stu-id="81dc4-114">The desired number of buffers is set to 10.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-115"><paramref name="logStore" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-115"><paramref name="logStore" /> is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="81dc4-116">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</span><span class="sxs-lookup"><span data-stu-id="81dc4-116">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="81dc4-117">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-117">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <summary><span data-ttu-id="81dc4-118">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-118">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-119">Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso e la modalità specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-119">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode.</span></span> <span data-ttu-id="81dc4-120">All'archivio viene assegnato l'accesso in lettura/scrittura e viene aperto con accesso in lettura condiviso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-120">It is given read/write access to the store, and the store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="81dc4-121"><paramref name="path" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-121"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-122"><paramref name="path" /> è una stringa vuota ("").</span><span class="sxs-lookup"><span data-stu-id="81dc4-122"><paramref name="path" /> is an empty string ("").</span></span>  
  
 <span data-ttu-id="81dc4-123">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-123">-or-</span></span>  
  
 <span data-ttu-id="81dc4-124"><paramref name="path" /> contiene solo spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-124"><paramref name="path" /> contains only white space.</span></span>  
  
 <span data-ttu-id="81dc4-125">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-125">-or-</span></span>  
  
 <span data-ttu-id="81dc4-126"><paramref name="path" /> contiene uno o più caratteri non validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-126"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-127"><paramref name="mode" /> contiene un valore non valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-127"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="81dc4-128">Impossibile trovare il file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-128">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-129">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</span><span class="sxs-lookup"><span data-stu-id="81dc4-129">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-130">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-130">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-131">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-131">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-132">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-132">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="81dc4-133">La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-133"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="81dc4-134">Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-134">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="81dc4-135"><see cref="T:System.IO.Log.LogStore" /> che deve utilizzare questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-135">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="81dc4-136">Dimensione desiderata del buffer in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-136">The desired buffer size in bytes.</span></span> <span data-ttu-id="81dc4-137">La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-137">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="81dc4-138">Numero desiderato di buffer.</span><span class="sxs-lookup"><span data-stu-id="81dc4-138">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="81dc4-139">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con l'archivio di log, la dimensione del buffer per ogni record e il numero di buffer specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-139">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-140">Utilizzare questo costruttore se si desidera specificare valori per `bufferSize` e `bufferCount` e non si desidera utilizzare il valore predefinito di 64 per `bufferSize` e il valore 10 per `bufferCount`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-140">Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="81dc4-141"><paramref name="logStore" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-141"><paramref name="logStore" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-142"><paramref name="bufferSize" /> è un valore negativo o zero.</span><span class="sxs-lookup"><span data-stu-id="81dc4-142"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
 <span data-ttu-id="81dc4-143">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-143">-or-</span></span>  
  
 <span data-ttu-id="81dc4-144"><paramref name="bufferCount" /> è un valore negativo o zero.</span><span class="sxs-lookup"><span data-stu-id="81dc4-144"><paramref name="bufferCount" /> is negative or zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="81dc4-145">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</span><span class="sxs-lookup"><span data-stu-id="81dc4-145">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="81dc4-146">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-146">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="81dc4-147">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-147">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <summary><span data-ttu-id="81dc4-148">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso e condivisione specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-148">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-149">Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-149">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="81dc4-150">L'archivio viene aperto condividendo l'accesso in lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-150">The store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="81dc4-151"><paramref name="path" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-151"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-152"><paramref name="path" /> è una stringa vuota ("").</span><span class="sxs-lookup"><span data-stu-id="81dc4-152"><paramref name="path" /> is an empty string ("").</span></span>  
  
 <span data-ttu-id="81dc4-153">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-153">-or-</span></span>  
  
 <span data-ttu-id="81dc4-154"><paramref name="path" /> contiene solo spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-154"><paramref name="path" /> contains only white space.</span></span>  
  
 <span data-ttu-id="81dc4-155">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-155">-or-</span></span>  
  
 <span data-ttu-id="81dc4-156"><paramref name="path" /> contiene uno o più caratteri non validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-156"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-157"><paramref name="mode" /> contiene un valore non valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-157"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="81dc4-158">Impossibile trovare il file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-158">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-159">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</span><span class="sxs-lookup"><span data-stu-id="81dc4-159">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-160">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-160">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-161">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-161">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-162">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-162">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="81dc4-163">La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-163"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="81dc4-164">Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-164">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="81dc4-165">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</span><span class="sxs-lookup"><span data-stu-id="81dc4-165">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="81dc4-166">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-166">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="81dc4-167">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-167">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="81dc4-168">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-168">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <summary><span data-ttu-id="81dc4-169">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio di log e la modalità di accesso specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-169">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-170">Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-170">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="81dc4-171">L'archivio viene aperto condividendo l'accesso specificato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-171">The store is opened sharing the specified access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-172">In questo esempio viene illustrato come utilizzare il costruttore <xref:System.IO.Log.LogRecordSequence>:</span><span class="sxs-lookup"><span data-stu-id="81dc4-172">This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="81dc4-173"><paramref name="path" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-173"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-174"><paramref name="path" /> è una stringa vuota ("").</span><span class="sxs-lookup"><span data-stu-id="81dc4-174"><paramref name="path" /> is an empty string ("").</span></span>  
  
 <span data-ttu-id="81dc4-175">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-175">-or-</span></span>  
  
 <span data-ttu-id="81dc4-176"><paramref name="path" /> contiene solo spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-176"><paramref name="path" /> contains only white space.</span></span>  
  
 <span data-ttu-id="81dc4-177">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-177">-or-</span></span>  
  
 <span data-ttu-id="81dc4-178"><paramref name="path" /> contiene uno o più caratteri non validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-178"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-179"><paramref name="mode" /> contiene un valore non valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-179"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="81dc4-180">Impossibile trovare il file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-180">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-181">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</span><span class="sxs-lookup"><span data-stu-id="81dc4-181">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-182">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-182">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-183">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-183">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-184">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-184">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="81dc4-185">La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-185"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="81dc4-186">Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-186">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="81dc4-187">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</span><span class="sxs-lookup"><span data-stu-id="81dc4-187">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="81dc4-188">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-188">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="81dc4-189">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-189">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="81dc4-190">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-190">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="81dc4-191">Dimensione desiderata del buffer in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-191">The desired buffer size in bytes.</span></span> <span data-ttu-id="81dc4-192">La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-192">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="81dc4-193">Numero desiderato di buffer.</span><span class="sxs-lookup"><span data-stu-id="81dc4-193">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="81dc4-194">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" /> con il percorso all'archivio dei log, l'autorizzazione per i file, le modalità di accesso e condivisione, la dimensione del buffer e il numero di record specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-194">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-195">Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogRecordSequence> in un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-195">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="81dc4-196">L'archivio viene aperto condividendo l'accesso specificato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-196">The store is opened sharing the specified access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="81dc4-197"><paramref name="path" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-197"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-198"><paramref name="path" /> è una stringa vuota ("").</span><span class="sxs-lookup"><span data-stu-id="81dc4-198"><paramref name="path" /> is an empty string ("").</span></span>  
  
 <span data-ttu-id="81dc4-199">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-199">-or-</span></span>  
  
 <span data-ttu-id="81dc4-200"><paramref name="path" /> contiene solo spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-200"><paramref name="path" /> contains only white space.</span></span>  
  
 <span data-ttu-id="81dc4-201">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-201">-or-</span></span>  
  
 <span data-ttu-id="81dc4-202"><paramref name="path" /> contiene uno o più caratteri non validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-202"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-203"><paramref name="mode" /> contiene un valore non valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-203"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="81dc4-204">Impossibile trovare il file.</span><span class="sxs-lookup"><span data-stu-id="81dc4-204">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-205">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</span><span class="sxs-lookup"><span data-stu-id="81dc4-205">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-206">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-206">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-207">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-207">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-208">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-208">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="81dc4-209">La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-209"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="81dc4-210">Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-210">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="81dc4-211">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</span><span class="sxs-lookup"><span data-stu-id="81dc4-211">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="81dc4-212">Valore <see cref="T:System.IO.FileMode" /> valido che determina come aprire o creare l'archivio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-212">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="81dc4-213">Valore <see cref="T:System.IO.FileAccess" /> valido che determina la modalità di accesso all'archivio dei log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-213">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</span></span></param>
        <param name="share"><span data-ttu-id="81dc4-214">Valore <see cref="T:System.IO.FileShare" /> valido che determina come verrà condiviso tra i processi l'archivio dei log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-214">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="81dc4-215">Dimensione desiderata del buffer in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-215">The desired buffer size in bytes.</span></span> <span data-ttu-id="81dc4-216">La dimensione del buffer determina la dimensione massima del record che può essere aggiunto o letto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-216">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="81dc4-217">Numero desiderato di buffer.</span><span class="sxs-lookup"><span data-stu-id="81dc4-217">The desired number of buffers.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="81dc4-218">Valore <see cref="T:System.Security.AccessControl.FileSecurity" /> valido che specifica la sicurezza da impostare sull'archivio appena creato se l'archivio deve essere protetto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-218">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span></span></param>
        <summary><span data-ttu-id="81dc4-219">Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-219">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-220">Il file specificato da <paramref name="path" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-220">The file specified by <paramref name="path" /> is not valid.</span></span>  
  
 <span data-ttu-id="81dc4-221">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-221">-or-</span></span>  
  
 <span data-ttu-id="81dc4-222">Il nome del file dell'archivio dei log specificato non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-222">The specified log store file name is not valid.</span></span>  
  
 <span data-ttu-id="81dc4-223">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-223">-or-</span></span>  
  
 <span data-ttu-id="81dc4-224"><paramref name="mode" /> presenta il valore <see cref="F:System.IO.FileMode.CreateNew" /> e non può essere utilizzato senza accesso in scrittura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-224"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.</span></span>  
  
 <span data-ttu-id="81dc4-225">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-225">-or-</span></span>  
  
 <span data-ttu-id="81dc4-226"><paramref name="mode" /> presenta il valore <see cref="F:System.IO.FileMode.OpenOrCreate" /> e non può essere utilizzato senza accesso in scrittura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-226"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-227">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-227">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-228">Uno o più argomenti non sono compresi nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-228">One or more of the arguments are out of range.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="81dc4-229">Non è possibile trovare il file specificato da <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-229">The file specified by <paramref name="path" /> cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-230">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-230">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-231">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-231">-or-</span></span>  
  
 <span data-ttu-id="81dc4-232">Non è possibile accedere al file specificato da <paramref name="path" /> poiché il file è attualmente utilizzato da un altro processo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-232">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span></span>  
  
 <span data-ttu-id="81dc4-233">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-233">-or-</span></span>  
  
 <span data-ttu-id="81dc4-234">Non è possibile creare il file specificato da <paramref name="path" /> perché il file o la directory esiste già.</span><span class="sxs-lookup"><span data-stu-id="81dc4-234">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span></span>  
  
 <span data-ttu-id="81dc4-235">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-235">-or-</span></span>  
  
 <span data-ttu-id="81dc4-236">Impossibile associare l'handle di registro al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="81dc4-236">The log handle could not be bound to the thread pool.</span></span>  
  
 <span data-ttu-id="81dc4-237">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-237">-or-</span></span>  
  
 <span data-ttu-id="81dc4-238">Il formato del file di log o la versione specificata non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-238">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-239">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-239">This operation is not supported.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-240">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-240">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-241">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-241">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="81dc4-242">La classe <see cref="T:System.IO.Log.LogRecordSequence" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-242"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="81dc4-243">Installare il componente CLFS se è disponibile per la piattaforma o utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-243">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-244">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-244">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-245">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-245">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber"><span data-ttu-id="81dc4-246">Specifica il nuovo <see cref="T:System.IO.Log.SequenceNumber" /> di base per il log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-246">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log.</span></span> <span data-ttu-id="81dc4-247">Deve essere compreso tra il numero di sequenza di base corrente e l'ultimo numero di sequenza del log inclusi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-247">This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</span></span></param>
        <summary><span data-ttu-id="81dc4-248">Sposta in avanti il numero di sequenza di base del log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-248">Moves the base sequence number of the log forward.</span></span> <span data-ttu-id="81dc4-249">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-249">This method cannot be inherited.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-250">Questo metodo viene spesso utilizzato con l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per liberare spazio in un record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-250">This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record.</span></span> <span data-ttu-id="81dc4-251">L'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> indica che la coda della sequenza (ovvero il numero di sequenza di base) deve essere spostata in avanti per liberare spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-251">The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</span></span> <span data-ttu-id="81dc4-252">Il recupero dello spazio può essere ottenuto scrivendo aree di riavvio mediante il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> o troncando il log e utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> per spostare in avanti il numero di sequenza di base di un log a quello specificato dal parametro `newBaseSequenceNumber`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-252">Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter.</span></span> <span data-ttu-id="81dc4-253">Il codice riportato nella sezione relativa agli esempi illustra la seconda possibilità.</span><span class="sxs-lookup"><span data-stu-id="81dc4-253">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="81dc4-254">Si noti che la chiamata a questo metodo corrisponde all'impostazione di un nuovo numero di sequenza di base utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, con la differenza che nessun record di riavvio viene scritto nel log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-254">Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-255">In questo esempio viene illustrato come utilizzare il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> con l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per liberare spazio in una sequenza del log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-255">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-256"><paramref name="newBaseSequenceNumber" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-256"><paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-257">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-257">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-258">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-258">-or-</span></span>  
  
 <span data-ttu-id="81dc4-259"><paramref name="newBaseSequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-259"><paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-260">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-260">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-261">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-261">-or-</span></span>  
  
 <span data-ttu-id="81dc4-262">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-262">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-263">Nel log specificato non esistono extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-263">The specified log does not have any extents.</span></span> <span data-ttu-id="81dc4-264">Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-264">One or more extents must be created before a record sequence may be used.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-265">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-265">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-266">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-266">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-267">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-267">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-268">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-268">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-269">Scrive un record di log in <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-269">Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="81dc4-270">In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.Append%2A>:</span><span class="sxs-lookup"><span data-stu-id="81dc4-270">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.Append%2A> member</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-271">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-271">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-272">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-272">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-273">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-273">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-274">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-274">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="81dc4-275">Scrive un record di log in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-275">Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="81dc4-276">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-276">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-277">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-277">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-278">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-278">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-279">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-279">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-280">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-280">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-281">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-281">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-282">Nell'esempio seguente viene dimostrato come utilizzare questo metodo per aggiungere un record di log alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-282">The following example demonstrates how to use this method to append a log record to the sequence.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-283"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-283"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-284">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-284">-or-</span></span>  
  
 <span data-ttu-id="81dc4-285">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-285"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-286">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-286">-or-</span></span>  
  
 <span data-ttu-id="81dc4-287"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-287"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-288">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-288">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-289"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-289"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-290">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-290">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-291">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-291">-or-</span></span>  
  
 <span data-ttu-id="81dc4-292">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-292">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-293">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-293">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-294">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-294">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-295">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-295">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-296">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-296">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-297">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-297">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-298">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-298">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-299">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-299">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-300">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-300">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-301">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-301">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="81dc4-302">Aggiunge un record di log a <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-302">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span> <span data-ttu-id="81dc4-303">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-303">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-304">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-304">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-305">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-305">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-306">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-306">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-307">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-307">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-308">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-308">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-309"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-309"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-310">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-310">-or-</span></span>  
  
 <span data-ttu-id="81dc4-311">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-311"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-312">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-312">-or-</span></span>  
  
 <span data-ttu-id="81dc4-313"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-313"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-314">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-314">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-315"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-315"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-316">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-316">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-317">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-317">-or-</span></span>  
  
 <span data-ttu-id="81dc4-318">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-318">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-319">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-319">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-320">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-320">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-321">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-321">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-322">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-322">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-323">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-323">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-324">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-324">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-325">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-325">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-326">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-326">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-327">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-327">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-328">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-328">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="81dc4-329">Accoda un record di log a <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-329">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="81dc4-330">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-330">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-331">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-331">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-332">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-332">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-333">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-333">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-334">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-334">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="81dc4-335">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-335">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-336">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-336">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-337">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-337">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-338"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-338"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-339">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-339">-or-</span></span>  
  
 <span data-ttu-id="81dc4-340">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-340"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-341">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-341">-or-</span></span>  
  
 <span data-ttu-id="81dc4-342"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-342"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-343">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-343">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-344"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-344"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-345">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-345">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-346">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-346">-or-</span></span>  
  
 <span data-ttu-id="81dc4-347">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-347">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-348">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-348">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-349">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-349">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-350">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-350">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-351">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-351">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-352">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-352">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-353">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-353">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-354">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-354">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-355">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-355">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-356">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-356">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-357">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-357">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-358">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-358">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="81dc4-359">Accoda un record di log a <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-359">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="81dc4-360">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-360">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-361">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-361">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-362">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-362">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-363">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-363">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-364">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-364">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="81dc4-365">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-365">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-366">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-366">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-367">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-367">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-368"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-368"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-369">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-369">-or-</span></span>  
  
 <span data-ttu-id="81dc4-370">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-370"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-371">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-371">-or-</span></span>  
  
 <span data-ttu-id="81dc4-372"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-372"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-373">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-373">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-374"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-374"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-375">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-375">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-376">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-376">-or-</span></span>  
  
 <span data-ttu-id="81dc4-377">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-377">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-378">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-378">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-379">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-379">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-380">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-380">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-381">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-381">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-382">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-382">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-383">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-383">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-384">Ottiene il numero di sequenza del primo record valido dell'oggetto <see cref="T:System.IO.Log.LogRecordSequence" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-384">Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <value><span data-ttu-id="81dc4-385">Numero di sequenza più basso corrispondente a un record valido nell'interfaccia <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-385">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-386">I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-386">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="81dc4-387">Il valore di questa proprietà può essere modificato chiamando il metodo <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> o il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-387">The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-388">In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> in un ciclo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-388">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> member in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-389">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-389">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-390">Avvia un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-390">Begins an asynchronous append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-391">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-391">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-392">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-392">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-393">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-393">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-394">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-394">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-395">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-395">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-396">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-396">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-397">Avvia un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-397">Begins an asynchronous append operation.</span></span> <span data-ttu-id="81dc4-398">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-398">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-399"><see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-399">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-400">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-400">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-401">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-401">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-402">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-402">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-403">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-403">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-404">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-404">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-405">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-405">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-406"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-406"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-407">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-407">-or-</span></span>  
  
 <span data-ttu-id="81dc4-408">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-408"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-409">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-409">-or-</span></span>  
  
 <span data-ttu-id="81dc4-410"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-410"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-411">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-411">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-412"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-412"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-413">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-413">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-414">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-414">-or-</span></span>  
  
 <span data-ttu-id="81dc4-415">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-415">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-416">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-416">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-417">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-417">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-418">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-418">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-419">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-419">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-420">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-420">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-421">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-421">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-422">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-422">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-423">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-423">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-424">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-424">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-425">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-425">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-426">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-426">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-427">Avvia un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-427">Begins an asynchronous append operation.</span></span> <span data-ttu-id="81dc4-428">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-428">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-429"><see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-429">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-430">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-430">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-431">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-431">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-432">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-432">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-433">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-433">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-434">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-434">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-435">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-435">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-436"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-436"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-437">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-437">-or-</span></span>  
  
 <span data-ttu-id="81dc4-438">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-438"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-439">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-439">-or-</span></span>  
  
 <span data-ttu-id="81dc4-440"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-440"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-441">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-441">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-442"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-442"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-443">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-443">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-444">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-444">-or-</span></span>  
  
 <span data-ttu-id="81dc4-445">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-445">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-446">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-446">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-447">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-447">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-448">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-448">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-449">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-449">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-450">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-450">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-451">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-451">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-452">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-452">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-453">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-453">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-454">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-454">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-455">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-455">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-456">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-456">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-457">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-457">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-458">Avvia un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-458">Begins an asynchronous append operation.</span></span> <span data-ttu-id="81dc4-459">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-459">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-460"><see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-460">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-461">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-461">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-462">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-462">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-463">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-463">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-464">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-464">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-465">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-465">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="81dc4-466">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-466">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-467">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-467">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-468">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-468">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-469"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-469"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-470">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-470">-or-</span></span>  
  
 <span data-ttu-id="81dc4-471">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-471"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-472">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-472">-or-</span></span>  
  
 <span data-ttu-id="81dc4-473"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-473"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-474">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-474">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-475"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-475"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-476">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-476">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-477">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-477">-or-</span></span>  
  
 <span data-ttu-id="81dc4-478">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-478">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-479">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-479">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-480">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-480">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-481">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-481">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-482">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-482">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-483">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-483">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-484">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-484">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-485">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-485">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-486">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-486">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-487">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-487">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-488">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-488">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-489">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-489">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-490">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-490">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-491">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-491">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-492">Avvia un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-492">Begins an asynchronous append operation.</span></span> <span data-ttu-id="81dc4-493">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-493">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-494"><see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-494">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-495">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-495">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-496">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-496">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-497">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-497">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-498">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-498">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-499">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-499">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="81dc4-500">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-500">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-501">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-501">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="81dc4-502">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-502">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-503"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-503"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-504">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-504">-or-</span></span>  
  
 <span data-ttu-id="81dc4-505">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-505"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-506">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-506">-or-</span></span>  
  
 <span data-ttu-id="81dc4-507"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-507"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-508">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-508">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-509"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-509"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-510">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-510">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-511">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-511">-or-</span></span>  
  
 <span data-ttu-id="81dc4-512">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-512">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-513">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-513">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-514">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-514">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-515">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-515">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-516">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-516">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-517">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-517">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-518">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-518">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="81dc4-519">Numero di sequenza dell'ultimo record che deve essere scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-519">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="81dc4-520">Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-520">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-521">Callback asincrono facoltativo, da chiamare quando lo scaricamento è stato completato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-521">An optional asynchronous callback, to be called when the flush is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-522">Oggetto fornito dall'utente che distingue questa specifica richiesta di scaricamento asincrono da altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-522">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-523">Avvia un'operazione di scaricamento asincrono, utilizzando spazio precedentemente riservato nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-523">Begins an asynchronous flush operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="81dc4-524">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-524">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-525">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di scaricamento asincrono che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-525">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-526">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita dal metodo corrente al metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> per garantire che lo scaricamento venga completato e le risorse vengano liberate in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-526">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="81dc4-527">Se si verifica un errore durante un'operazione di scaricamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> non viene chiamato con il valore <xref:System.IAsyncResult> restituito da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-527">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-528">La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.LogRecordSequence> siano scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="81dc4-528">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="81dc4-529">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-529">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-530">Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, comportano la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-530">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-531"><paramref name="sequenceNumber" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-531"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-532"><paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-532"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-533">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-533">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-534">Nel log specificato non esistono extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-534">The specified log does not have any extents.</span></span> <span data-ttu-id="81dc4-535">Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-535">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-536">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-536">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-537">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-537">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-538">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-538">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-539">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-539">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-540">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-540">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-541">Avvia un'operazione asincrona di prenotazione e accodamento.</span><span class="sxs-lookup"><span data-stu-id="81dc4-541">Begins an asynchronous reserve and append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-542">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-542">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-543">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-543">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-544">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-544">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-545">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-545">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-546">raccolta di prenotazioni nella quale fare prenotazioni.</span><span class="sxs-lookup"><span data-stu-id="81dc4-546">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-547">Prenotazioni da fare, in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-547">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-548">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-548">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-549">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-549">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-550">Avvia un'operazione asincrona di prenotazione e accodamento.</span><span class="sxs-lookup"><span data-stu-id="81dc4-550">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="81dc4-551">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-551">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-552">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-552">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-553">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-553">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-554">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-554">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-555">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-555">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-556">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-556">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-557">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-557">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="81dc4-558">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-558">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="81dc4-559">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-559">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="81dc4-560">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-560">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-561">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-561">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-562">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-562">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-563"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-563"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-564">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-564">-or-</span></span>  
  
 <span data-ttu-id="81dc4-565">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-565"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-566">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-566">-or-</span></span>  
  
 <span data-ttu-id="81dc4-567"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-567"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-568">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-568">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-569"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-569"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-570">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-570">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-571">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-571">-or-</span></span>  
  
 <span data-ttu-id="81dc4-572">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-572">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-573">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-573">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-574">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-574">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-575">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-575">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-576">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-576">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-577">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-577">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-578">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-578">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-579">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-579">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-580">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-580">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-581">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-581">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-582">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-582">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-583">raccolta di prenotazioni nella quale fare prenotazioni.</span><span class="sxs-lookup"><span data-stu-id="81dc4-583">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-584">Prenotazioni da fare, in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-584">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-585">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-585">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-586">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-586">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-587">Avvia un'operazione asincrona di prenotazione e accodamento.</span><span class="sxs-lookup"><span data-stu-id="81dc4-587">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="81dc4-588">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-588">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-589">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-589">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-590">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="81dc4-590">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-591">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-591">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-592">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-592">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-593">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-593">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-594">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-594">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="81dc4-595">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-595">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="81dc4-596">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-596">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="81dc4-597">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-597">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-598">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-598">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-599">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-599">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-600">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-600">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-601">Si è verificato un errore di I/O durante l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-601">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-602">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-602">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-603">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-603">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-604">Inizia un'operazione asincrona di scrittura dell'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-604">Begins an asynchronous restart area write operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-605">Segmenti della matrice di byte che verranno concatenati e aggiunti come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-605">Byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-606">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-606">The new base sequence number.</span></span> <span data-ttu-id="81dc4-607">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-607">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="81dc4-608">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-608">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-609">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-609">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-610">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-610">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-611">Avvia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-611">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="81dc4-612">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-612">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-613">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-613">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-614">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-614">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-615">Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-615">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-616">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-616">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-617">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-617">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-618">Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-618">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-619">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-619">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-620">Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-620">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="81dc4-621">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-621">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-622">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-622">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-623">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-623">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-624"><paramref name="newBaseSeqNum" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-624"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-625">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-625">-or-</span></span>  
  
 <span data-ttu-id="81dc4-626">Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-626">The specified log enumeration start sequence number is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-627">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-627">-or-</span></span>  
  
 <span data-ttu-id="81dc4-628">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-628"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-629">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-629">-or-</span></span>  
  
 <span data-ttu-id="81dc4-630"><paramref name="reservation" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-630"><paramref name="reservation" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-631">Uno o più parametri sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-631">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-632">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-632">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-633">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-633">-or-</span></span>  
  
 <span data-ttu-id="81dc4-634"><paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-634"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-635">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-635">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-636">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-636">-or-</span></span>  
  
 <span data-ttu-id="81dc4-637">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-637">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-638">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-638">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-639">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-639">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-640">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-640">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-641">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-641">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-642">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-642">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-643">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-643">The new base sequence number.</span></span> <span data-ttu-id="81dc4-644">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-644">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-645">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-645">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="81dc4-646">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-646">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="81dc4-647">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</span><span class="sxs-lookup"><span data-stu-id="81dc4-647">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="81dc4-648">Avvia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-648">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="81dc4-649">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-649">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-650">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-650">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-651">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-651">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="81dc4-652">Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-652">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="81dc4-653">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-653">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-654">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-654">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-655">Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-655">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-656">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-656">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-657">Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-657">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="81dc4-658">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-658">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-659">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-659">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-660">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-660">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-661"><paramref name="newBaseSeqNum" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-661"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-662">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-662">-or-</span></span>  
  
 <span data-ttu-id="81dc4-663">Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-663">The specified log enumeration start sequence number is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-664">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-664">-or-</span></span>  
  
 <span data-ttu-id="81dc4-665">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-665"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-666">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-666">-or-</span></span>  
  
 <span data-ttu-id="81dc4-667"><paramref name="reservationCollection" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-667"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-668">Uno o più parametri sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-668">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-669">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-669">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-670">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-670">-or-</span></span>  
  
 <span data-ttu-id="81dc4-671"><paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-671"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-672">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-672">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-673">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-673">-or-</span></span>  
  
 <span data-ttu-id="81dc4-674">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-674">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-675">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-675">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-676">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-676">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-677">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-677">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-678">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-678">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="81dc4-679">Crea un nuovo oggetto <see cref="T:System.IO.Log.ReservationCollection" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-679">Creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span></span> <span data-ttu-id="81dc4-680">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-680">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-681">Oggetto <see cref="T:System.IO.Log.ReservationCollection" /> appena creato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-681">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="81dc4-682">Le prenotazioni possono essere eseguite in due modalità come illustrato negli esempi riportati di seguito.</span><span class="sxs-lookup"><span data-stu-id="81dc4-682">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="81dc4-683">È possibile adottare le pratiche negli esempi per un'elaborazione affidabile.</span><span class="sxs-lookup"><span data-stu-id="81dc4-683">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="81dc4-684">Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.</span><span class="sxs-lookup"><span data-stu-id="81dc4-684">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-685">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-685">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="81dc4-686">Rilascia le risorse utilizzate dal componente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-686">Releases the resources used by the component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="81dc4-687">In questo esempio viene illustrato come utilizzare <xref:System.IO.Log.LogRecordSequence.Dispose%2A> per rilasciare le risorse:</span><span class="sxs-lookup"><span data-stu-id="81dc4-687">This example shows how to use <xref:System.IO.Log.LogRecordSequence.Dispose%2A> to release resources:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-688">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-688">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-689">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-689">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="81dc4-690">Riferimento alla richiesta di I/O asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-690">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="81dc4-691">Termina un'operazione di accodamento asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-691">Ends an asynchronous append operation.</span></span> <span data-ttu-id="81dc4-692">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-692">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-693">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-693">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-694">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-694">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="81dc4-695">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-695">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="81dc4-696">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-696">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-697"><paramref name="result" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-697"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-698">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-698">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-699">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-699">-or-</span></span>  
  
 <span data-ttu-id="81dc4-700">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-700">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="81dc4-701"><see langword="End" /> è stato già chiamato per questa operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-701"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-702">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-702">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-703">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-703">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-704">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-704">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-705">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-705">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-706">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-706">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="81dc4-707">Riferimento alla richiesta di I/O asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-707">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="81dc4-708">Termina un'operazione di scaricamento asincrono.</span><span class="sxs-lookup"><span data-stu-id="81dc4-708">Ends an asynchronous flush operation.</span></span> <span data-ttu-id="81dc4-709">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-709">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-710">Numero di sequenza dell'ultimo record scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-710">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-711">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-711">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="81dc4-712">Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, risultano visibili quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-712">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="81dc4-713">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-713">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-714"><paramref name="result" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-714"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-715">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-715">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="81dc4-716"><see langword="End" /> è stato già chiamato per questa operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-716"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-717">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-717">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-718">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-718">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-719">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-719">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-720">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-720">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-721">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-721">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="81dc4-722">Riferimento alla richiesta di I/O asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-722">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="81dc4-723">Termina un'operazione asincrona di prenotazione e accodamento.</span><span class="sxs-lookup"><span data-stu-id="81dc4-723">Ends an asynchronous reserve and append operation.</span></span> <span data-ttu-id="81dc4-724">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-724">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-725">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-725">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-726">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-726">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="81dc4-727">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-727">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="81dc4-728">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-728">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-729"><paramref name="result" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-729"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-730">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-730">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-731">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-731">-or-</span></span>  
  
 <span data-ttu-id="81dc4-732">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-732">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="81dc4-733"><see langword="End" /> è stato già chiamato per questa operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-733"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-734">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-734">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-735">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-735">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-736">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-736">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-737">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-737">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-738">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-738">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="81dc4-739">Riferimento alla richiesta di I/O asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-739">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="81dc4-740">Termina un'operazione asincrona di scrittura dell'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-740">Ends an asynchronous restart area write operation.</span></span> <span data-ttu-id="81dc4-741">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-741">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-742">Numero di sequenza del record del log scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-742">The sequence number of the written log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-743">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-743">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="81dc4-744">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-744">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="81dc4-745">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-745">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-746"><paramref name="result" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-746"><paramref name="result" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-747">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-747">A new or existing archive tail or base of the active log is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-748">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-748">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="81dc4-749"><see langword="End" /> è stato già chiamato per questa operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="81dc4-749"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-750">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-750">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-751">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-751">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-752">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-752">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-753">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-753">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-754">Scrive i record aggiunti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="81dc4-754">Writes appended records durably</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="81dc4-755">Garantisce la scrittura di tutti i record aggiunti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-755">Ensures that all appended records have been written.</span></span> <span data-ttu-id="81dc4-756">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-756">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-757">Numero di sequenza dell'ultimo record scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-757">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-758">La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.LogRecordSequence> siano stati scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="81dc4-758">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-759">Si è verificato un errore di I/O durante lo scaricamento dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-759">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-760">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-760">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-761">Operazione non supportata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-761">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-762">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-762">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-763">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-763">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-764">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-764">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-765">Nel log specificato non esistono extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-765">The specified log does not have any extents.</span></span> <span data-ttu-id="81dc4-766">Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-766">One or more extents must be created before a record sequence can be used.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="81dc4-767">Numero di sequenza dell'ultimo record che deve essere scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-767">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="81dc4-768">Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-768">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <summary><span data-ttu-id="81dc4-769">Garantisce che tutti i record aggiunti fino al record con il numero di sequenza specificato incluso siano stati scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="81dc4-769">Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span></span> <span data-ttu-id="81dc4-770">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-770">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-771">Numero di sequenza dell'ultimo record scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-771">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-772">La chiamata a questo metodo garantisce che tutti i record con numeri di sequenza fino al numero di sequenza specificato incluso siano stati scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="81dc4-772">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-773"><paramref name="sequenceNumber" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-773"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-774"><paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-774"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-775">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-775">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-776">Nel log specificato non esistono extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-776">The specified log does not have any extents.</span></span> <span data-ttu-id="81dc4-777">Prima di utilizzare una sequenza di record, è necessario creare uno o più extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-777">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-778">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-778">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-779">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-779">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-780">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-780">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-781">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-781">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-782">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-782">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-783">Ottiene il numero di sequenza maggiore dell'ultimo record aggiunto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-783">Gets the sequence number which is greater than the last record appended</span></span></summary>
        <value><span data-ttu-id="81dc4-784">Numero di sequenza maggiore dell'ultimo record accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-784">A sequence number which is greater than the last record appended.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-785">Questa proprietà  contiene un numero di sequenza maggiore del numero di sequenza dell'ultimo record accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-785">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="81dc4-786">I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-786">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span> <span data-ttu-id="81dc4-787">Tutti gli altri numeri di sequenza non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-787">All other sequence numbers are invalid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-788">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-788">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-789">Ottiene l'oggetto <see cref="T:System.IO.Log.LogStore" /> che contiene i dati per questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-789">Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span> <span data-ttu-id="81dc4-790">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-790">This method cannot be inherited.</span></span></summary>
        <value><span data-ttu-id="81dc4-791">Oggetto <see cref="T:System.IO.Log.LogStore" /> che contiene i dati per questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-791">The <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="81dc4-792">In questo esempio viene illustrato come utilizzare il membro <xref:System.IO.Log.LogRecordSequence.LogStore%2A> per aggiungere extent.</span><span class="sxs-lookup"><span data-stu-id="81dc4-792">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.LogStore%2A> member to add extents.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-793">Ottiene la dimensione massima di un record che può essere aggiunto alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-793">Gets the maximum size of a record that can be added to this record sequence.</span></span></summary>
        <value><span data-ttu-id="81dc4-794">Dimensione massima di un record che può essere aggiunto alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-794">The maximum size of a record that can be added to this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="81dc4-795">Numero di sequenza del primo record in cui viene avviata la lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-795">The sequence number of the first record where the reading starts.</span></span></param>
        <param name="logRecordEnum"><span data-ttu-id="81dc4-796">Valore <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valido che specifica la direzione di lettura, ovvero in avanti o indietro, dei record da una classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-796">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></param>
        <summary><span data-ttu-id="81dc4-797">Restituisce una raccolta enumerabile di record inclusi nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-797">Returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="81dc4-798">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-798">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-799">raccolta enumerabile di record inclusi nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-799">An enumerable collection of records in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-800">Questo metodo restituisce una raccolta enumerabile dei record inclusi nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-800">This method returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="81dc4-801">L'ordine dei record enumerati dipende dal valore del parametro `logRecordEnum`.</span><span class="sxs-lookup"><span data-stu-id="81dc4-801">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-802">In questo esempio viene illustrato come utilizzare <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in un ciclo:</span><span class="sxs-lookup"><span data-stu-id="81dc4-802">This example shows how to use <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-803"><paramref name="start" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-803"><paramref name="start" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-804">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-804">-or-</span></span>  
  
 <span data-ttu-id="81dc4-805"><paramref name="logRecordEnum" /> non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-805"><paramref name="logRecordEnum" /> is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-806">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-806">-or-</span></span>  
  
 <span data-ttu-id="81dc4-807">L'elemento specificato non è stato trovato nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-807">The specified element was not found in the collection.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-808"><paramref name="start" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-808"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-809">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-809">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-810">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-810">-or-</span></span>  
  
 <span data-ttu-id="81dc4-811">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-811">The request could not be performed because of an I/O device error.</span></span>  
  
 <span data-ttu-id="81dc4-812">-oppure–</span><span class="sxs-lookup"><span data-stu-id="81dc4-812">-or</span></span>  
  
 <span data-ttu-id="81dc4-813">La dimensione del buffer utilizzata per scrivere il record di log è maggiore della dimensione del buffer utilizzata per leggerlo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-813">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
 <span data-ttu-id="81dc4-814">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-814">-or-</span></span>  
  
 <span data-ttu-id="81dc4-815">La sequenza di record è danneggiata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-815">The record sequence is corrupted.</span></span>  
  
 <span data-ttu-id="81dc4-816">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-816">-or-</span></span>  
  
 <span data-ttu-id="81dc4-817">Il formato del file di log o la versione specificata non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-817">The specified log file format or version is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-818">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-818">-or-</span></span>  
  
 <span data-ttu-id="81dc4-819">Il record è scritto con una versione incompatibile della sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-819">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-820">L'operazione non è valida perché l'enumerazione non è stata avviata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-820">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="81dc4-821">È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-821">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-822">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-822">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-823">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-823">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-824">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-824">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="81dc4-825">Restituisce una raccolta enumerabile delle aree di riavvio contenute nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-825">Returns an enumerable collection of the restart areas in the sequence.</span></span> <span data-ttu-id="81dc4-826">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-826">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-827">raccolta enumerabile delle aree di riavvio nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-827">An enumerable collection of the restart areas in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-828">Le aree di riavvio sono enumerate in ordine inverso, ovvero dal numero di sequenza più alto a quello più basso.</span><span class="sxs-lookup"><span data-stu-id="81dc4-828">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="81dc4-829">Vengono enumerate soltanto le aree di riavvio con numeri di sequenza compresi tra l'ultimo numero di sequenza e il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-829">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-830"><paramref name="start" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-830"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-831">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-831">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-832">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-832">-or-</span></span>  
  
 <span data-ttu-id="81dc4-833">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-833">The request could not be performed because of an I/O device error.</span></span>  
  
 <span data-ttu-id="81dc4-834">-oppure–</span><span class="sxs-lookup"><span data-stu-id="81dc4-834">-or</span></span>  
  
 <span data-ttu-id="81dc4-835">La dimensione del buffer utilizzata per scrivere il record di log è maggiore della dimensione del buffer utilizzata per leggerlo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-835">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
 <span data-ttu-id="81dc4-836">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-836">-or-</span></span>  
  
 <span data-ttu-id="81dc4-837">La sequenza di record è danneggiata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-837">The record sequence is corrupted.</span></span>  
  
 <span data-ttu-id="81dc4-838">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-838">-or-</span></span>  
  
 <span data-ttu-id="81dc4-839">Il formato del file di log o la versione specificata non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-839">The specified log file format or version is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-840">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-840">-or-</span></span>  
  
 <span data-ttu-id="81dc4-841">Il record è scritto con una versione incompatibile della sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-841">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81dc4-842">L'operazione non è valida perché l'enumerazione non è stata avviata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-842">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="81dc4-843">È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-843">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span>  
  
 <span data-ttu-id="81dc4-844">-oppure–</span><span class="sxs-lookup"><span data-stu-id="81dc4-844">-or</span></span>  
  
 <span data-ttu-id="81dc4-845">L'enumerazione è stata terminata.</span><span class="sxs-lookup"><span data-stu-id="81dc4-845">The enumeration has ended.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-846">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-846">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-847">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-847">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-848">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-848">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-849">Crea automaticamente una sola prenotazione e accoda un record alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-849">Automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-850">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-850">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="81dc4-851">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-851">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-852">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-852">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-853">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-853">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-854">Classe <see cref="T:System.IO.Log.ReservationCollection" /> che contiene la raccolta in cui effettuare prenotazioni.</span><span class="sxs-lookup"><span data-stu-id="81dc4-854">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-855">Prenotazioni da fare, in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-855">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="81dc4-856">Crea automaticamente una sola prenotazione e accoda un record alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-856">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="81dc4-857">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-857">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-858">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-858">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-859">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-859">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-860">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-860">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-861">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-861">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="81dc4-862">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-862">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="81dc4-863">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-863">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="81dc4-864">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-864">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-865">Nell'esempio seguente viene illustrato come utilizzare tale metodo per creare prenotazioni.</span><span class="sxs-lookup"><span data-stu-id="81dc4-865">The following example shows how to use this method to make reservations.</span></span> <span data-ttu-id="81dc4-866">Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.</span><span class="sxs-lookup"><span data-stu-id="81dc4-866">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-867"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-867"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-868">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-868">-or-</span></span>  
  
 <span data-ttu-id="81dc4-869">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-869"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-870">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-870">-or-</span></span>  
  
 <span data-ttu-id="81dc4-871"><paramref name="reservations" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-871"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-872">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-872">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-873"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-873"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-874">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-874">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-875">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-875">-or-</span></span>  
  
 <span data-ttu-id="81dc4-876">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-876">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-877">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-877">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-878">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-878">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-879">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-879">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-880">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-880">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-881">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-881">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-882">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-882">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-883">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-883">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="81dc4-884">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-884">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="81dc4-885">Numero di sequenza del record successivo nell'ordine Precedente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-885">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="81dc4-886">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-886">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-887">raccolta di prenotazioni nella quale fare prenotazioni.</span><span class="sxs-lookup"><span data-stu-id="81dc4-887">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-888">Prenotazioni da fare, in byte.</span><span class="sxs-lookup"><span data-stu-id="81dc4-888">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="81dc4-889">Crea automaticamente una sola prenotazione e accoda un record alla sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-889">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="81dc4-890">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-890">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-891">Numero di sequenza del record di registro accodato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-891">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-892">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-892">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-893">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-893">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="81dc4-894">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-894">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="81dc4-895">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-895">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="81dc4-896">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="81dc4-896">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="81dc4-897">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-897">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-898">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-898">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-899">Si è verificato un errore di I/O durante l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-899">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-900">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-900">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-901">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-901">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-902">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-902">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="81dc4-903"><paramref name="userRecord" /> o <paramref name="previousRecord" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-903"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="81dc4-904">L'operazione non può essere eseguita perché la sequenza di record è stata aperta con accesso in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="81dc4-904">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-905">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-905">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-906">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-906">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="81dc4-907">Impossibile trovare una prenotazione abbastanza grande da soddisfare il parametro <paramref name="data" /> in <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-907">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-908">Ottiene il numero totale di byte che sono stati riservati.</span><span class="sxs-lookup"><span data-stu-id="81dc4-908">Gets the total number of bytes that have been reserved.</span></span></summary>
        <value><span data-ttu-id="81dc4-909">Dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-909">The total size of all reservations made in this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-910">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-910">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-911">Ottiene il numero di sequenza dell'area di riavvio più vicina alla fine del log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-911">Gets the sequence number of the restart area closest to the end of the log.</span></span></summary>
        <value><span data-ttu-id="81dc4-912">Numero di sequenza dell'area di riavvio più vicina alla fine del log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-912">The sequence number of the restart area closest to the end of the log.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-913">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-913">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-914">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-914">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-915">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-915">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-916">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-916">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-917">Utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>, è possibile rimuovere l'area di riavvio scritta più recentemente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-917">Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-918">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-918">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-919">Ottiene o imposta un valore che indica se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno.</span><span class="sxs-lookup"><span data-stu-id="81dc4-919">Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</span></span></summary>
        <value>
          <span data-ttu-id="81dc4-920"><see langword="true" /> se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno. In caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-920"><see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="81dc4-921">Il valore predefinito è <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-921">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-922">Se il valore di questa proprietà è `true` e un'operazione <xref:System.IO.Log.LogRecordSequence.Append%2A> non riesce per mancanza di spazio sufficiente nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.</span><span class="sxs-lookup"><span data-stu-id="81dc4-922">If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-923">In questo esempio viene illustrato come utilizzare la proprietà <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>:</span><span class="sxs-lookup"><span data-stu-id="81dc4-923">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> property.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-924">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-924">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="81dc4-925">Nuovo ultimo numero di sequenza contenuto in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-925">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span>  
  
 <span data-ttu-id="81dc4-926">Deve riferirsi a un record attualmente valido contenuto nel log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-926">This should refer to a current valid record   currently in the log.</span></span></param>
        <summary><span data-ttu-id="81dc4-927">Imposta l'ultimo record contenuto in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-927">Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-928">Il numero di sequenza specificato deve essere maggiore del numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-928">The specified sequence number must be larger than the base sequence number.</span></span>  
  
 <span data-ttu-id="81dc4-929">Quando questo metodo viene completato, tutti i record che erano stati precedentemente aggiunti con numeri di sequenza maggiori del numero di sequenza specificato sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-929">When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-930"><paramref name="sequenceNumber" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-930"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-931">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-931">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-932">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-932">-or-</span></span>  
  
 <span data-ttu-id="81dc4-933"><paramref name="sequenceNumber" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-933"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-934">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-934">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-935">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-935">-or-</span></span>  
  
 <span data-ttu-id="81dc4-936">È stata raggiunta la fine del log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-936">The end of the log has been reached.</span></span>  
  
 <span data-ttu-id="81dc4-937">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-937">-or-</span></span>  
  
 <span data-ttu-id="81dc4-938">Il formato del file di log o la versione specificata non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-938">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-939">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-939">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-940">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-940">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-941">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-941">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81dc4-942">Segnala l'esigenza di spostare la coda della sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-942">Signals the need to move the tail of the sequence.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-943">Questo evento può essere generato quando si verifica una condizione di spazio insufficiente nella sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-943">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="81dc4-944">Quando viene generato questo evento, la coda della sequenza (ovvero il numero di sequenza di base) viene spostata in avanti per liberare spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-944">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 <span data-ttu-id="81dc4-945">L'evento può essere generato in qualsiasi momento in cui la sequenza di record decide che è necessario liberare spazio, per una qualsiasi ragione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-945">The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</span></span> <span data-ttu-id="81dc4-946">Ad esempio, il motore dei criteri CLFS può decidere di generare l'evento quando determina che le code di due client di log che condividono lo stesso file di log sono troppo distanti.</span><span class="sxs-lookup"><span data-stu-id="81dc4-946">For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</span></span> <span data-ttu-id="81dc4-947">Il recupero dello spazio può essere effettuato scrivendo aree di riavvio o troncando il log e utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> per il recupero dello spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-947">Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space.</span></span> <span data-ttu-id="81dc4-948">Il codice riportato nella sezione relativa agli esempi illustra la seconda possibilità.</span><span class="sxs-lookup"><span data-stu-id="81dc4-948">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="81dc4-949">È inoltre possibile chiamare il metodo <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> all'esterno dell'evento <xref:System.IO.Log.LogRecordSequence.TailPinned> per recuperare spazio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-949">You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free space.</span></span> <span data-ttu-id="81dc4-950">Un'area di riavvio è simile a un checkpoint in altri sistemi di elaborazione di log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-950">A restart area is similar to a checkpoint in other log processing systems.</span></span> <span data-ttu-id="81dc4-951">La chiamata di questo metodo indica che l'applicazione considera tutti i record precedenti prima dell'area di riavvio come completi e utilizzabili per successive aggiunte di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-951">Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</span></span> <span data-ttu-id="81dc4-952">Analogamente agli altri record, per poter funzionare, il record scritto da questo metodo richiede spazio disponibile effettivo nel log.</span><span class="sxs-lookup"><span data-stu-id="81dc4-952">Similar to any other records, the record written by this method requires actual free space in the log to function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81dc4-953">In questo esempio viene illustrato come utilizzare l'evento <xref:System.IO.Log.LogRecordSequence.TailPinned>:</span><span class="sxs-lookup"><span data-stu-id="81dc4-953">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.TailPinned> event.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81dc4-954">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-954">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-955">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-955">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-956">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-956">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-957">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-957">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-958">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-958">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-959">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-959">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-960">Segmento di matrice che verrà concatenato e aggiunto come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-960">An array segment that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="81dc4-961">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-961">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="81dc4-962">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-962">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-963">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-963">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-964">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-964">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-965">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-965">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-966">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-966">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-967">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-967">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-968">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-968">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-969">I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-969">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-970">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-970">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-971">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-971">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-972">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-972">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-973">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-973">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-974">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-974">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-975">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-975">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-976">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-976">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-977">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-977">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-978">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-978">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="81dc4-979">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-979">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="81dc4-980">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-980">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-981">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-981">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-982">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-982">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-983">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-983">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-984">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-984">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-985">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-985">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-986">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-986">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-987">I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-987">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-988">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-988">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-989">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-989">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-990">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-990">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-991">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-991">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-992">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-992">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-993">Uno o più argomenti sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-993">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-994">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-994">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-995">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-995">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-996">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-996">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-997">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-997">The new base sequence number.</span></span> <span data-ttu-id="81dc4-998">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-998">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="81dc4-999">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> e aggiorna il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-999">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="81dc4-1000">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1000">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-1001">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1001">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-1002">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1002">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1003">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1003">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-1004">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1004">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1005">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1005">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-1006">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1006">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-1007">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1007">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-1008">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1008">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="81dc4-1009">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1009">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-1010">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1010">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-1011">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1011">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-1012">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1012">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-1013">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1013">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-1014">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1014">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-1015">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1015">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-1016">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1016">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-1017">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1017">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-1018">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1018">The new base sequence number.</span></span> <span data-ttu-id="81dc4-1019">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1019">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="81dc4-1020">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> e aggiorna il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1020">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="81dc4-1021">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1021">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-1022">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1022">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-1023">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1023">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1024">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1024">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-1025">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1025">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1026">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1026">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-1027">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1027">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-1028">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1028">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-1029">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1029">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="81dc4-1030">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1030">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-1031">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1031">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-1032">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1032">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-1033">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1033">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-1034">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1034">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-1035">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1035">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-1036">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1036">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-1037">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1037">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-1038">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1038">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-1039">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1039">The new base sequence number.</span></span> <span data-ttu-id="81dc4-1040">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1040">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservations"><span data-ttu-id="81dc4-1041">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1041">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="81dc4-1042">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1042">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="81dc4-1043">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1043">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-1044">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1044">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-1045">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1045">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1046">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1046">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-1047">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1047">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1048">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1048">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-1049">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1049">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-1050">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1050">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-1051">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1051">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="81dc4-1052">Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1052">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="81dc4-1053">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1053">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-1054">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1054">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-1055">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1055">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-1056">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1056">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-1057">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1057">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="81dc4-1058">Uno o più argomenti non sono validi.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1058">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-1059">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1059">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-1060">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1060">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-1061">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1061">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="81dc4-1062">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1062">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="81dc4-1063">Nuovo numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1063">The new base sequence number.</span></span> <span data-ttu-id="81dc4-1064">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1064">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="81dc4-1065">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1065">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="81dc4-1066">Scrive un'area di riavvio in <see cref="T:System.IO.Log.LogRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1066">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="81dc4-1067">Questo metodo non può essere ereditato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1067">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="81dc4-1068">Numero di sequenza dell'area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1068">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81dc4-1069">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1069">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1070">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1070">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="81dc4-1071">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1071">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="81dc4-1072">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1072">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="81dc4-1073">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1073">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="81dc4-1074">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1074">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="81dc4-1075">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1075">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="81dc4-1076">Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1076">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="81dc4-1077">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1077">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="81dc4-1078">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1078">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="81dc4-1079">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1079">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="81dc4-1080">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1080">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="81dc4-1081">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1081">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="81dc4-1082"><paramref name="newBaseSeqNum" /> non è valido per questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1082"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
 <span data-ttu-id="81dc4-1083">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-1083">-or-</span></span>  
  
 <span data-ttu-id="81dc4-1084">Il numero della sequenza di avvio dell'enumerazione del log specificato non è valido.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1084">The specified log enumeration start sequence number is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-1085">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-1085">-or-</span></span>  
  
 <span data-ttu-id="81dc4-1086">Non è possibile aggiungere <paramref name="data" /> perché le dimensioni superano le dimensioni massime dei record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1086"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
 <span data-ttu-id="81dc4-1087">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-1087">-or-</span></span>  
  
 <span data-ttu-id="81dc4-1088"><paramref name="reservationCollection" /> non è stato creato da questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1088"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="81dc4-1089">Uno o più parametri sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1089">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="81dc4-1090">Una coda o base di archivio nuova o esistente del log attivo non è valida.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1090">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
 <span data-ttu-id="81dc4-1091">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-1091">-or-</span></span>  
  
 <span data-ttu-id="81dc4-1092"><paramref name="newBaseSeqNum" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1092"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="81dc4-1093">Impossibile eseguire la richiesta a causa di un'eccezione I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1093">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
 <span data-ttu-id="81dc4-1094">oppure</span><span class="sxs-lookup"><span data-stu-id="81dc4-1094">-or-</span></span>  
  
 <span data-ttu-id="81dc4-1095">Impossibile eseguire la richiesta a causa di un errore del dispositivo di I/O.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1095">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="81dc4-1096">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1096">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="81dc4-1097">Memoria insufficiente per continuare l'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1097">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="81dc4-1098">L'accesso per la sequenza dei log specificata viene negato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1098">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="81dc4-1099">Sequenza di record piena.</span><span class="sxs-lookup"><span data-stu-id="81dc4-1099">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>