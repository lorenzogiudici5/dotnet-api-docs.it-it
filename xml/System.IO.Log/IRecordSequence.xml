<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="55071e6e771f10cc96e2985b37bd85ac9623b58a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="f8565-101">Fornisce un'interfaccia generica per una sequenza di record.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f8565-101">Provides a generic interface to a sequence of records.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-102">L'interfaccia <xref:System.IO.Log.IRecordSequence> fornisce un'interfaccia astratta a un flusso orientato ai record.</span><span class="sxs-lookup"><span data-stu-id="f8565-102">The <xref:System.IO.Log.IRecordSequence> interface provides an abstract interface to a record-oriented stream.</span></span> <span data-ttu-id="f8565-103">Un'istanza <xref:System.IO.Log.IRecordSequence> può essere utilizzata per leggere e scrivere record del registro.</span><span class="sxs-lookup"><span data-stu-id="f8565-103">A <xref:System.IO.Log.IRecordSequence> instance can be used to read and write log records.</span></span>  
  
 <span data-ttu-id="f8565-104">L'interfaccia <xref:System.IO.Log.IRecordSequence> fornisce le funzionalità seguenti:</span><span class="sxs-lookup"><span data-stu-id="f8565-104">The <xref:System.IO.Log.IRecordSequence> interface provides the following capabilities,</span></span>  
  
-   <span data-ttu-id="f8565-105">Accodare record del registro utilizzando i metodi <xref:System.IO.Log.IRecordSequence.Append%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-105">Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.</span></span>  
  
-   <span data-ttu-id="f8565-106">Leggere i record accodati utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-106">Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
-   <span data-ttu-id="f8565-107">Scrivere un record di riavvio speciale utilizzando il metodo <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-107">Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
-   <span data-ttu-id="f8565-108">Leggere record di riavvio dal record di riavvio scritto più recentemente utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-108">Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
-   <span data-ttu-id="f8565-109">Scaricare i record dell'archivio durevole utilizzando il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-109">Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
-   <span data-ttu-id="f8565-110">Riservare spazio per l'accodamento di record.</span><span class="sxs-lookup"><span data-stu-id="f8565-110">Reserve space for appending records.</span></span>  
  
-   <span data-ttu-id="f8565-111">Liberare spazio anticipando la base del log.</span><span class="sxs-lookup"><span data-stu-id="f8565-111">Free log space by advancing the base of the log.</span></span>  
  
-   <span data-ttu-id="f8565-112">Ricevere notifiche di evento <xref:System.IO.Log.IRecordSequence.TailPinned> per spostare la base del log e liberare spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-112">Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.</span></span>  
  
 <span data-ttu-id="f8565-113">I record del registro vengono accodati a un'istanza <xref:System.IO.Log.IRecordSequence> e a ogni record viene assegnato un numero di sequenza univoco.</span><span class="sxs-lookup"><span data-stu-id="f8565-113">Log records are appended to a <xref:System.IO.Log.IRecordSequence> instance, and each log record is given a unique sequence number.</span></span> <span data-ttu-id="f8565-114">I numeri di sequenza sono a incremento progressivo costante all'interno di una determinata sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="f8565-114">Sequence numbers are strictly monotonically increasing within a given record sequence.</span></span> <span data-ttu-id="f8565-115">Un record del registro è costituito da dati opachi, forniti all'istanza <xref:System.IO.Log.IRecordSequence> in un'interfaccia <xref:System.Collections.IList> di ArraySegments di byte.</span><span class="sxs-lookup"><span data-stu-id="f8565-115">A log record consists of opaque data, supplied to the <xref:System.IO.Log.IRecordSequence> instance in an <xref:System.Collections.IList> of ArraySegments of bytes.</span></span>  
  
 <span data-ttu-id="f8565-116">L'interfaccia <xref:System.IO.Log.IRecordSequence> espone anche alcune proprietà di base che forniscono informazioni sui limiti del log.</span><span class="sxs-lookup"><span data-stu-id="f8565-116">The <xref:System.IO.Log.IRecordSequence> interface also exposes a few basic properties which provides information about log boundaries.</span></span>  
  
-   <span data-ttu-id="f8565-117">La proprietà <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contiene il numero di sequenza del primo record valido della sequenza.</span><span class="sxs-lookup"><span data-stu-id="f8565-117">The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.</span></span>  
  
-   <span data-ttu-id="f8565-118">La proprietà <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contiene un numero di sequenza più grande del numero di sequenza dell'ultimo record accodato.</span><span class="sxs-lookup"><span data-stu-id="f8565-118">The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span>  
  
-   <span data-ttu-id="f8565-119">La proprietà <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contiene il numero di sequenza dell'ultima area di riavvio scritta.</span><span class="sxs-lookup"><span data-stu-id="f8565-119">The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.</span></span>  
  
-   <span data-ttu-id="f8565-120">La proprietà <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contiene la dimensione del record più grande che può essere accodato alla sequenza o letto da quest'ultima.</span><span class="sxs-lookup"><span data-stu-id="f8565-120">The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.</span></span>  
  
-   <span data-ttu-id="f8565-121">La proprietà <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contiene la dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="f8565-121">The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.</span></span>  
  
-   <span data-ttu-id="f8565-122">Se la proprietà <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> è impostata su `true` e un'operazione <xref:System.IO.Log.IRecordSequence.Append%2A> non riesce per mancanza di spazio disponibile nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.</span><span class="sxs-lookup"><span data-stu-id="f8565-122">If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-123">Nuovo numero di sequenza di base della sequenza di record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-123">The new base sequence number of the record sequence.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-124">Sposta in avanti il numero di sequenza di base del log.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-124">Moves the base sequence number of the log forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-125">Quando si utilizza un'istanza <xref:System.IO.Log.LogRecordSequence> e si tenta di anticipare il numero di sequenza per liberare spazio nel log, affinché l'extent precedente venga contrassegnato come vuoto il nuovo numero di sequenza di base deve risiedere in un extent del log diverso.</span><span class="sxs-lookup"><span data-stu-id="f8565-125">When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.</span></span> <span data-ttu-id="f8565-126">Non è possibile liberare extent parzialmente.</span><span class="sxs-lookup"><span data-stu-id="f8565-126">Freeing extents partially is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-127">
            <paramref name="newBaseSequenceNumber" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-127">
              <paramref name="newBaseSequenceNumber" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f8565-128">
            <paramref name="newBaseSequenceNumber" /> non è attivo nel log.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-128">
              <paramref name="newBaseSequenceNumber" /> is not active in the log.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-129">Si è verificato un errore di I/O durante la modifica della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-129">An I/O error occurred while modifying the sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-130">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-130">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-131">Sequenza di record piena.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-131">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-132">Quando sottoposto a override in una classe derivata, scrive un record del registro nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-132">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-133">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-133">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-134">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-134">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-135">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-135">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-136">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-136">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-137">Quando sottoposto a override in una classe derivata, scrive un record del registro nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-137">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-138">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-138">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-139">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-139">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-140">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-140">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-141">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-141">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-142">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-142">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-143">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-143">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-144">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-144">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-145">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-145">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-146">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-146">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-147">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-147">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-148">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-148">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-149">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-149">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-150">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-150">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-151">Quando sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-151">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-152">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-152">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-153">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-153">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-154">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-154">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-155">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-155">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-156">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-156">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-157">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-157">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-158">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-158">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-159">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-159">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-160">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-160">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-161">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-161">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-162">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-162">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-163">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-163">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-164">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-164">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-165">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-165">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-166">Quando viene sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-166">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-167">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-167">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-168">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-168">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-169">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-169">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-170">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="f8565-170">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="f8565-171">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-171">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-172">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-172">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-173">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-173">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-174">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-174">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-175">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-175">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-176">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-176">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-177">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-177">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-178">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-178">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-179">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-179">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-180">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-180">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-181">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-181">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-182">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-182">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-183">Quando viene sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-183">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-184">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-184">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-185">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-185">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-186">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-186">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-187">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="f8565-187">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="f8565-188">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-188">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-189">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-189">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-190">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-190">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-191">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-191">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-192">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-192">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-193">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-193">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-194">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-194">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-195">Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza del primo record valido nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-195">When overridden in a derived class, gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-196">Numero di sequenza più basso corrispondente a un record valido nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-196">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-197">I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-197">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="f8565-198">Il valore di questa proprietà può essere modificato chiamando il metodo <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-198">The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-199">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-199">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-200">Quando sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-200">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-201">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-201">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-202">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-202">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-203">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-203">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-204">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-204">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-205">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-205">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-206">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-206">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-207">Quando sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-207">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-208">
            <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-208">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-209">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-209">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-210">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-210">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-211">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-211">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-212">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-212">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-213">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-213">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-214">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-214">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-215">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-215">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-216">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-216">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-217">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-217">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-218">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-218">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-219">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-219">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-220">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-220">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-221">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-221">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-222">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-222">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-223">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-223">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-224">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-224">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-225">Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-225">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-226">
            <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-226">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-227">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-227">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-228">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-228">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-229">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-229">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-230">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-230">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-231">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-231">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-232">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-232">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-233">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-233">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-234">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-234">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-235">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-235">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-236">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-236">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-237">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-237">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-238">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-238">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-239">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-239">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-240">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-240">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-241">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-241">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-242">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-242">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-243">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-243">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-244">Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-244">When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-245">
            <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-245">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-246">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-246">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-247">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-247">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-248">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-248">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-249">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-249">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-250">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="f8565-250">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="f8565-251">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-251">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-252">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-252">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-253">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-253">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-254">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-254">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-255">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-255">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-256">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-256">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-257">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-257">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-258">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-258">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-259">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-259">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousUndoRecord">
          <span data-ttu-id="f8565-260">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-260">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-261">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-261">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-262">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-262">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-263">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-263">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-264">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-264">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-265">Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-265">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-266">
            <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-266">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-267">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-267">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-268">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-268">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-269">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-269">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-270">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-270">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-271">Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="f8565-271">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="f8565-272">Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-272">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-273">In genere questo metodo viene completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-273">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="f8565-274">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-274">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-275">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-275">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-276">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-276">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-277">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-277">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-278">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-278">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="f8565-279">Numero di sequenza dell'ultimo record che deve essere scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-279">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="f8565-280">Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-280">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-281">Callback asincrono facoltativo, da chiamare quando lo scaricamento è stato completato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-281">An optional asynchronous callback, to be called when the flush is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-282">Oggetto fornito dall'utente che distingue questa specifica richiesta di scaricamento asincrono da altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-282">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-283">Quando viene sottoposto a override in una classe derivata, inizia un'operazione di scaricamento asincrono utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-283">When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-284">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di scaricamento asincrono che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-284">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-285">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita dal metodo corrente al metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A> per garantire che lo scaricamento venga completato e le risorse vengano liberate in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="f8565-285">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="f8565-286">Se si verifica un errore durante un'operazione di scaricamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A> non viene chiamato con il valore <xref:System.IAsyncResult> restituito da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-286">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-287">La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.IRecordSequence> siano scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="f8565-287">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="f8565-288">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-288">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-289">Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, comportano la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-289">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-290">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-290">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-291">Si è verificato un errore di I/O durante lo scaricamento dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-291">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-292">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-292">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-293">Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-293">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-294">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-294">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-295">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-295">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-296">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-296">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-297">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-297">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="f8565-298">raccolta di prenotazioni nella quale fare prenotazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-298">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-299">Prenotazioni da fare, in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-299">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-300">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-300">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-301">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-301">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-302">Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-302">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-303">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-303">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-304">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-304">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-305">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-305">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-306">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-306">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-307">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-307">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-308">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="f8565-308">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="f8565-309">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-309">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="f8565-310">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-310">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="f8565-311">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-311">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-312">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-312">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-313">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-313">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-314">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-314">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-315">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-315">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-316">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-316">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-317">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-317">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-318">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-318">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-319">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-319">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-320">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-320">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-321">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-321">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="f8565-322">raccolta di prenotazioni nella quale fare prenotazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-322">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-323">Prenotazioni da fare, in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-323">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-324">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-324">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-325">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-325">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-326">Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-326">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-327">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-327">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-328">È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="f8565-328">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-329">Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-329">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-330">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-330">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-331">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-331">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-332">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="f8565-332">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="f8565-333">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-333">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="f8565-334">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-334">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="f8565-335">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-335">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-336">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-336">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-337">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-337">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-338">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-338">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-339">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-339">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-340">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-340">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-341">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-341">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-342">Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di scrittura dell'area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-342">When overridden in a derived class, begins an asynchronous restart area write operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-343">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-343">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-344">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-344">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-345">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-345">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="f8565-346">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-346">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-347">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-347">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-348">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-348">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-349">Quando viene sottoposto a override in una classe derivata, inizia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-349">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-350">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-350">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-351">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="f8565-351">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-352">Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-352">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-353">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-353">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-354">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-354">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-355">Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-355">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-356">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-356">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="f8565-357">Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-357">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="f8565-358">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-358">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-359">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-359">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-360">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-360">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-361">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-361">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-362">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-362">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-363">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-363">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="f8565-364">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-364">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="f8565-365">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-365">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="f8565-366">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-366">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-367">Quando viene sottoposto a override in una classe derivata, inizia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-367">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-368">Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-368">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-369">È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="f8565-369">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="f8565-370">Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="f8565-370">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="f8565-371">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-371">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-372">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-372">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-373">Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-373">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-374">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-374">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="f8565-375">Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-375">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="f8565-376">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-376">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-377">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-377">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-378">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-378">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-379">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-379">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-380">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-380">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-381">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-381">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-382">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-382">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f8565-383">Quando è sottoposto a override in una classe derivata, crea un nuovo elemento <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-383">When overridden in a derived class, creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-384">Oggetto <see cref="T:System.IO.Log.ReservationCollection" /> appena creato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-384">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-385">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-385">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="f8565-386">Riferimento alla richiesta di I/O asincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-386">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-387">Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di accodamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-387">When overridden in a derived class, ends an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-388">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-388">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-389">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="f8565-389">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="f8565-390">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-390">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="f8565-391">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-391">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-392">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-392">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-393">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-393">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="f8565-394">Riferimento alla richiesta di I/O asincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-394">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-395">Quando sottoposto a override in una classe derivata, termina un'operazione di scaricamento asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-395">When overridden in a derived class, ends an asynchronous flush operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-396">Numero di sequenza dell'ultimo record scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-396">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-397">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="f8565-397">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="f8565-398">Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, risultano visibili quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-398">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="f8565-399">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-399">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-400">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-400">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-401">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-401">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="f8565-402">Riferimento alla richiesta di I/O asincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-402">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-403">Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di prenotazione e accodamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-403">When overridden in a derived class, ends an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-404">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-404">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-405">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="f8565-405">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="f8565-406">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-406">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="f8565-407">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-407">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-408">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-408">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-409">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-409">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="f8565-410">Riferimento alla richiesta di I/O asincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-410">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-411">Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di scrittura dell'area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-411">When overridden in a derived class, ends an asynchronous restart area write operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-412">Numero di sequenza del record del log scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-412">The sequence number of the written log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-413">Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.</span><span class="sxs-lookup"><span data-stu-id="f8565-413">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="f8565-414">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-414">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="f8565-415">Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-415">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-416">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-416">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-417">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-417">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-418">Quando sottoposto a override in una classe derivata, determina la scrittura dei record accodati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-418">When overridden in a derived class, causes appended records to be written.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f8565-419">Quando sottoposto a override in una classe derivata, verifica che tutti i record accodati siano stati scritti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-419">When overridden in a derived class, ensures that all appended records have been written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-420">Numero di sequenza dell'ultimo record scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-420">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-421">La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.IRecordSequence> siano stati scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="f8565-421">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-422">Si è verificato un errore di I/O durante lo scaricamento dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-422">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-423">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-423">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="f8565-424">Numero di sequenza dell'ultimo record che deve essere scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-424">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="f8565-425">Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-425">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-426">Quando sottoposto a override in una classe derivata, verifica che tutti i record accodati fino al record con il numero di sequenza incluso siano stati scritti in modo durevole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-426">When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-427">Numero di sequenza dell'ultimo record scritto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-427">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-428">La chiamata a questo metodo garantisce che tutti i record con numeri di sequenza fino al numero di sequenza specificato incluso siano stati scritti in modo durevole.</span><span class="sxs-lookup"><span data-stu-id="f8565-428">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-429">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-429">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-430">Si è verificato un errore di I/O durante lo scaricamento dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-430">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-431">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-431">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-432">Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza maggiore dell'ultimo record accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-432">When overridden in a derived class, gets the sequence number which is greater than the last record appended.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-433">Numero di sequenza maggiore dell'ultimo record accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-433">A sequence number which is greater than the last record appended.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-434">Questa proprietà  contiene un numero di sequenza maggiore del numero di sequenza dell'ultimo record accodato.</span><span class="sxs-lookup"><span data-stu-id="f8565-434">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="f8565-435">I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-435">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8565-436">Quando si utilizza un'istanza <xref:System.IO.Log.LogRecordSequence>, il valore <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> può non risultare aggiornato fino a quando i record non vengono scaricati nel log.</span><span class="sxs-lookup"><span data-stu-id="f8565-436">When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log.</span></span> <span data-ttu-id="f8565-437">Per ulteriori informazioni sullo scaricamento dei record, vedere <xref:System.IO.Log.IRecordSequence.Flush%2A> e <xref:System.IO.Log.RecordAppendOptions>.</span><span class="sxs-lookup"><span data-stu-id="f8565-437">See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-438">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-438">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-439">Quando sottoposto a override in una classe derivata, ottiene la dimensione, in byte, del record più grande che può essere accodato in questa sequenza o letto dalla stessa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-439">When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-440">Dimensione, in byte, del record più grande che può essere accodato alla sequenza o letto da quest'ultima.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-440">The size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-441">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-441">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="f8565-442">Numero di sequenza del primo record in cui viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-442">The sequence number of the first record where the reading starts.</span>
          </span>
        </param>
        <param name="logRecordEnum">
          <span data-ttu-id="f8565-443">Valore <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valido che specifica la direzione di lettura, ovvero in avanti o indietro, dei record da una classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-443">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-444">Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record inclusi nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-444">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-445">raccolta enumerabile di record inclusi nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-445">An enumerable collection of records in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-446">Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record inclusi nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="f8565-446">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="f8565-447">L'ordine dei record enumerati dipende dal valore del parametro `logRecordEnum`.</span><span class="sxs-lookup"><span data-stu-id="f8565-447">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f8565-448">Nell'esempio viene illustrato l'utilizzo del metodo <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-448">This sample demonstrates the use of the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-449">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-449">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-450">Si è verificato un errore di I/O durante la lettura del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-450">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-451">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-451">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f8565-452">Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile delle aree di riavvio incluse nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-452">When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-453">raccolta enumerabile delle aree di riavvio nella sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-453">An enumerable collection of the restart areas in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-454">Le aree di riavvio sono enumerate in ordine inverso, ovvero dal numero di sequenza più alto a quello più basso.</span><span class="sxs-lookup"><span data-stu-id="f8565-454">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="f8565-455">Vengono enumerate soltanto le aree di riavvio con numeri di sequenza compresi tra l'ultimo numero di sequenza e il numero di sequenza di base.</span><span class="sxs-lookup"><span data-stu-id="f8565-455">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8565-456">Se l'extent del log che contiene <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> è danneggiato, questo metodo può generare un'eccezione <xref:System.IO.IOException> con il messaggio di errore "Impossibile eseguire la richiesta a causa di un'eccezione di I/O imprevista.</span><span class="sxs-lookup"><span data-stu-id="f8565-456">If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message "The request could not be performed because of an unexpected I/O exception.</span></span> <span data-ttu-id="f8565-457">È stato restituito il seguente codice di errore: '80070026'".</span><span class="sxs-lookup"><span data-stu-id="f8565-457">The following error code was returned: '80070026'".</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-458">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-458">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-459">Si è verificato un errore di I/O durante la lettura del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-459">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-460">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-460">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-461">Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-461">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-462">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-462">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-463">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-463">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-464">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-464">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-465">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-465">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="f8565-466">Classe <see cref="T:System.IO.Log.ReservationCollection" /> che contiene la raccolta in cui effettuare prenotazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-466">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-467">Prenotazioni da fare, in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-467">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-468">Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-468">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-469">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-469">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-470">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-470">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-471">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-471">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-472">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="f8565-472">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="f8565-473">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-473">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="f8565-474">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-474">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="f8565-475">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-475">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-476">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-476">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-477">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-477">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-478">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-478">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-479">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-479">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-480">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-480">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="f8565-481">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-481">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="f8565-482">Numero di sequenza del record successivo nell'ordine Precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-482">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="f8565-483">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-483">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="f8565-484">raccolta di prenotazioni nella quale fare prenotazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-484">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="f8565-485">Prenotazioni da fare, in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-485">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-486">Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-486">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-487">Numero di sequenza del record di registro accodato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-487">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-488">I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-488">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-489">Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.</span><span class="sxs-lookup"><span data-stu-id="f8565-489">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="f8565-490">Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record.</span><span class="sxs-lookup"><span data-stu-id="f8565-490">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="f8565-491">Se l'accodamento non riesce, non verrà riservato alcuno spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-491">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="f8565-492">In genere questo metodo può essere completato prima che il record sia stato scritto.</span><span class="sxs-lookup"><span data-stu-id="f8565-492">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="f8565-493">Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-493">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-494">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-494">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-495">Si è verificato un errore di I/O durante l'accodamento del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-495">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-496">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-496">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-497">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-497">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-498">Quando viene sottoposto a override in una classe derivata, ottiene il numero totale di byte che sono stati prenotati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-498">When overridden in a derived class, gets the total number of bytes that have been reserved.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-499">Dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-499">The total size of all reservations made in this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-500">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-500">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-501">Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza dell'area di riavvio scritta più recentemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-501">When overridden in a derived class, gets the sequence number of the most recently written restart area.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-502">Numero di sequenza dell'area di riavvio scritta più recentemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-502">The sequence number of the most recently written restart area.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-503">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-503">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-504">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-504">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-505">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-505">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-506">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-506">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-507">Ottiene o imposta un valore che indica se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-507">Gets or sets a value indicating whether appends are automatically retried if the log is full.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f8565-508">
            <see langword="true" /> se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-508">
              <see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f8565-509">Il valore predefinito è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-509">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-510">Se il valore di questa proprietà è `true` e un'operazione <xref:System.IO.Log.IRecordSequence.Append%2A> non riesce per mancanza di spazio sufficiente nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.</span><span class="sxs-lookup"><span data-stu-id="f8565-510">If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-511">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-511">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-512">Si verifica quando la sequenza di record determina che la coda deve essere spostata in avanti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-512">Occurs when the record sequence determines that the tail must be moved forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-513">Questo evento può essere generato quando si verifica una condizione di spazio insufficiente nella sequenza di record.</span><span class="sxs-lookup"><span data-stu-id="f8565-513">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="f8565-514">Quando viene generato questo evento, la coda della sequenza (ovvero il numero di sequenza di base) viene spostata in avanti per liberare spazio.</span><span class="sxs-lookup"><span data-stu-id="f8565-514">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f8565-515">Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-515">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-516">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-516">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-517">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-517">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-518">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-518">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-519">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-519">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-520">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-520">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-521">Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-521">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-522">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-522">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-523">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-523">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-524">CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida.</span><span class="sxs-lookup"><span data-stu-id="f8565-524">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="f8565-525">Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-525">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-526">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-526">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="f8565-527">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-527">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-528">I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="f8565-528">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-529">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-529">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-530">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-530">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-531">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-531">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-532">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-532">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-533">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-533">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-534">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-534">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-535">Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-535">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-536">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-536">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-537">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-537">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-538">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-538">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-539">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-539">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-540">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-540">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-541">I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record.</span><span class="sxs-lookup"><span data-stu-id="f8565-541">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-542">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-542">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-543">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-543">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-544">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-544">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-545">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-545">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-546">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-546">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-547">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-547">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-548">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-548">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-549">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-549">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-550">Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> e aggiorna il numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-550">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-551">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-551">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-552">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-552">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-553">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-553">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-554">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-554">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-555">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-555">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-556">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-556">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-557">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-557">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="f8565-558">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-558">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-559">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-559">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-560">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-560">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-561">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-561">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-562">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-562">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-563">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-563">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-564">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-564">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-565">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-565">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-566">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-566">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-567">Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> e aggiorna il numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-567">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-568">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-568">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-569">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-569">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-570">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-570">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-571">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-571">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-572">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-572">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-573">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-573">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-574">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-574">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="f8565-575">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-575">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-576">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-576">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-577">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-577">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-578">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-578">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-579">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-579">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-580">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-580">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-581">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-581">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-582">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-582">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-583">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-583">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="f8565-584">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-584">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-585">Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-585">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-586">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-586">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-587">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-587">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-588">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-588">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-589">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-589">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-590">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-590">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-591">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-591">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-592">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-592">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="f8565-593">Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-593">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="f8565-594">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-594">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-595">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-595">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-596">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-596">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="f8565-597">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-597">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-598">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-598">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-599">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-599">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-600">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-600">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-601">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-601">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-602">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-602">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="f8565-603">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-603">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="f8565-604">Nuovo numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-604">The new base sequence number.</span>
          </span>
          <span data-ttu-id="f8565-605">Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-605">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="f8565-606">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-606">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f8565-607">Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-607">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f8565-608">Numero di sequenza dell'area di riavvio scritta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-608">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8565-609">Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client.</span><span class="sxs-lookup"><span data-stu-id="f8565-609">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="f8565-610">Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint.</span><span class="sxs-lookup"><span data-stu-id="f8565-610">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="f8565-611">Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.</span><span class="sxs-lookup"><span data-stu-id="f8565-611">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="f8565-612">È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-612">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="f8565-613">Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record.</span><span class="sxs-lookup"><span data-stu-id="f8565-613">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="f8565-614">Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.</span><span class="sxs-lookup"><span data-stu-id="f8565-614">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="f8565-615">Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-615">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="f8565-616">Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="f8565-616">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="f8565-617">Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato.</span><span class="sxs-lookup"><span data-stu-id="f8565-617">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="f8565-618">Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.</span><span class="sxs-lookup"><span data-stu-id="f8565-618">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="f8565-619">Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="f8565-619">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="f8565-620">Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8565-620">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f8565-621">Uno o più argomenti non sono validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-621">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f8565-622">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-622">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="f8565-623">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-623">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f8565-624">Il metodo è stato chiamato dopo l'eliminazione sequenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f8565-624">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>