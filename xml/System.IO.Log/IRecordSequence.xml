<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="55071e6e771f10cc96e2985b37bd85ac9623b58a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce un'interfaccia generica per una sequenza di record.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'interfaccia <xref:System.IO.Log.IRecordSequence> fornisce un'interfaccia astratta a un flusso orientato ai record. Un'istanza <xref:System.IO.Log.IRecordSequence> può essere utilizzata per leggere e scrivere record del registro.  
  
 L'interfaccia <xref:System.IO.Log.IRecordSequence> fornisce le funzionalità seguenti:  
  
-   Accodare record del registro utilizzando i metodi <xref:System.IO.Log.IRecordSequence.Append%2A>.  
  
-   Leggere i record accodati utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
-   Scrivere un record di riavvio speciale utilizzando il metodo <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
-   Leggere record di riavvio dal record di riavvio scritto più recentemente utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
-   Scaricare i record dell'archivio durevole utilizzando il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
-   Riservare spazio per l'accodamento di record.  
  
-   Liberare spazio anticipando la base del log.  
  
-   Ricevere notifiche di evento <xref:System.IO.Log.IRecordSequence.TailPinned> per spostare la base del log e liberare spazio.  
  
 I record del registro vengono accodati a un'istanza <xref:System.IO.Log.IRecordSequence> e a ogni record viene assegnato un numero di sequenza univoco. I numeri di sequenza sono a incremento progressivo costante all'interno di una determinata sequenza di record. Un record del registro è costituito da dati opachi, forniti all'istanza <xref:System.IO.Log.IRecordSequence> in un'interfaccia <xref:System.Collections.IList> di ArraySegments di byte.  
  
 L'interfaccia <xref:System.IO.Log.IRecordSequence> espone anche alcune proprietà di base che forniscono informazioni sui limiti del log.  
  
-   La proprietà <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contiene il numero di sequenza del primo record valido della sequenza.  
  
-   La proprietà <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contiene un numero di sequenza più grande del numero di sequenza dell'ultimo record accodato.  
  
-   La proprietà <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contiene il numero di sequenza dell'ultima area di riavvio scritta.  
  
-   La proprietà <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contiene la dimensione del record più grande che può essere accodato alla sequenza o letto da quest'ultima.  
  
-   La proprietà <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contiene la dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.  
  
-   Se la proprietà <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> è impostata su `true` e un'operazione <xref:System.IO.Log.IRecordSequence.Append%2A> non riesce per mancanza di spazio disponibile nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base della sequenza di record.</param>
        <summary>Sposta in avanti il numero di sequenza di base del log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza un'istanza <xref:System.IO.Log.LogRecordSequence> e si tenta di anticipare il numero di sequenza per liberare spazio nel log, affinché l'extent precedente venga contrassegnato come vuoto il nuovo numero di sequenza di base deve risiedere in un extent del log diverso. Non è possibile liberare extent parzialmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSequenceNumber" /> non è attivo nel log.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la modifica della sequenza.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, scrive un record del registro nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un record del registro nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <summary>Quando sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, accoda un record del registro all'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza del primo record valido nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> corrente.</summary>
        <value>Numero di sequenza più basso corrispondente a un record valido nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 Il valore di questa proprietà può essere modificato chiamando il metodo <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousUndoRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservations">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questo record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, avvia un'operazione di accodamento asincrona utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di accodamento asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Il record accodato utilizzerà spazio precedentemente riservato, utilizzando una prenotazione specificata dal parametro `reservations`. Se l'accodamento riesce, utilizzerà la più piccola area della prenotazione che può contenere i dati e quell'area sarà rimossa dalla raccolta.  
  
 In genere questo metodo viene completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numero di sequenza dell'ultimo record che deve essere scritto. Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando lo scaricamento è stato completato.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di scaricamento asincrono da altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, inizia un'operazione di scaricamento asincrono utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione di scaricamento asincrono che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita dal metodo corrente al metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A> per garantire che lo scaricamento venga completato e le risorse vengano liberate in modo appropriato. Se si verifica un errore durante un'operazione di scaricamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A> non viene chiamato con il valore <xref:System.IAsyncResult> restituito da questo metodo.  
  
 La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.IRecordSequence> siano scritti in modo durevole.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, comportano la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante lo scaricamento dei dati.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando l'accodamento è completo.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di accodamento asincrona dalle altre richieste.</param>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di prenotazione e accodamento.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta questa operazione di cancellazione asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'oggetto della classe <xref:System.IAsyncResult> restituito da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> per garantire che l'operazione di accodamento sia stata completata e che sia possibile liberare appropriatamente le risorse. Se si è verificato un errore durante un accodamento asincrono, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, avvia un'operazione asincrona di scrittura dell'area di riavvio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservation">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, inizia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato. Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservation">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la scrittura dell'area di riavvio è stata completata.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta asincrona di scrittura dell'area di riavvio da altre richieste.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, inizia un'operazione asincrona di scrittura dell'area di riavvio utilizzando spazio precedentemente riservato nella sequenza.</summary>
        <returns>Interfaccia <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona di scrittura dell'area di riavvio che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario passare l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo al metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> per garantire che l'operazione di scrittura dell'area di riavvio sia stata completata e che sia possibile liberare risorse in modo appropriato. Se si è verificato un errore durante un'operazione asincrona di scrittura dell'area di riavvio, non viene generata alcuna eccezione fino a quando il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> non viene chiamato con l'interfaccia <xref:System.IAsyncResult> restituita da questo metodo.  
  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Quando l'operazione viene completata senza che si verifichino errori, il numero di sequenza di base viene aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se viene specificato una raccolta <xref:System.IO.Log.ReservationCollection>, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, crea un nuovo elemento <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Oggetto <see cref="T:System.IO.Log.ReservationCollection" /> appena creato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di accodamento.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndAppend%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Quando sottoposto a override in una classe derivata, termina un'operazione di scaricamento asincrono.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scaricamento asincrono, ad esempio un errore del disco durante una richiesta di I/O, risultano visibili quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di prenotazione e accodamento.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Quando sottoposto a override in una classe derivata, termina un'operazione asincrona di scrittura dell'area di riavvio.</summary>
        <returns>Numero di sequenza del record del log scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta di I/O, diventano evidenti quando si chiama il metodo <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 Questo metodo deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> restituito dal metodo <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, determina la scrittura dei record accodati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, verifica che tutti i record accodati siano stati scritti.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a questo metodo garantisce che tutti i record accodati all'interfaccia <xref:System.IO.Log.IRecordSequence> siano stati scritti in modo durevole.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante lo scaricamento dei dati.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numero di sequenza dell'ultimo record che deve essere scritto. Se <see cref="T:System.IO.Log.SequenceNumber" /> non è valido, devono essere scritti tutti i record.</param>
        <summary>Quando sottoposto a override in una classe derivata, verifica che tutti i record accodati fino al record con il numero di sequenza incluso siano stati scritti in modo durevole.</summary>
        <returns>Numero di sequenza dell'ultimo record scritto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a questo metodo garantisce che tutti i record con numeri di sequenza fino al numero di sequenza specificato incluso siano stati scritti in modo durevole.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante lo scaricamento dei dati.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza maggiore dell'ultimo record accodato.</summary>
        <value>Numero di sequenza maggiore dell'ultimo record accodato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà  contiene un numero di sequenza maggiore del numero di sequenza dell'ultimo record accodato. I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Quando si utilizza un'istanza <xref:System.IO.Log.LogRecordSequence>, il valore <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> può non risultare aggiornato fino a quando i record non vengono scaricati nel log. Per ulteriori informazioni sullo scaricamento dei record, vedere <xref:System.IO.Log.IRecordSequence.Flush%2A> e <xref:System.IO.Log.RecordAppendOptions>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene la dimensione, in byte, del record più grande che può essere accodato in questa sequenza o letto dalla stessa.</summary>
        <value>Dimensione, in byte, del record più grande che può essere accodato alla sequenza o letto da quest'ultima.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numero di sequenza del primo record in cui viene avviata la lettura.</param>
        <param name="logRecordEnum">Valore <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valido che specifica la direzione di lettura, ovvero in avanti o indietro, dei record da una classe <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record inclusi nella sequenza.</summary>
        <returns>raccolta enumerabile di record inclusi nella sequenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile di record inclusi nella sequenza. L'ordine dei record enumerati dipende dal valore del parametro `logRecordEnum`.  
  
   
  
## Examples  
 Nell'esempio viene illustrato l'utilizzo del metodo <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la lettura del record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, restituisce una raccolta enumerabile delle aree di riavvio incluse nella sequenza.</summary>
        <returns>raccolta enumerabile delle aree di riavvio nella sequenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le aree di riavvio sono enumerate in ordine inverso, ovvero dal numero di sequenza più alto a quello più basso. Vengono enumerate soltanto le aree di riavvio con numeri di sequenza compresi tra l'ultimo numero di sequenza e il numero di sequenza di base.  
  
> [!NOTE]
>  Se l'extent del log che contiene <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> è danneggiato, questo metodo può generare un'eccezione <xref:System.IO.IOException> con il messaggio di errore "Impossibile eseguire la richiesta a causa di un'eccezione di I/O imprevista. È stato restituito il seguente codice di errore: '80070026'".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la lettura del record.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">Classe <see cref="T:System.IO.Log.ReservationCollection" /> che contiene la raccolta in cui effettuare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <summary>Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="nextUndoRecord">Numero di sequenza del record successivo nell'ordine specificato dall'utente.</param>
        <param name="previousRecord">Numero di sequenza del record successivo nell'ordine Precedente.</param>
        <param name="recordAppendOptions">Valore valido di <see cref="T:System.IO.Log.RecordAppendOptions" /> che specifica la modalità da utilizzare per la scrittura dei dati.</param>
        <param name="reservationCollection">raccolta di prenotazioni nella quale fare prenotazioni.</param>
        <param name="reservations">Prenotazioni da fare, in byte.</param>
        <summary>Quando sottoposto a override in una classe derivata, crea automaticamente una sola prenotazione e quindi accoda un record alla sequenza.</summary>
        <returns>Numero di sequenza del record di registro accodato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati contenuti nel parametro `data` verranno concatenati in una matrice a byte singolo per essere quindi accodati come record. Tuttavia, non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letto il record.  
  
 Le prenotazioni specificate vengono aggiunte alla raccolta di prenotazioni fornita mediante un'operazione atomica con un'operazione di accodamento record. Se l'accodamento non riesce, non verrà riservato alcuno spazio.  
  
 In genere questo metodo può essere completato prima che il record sia stato scritto. Per garantire che un record è stato scritto, specificare il flag <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizzando il parametro `recordAppendOptions` oppure chiamare il metodo <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'accodamento del record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere il nuovo record, o fare la prenotazione.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando viene sottoposto a override in una classe derivata, ottiene il numero totale di byte che sono stati prenotati.</summary>
        <value>Dimensione totale di tutte le prenotazioni effettuate in questa sequenza di record.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza dell'area di riavvio scritta più recentemente.</summary>
        <value>Numero di sequenza dell'area di riavvio scritta più recentemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno.</summary>
        <value>
          <see langword="true" /> se le operazioni di accodamento vengono ripetute automaticamente nel caso in cui il log sia pieno. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di questa proprietà è `true` e un'operazione <xref:System.IO.Log.IRecordSequence.Append%2A> non riesce per mancanza di spazio sufficiente nella sequenza, la sequenza di record tenterà di liberare spazio ed eseguirà nuovamente l'operazione di accodamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la sequenza di record determina che la coda deve essere spostata in avanti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento può essere generato quando si verifica una condizione di spazio insufficiente nella sequenza di record. Quando viene generato questo evento, la coda della sequenza (ovvero il numero di sequenza di base) viene spostata in avanti per liberare spazio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. CLFS (Common Log File System) gestisce due aree di riavvio per garantire che sia sempre disponibile almeno un'area valida. Quando è necessario un ripristino, CLFS legge la propria area di riavvio e tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino.  
  
 È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 I dati contenuti nei segmenti della matrice di byte verranno concatenati in un'unica matrice di byte per l'accodamento del record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> e aggiorna il numero di sequenza di base.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> e aggiorna il numero di sequenza di base.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservation">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <summary>Quando sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Elenco di segmenti della matrice di byte che verranno concatenati e accodati come record.</param>
        <param name="newBaseSequenceNumber">Nuovo numero di sequenza di base. Il numero di sequenza specificato deve essere maggiore o uguale al numero di sequenza di base corrente.</param>
        <param name="reservation">Classe <see cref="T:System.IO.Log.ReservationCollection" /> contenente la prenotazione da utilizzare per questa area di riavvio.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, scrive un'area di riavvio nell'interfaccia <see cref="T:System.IO.Log.IRecordSequence" /> utilizzando una prenotazione e aggiorna il numero di sequenza di base.</summary>
        <returns>Numero di sequenza dell'area di riavvio scritta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'area di riavvio è utilizzata per archiviare temporaneamente informazioni che contengono l'ultima operazione di checkpoint di un client. Quando è necessario un ripristino è possibile analizzare l'area di riavvio per recuperare tutti i dati a partire dall'ultima operazione di checkpoint. Questi dati inizializzano la tabella transazione, la tabella delle pagine dirty e la tabella del file aperto così da utilizzarle nel processo di ripristino. È possibile leggere un'area di riavvio utilizzando il metodo <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Quando viene scritta un'area di riavvio, i dati contenuti nei segmenti della matrice di byte vengono concatenati in una matrice a singolo byte, che quindi può essere accodati come record. Non esiste alcun provisioning per suddividere dati in segmenti della matrice una volta letta l'area di riavvio.  
  
 Se viene specificata una prenotazione, l'area di riavvio scritta utilizzerà spazio precedentemente riservato utilizzando una prenotazione contenuta nella raccolta. Se ha esito positivo, il metodo utilizzerà la prenotazione più piccola che possa contenere i dati e tale prenotazione verrà rimossa dalla raccolta.  
  
 Al termine dell'esecuzione di questo metodo, se non si sono verificati errori, il numero di sequenza di base è stato aggiornato. Tutti i record del registro con numeri di sequenza inferiori al nuovo numero di base sono inaccessibili.  
  
 Se una sequenza di record è stata eliminata o se si passa un argomento non valido, le eccezioni vengono immediatamente generate all'interno di questa operazione. Gli errori che si verificano durante una richiesta di accodamento asincrona, ad esempio un errore del disco durante una richiesta di I/O, comporteranno la generazione di eccezioni quando viene chiamato il metodo <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la scrittura dell’area di riavvio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La sequenza di record non ha potuto fare abbastanza spazio per contenere la nuova area di riavvio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
  </Members>
</Type>