<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="37759113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un archivio organizzato in log.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.Log.LogRecordSequence> fornisce un'implementazione dell'interfaccia della sequenza di record all'inizio di un log Common Log File System (CLFS). Questa classe viene utilizzata insieme alla classe <xref:System.IO.Log.LogStore> che fornisce un'interfaccia per la modifica e la gestione diretta di un file di log CLFS. Un archivio di log fornisce un'archiviazione a solo accodamento in un set di extent del disco. La classe <xref:System.IO.Log.LogStore> rappresenta quest'archiviazione e fornisce metodi per l'aggiunta e la rimozione di contenitori, per l'impostazione di criteri e per la creazione di archivi. Non fornisce metodi per la lettura e la scrittura nell'archivio. Questi metodi vengono forniti dalla classe <xref:System.IO.Log.LogRecordSequence>.  
  
 La relazione tra la classe <xref:System.IO.Log.LogStore> e la classe <xref:System.IO.Log.LogRecordSequence> è simile alla relazione tra un file del disco e un oggetto <xref:System.IO.FileStream>. Il file del disco fornisce l'archivio effettiva e dispone di attributi quali la lunghezza e l'ora dell'ultimo accesso, mentre l'oggetto <xref:System.IO.FileStream> fornisce una visualizzazione del file che può essere utilizzata per operazioni di lettura o scrittura su di esso. Analogamente, la classe <xref:System.IO.Log.LogStore> dispone di attributi quali i criteri e una raccolta di extent del disco e la classe <xref:System.IO.Log.LogRecordSequence> fornisce un meccanismo orientato ai record per la lettura e la scrittura di dati.  
  
 Diversamente dalla sequenza di record di file rappresentata dalla classe <xref:System.IO.Log.FileRecordSequence>, un'istanza <xref:System.IO.Log.LogStore> memorizza i relativi dati in una raccolta di extent del disco, rappresentati da istanze <xref:System.IO.Log.LogExtent>. Gli extent di una determinata istanza <xref:System.IO.Log.LogStore> sono tutti della stessa dimensione e lo spazio viene aggiunto e rimosso da un'istanza <xref:System.IO.Log.LogStore> per incrementi di extent. Per aggiungere e rimuovere extent del log, utilizzare i metodi <xref:System.IO.Log.LogExtentCollection.Add%2A> e <xref:System.IO.Log.LogExtentCollection.Remove%2A> dell'oggetto <xref:System.IO.Log.LogExtentCollection> che può essere restituito dalla proprietà <xref:System.IO.Log.LogStore.Extents%2A>.  
  
 A un'istanza <xref:System.IO.Log.LogStore> possono essere associati criteri. Questi criteri sono rappresentati da istanze <xref:System.IO.Log.LogPolicy> che possono essere restituite dalla proprietà <xref:System.IO.Log.LogStore.Policy%2A>. I criteri specificano le regole che il log tenterà di seguire, ad esempio il numero massimo di extent e la dimensione minima, nonché le istruzioni sull'aumento o la riduzione dell'istanza <xref:System.IO.Log.LogStore> in determinate condizioni. In inoltre possibile specificare se un'istanza <xref:System.IO.Log.LogStore> può essere archiviata. I criteri vengono impostati per ogni singolo log e sono volatili. Ciò significa che, dopo la chiusura dell'ultimo handle del log, i criteri non esistono più.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come memorizzare un <xref:System.IO.Log.LogStore> in un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file di log incapsulato nell'oggetto <see cref="T:System.IO.Log.LogStore" /> corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" /> per l'handle specificato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Impossibile associare l'handle di registro al pool di thread.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" /> con il percorso e la modalità specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo costruttore per aprire un archivio dei log con il percorso e la modalità specificati. L'archivio viene aperto con accesso in lettura/scrittura e condivide l'accesso in lettura.  
  
 Il parametro `path` deve attenersi alla sintassi seguente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 dove `<physical log name>` è un percorso valido relativo a un file di log e `<log client name>` è un identificatore univoco di client. Un archivio dei registri deve essere un archivio dei registri fisico o un archivio dei registri virtuale, ma non entrambi. Una volta creato fisicamente o virtualmente un archivio dei registri , rimarrà tale per tutta la sua durata. Un archivio dei registri fisico viene creato specificando solo il nome del registro fisico. Un archivio dei registri virtuale viene creato specificando il nome del registro fisico e il nome del client di registrazione.  
  
 I client che presentano lo stesso nome di registro fisico condividono la stessa raccolta di extent e gli stessi criteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
oppure 
 <paramref name="path" /> contiene solo spazi vuoti.  
  
oppure 
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La classe <see cref="T:System.IO.Log.LogStore" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o in alternativa utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" /> con il percorso, la modalità e l'accesso specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo costruttore per aprire un archivio di log con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso in lettura.  
  
 Il parametro `path` deve attenersi alla sintassi seguente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 dove `<physical log name>` è un percorso valido relativo a un file di log e `<log client name>` è un identificatore univoco di client. Un archivio dei registri deve essere un archivio dei registri fisico o un archivio dei registri virtuale, ma non entrambi. Una volta creato fisicamente o virtualmente un archivio dei registri , rimarrà tale per tutta la sua durata. Un archivio dei registri fisico viene creato specificando solo il nome del registro fisico. Un archivio dei registri virtuale viene creato specificando il nome del registro fisico e il nome del client di registrazione.  
  
 I client che presentano lo stesso nome di registro fisico condividono la stessa raccolta di extent e gli stessi criteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
oppure 
 <paramref name="path" /> contiene solo spazi vuoti.  
  
oppure 
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.  
  
-oppure– 
 <paramref name="access" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La classe <see cref="T:System.IO.Log.LogStore" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o in alternativa utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <param name="share">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso specificato.  
  
 Il parametro `path` deve attenersi alla sintassi seguente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 dove `<physical log name>` è un percorso valido relativo a un file di log e `<log client name>` è un identificatore univoco di client. Un archivio dei registri deve essere un archivio dei registri fisico o un archivio dei registri virtuale, ma non entrambi. Una volta creato fisicamente o virtualmente un archivio dei registri , rimarrà tale per tutta la sua durata. Un archivio dei registri fisico viene creato specificando solo il nome del registro fisico. Un archivio dei registri virtuale viene creato specificando il nome del registro fisico e il nome del client di registrazione.  
  
 I client che presentano lo stesso nome di registro fisico condividono la stessa raccolta di extent e gli stessi criteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
oppure 
 <paramref name="path" /> contiene solo spazi vuoti.  
  
oppure 
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.  
  
-oppure– 
 <paramref name="access" /> contiene un valore non valido.  
  
oppure 
 <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La classe <see cref="T:System.IO.Log.LogStore" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o in alternativa utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da aprire.</param>
        <param name="mode">Uno dei valori <see cref="T:System.IO.FileMode" /> che determina come aprire o creare l'archivio.</param>
        <param name="access">Uno dei valori <see cref="T:System.IO.FileAccess" /> che determina la modalità con cui la classe <see cref="T:System.IO.Log.LogStore" /> può accedere al file.</param>
        <param name="share">Uno dei valori di <see cref="T:System.IO.FileShare" /> che determina come verrà condiviso tra i processi l'archivio dei log.</param>
        <param name="fileSecurity">Uno dei valori <see cref="T:System.Security.AccessControl.FileSecurity" /> che specificano la sicurezza da impostare sull'archivio appena creato se l'archivio deve essere protetto.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un nuovo oggetto <xref:System.IO.Log.LogStore> che viene aperto con il percorso, la modalità e l'accesso specificati. L'archivio viene aperto condividendo l'accesso specificato. Il parametro `path` deve attenersi alla sintassi seguente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 dove `<physical log name>` è un percorso valido relativo a un file di log e `<log client name>` è un identificatore univoco di client. Un archivio dei registri deve essere un archivio dei registri fisico o un archivio dei registri virtuale, ma non entrambi. Una volta creato fisicamente o virtualmente un archivio dei registri , rimarrà tale per tutta la sua durata. Un archivio dei registri fisico viene creato specificando solo il nome del registro fisico. Un archivio dei registri virtuale viene creato specificando il nome del registro fisico e il nome del client di registrazione.  
  
 I client che presentano lo stesso nome di registro fisico condividono la stessa raccolta di extent e gli stessi criteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome del file dell'archivio dei log specificato da <paramref name="path" />non è valido.  
  
oppure 
 <paramref name="Mode" /> è <see langword="CreateNew" /> e non può quindi essere utilizzato senza accesso in scrittura.  
  
oppure 
 <paramref name="Mode" /> è <see langword="OpenOrCreate" /> e non può quindi essere utilizzato senza accesso in scrittura.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.  
  
-oppure– 
 <paramref name="access" /> contiene un valore non valido.  
  
oppure 
 <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.  
  
Non è possibile accedere al file specificato da <paramref name="path" /> poiché il file è attualmente utilizzato da un altro processo.  
  
oppure 
Non è possibile creare il file specificato da <paramref name="path" /> perché il file o la directory esiste già.  
  
oppure 
Impossibile associare l'handle di registro al pool di thread.  
  
oppure 
Il formato del file di log o la versione specificata non è valida.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La classe <see cref="T:System.IO.Log.LogStore" /> non può essere utilizzata perché il componente necessario Common Log File System (CLFS) non è installato. Installare il componente CLFS se è disponibile per la piattaforma o in alternativa utilizzare la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questa istanza <see cref="T:System.IO.Log.LogStore" /> può essere archiviata.</summary>
        <value>
          <see langword="true" /> se l'istanza <see cref="T:System.IO.Log.LogStore" /> può essere archiviata, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un'istanza <xref:System.IO.Log.LogStore> non è archiviabile, le chiamate ai metodi <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> e <xref:System.IO.Log.LogStore.SetArchiveTail%2A> causano la generazione di un'eccezione <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di sequenza più basso che corrisponde a un record valido in questa istanza <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>Numero di sequenza più basso che corrisponde a un record valido in questa istanza <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea uno snapshot dello stato dell'archivio dei log necessario per eseguire un backup.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea uno snapshot dello stato dell'archivio dei log per eseguire un backup.</summary>
        <returns>Oggetto <see cref="T:System.IO.Log.LogArchiveSnapshot" /> che contiene lo stato necessario per creare un archivio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come memorizzare un <xref:System.IO.Log.LogStore> in un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'archivio dei registri non è archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.ArgumentException">Un argomento non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">È stata eseguita un’operazione non valida.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Numero di sequenza iniziale nell'intervallo da archiviare.</param>
        <param name="last">Numero di sequenza finale nell'intervallo da archiviare.</param>
        <summary>Crea uno snapshot dello stato dell'archivio dei log tra i numeri di sequenza specificati per l'esecuzione di un backup.</summary>
        <returns>Oggetto <see cref="T:System.IO.Log.LogArchiveSnapshot" /> che contiene lo stato necessario per creare un archivio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo snapshot dell'archivio restituito da questo metodo include informazioni dal numero di sequenza di base o dal numero di sequenza dell'archivio, in base a quale dei due valori risulta inferiore, all'ultimo numero di sequenza. Non include l'ultimo numero di sequenza, che significa che l'archivio include soltanto i record fino all'ultimo escluso. Inoltre, quando si utilizza questo metodo, perché l'archivio sia coerente è necessario che il valore SequenceNumber iniziale sia uguale al valore BaseSequenceNumber.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" /> o <paramref name="last" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> è maggiore di <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">È stata eseguita un’operazione non valida.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.NotSupportedException">L'archivio dei registri non è archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto del file base dell'archivio dei log da rimuovere.</param>
        <summary>Rimuove l'archivio dei log.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").  
  
oppure 
 <paramref name="path" /> contiene solo spazi vuoti.  
  
oppure 
 <paramref name="path" /> contiene uno o più caratteri non validi.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante l’apertura dell’archivio dei registri.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo <xref:System.IO.Log.LogStore.Dispose%2A> dopo aver finito di utilizzare <xref:System.IO.Log.LogStore>. Il metodo <xref:System.IO.Log.LogStore.Dispose%2A> lascia l'oggetto <xref:System.IO.Log.LogStore> in una condizione di inutilizzabilità. Dopo la chiamata a <xref:System.IO.Log.LogStore.Dispose%2A>, è necessario rilasciare tutti i riferimenti a <xref:System.IO.Log.LogStore> affinché la memoria occupata da <xref:System.IO.Log.LogStore> possa essere recuperata dal Garbage Collector.  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.IO.Log.LogStore.Dispose%2A> prima di rilasciare l'ultimo riferimento a <xref:System.IO.Log.LogStore>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.IO.Log.LogStore> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di extent del log che contengono i dati per questo archivio dei log.</summary>
        <value>Istanza <see cref="T:System.IO.Log.LogExtentCollection" /> contenente la raccolta di extent del log che incapsula dati per questo archivio di log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza di <xref:System.IO.Log.LogStore> memorizza i relativi dati in una raccolta di extent del disco, rappresentati da istanze <xref:System.IO.Log.LogExtent>. Gli extent di una determinata istanza <xref:System.IO.Log.LogStore> sono tutti della stessa dimensione e lo spazio viene aggiunto e rimosso da un'istanza <xref:System.IO.Log.LogStore> per incrementi di extent. Per aggiungere e rimuovere extent del log, utilizzare i metodi <xref:System.IO.Log.LogExtentCollection.Add%2A> and <xref:System.IO.Log.LogExtentCollection.Remove%2A> dell'oggetto <xref:System.IO.Log.LogExtentCollection> che viene restituito da questa proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte disponibili nell'archivio dei log.</summary>
        <value>Numero di byte disponibili nell'archivio dei log.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle di file del sistema operativo per il file di log incapsulato nell'istanza <see cref="T:System.IO.Log.LogStore" /> corrente.</summary>
        <value>Handle di file del sistema operativo per il file di log incapsulato nell'istanza <see cref="T:System.IO.Log.LogStore" /> corrente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, ottiene il numero di sequenza del record successivo da accodare all'archivio dei log.</summary>
        <value>Il numero di sequenza del record successivo da accodare all'archivio dei log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I numeri di sequenza validi sono quelli maggiori o uguali a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> e quelli minori di <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la dimensione, in byte, dell'archivio dei log.</summary>
        <value>Dimensione, in byte, dell'archivio dei log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dimensione dell'archivio dei log è la somma delle dimensioni degli extent di log.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">È stato eseguito l'accesso alla proprietà dopo l'eliminazione della sequenza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i criteri associati a questo archivio dei log.</summary>
        <value>Istanza <see cref="T:System.IO.Log.LogPolicy" /> che rappresenta i criteri associati a questo archivio dei log.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare l'istanza <xref:System.IO.Log.LogPolicy> restituita da questa proprietà per esaminare e utilizzare i criteri di log associato all'istanza <xref:System.IO.Log.LogStore> corrente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Numero di sequenza della coda di archiviazione.</param>
        <summary>Imposta il numero di sequenza della coda di archiviazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di sequenza di base inferiore e la coda di archiviazione determinano la coda del log.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come memorizzare un <xref:System.IO.Log.LogStore> in un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" /> non è valido per questa sequenza.</exception>
        <exception cref="T:System.InvalidOperationException">È stata eseguita un’operazione non valida.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.NotSupportedException">L'archivio dei registri non è archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione di un programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di flussi di registrazione in questo archivio dei log.</summary>
        <value>Numero di flussi di registrazione in questo archivio dei log.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>