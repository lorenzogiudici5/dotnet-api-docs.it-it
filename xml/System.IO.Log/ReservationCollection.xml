<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80315a981ff347b7a3a3838866d59fe9768b1d59" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419265" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Gestisce la raccolta di prenotazioni dello spazio eseguite in una sequenza di record.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe rappresenta un set di aree di prenotazione create in una sequenza di record. L'aggiunta di elementi alla raccolta comporta l'allocazione di nuove prenotazioni. La rimozione di elementi dalla raccolta comporta la liberazione di tali prenotazioni.  
  
 Lo spazio viene riservato nel log dall'applicazione quando contiene dati che non possono essere scritti nel log immediatamente, ma che devono essere scritti in seguito. Le prenotazioni costituiscono la garanzia che i dati verranno scritti nel log quando saranno disponibili per questa operazione. In caso di utilizzo di log, per le applicazioni vengono spesso riservati uno o più record di log in un'area di marshalling. È necessario riservare i record prima di aggiungerli.  
  
 Le prenotazioni possono essere utilizzate a garanzia che un'operazione possa essere completata prima che venga eseguito il commit dei dati, in caso contrario viene eseguito il rollback delle modifiche. Possono inoltre essere utilizzate per registrare un'"azione di annullamento" nel log. Durante un'operazione di rollback è necessario che il gestore di risorse transazionale sia in grado di ripristinare il proprio stato se viene interrotto durante l'operazione di rollback. L'impiego di un'area di prenotazione consente al gestore di risorse di riservare spazio in un log prima che venga utilizzato.  
  
 Il metodo <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> è in grado di riservare spazio o aggiungere dati o di eseguire entrambe le operazioni, a seconda dei parametri specificati durante la chiamata. Man mano che una transazione viene elaborata, un'applicazione può aggiungere le informazioni di annullamento e riservare spazio per i record di compensazione. Durante un'operazione di rollback, i record di compensazione creati indicano ciò che è stato annullato sul disco. I record vengono aggiunti utilizzando lo spazio precedentemente riservato. Ciò garantisce che il gestore di risorse non esaurisca spazio di log, condizione irreversibile, durante l'esecuzione di un'operazione di rollback. Se un log si riempie durante una transazione, è possibile per l'applicazione eseguire senza problemi il rollback della transazione senza danneggiare dati durevoli.  
  
 CLFS è un sistema di registrazione conforme con ARIES, specifico per il log write-ahead. Con questo tipo di registrazione un'applicazione scrive un record di annullamento prima di eseguire l'operazione, prenotando la quantità di spazio del log necessaria per scrivere un record di compensazione, che può essere utilizzato durante il rollback. Lo spazio riservato verrà utilizzato in un secondo momento quando il record di compensazione verrà effettivamente scritto.  
  
 Le applicazioni possono prenotare o accedere allo spazio di registro in qualsiasi momento (si tratta di operazioni che si escludono a vicenda). Dopo la scrittura nel log di un record di commit, un'applicazione può liberare le prenotazioni per i record di compensazione. Questa azione può essere eseguita chiamando il metodo <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> o il metodo <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>. La chiamata al metodo <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> garantisce che l'operazione sia atomica, diversamente dalla chiamata al metodo <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>.  
  
 Quando si liberano record, è necessario liberare gli stessi record prenotati insieme in una chiamata precedente al metodo <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>.  
  
> [!NOTE]
>  L'implementazione di <xref:System.IO.Log.IRecordSequence> deve implementare i metodi <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> e <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> per eseguire le effettive operazioni di allocazione e deallocazione della prenotazione. L'implementazione, inoltre, deve chiamare <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> quando un record viene scritto in uno spazio riservato.  
  
   
  
## Examples  
 Le prenotazioni possono essere eseguite in due modalità come illustrato negli esempi riportati di seguito. È possibile adottare le pratiche negli esempi per un'elaborazione affidabile. Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione, in byte, della prenotazione richiesta.</param>
        <summary>Alloca una prenotazione e la aggiunge alla raccolta. Questo metodo non può essere ereditato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una prenotazione manualmente. Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> non è compreso tra i numeri di sequenza di base e finale di questa sequenza.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> non è valido o supera la dimensione massima della prenotazione.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le prenotazioni contenute nella raccolta. Questo metodo non può essere ereditato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> non è valido o supera la dimensione massima della prenotazione.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione da individuare nella raccolta.</param>
        <summary>Determina se una prenotazione della dimensione specificata è stata eseguita. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see langword="true" /> se è stata eseguita almeno una prenotazione della dimensione specificata, in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice di destinazione della copia.</param>
        <param name="arrayIndex">Indice in base zero nella matrice in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia l'intera raccolta in una matrice unidimensionale, a partire dall'indice specificato della matrice di destinazione. Questo metodo non può essere ereditato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> o <paramref name="arrayIndex" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero oppure maggiore o uguale alla lunghezza di <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Non c'è spazio sufficiente nella matrice specificata per copiare i dati.  
  
 oppure  
  
 <paramref name="array" /> non è una matrice unidimensionale, che è l'unico tipo supportato per l'azione richiesta.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di prenotazioni contenute nella raccolta.</summary>
        <value>Numero di prenotazioni contenute nella raccolta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente all'oggetto <see cref="T:System.IO.Log.ReservationCollection" /> di liberare risorse prima di essere eliminato dal Garbage Collector.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione della prenotazione da rilasciare.</param>
        <summary>Se sottoposto a override in una classe derivata, rilascia una prenotazione della dimensione specificata.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita da <see cref="T:System.IO.Log.ReservationCollection" />, è necessario implementare questo metodo per rilasciare effettivamente lo spazio nella sequenza di record. Non è necessario chiamare <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> quando questo metodo è completo: tale logica viene gestita automaticamente.  
  
 Quando si liberano record, è necessario liberare gli stessi record prenotati insieme in una chiamata precedente al metodo <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione della prenotazione che deve essere rispettata.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, ottiene la migliore prenotazione corrispondente per una data dimensione.</summary>
        <returns>Prenotazione contenuta nella raccolta, maggiore o uguale alla dimensione specificata oppure -1 se tale prenotazione non esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato in genere in caso di aggiunta di un record dallo spazio riservato a una sequenza di record. Quando viene restituito, una prenotazione della dimensione restituita è stata rimossa dalla raccolta. Se, per qualche ragione, non viene effettuato l'accesso allo spazio riservato, è opportuno chiamare il metodo <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> per avere la certezza che <xref:System.IO.Log.ReservationCollection> rappresenti con precisione la quantità di spazio riservato nella sequenza di record.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore in grado di scorrere l'oggetto <see cref="T:System.IO.Log.ReservationCollection" />. Questo metodo non può essere ereditato.</summary>
        <returns>Enumeratore in grado di scorrere l'oggetto <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'operazione non è valida per uno dei motivi seguenti:  
  
-   L'enumerazione è stata terminata.  
  
-   La raccolta è stata modificata.  
  
-   L'enumerazione non è stata avviata. È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la raccolta è di sola lettura.</summary>
        <value>Questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto <xref:System.IO.Log.ReservationCollection> non è mai di sola lettura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione della prenotazione da allocare.</param>
        <summary>Se sottoposto a override in una classe derivata, alloca una prenotazione della dimensione specificata.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita da <see cref="T:System.IO.Log.ReservationCollection" />, è necessario implementare questo metodo per allocare effettivamente lo spazio nella sequenza di record. Non è necessario chiamare <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> quando questo metodo è completo: tale logica viene gestita automaticamente.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">Dimensione della prenotazione da rilasciare.</param>
        <summary>Rilascia una prenotazione della dimensione specificata, se precedentemente creata. Questo metodo non può essere ereditato.</summary>
        <returns>
          <see langword="true" /> se una prenotazione della dimensione specificata è stata trovata e rimossa, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una prenotazione manualmente. Questa attività può essere eseguita solo se si utilizza la classe <xref:System.IO.Log.LogRecordSequence> basata su CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nella raccolta di prenotazioni specificata non è stata trovata nessuna prenotazione con dimensioni tali da corrispondere al record indicato.</exception>
        <exception cref="T:System.IO.IOException">Si verifica un errore di I/O durante la creazione dell’istantanea dell'archivio.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sequenza di record piena.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione della prenotazione rilasciata.</param>
        <summary>Se sottoposto a override in una classe derivata, indica che una prenotazione è stata rilasciata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si eredita da <xref:System.IO.Log.ReservationCollection>, è necessario chiamare questo metodo quando una prenotazione viene rilasciata per una ragione diversa dalla rimozione dalla raccolta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Dimensione della prenotazione creata.</param>
        <summary>Se sottoposto a override in una classe derivata, indica che una prenotazione è stata creata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si eredita da <xref:System.IO.Log.ReservationCollection>, è necessario chiamare questo metodo quando una prenotazione viene creata esternamente a una chiamata a <xref:System.IO.Log.ReservationCollection.Add%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore in grado di scorrere l'oggetto <see cref="T:System.IO.Log.ReservationCollection" />. Questo metodo non può essere ereditato.</summary>
        <returns>Enumeratore in grado di scorrere l'oggetto <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'operazione non è valida per uno dei motivi seguenti:  
  
-   L'enumerazione è stata terminata.  
  
-   La raccolta è stata modificata.  
  
-   L'enumerazione non è stata avviata. È necessario chiamare <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo è stato chiamato dopo l'eliminazione sequenza.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente per continuare l'esecuzione del programma.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso per l'archivio dei registri specificato viene negato dal sistema operativo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>