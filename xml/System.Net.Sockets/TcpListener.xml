<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="08844ec4200e956b530486778593461aeef6b051" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37476659" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Vengono attese le connessioni dai client di rete TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.TcpListener> classe fornisce metodi semplici per ascoltare e accettano le richieste di connessione in ingresso nella modalità di blocco sincrono. È possibile usare una <xref:System.Net.Sockets.TcpClient> o un <xref:System.Net.Sockets.Socket> per la connessione con un <xref:System.Net.Sockets.TcpListener>. Creare un <xref:System.Net.Sockets.TcpListener> usando un <xref:System.Net.IPEndPoint>, un indirizzo IP locale e il numero di porta o un numero di porta. Specificare <xref:System.Net.IPAddress.Any> per l'indirizzo IP locale e 0 per il numero di porta locale se si desidera che il provider di servizi sottostante a tali valori vengono assegnati automaticamente. Se si sceglie di eseguire questa operazione, è possibile usare il <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> proprietà per identificare le informazioni assegnate, dopo la connessione del socket.  
  
 Usare il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo per iniziare l'ascolto delle richieste di connessione in ingresso. <xref:System.Net.Sockets.TcpListener.Start%2A> verranno messi in coda le connessioni in ingresso fino a quando non si chiama il <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo oppure è inserita nella coda <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Usare uno <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> effettuare il pull di una connessione dalla coda di richieste di connessione in ingresso. Questi due metodi si bloccheranno. Se si desidera evitare il blocco, è possibile usare il <xref:System.Net.Sockets.TcpListener.Pending%2A> metodo per determinare se sono disponibili nella coda di richieste di connessione.  
  
 Chiamare il <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo per chiudere il <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo chiude le connessioni accettate. È responsabili della chiusura questi separatamente.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Vedere <xref:System.Net.Sockets.TcpClient> per un esempio di client.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">per stabilire una connessione in uscita o accettare una richiesta in ingresso.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Porta su cui attendere i tentativi di connessione in ingresso.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.TcpListener" /> che è in attesa sulla porta specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore è obsoleto. Usare la <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> o <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> costruttori.  
  
 Questo costruttore consente di specificare il numero di porta su cui rimanere in ascolto per i tentativi di connessione in ingresso. Con questo costruttore, il provider del servizio sottostante viene assegnato l'indirizzo di rete più appropriato. Se non si desidera che la porta locale viene usata, è possibile specificare 0 per il numero di porta. In questo caso, il provider del servizio assegnerà un numero di porte temporanee disponibili. Se si usa questo approccio, è possibile individuare quali numero di porta e indirizzo di rete locale è stato assegnato usando il <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> proprietà.  
  
 Chiamare il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo per iniziare l'ascolto di tentativi di connessione in ingresso.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Net.Sockets.TcpListener> utilizzando un numero di porta locale.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="port" /> non è compreso tra <see cref="F:System.Net.IPEndPoint.MinPort" /> e <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> che rappresenta l'endpoint locale a cui associare il <see cref="T:System.Net.Sockets.Socket" /> listener.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.TcpListener" /> con l'endpoint locale specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare l'indirizzo IP locale e tenta di numero di porta su cui rimanere in ascolto per la connessione in ingresso. Prima di utilizzare questo costruttore, è necessario creare un <xref:System.Net.IPEndPoint> utilizzando il numero porta e indirizzo IP locale desiderato. Passare questo <xref:System.Net.IPEndPoint> al costruttore come il `localEP` parametro.  
  
 Se non si desidera eseguire viene assegnato l'indirizzo locale, è possibile creare un <xref:System.Net.IPEndPoint> usando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> come parametro l'indirizzo e il servizio sottostante provider assegnerà l'indirizzo di rete più appropriato. In questo modo è possibile semplificare l'applicazione se si dispongono di più interfacce di rete. Se non si desidera che la porta locale viene usata, è possibile creare un <xref:System.Net.IPEndPoint> usando 0 per il numero di porta. In questo caso, il provider del servizio assegnerà un numero di porte temporanee disponibili. Se si usa questo approccio, è possibile individuare quali numero di porta e indirizzo di rete locale è stato assegnato usando il <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> proprietà.  
  
 Chiamare il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo per iniziare l'ascolto di tentativi di connessione in ingresso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'istanza del <xref:System.Net.Sockets.TcpListener> classe usando l'endpoint locale.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">
          <see cref="T:System.Net.IPAddress" /> che rappresenta l'indirizzo IP locale.</param>
        <param name="port">Porta su cui attendere i tentativi di connessione in ingresso.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.TcpListener" /> in attesa dei tentativi di connessione in ingrasso sull'indirizzo IP e sul numero di porta specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare l'indirizzo IP locale e tenta di numero di porta su cui rimanere in ascolto per la connessione in ingresso. Prima di chiamare questo costruttore è necessario creare innanzitutto un <xref:System.Net.IPAddress> usando l'indirizzo locale desiderato. Passare questo <xref:System.Net.IPAddress> al costruttore come il `localaddr` parametro. Se non si desidera eseguire viene assegnato l'indirizzo locale, specificare <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> per il `localaddr` parametro e il provider di servizi sottostante verrà assegnato l'indirizzo di rete più appropriato. In questo modo è possibile semplificare l'applicazione se si dispongono di più interfacce di rete. Se non si desidera che la porta locale viene usata, è possibile specificare 0 per il numero di porta. In questo caso, il provider del servizio assegnerà un numero di porta disponibile tra 1024 e 5000. Se si usa questo approccio, è possibile individuare quali numero di porta e indirizzo di rete locale è stato assegnato usando il <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> proprietà.  
  
 Chiamare il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo per iniziare l'ascolto di tentativi di connessione in ingresso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'istanza del <xref:System.Net.Sockets.TcpListener> classe utilizzando un numero di porta e indirizzo IP locale.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localaddr" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="port" /> non è compreso tra <see cref="F:System.Net.IPEndPoint.MinPort" /> e <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accetta una richiesta di connessione in sospeso.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.Socket" /> utilizzato per inviare e ricevere dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> un metodo di blocco che restituisce un <xref:System.Net.Sockets.Socket> che è possibile usare per inviare e ricevere dati. Se si desidera evitare il blocco, usare il <xref:System.Net.Sockets.TcpListener.Pending%2A> metodo per determinare se le richieste di connessione sono disponibili nella coda di connessioni in ingresso.  
  
 Il <xref:System.Net.Sockets.Socket> restituito viene inizializzato con il numero di porta e indirizzo IP dell'host remoto. È possibile usare uno qualsiasi dei <xref:System.Net.Sockets.Socket.Send%2A> e <xref:System.Net.Sockets.Socket.Receive%2A> metodi disponibili nel <xref:System.Net.Sockets.Socket> classi per comunicare con l'host remoto. Al termine usando il <xref:System.Net.Sockets.Socket>, assicurarsi di chiamare relativo <xref:System.Net.Sockets.Socket.Close%2A> (metodo). Se l'applicazione è relativamente semplice, è consigliabile usare la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo anziché la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo). <xref:System.Net.Sockets.TcpClient> offre semplici metodi per l'invio e ricezione di dati in una rete in modalità di blocco sincrono.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice seguente, il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> metodo viene utilizzato per restituire un <xref:System.Net.Sockets.Socket>. Ciò <xref:System.Net.Sockets.Socket> viene usato per comunicare con il client appena connesso.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il listener non è stato avviato con una chiamata a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accetta una richiesta di connessione in sospeso come operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task`1" />  Oggetto attività che rappresenta l'operazione asincrona. La proprietà <see cref="P:System.Threading.Tasks.Task`1.Result" /> nell'oggetto attività restituisce <see cref="T:System.Net.Sockets.Socket" /> utilizzato per inviare e ricevere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non verrà bloccata. L'oggetto restituito <xref:System.Threading.Tasks.Task%601> oggetto verrà completato dopo che la connessione socket è stata accettata.  
  
 Il <xref:System.Net.Sockets.Socket> restituiti in <xref:System.Threading.Tasks.Task%601> viene inizializzato con il numero di porta e indirizzo IP dell'host remoto. È possibile usare uno qualsiasi dei <xref:System.Net.Sockets.Socket.Send%2A> e <xref:System.Net.Sockets.Socket.Receive%2A> metodi disponibili nel <xref:System.Net.Sockets.Socket> classi per comunicare con l'host remoto. Al termine usando il <xref:System.Net.Sockets.Socket>, assicurarsi di chiamare relativo <xref:System.Net.Sockets.Socket.Close%2A> (metodo). Se l'applicazione è relativamente semplice, è consigliabile usare la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo anziché la <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> (metodo). <xref:System.Net.Sockets.TcpClient> offre semplici metodi per l'invio e ricezione di dati in una rete in modalità di blocco sincrono.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il listener non è stato avviato con una chiamata a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accetta una richiesta di connessione in sospeso.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.TcpClient" /> utilizzato per inviare e ricevere dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> un metodo di blocco che restituisce un <xref:System.Net.Sockets.TcpClient> che è possibile usare per inviare e ricevere dati. Usare il <xref:System.Net.Sockets.TcpListener.Pending%2A> metodo per determinare se le richieste di connessione sono disponibili nella coda di connessioni in ingresso, se si desidera evitare il blocco.  
  
 Usare la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> metodo per ottenere l'oggetto sottostante <xref:System.Net.Sockets.NetworkStream> dell'oggetto restituito <xref:System.Net.Sockets.TcpClient>. Il <xref:System.Net.Sockets.NetworkStream> fornirà i metodi per l'invio e ricezione con l'host remoto. Quando è tramite il <xref:System.Net.Sockets.TcpClient>, assicurarsi di chiamare relativo <xref:System.Net.Sockets.TcpClient.Close%2A> (metodo). Se si desidera maggiore flessibilità rispetto a un <xref:System.Net.Sockets.TcpClient> offerte, è consigliabile usare <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice seguente, il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo viene utilizzato per restituire un <xref:System.Net.Sockets.TcpClient>. Ciò <xref:System.Net.Sockets.TcpClient> viene usato per comunicare con il client appena connesso.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il listener non è stato avviato con una chiamata a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Per ottenere il codice di errore specificato, utilizzare la proprietà <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Una volta ottenuto il codice, è possibile trovare una descrizione dettagliata dell'errore nella documentazione relativa ai codici di errore dell'API di Windows Sockets versione 2 in MSDN.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accetta una richiesta di connessione in sospeso come operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task`1" />  Oggetto attività che rappresenta l'operazione asincrona. La proprietà <see cref="P:System.Threading.Tasks.Task`1.Result" /> nell'oggetto attività restituisce <see cref="T:System.Net.Sockets.TcpClient" /> utilizzato per inviare e ricevere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non verrà bloccata. L'oggetto restituito <xref:System.Threading.Tasks.Task%601> oggetto verrà completato dopo che è stata accettata la connessione TCP.  
  
 Usare la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> metodo per ottenere l'oggetto sottostante <xref:System.Net.Sockets.NetworkStream> del valore restituito <xref:System.Net.Sockets.TcpClient> nel <xref:System.Threading.Tasks.Task%601>. Il <xref:System.Net.Sockets.NetworkStream> fornirà i metodi per l'invio e ricezione con l'host remoto. Quando è tramite il <xref:System.Net.Sockets.TcpClient>, assicurarsi di chiamare relativo <xref:System.Net.Sockets.TcpClient.Close%2A> (metodo). Se si desidera maggiore flessibilità rispetto a un <xref:System.Net.Sockets.TcpClient> offerte, considerare l'uso <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il listener non è stato avviato con una chiamata a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Per ottenere il codice di errore specificato, utilizzare la proprietà <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Una volta ottenuto il codice, è possibile trovare una descrizione dettagliata dell'errore nella documentazione relativa ai codici di errore dell'API di Windows Sockets versione 2 in MSDN.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Net.Sockets.TcpListener" /> è attivamente in attesa di connessioni client.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Net.Sockets.TcpListener" /> è attivamente in attesa; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano da <xref:System.Net.Sockets.TcpListener> possibile usare questa proprietà per determinare se il <xref:System.Net.Sockets.Socket> è attualmente in ascolto per i tentativi di connessione in ingresso. Il <xref:System.Net.Sockets.TcpClient.Active%2A> proprietà può essere utilizzata per evitare la ridondanza <xref:System.Net.Sockets.TcpListener.Start%2A> tentativi.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Valore booleano che specifica se abilitare o disabilitare l'attraversamento NAT.</param>
        <summary>Abilita o disabilita l'attraversamento NAT (Network Address Translation) in un'istanza di <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> metodo viene utilizzato per abilitare o disabilitare l'attraversamento di NAT per un <xref:System.Net.Sockets.TcpListener> istanza. Attraversamento NAT può essere fornito tramite un tunnel ISATAP, 6to4 o Teredo.  
  
 Quando la `allowed` parametro è impostato su false, il <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opzione sul socket associato è impostata su <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Ciò disabilita in modo esplicito l'attraversamento di NAT per un <xref:System.Net.Sockets.TcpListener> istanza.  
  
 Quando la `allowed` parametro è true, il <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opzione sul socket associato è impostata su <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Questo può consentire l'attraversamento di NAT per una <xref:System.Net.Sockets.TcpListener> a seconda delle regole firewall attive sul sistema.  
  
 Il <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> metodo deve essere chiamato prima di chiamare il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo per iniziare l'ascolto delle richieste di connessione in ingresso (prima che venga associato al socket). Se <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> metodo viene chiamato dopo il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo, un oggetto <xref:System.InvalidOperationException> verrà generata.  
  
 Un indirizzo di Teredo è un indirizzo IPv6 con il prefisso del 2001,::/ / 32. Gli indirizzi Teredo possono essere restituiti attraverso normale risoluzione dei nomi DNS o enumerati come un indirizzo IPv6 assegnato a un'interfaccia locale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> è stato chiamato dopo avere chiamato il metodo <see cref="M:System.Net.Sockets.TcpListener.Start" /></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di accettazione. L'oggetto viene passato al delegato <c>callback</c> al completamento dell'operazione.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  È possibile chiamare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà utilizzata per ottenere il codice di errore specifico e fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN library all'indirizzo [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) per maggiori Descrizione dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> metodo per creare e connettere un socket. Il delegato di callback chiama il <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> metodo per terminare la richiesta asincrona.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di accettazione. L'oggetto viene passato al delegato <c>callback</c> al completamento dell'operazione.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà utilizzata per ottenere il codice di errore specifico e fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN library all'indirizzo [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) per maggiori Descrizione dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> metodo per creare e connettere un socket. Il delegato di callback chiama il <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> metodo per terminare la richiesta asincrona.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Porta su cui attendere i tentativi di connessione in ingresso.</param>
        <summary>Crea una nuova istanza di <see cref="T:System.Net.Sockets.TcpListener" /> in ascolto sulla porta specificata.</summary>
        <returns>Restituisce <see cref="T:System.Net.Sockets.TcpListener" />.  Nuova istanza di <see cref="T:System.Net.Sockets.TcpListener" /> in ascolto sulla porta specificata.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.Socket" />.  Oggetto <see cref="T:System.Net.Sockets.Socket" /> utilizzato per inviare e ricevere dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca fino a quando l'operazione è completata. Per eseguire questa operazione in modo sincrono, usare il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo).  
  
> [!NOTE]
>  È possibile chiamare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà utilizzata per ottenere il codice di errore specifico e fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN library all'indirizzo [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) per maggiori Descrizione dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> metodo per creare e connettere un socket. Il delegato di callback chiama il <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> metodo per terminare la richiesta asincrona.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Oggetto <see cref="T:System.Net.Sockets.Socket" /> sottostante è stato chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" /> è stato chiamato precedentemente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.TcpClient" /> per gestire la comunicazione con l'host remoto.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.TcpClient" />.  Oggetto <see cref="T:System.Net.Sockets.TcpClient" /> utilizzato per inviare e ricevere dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca fino a quando l'operazione è completata. Per eseguire questa operazione in modo sincrono, usare il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> (metodo).  
  
> [!NOTE]
>  È possibile chiamare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà del socket sottostante (<xref:System.Net.Sockets.TcpClient.Client%2A>) per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà utilizzata per ottenere il codice di errore specifico e fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN library all'indirizzo [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) per maggiori Descrizione dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> metodo per creare e connettere un socket. Il delegato di callback chiama il <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> metodo per terminare la richiesta asincrona.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.TcpListener" /> consente a un unico socket sottostante di restare in attesa di una porta specifica.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.TcpListener" /> consente a un solo <see cref="T:System.Net.Sockets.TcpListener" /> di restare in attesa di una porta specifica; in caso contrario, <see langword="false" />. . Il valore predefinito è <see langword="true" /> per Windows Server 2003 e Windows XP Service Pack 2 e versioni successive e <see langword="false" /> per tutte le altre versioni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, più listener può restare in ascolto su una porta specifica. Tuttavia, solo uno dei listener può eseguire operazioni sul traffico di rete inviati alla porta. Se più di un listener tenta di eseguire l'associazione a una porta specifica, quello con l'indirizzo IP più specifico gestisce il traffico di rete inviato a tale porta. È possibile usare il <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> proprietà per evitare che più listener in ascolto su una porta specifica.  
  
 Impostare questa proprietà prima di chiamare <xref:System.Net.Sockets.TcpListener.Start%2A>, o chiamare il <xref:System.Net.Sockets.TcpListener.Stop%2A> (metodo) e quindi impostare questa proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> proprietà.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il <see cref="T:System.Net.Sockets.TcpListener" /> è stato avviato. Chiamare il metodo <see cref="M:System.Net.Sockets.TcpListener.Stop" />, quindi impostare la proprietà <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket sottostante.</exception>
        <exception cref="T:System.ObjectDisposedException">Oggetto <see cref="T:System.Net.Sockets.Socket" /> sottostante è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Net.EndPoint" /> sottostante del <see cref="T:System.Net.Sockets.TcpListener" /> corrente.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> a cui è associato il <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> proprietà per identificare il numero di porta e interfaccia di rete locale viene usato per l'ascolto delle richieste di connessione client in ingresso, dopo che è stata stabilita una connessione socket. È necessario innanzitutto eseguire il cast ciò <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint>. È quindi possibile chiamare il <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> proprietà di cui recuperare l'indirizzo IP locale e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> proprietà per recuperare il numero di porta locale.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il numero di porta e indirizzo IP locale in cui il <xref:System.Net.Sockets.TcpListener> è in ascolto delle richieste di connessione in ingresso.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se sono presenti richieste di connessione in sospeso.</summary>
        <returns>
          <see langword="true" /> se vi sono connessioni in sospeso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non bloccante determina se sono presenti eventuali richieste di connessione in sospeso. Poiché il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> e <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodi bloccano l'esecuzione fino al <xref:System.Net.Sockets.TcpListener.Start%2A> metodo ha accodato una richiesta di connessione in ingresso, il <xref:System.Net.Sockets.TcpListener.Pending%2A> metodo può essere utilizzato per determinare se le connessioni sono disponibili prima di tentare di accettare le condizioni.  
  
   
  
## Examples  
 Nell'esempio di codice viene controllato il <xref:System.Net.Sockets.TcpListener.Pending%2A> (metodo). Se una richiesta di connessione è in attesa di essere accettata, quindi una chiamata al <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo è costituito.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il listener non è stato avviato con una chiamata a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Net.Sockets.Socket" /> di rete sottostante.</summary>
        <value>Oggetto <see cref="T:System.Net.Sockets.Socket" /> sottostante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> Crea un <xref:System.Net.Sockets.Socket> per l'ascolto delle richieste di connessione client in ingresso. Le classi che derivano da <xref:System.Net.Sockets.TcpListener> possibile usare questa proprietà per ottenere questo <xref:System.Net.Sockets.Socket>. Usare sottostante <xref:System.Net.Sockets.Socket> restituiti dai <xref:System.Net.Sockets.TcpListener.Server%2A> proprietà se richiedono accesso diverso da quello <xref:System.Net.Sockets.TcpListener> fornisce.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.TcpListener.Server%2A> proprietà restituisce solo il <xref:System.Net.Sockets.Socket> usato per l'ascolto delle richieste di connessione client in ingresso. Usare la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> metodo per accettare una richiesta di connessione in sospeso e ottenere un <xref:System.Net.Sockets.Socket> per l'invio e ricezione di dati. È anche possibile usare la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo per accettare una richiesta di connessione in sospeso e ottenere un <xref:System.Net.Sockets.TcpClient> per l'invio e ricezione di dati.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.TcpListener.Server%2A> proprietà. Sottostante <xref:System.Net.Sockets.Socket> viene recuperato e la <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> opzione è configurata per raggiungere il timeout dopo 10 secondi se i dati rimangono nel buffer di rete dopo la connessione viene chiusa.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia l'attesa delle richieste di connessione in ingresso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'attesa delle richieste di connessione in ingresso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo inizializza sottostante <xref:System.Net.Sockets.Socket>, lo associa a un endpoint locale e ascolta i tentativi di connessione in ingresso. Se viene ricevuta una richiesta di connessione, il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo Accoda la richiesta e continuerà ad attendere ulteriori richieste finché non si chiama il <xref:System.Net.Sockets.TcpListener.Stop%2A> (metodo). Se <xref:System.Net.Sockets.TcpListener> riceve una richiesta di connessione dopo che è già in coda il numero massimo di connessioni, verrà generata una <xref:System.Net.Sockets.SocketException> sul client.  
  
 Per rimuovere una connessione dalla coda di connessioni in ingresso, usare il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo o il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo). Il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo rimuove una connessione dalla coda e restituirà un <xref:System.Net.Sockets.TcpClient> che è possibile usare per inviare e ricevere dati. Il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> metodo restituirà un <xref:System.Net.Sockets.Socket> che è possibile usare per eseguire la stessa. Se l'applicazione richiede solo i/o sincrono, usare <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Per informazioni dettagliate di un controllo del funzionamento, usare <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Entrambi questi metodi consentono di bloccare fino a quando una richiesta di connessione è disponibile nella coda.  
  
 Usare la <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo per chiudere il <xref:System.Net.Sockets.TcpListener> e interrompere l'ascolto. Si è responsabili della chiusura delle connessioni accettate separatamente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra come <xref:System.Net.Sockets.TcpListener.Start%2A> viene utilizzata per l'ascolto per i tentativi di connessione client in ingresso.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Per ottenere il codice di errore specificato, utilizzare la proprietà <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Una volta ottenuto il codice, è possibile trovare una descrizione dettagliata dell'errore nella documentazione relativa ai codici di errore dell'API di Windows Sockets versione 2 in MSDN.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Lunghezza massima della coda delle connessioni in sospeso.</param>
        <summary>Avvia l'attesa delle richieste di connessione in ingresso specificando un numero massimo di possibili connessioni in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.TcpListener.Start%2A> metodo inizializza sottostante <xref:System.Net.Sockets.Socket>, lo associa a un endpoint locale e ascolta i tentativi di connessione in ingresso. Se viene ricevuta una richiesta di connessione, <xref:System.Net.Sockets.TcpListener.Start%2A> accoderà la richiesta e continuerà ad attendere ulteriori richieste finché non si chiama il <xref:System.Net.Sockets.TcpListener.Stop%2A> (metodo). Se <xref:System.Net.Sockets.TcpListener> riceve una richiesta di connessione dopo che è già in coda il numero massimo di connessioni, genererà una <xref:System.Net.Sockets.SocketException> sul client.  
  
 Per rimuovere una connessione dalla coda di connessioni in ingresso, usare il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo o il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo). Il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> metodo rimuove una connessione dalla coda e restituirà un <xref:System.Net.Sockets.TcpClient> che è possibile usare per inviare e ricevere dati. Il <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> metodo restituirà un <xref:System.Net.Sockets.Socket> che è possibile usare per eseguire la stessa. Se l'applicazione richiede solo i/o sincrono, usare il <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Per informazioni dettagliate di un controllo del funzionamento, usare <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> (metodo). Entrambi questi metodi consentono di bloccare fino a quando una richiesta di connessione è disponibile nella coda.  
  
 Usare la <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo per chiudere il <xref:System.Net.Sockets.TcpListener> e interrompere l'ascolto. Si è responsabili della chiusura delle connessioni accettate separatamente.  
  
> [!NOTE]
>  Usare la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico e fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN library all'indirizzo [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra come <xref:System.Net.Sockets.TcpListener.Start%2A> viene utilizzata per l'ascolto per i tentativi di connessione client in ingresso.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante l'accesso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="backlog" /> è minore di zero o supera il numero massimo di connessioni consentite.</exception>
        <exception cref="T:System.InvalidOperationException">Il <see cref="T:System.Net.Sockets.Socket" /> sottostante è null.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude il listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Chiude il listener. Le richieste di connessione non accettato nella coda andranno perse. Host remoti in attesa di una connessione di essere accettati genererà un <xref:System.Net.Sockets.SocketException>. Si è responsabili della chiusura delle connessioni accettate separatamente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Net.Sockets.TcpListener.Stop%2A> metodo per chiudere l'oggetto sottostante <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Per ottenere il codice di errore specificato, utilizzare la proprietà <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Una volta ottenuto il codice, è possibile trovare una descrizione dettagliata dell'errore nella documentazione relativa ai codici di errore dell'API di Windows Sockets versione 2 in MSDN.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="M:System.Net.Sockets.TcpListener.Stop" /> metodo chiude anche sottostante <see cref="T:System.Net.Sockets.Socket" />e crea un nuovo <see cref="T:System.Net.Sockets.Socket" /> per il <see cref="T:System.Net.Sockets.TcpListener" />. Se si impostano le proprietà sottostante <see cref="T:System.Net.Sockets.Socket" /> prima di chiamare il <see cref="M:System.Net.Sockets.TcpListener.Stop" /> metodo, tali proprietà non verranno trasferite al nuovo <see cref="T:System.Net.Sockets.Socket" />.</para>
        </block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>