<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="01fdce60bc7bce0ce178c52b0df4ff7ec0f7ffb1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39888284" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa l'interfaccia dei socket Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket> classe fornisce un set completo di metodi e proprietà per le comunicazioni di rete. Il <xref:System.Net.Sockets.Socket> classe consente di eseguire sia sincrona e trasferimento dei dati asincrono usando uno dei protocolli di comunicazione elencati nel <xref:System.Net.Sockets.ProtocolType> enumerazione.  
  
 Il <xref:System.Net.Sockets.Socket> classe segue il modello di denominazione di .NET Framework per i metodi asincroni. Ad esempio, sincroni <xref:System.Net.Sockets.Socket.Receive%2A> metodo corrisponde a asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> metodi.  
  
 Se l'applicazione richiede solo un thread durante l'esecuzione, usare i metodi seguenti, che sono progettati per la modalità operativa sincrona.  
  
-   Se si usa un protocollo orientato alla connessione quali TCP, il server può restare in ascolto per le connessioni usando la <xref:System.Net.Sockets.Socket.Listen%2A> (metodo). Il <xref:System.Net.Sockets.Socket.Accept%2A> metodo elabora qualsiasi connessione in ingresso richieste e restituisce un <xref:System.Net.Sockets.Socket> che è possibile usare per comunicare i dati con l'host remoto. Utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per chiamare il <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> (metodo). Chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo prima di chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo se si desidera specificare il numero di porta e indirizzo IP locale. Se si desidera che il provider di servizi sottostante per assegnare una porta disponibile per l'utente, usare un numero di porta pari a zero. Se si desidera connettersi a un host in attesa, chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Per comunicare i dati, chiamare il <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> (metodo).  
  
-   Se si usa un protocollo senza connessione, ad esempio UDP, non devi attendere le connessioni. Chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo per accettare i datagrammi in ingresso. Usare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo per inviare datagrammi in un host remoto.  
  
 Per elaborare le comunicazioni tramite un thread separato durante l'esecuzione, usare i metodi seguenti, che sono progettati per la modalità operativa asincrona.  
  
-   Se si usa un protocollo orientato alla connessione quali TCP, usare il <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, e <xref:System.Net.Sockets.Socket.EndConnect%2A> metodi per la connessione con un host in attesa. Usare la <xref:System.Net.Sockets.Socket.BeginSend%2A> e <xref:System.Net.Sockets.Socket.EndSend%2A> oppure <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> metodi per comunicare in modo asincrono i dati. Le richieste di connessione in ingresso possono essere elaborate tramite <xref:System.Net.Sockets.Socket.BeginAccept%2A> e <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Se si usa un protocollo senza connessione, ad esempio UDP, è possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.EndSendTo%2A> per inviare datagrammi, e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> e <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> per ricevere datagrammi.  
  
 Se si eseguono più operazioni asincrone in un socket, non necessariamente completano nell'ordine in cui sono state avviate.  
  
 Una volta completato l'invio e ricezione di dati, usare il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo per disabilitare il <xref:System.Net.Sockets.Socket>. Dopo avere chiamato <xref:System.Net.Sockets.Socket.Shutdown%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo per rilasciare tutte le risorse associate di <xref:System.Net.Sockets.Socket>.  
  
 Il <xref:System.Net.Sockets.Socket> classe consente di configurare la <xref:System.Net.Sockets.Socket> usando il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo). Recuperare le impostazioni utilizzando le <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (metodo).  
  
> [!NOTE]
>  Se si sta scrivendo un'applicazione relativamente semplice e non richiedono le massime prestazioni, è consigliabile usare <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, e <xref:System.Net.Sockets.UdpClient>. Queste classi forniscono un'interfaccia semplice e intuitiva per <xref:System.Net.Sockets.Socket> le comunicazioni.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come il <xref:System.Net.Sockets.Socket> classe può essere utilizzata per inviare dati a un server HTTP e ricevere la risposta. Questo esempio si blocca fino a quando non viene ricevuta l'intera pagina.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Per stabilire una connessione in uscita o accettare una richiesta in ingresso.</permission>
    <threadsafe>Le istanze di questa classe sono thread-safe.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Le informazioni sul socket restituite da <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando il valore specificato restituito da <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si chiama il <xref:System.Net.Sockets.Socket.%23ctor%2A> costruttore più volte con la stessa matrice di byte come argomento per ogni chiamata, si creerà più gestiti <xref:System.Net.Sockets.Socket>s con lo stesso socket sottostante. Questa pratica è fortemente sconsigliata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando il tipo di socket e il protocollo specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `socketType` parametro specifica il tipo del <xref:System.Net.Sockets.Socket> classe e il `protocolType` parametro specifica il protocollo usato dai <xref:System.Net.Sockets.Socket>. I due parametri non sono indipendenti. Spesso il <xref:System.Net.Sockets.Socket> tipo è implicita nel protocollo. Se la combinazione delle <xref:System.Net.Sockets.Socket> tipo e tipo di protocollo i risultati in un valore non valido <xref:System.Net.Sockets.Socket>, questo costruttore genera un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se questo costruttore genera un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Il risultato della combinazione di <paramref name="socketType" /> e <paramref name="protocolType" /> è un socket non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Uno dei valori di <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando la famiglia di indirizzi, il tipo di socket e il protocollo specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `addressFamily` parametro specifica lo schema di indirizzamento che il <xref:System.Net.Sockets.Socket> classe viene utilizzato, il `socketType` parametro specifica il tipo del <xref:System.Net.Sockets.Socket> (classe) e il `protocolType` parametro specifica il protocollo utilizzato dal <xref:System.Net.Sockets.Socket>. I tre parametri non sono indipendenti. Alcune famiglie di indirizzi di limitano il protocollo da usare con loro e spesso il <xref:System.Net.Sockets.Socket> tipo è implicita nel protocollo. Se la combinazione di famiglia di indirizzi <xref:System.Net.Sockets.Socket> , tipo e il protocollo digitare i risultati in un valore non valido <xref:System.Net.Sockets.Socket>, questo costruttore genera un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se questo costruttore genera un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un'istanza di <xref:System.Net.Sockets.Socket> classe.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Il risultato della combinazione di <paramref name="addressFamily" />, <paramref name="socketType" /> e <paramref name="protocolType" /> è un socket non valido.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per una nuova connessione.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> per una nuova connessione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> in modo sincrono estrae la prima richiesta di connessione in sospeso da coda di richieste di connessione del socket in ascolto e quindi crea e restituisce un nuovo <xref:System.Net.Sockets.Socket>. Non è possibile usare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare connessioni dalla coda di connessioni aggiuntive. Tuttavia, è possibile chiamare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metodo dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
 In modalità di blocco, <xref:System.Net.Sockets.Socket.Accept%2A> blocca finché non viene accodato un tentativo di connessione in ingresso. Una volta che viene accettata una connessione, originale <xref:System.Net.Sockets.Socket> continua connessione in ingresso di Accodamento messaggi fino a chiudere lo richiede.  
  
 Se si chiama questo metodo utilizza un non bloccante <xref:System.Net.Sockets.Socket>e nessuna connessione richieste vengono accodate, <xref:System.Net.Sockets.Socket.Accept%2A> genera un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Prima di chiamare il <xref:System.Net.Sockets.Socket.Accept%2A> metodo, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per ascoltare e accodare le richieste di connessione in ingresso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente accetta una semplice <xref:System.Net.Sockets.Socket> connessione.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">Il socket preposto ad accettare la connessione non è in attesa di connessioni. È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. L'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> nel parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo ha restituito il risultato, per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Possono usare protocolli orientati alla connessione di <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso. Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato. Prima di chiamare il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per ascoltare e accodare le richieste di connessione in ingresso.  
  
 Per ricevere una notifica del completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegato e associarlo al <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può facoltativamente specificare un oggetto esistente <xref:System.Net.Sockets.Socket> da usare per la connessione in ingresso specificando le <xref:System.Net.Sockets.Socket> da usare con il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà.  
  
 Se il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà è null, una nuova <xref:System.Net.Sockets.Socket> costruito con lo stesso <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, e <xref:System.Net.Sockets.Socket.ProtocolType%2A> corrente <xref:System.Net.Sockets.Socket> e impostare come il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà.  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Facoltativamente, può fornire un buffer in cui ricevere il blocco iniziale dei dati sul socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo. In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostata per il buffer che contiene i dati da ricevere e il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostata per il numero massimo di byte di dati da ricevere nel buffer. Queste proprietà possono essere impostate usando il <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> (metodo). Parte del buffer passato verrà utilizzate internamente per l'utilizzo dalla chiamata Winsock AcceptEx sottostante. Ciò significa che la quantità di dati restituiti sarà sempre inferiore al valore della <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> istanza fornita. La quantità di buffer utilizzato internamente varia in base alla famiglia di indirizzi del socket. Le dimensioni minime del buffer richieste sono 288 byte. Se viene specificata una dimensione del buffer più grande, il <xref:System.Net.Sockets.Socket> si aspetta di ricevere alcuni dati aggiuntivi diversi dai dati indirizzo ricevuti dalla chiamata Winsock AcceptEx e rimarrà in attesa fino alla ricezione di questi dati aggiuntivi. Se si verifica un timeout, la connessione viene reimpostata. Pertanto, se si prevede che i dati aggiuntivi di un importo specifico, quindi le dimensioni del buffer impostare per le dimensioni minime del buffer oltre questa quantità.  
  
 Il metodo di callback di completamento deve esaminare i <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operazione è stata completata.  
  
 Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento può verificarsi in alcuni casi quando nessuna connessione è stata accettata e causare il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> proprietà da impostare <xref:System.Net.Sockets.SocketError.ConnectionReset>. Questa situazione può verificarsi come risultato la scansione delle porte tramite un'analisi di tipo SYN semiaperto (un SYN -> SYN-ACK-> sequenza RST). Applicazioni che utilizzano il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodo deve essere preparato a gestire questa condizione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argomento non è valido. Questa eccezione si verifica se il buffer fornito non è abbastanza grande. Il buffer deve essere di almeno 2 * (sizeof(SOCKADDR_STORAGE + 16) byte.  
  
Questa eccezione si verifica anche se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un argomento non è compreso nell'intervallo. L'eccezione si verifica se l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> è minore di 0.</exception>
        <exception cref="T:System.InvalidOperationException">È stata richiesta un'operazione non valida. Questa eccezione si verifica se l'oggetto <see cref="T:System.Net.Sockets.Socket" /> preposto ad accettare la connessione non è in attesa di connessioni o se il socket accettato è associato.  
  
È necessario chiamare il metodo <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
Questa eccezione si verifica anche se il socket è già connesso o se un'operazione socket era già in corso utilizzando il parametro <paramref name="e" /> specificato.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la famiglia di indirizzi del <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno dei valori di <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.AddressFamily> specifica lo schema di indirizzamento che un'istanza del <xref:System.Net.Sockets.Socket> classe può utilizzare. Questa proprietà è di sola lettura e viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità dei dati ricevuti dalla rete e disponibili per essere letti.</summary>
        <value>Numero di byte di dati ricevuti dalla rete e disponibili per essere letti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un non bloccante <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> è un buon metodo per determinare se i dati vengono accodati per la lettura, prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. I dati disponibili sono che la quantità totale di dati in coda nel buffer di rete per la lettura. Se nessun dato viene accodato nel buffer di rete, <xref:System.Net.Sockets.Socket.Available%2A> restituisce 0.  
  
 Se l'host remoto viene arrestato o chiude la connessione <xref:System.Net.Sockets.Socket.Available%2A> può generare un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono confrontati i risultati della chiamata di IOControl FIONREAD e le proprietà disponibili.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Possono usare protocolli orientati alla connessione di <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso. Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato. Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per ascoltare e accodare le richieste di connessione in ingresso.  
  
 È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> dell'oggetto a <xref:System.Net.Sockets.Socket.BeginAccept%2A> attraverso il `state` parametro. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificati e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso. <xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> dell'oggetto che è possibile usare per inviare e ricevere i dati con l'host remoto. Non è possibile usare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare connessioni dalla coda di connessioni aggiuntive. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, usare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione.  
  
 Il sistema può anche usare il thread chiamante per richiamare il metodo di callback. In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostato per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene completato in modo sincrono.  
  
 Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
> [!NOTE]
>  È possibile usare la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, vedere la [codice di errore API Windows Sockets versione 2](/windows/desktop/winsock/windows-sockets-error-codes-2) documentazione per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente tenta di ricevere una connessione in ingresso in modo asincrono.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Il socket preposto ad accettare la connessione non è in attesa di connessioni. È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
oppure 
Il socket accettato è associato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> è minore di 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Numero di byte da accettare dal mittente.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso e riceve il primo blocco di dati inviato dall'applicazione client.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Possono usare protocolli orientati alla connessione di <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso. Accettare le connessioni in modo asincrono consente di inviare e ricevere dati all'interno di un thread di esecuzione separato. Questo overload consente di specificare il numero di byte da accettare il trasferimento iniziale nel `receiveSize` parametro.  
  
 Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per ascoltare e accodare le richieste di connessione in ingresso.  
  
 È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> dell'oggetto a <xref:System.Net.Sockets.Socket.BeginAccept%2A> attraverso il `state` parametro. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificati e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> che è possibile usare per inviare e ricevere i dati con l'host remoto. Non è possibile usare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare connessioni dalla coda di connessioni aggiuntive. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, usare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione.  
  
 Il sistema può anche usare il thread chiamante per richiamare il metodo di callback. In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostato per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene completato in modo sincrono.  
  
 Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>.  Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
> [!NOTE]
>  È possibile chiamare Usa la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> oggetto per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente consente di aprire un socket e accetta una connessione asincrona. In questo esempio, il socket accetta i primi 10 byte di dati. Il numero di byte ricevuti e i dati vengono visualizzati nella console per il delegato di callback. Vedere <xref:System.Net.Sockets.Socket.BeginReceive%2A> per una descrizione del modo in cui viene ricevuti i dati rimanenti.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Il socket preposto ad accettare la connessione non è in attesa di connessioni. È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
oppure 
Il socket accettato è associato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> è minore di 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Oggetto <see cref="T:System.Net.Sockets.Socket" /> accettato. Questo valore può essere <see langword="null" />.</param>
        <param name="receiveSize">Il numero massimo dei byte da ricevere.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso da un socket specificato e riceve il primo blocco di dati inviato dall'applicazione client.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona dell'oggetto <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Possono usare protocolli orientati alla connessione di <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso. Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato. Questo overload consente di specificare il socket accettato nel `acceptSocket` parametro. Se questo parametro è `null`, viene creato il socket accettato dal <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). È possibile specificare il numero di byte da accettare il trasferimento iniziale nel `receiveSize` parametro.  
  
 Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per ascoltare e accodare le richieste di connessione in ingresso.  
  
 È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> dell'oggetto a <xref:System.Net.Sockets.Socket.BeginAccept%2A> attraverso il `state` parametro. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificati e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> dell'oggetto che è possibile usare per inviare e ricevere i dati con l'host remoto. Non è possibile usare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare connessioni dalla coda di connessioni aggiuntive. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, usare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione.  
  
 Il sistema può anche usare il thread chiamante per richiamare il metodo di callback. In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostato per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene completato in modo sincrono.  
  
 Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
> [!NOTE]
>  È possibile usare la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> oggetto per identificare il numero porta e indirizzo di rete dell'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente consente di aprire un socket e accetta una connessione asincrona. In questo esempio, il socket accetta i primi 10 byte di dati e il `acceptSocket` parametro è `null`, che forza il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo per creare il socket accettato. Il numero di byte ricevuti e i dati vengono visualizzati nella console per il delegato di callback. Vedere <xref:System.Net.Sockets.Socket.BeginReceive%2A> per una descrizione del modo in cui viene ricevuti i dati rimanenti.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Il socket preposto ad accettare la connessione non è in attesa di connessioni. È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
oppure 
Il socket accettato è associato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> è minore di 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta l'host remoto.</param>
        <param name="end_point">
          <see cref="T:System.Net.EndPoint" /> che rappresenta l'host remoto.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo avvia una richiesta asincrona per una connessione di `remoteEP` parametro. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.BeginConnect%2A> stabilisce un host remoto predefinito. La connessione o impostando in modo asincrono l'host remoto predefinito offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo). Come minimo, è necessario passare il <xref:System.Net.Sockets.Socket> al <xref:System.Net.Sockets.Socket.BeginConnect%2A> attraverso il `state` parametro. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket>e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndConnect%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndConnect%2A> fino a quando non la <xref:System.Net.Sockets.Socket> si connette correttamente o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, usare <xref:System.Threading.WaitHandle.WaitOne%2A>. Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> per comunicare con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si vuole impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast `true`. Se non è possibile, <xref:System.Net.Sockets.Socket.BeginConnect%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si usa un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo nuovamente con l'endpoint desiderato.  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che non terminerà fino al completamento dell'operazione. Si tratta di una limitazione del provider sottostante.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente avvia un tentativo di connessione asincrona.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> dell'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <param name="requestCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="state">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione. Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto. L'host remoto viene specificato da un <see cref="T:System.Net.IPAddress" /> e da un numero di porta.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> (metodo). In genere, il metodo viene richiamato dal `requestCallback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno dei <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo o <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che non terminerà fino al completamento dell'operazione. Si tratta di una limitazione del provider sottostante. Anche il <xref:System.Net.EndPoint> vale a dire usata deve essere diverso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente avvia un tentativo di connessione asincrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è incluso nella famiglia di socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="address" /> è zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">Almeno un <see cref="T:System.Net.IPAddress" />, che specifica l'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <param name="requestCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="state">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione. Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto. L'host viene specificato da una matrice di <see cref="T:System.Net.IPAddress" /> e un numero di porta.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alle connessioni asincrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> (metodo). In genere, il metodo viene richiamato dal `requestCallback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo.  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che non terminerà fino al completamento dell'operazione. Si tratta di una limitazione del provider sottostante. Anche il <xref:System.Net.EndPoint> vale a dire usata deve essere diverso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente avvia un tentativo di connessione asincrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo è valido per i socket che utilizzano <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="address" /> è zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">Il nome dell'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <param name="requestCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'operazione di connessione.</param>
        <param name="state">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione. Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto. L'host viene specificato da un nome host e da un numero di porta.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> (metodo). In genere, il metodo viene richiamato dal `requestCallback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo.  
  
 Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, chiudere il <xref:System.Net.Sockets.Socket>. Quando la <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> viene chiamato il metodo.  Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che non terminerà fino al completamento dell'operazione. Si tratta di una limitazione del provider sottostante. Anche il <xref:System.Net.EndPoint> vale a dire usata deve essere diverso.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente avvia un tentativo di connessione asincrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> se il socket può essere riutilizzato una volta chiusa la connessione; in caso contrario, <see langword="false" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia una richiesta asincrona di disconnessione da un endpoint remoto.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, è possibile chiamare il <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodo per la richiesta di disconnessione da un endpoint remoto. Se `reuseSocket` è `true`, è possibile riutilizzare il socket.  
  
 Il <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodo utilizza un thread separato per richiamare il metodo di callback specificati. Il <xref:System.Net.Sockets.Socket.EndDisconnect%2A> metodo si blocca finché la disconnessione in sospeso è stata completata. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea un socket per la comunicazione asincrona e vengono inviati dati a un host remoto. Quando i dati sono stati inviati, <xref:System.Net.Sockets.Socket.Shutdown%2A> viene chiamato per arrestare l'invio e ricezione attività. Quindi <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> viene chiamato per avviare una richiesta di disconnessione. Al completamento della richiesta, il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà viene eseguita una query per verificare se il socket è disconnesso.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione. Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione. Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="offset">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione. Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente inizia a ricevere in modo asincrono i dati da un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="offset">Posizione in <c>buffer</c> per archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="flags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <param name="error">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</param>
        <param name="state">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione. Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> (metodo). In genere, il metodo viene richiamato dal `callback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="offset">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta l'origine dei dati.</param>
        <param name="remote_end">
          <see cref="T:System.Net.EndPoint" /> che rappresenta l'origine dei dati.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un dispositivo di rete specificato.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo inizia la lettura asincrona dei datagrammi senza connessione da un host remoto. La chiamata di <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo offre la possibilità di ricevere i dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> fino a quando non la <xref:System.Net.Sockets.Socket> legge i dati o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo, usare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Questo metodo legge i dati nel `buffer` parametro e le acquisizioni remoto ospitare endpoint da cui i dati vengono inviati. Per informazioni su come recuperare questo endpoint, fare riferimento a <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Questo metodo è particolarmente utile se si prevede di ricevere in modo asincrono senza connessione di datagrammi da un host sconosciuto o più host. In questi casi, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale. Se il datagramma ricevuto è maggiore della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo riempirà `buffer` con il maggior numero del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo non affidabile, i dati in eccesso andranno perse. Se si usa un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperarla chiamando il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo con un buffer di dimensione sufficienti.  
  
 Per garantire che l'endpoint dell'host remoto viene sempre restituito, un'applicazione deve essere associato in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale usando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo e quindi chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo con il `optionLevel` parametro impostato su <xref:System.Net.Sockets.SocketOptionLevel.IP>oppure <xref:System.Net.Sockets.SocketOptionLevel.IPv6> come appropriato, il `optionName` parametro impostato su <xref:System.Net.Sockets.SocketOptionName.PacketInformation>e il `optionValue` parametro per abilitare questa opzione prima di chiamare il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo). In caso contrario, è possibile che l'endpoint dell'host remoto non venga restituito quando il mittente ha inviato un numero di datagrammi prima che il destinatario ha chiamato la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo).  
  
 Sebbene <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile usare anche un protocollo orientato alla connessione. Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo oppure accettare una richiesta di connessione in ingresso chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo prima di stabilire o accettare una connessione, si otterrà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo). In entrambi i casi, il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e ricevere solo i dati da connesso o dell'host remoto predefinito.  
  
 Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leggerà quantità di dati è disponibile fino al numero di byte specificato da di `size` parametro.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente riceve in modo asincrono senza connessione di datagrammi da un host remoto.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="offset">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta l'origine dei dati.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Avvia la ricezione asincrona del numero di byte specificato in una posizione specificata del buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint e le informazioni sui pacchetti.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operazione di ricezione asincrona deve essere completata tramite la chiamata di <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> (metodo). In genere, il metodo viene richiamato dal `asyncCallback` delegare.  
  
 Questo metodo non blocca fino al completamento dell'operazione. Per bloccare fino al completamento dell'operazione, usare il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (metodo).  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Questo metodo legge i dati nel `buffer` parametro e le acquisizioni remoto ospitare endpoint da cui vengono inviati i dati, nonché informazioni sul pacchetto ricevuto. Per informazioni su come recuperare questo endpoint, fare riferimento a <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Questo metodo è particolarmente utile se si prevede di ricevere in modo asincrono senza connessione di datagrammi da un host sconosciuto o più host.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). <xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o una struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia il numero di byte richiesto o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, usare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (metodo). Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. È possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> è vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). <xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o una struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia il numero di byte richiesto o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, usare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (metodo). Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. È possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> è vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). <xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o una struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia il numero di byte richiesto o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, usare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (metodo). Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. È possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è minore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo). <xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o una struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia il numero di byte richiesto o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, usare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (metodo). Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. È possibile usare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  `state` rappresenta un'istanza di una classe definita dall'utente.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente avvia in modo asincrono l'invio di dati a un host remoto.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è minore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Esempio di socket client asincrono</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Esempio di socket server asincrono</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia un file in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Stringa contenente il percorso e il nome del file da inviare. Questo parametro può essere <see langword="null" />.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia il file <paramref name="fileName" /> a un oggetto connesso <see cref="T:System.Net.Sockets.Socket" /> utilizzando il flag <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta l'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload invia il file `fileName` al socket connesso. Se `fileName` è nella directory locale, potrebbe essere identificato utilizzando solo il nome del file; in caso contrario, deve essere specificati il percorso completo e nome del file. I caratteri jolly (".. \\\myfile.txt ") e nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati. Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.  
  
 Questo metodo Usa il `TransmitFile` funzione disponibile nell'API di Windows Sockets versione 2. Per altre informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di socket di Windows in MSDN Library.  
  
 Il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodi. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo consente di inviare un file all'interno di un thread di esecuzione separato.  
  
 Per completare l'operazione, è possibile creare un metodo di callback che viene richiamato dal <xref:System.AsyncCallback> parametro delegato. A tale scopo, nel caso minimo, il `state` parametro deve contenere il <xref:System.Net.Sockets.Socket> oggetto usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passare un'istanza dell'oggetto personalizzato per il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, il sistema utilizza un thread separato per eseguire il metodo di callback specificato e si blocca sulle <xref:System.Net.Sockets.Socket.EndSendFile%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia tutto il file o genera un'eccezione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Protocolli senza connessione, è necessario assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non viene inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un <xref:System.Net.Sockets.SocketException> eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente crea e connette un socket per la comunicazione asincrona. In primo luogo, il file "txt" viene inviato in modo asincrono all'host remoto. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Il socket non è connesso a un host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="fileName" /> del file non è stato trovato.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Stringa contenente il percorso e il nome del file da inviare. Questo parametro può essere <see langword="null" />.</param>
        <param name="preBuffer">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare prima dell'invio del file. Questo parametro può essere <see langword="null" />.</param>
        <param name="postBuffer">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare dopo l'invio del file. Questo parametro può essere <see langword="null" />.</param>
        <param name="flags">Combinazione bit per bit di valori di <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Delegato di <see cref="T:System.AsyncCallback" /> da chiamare al completamento dell'operazione. Questo parametro può essere <see langword="null" />.</param>
        <param name="state">Oggetto definito dall'utente contenente le informazioni di stato per la richiesta. Questo parametro può essere <see langword="null" />.</param>
        <summary>Invia un file e buffer di dati in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload richiede il nome del file da inviare e una combinazione bit per bit di <xref:System.Net.Sockets.TransmitFileOptions> valori. Il `preBuffer` parametro contiene tutti i dati che si desidera far precedere il file. `postBuffer` contiene dati che si desidera eseguire il file. Se `fileName` è nella directory locale, potrebbe essere identificato utilizzando solo il nome del file; in caso contrario, deve essere specificati il percorso completo e nome del file. I caratteri jolly (".. \\\myfile.txt ") e nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati. Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.  
  
 Il `flags` parametro fornisce al provider di servizio finestra socket con informazioni aggiuntive sul trasferimento di file. Per altre informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Questo metodo Usa il `TransmitFile` funzione disponibile nell'API di Windows Sockets versione 2. Per altre informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di socket di Windows in MSDN Library.  
  
 Il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodi. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. La chiamata di <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo offre la possibilità di inviare un file all'interno di un thread di esecuzione separato.  
  
 Per completare l'operazione, è possibile creare un metodo di callback che viene richiamato dal <xref:System.AsyncCallback> parametro delegato. A tale scopo, nel caso minimo, il `state` parametro deve contenere il <xref:System.Net.Sockets.Socket> oggetto usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni necessarie. Passare un'istanza dell'oggetto personalizzato per il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, il sistema utilizza un thread separato per eseguire il metodo di callback specificato e si blocca sulle <xref:System.Net.Sockets.Socket.EndSendFile%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia tutto il file o genera un'eccezione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non viene inviato datagramma e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un <xref:System.Net.Sockets.SocketException> eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente crea e si connette a un socket per la comunicazione asincrona e inizia a inviare il file "txt" in modo asincrono all'host remoto. In questo esempio, un `preBuffer` e una `postBuffer` dei dati viene creato per l'invio con il file e il valore predefinito <xref:System.Net.Sockets.TransmitFileOptions> valore viene utilizzato. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.NotSupportedException">Il sistema operativo non è Windows NT o versioni successive.  
  
\- oppure - 
Il socket non è connesso a un host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="fileName" /> del file non è stato trovato.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione in base zero in <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" /> che rappresenta il dispositivo remoto.</param>
        <param name="remote_end">Oggetto <see cref="T:System.Net.EndPoint" /> che rappresenta il dispositivo remoto.</param>
        <param name="callback">Delegato <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Oggetto che contiene informazioni sullo stato per questa richiesta.</param>
        <summary>Invia i dati in modo asincrono a un host remoto specifico.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo avvia un'operazione di invio asincrono per l'host remoto specificato nella `remoteEP` parametro. La chiamata di <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato. Sebbene sia destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funziona con i protocolli senza connessione e orientato alla connessione.  
  
 È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il relativo nome per il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> (metodo). A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> usato per la comunicazione. Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket>e le altre informazioni necessarie. Passa un'istanza di questa classe per il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo attraverso il `state` parametro.  
  
 Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendTo%2A> (metodo). Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, il sistema userà un thread separato per eseguire il metodo di callback specificati e si bloccherà <xref:System.Net.Sockets.Socket.EndSendTo%2A> fino a quando non la <xref:System.Net.Sockets.Socket> invia il numero di byte richiesto o genera un'eccezione. Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo, usare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> (metodo). Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale di continuare l'esecuzione. Per altre informazioni su come scrivere i metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignorerà il `remoteEP` parametro e invia dati al <xref:System.Net.EndPoint> stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> oppure <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> oppure <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro ignora l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In questo caso, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se si desidera che il provider di servizi sottostante per selezionare una porta disponibile, usare un numero di porta pari a zero. Se è necessario identificare il numero di porta e indirizzo di rete locale assegnata, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodo viene completato correttamente.  
  
 Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. -È inoltre necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.EndSendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e contesto del chiamante) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi. Dopo il primo utilizzo di un particolare contesto (asincrono uno specifico <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente invia in modo asincrono i dati nell'host remoto specificato.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling di un delegato come metodo di callback</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.EndPoint" /> locale da associare al <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Associa un <see cref="T:System.Net.Sockets.Socket" /> a un endpoint locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo se è necessario usare uno specifico endpoint. È necessario chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di poter chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> (metodo). Non è necessario chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di usare il <xref:System.Net.Sockets.Socket.Connect%2A> metodo a meno che non è necessario usare uno specifico endpoint. È possibile usare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo su protocolli senza connessione e orientato alla connessione.  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.Bind%2A>, è innanzitutto necessario creare locale <xref:System.Net.IPEndPoint> da cui si intende trasmettere i dati. Se non si desidera eseguire viene assegnato l'indirizzo locale, è possibile creare un <xref:System.Net.IPEndPoint> usando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> come parametro l'indirizzo e il servizio sottostante provider assegnerà l'indirizzo di rete più appropriato. In questo modo è possibile semplificare l'applicazione se si dispongono di più interfacce di rete. Se non si desidera che la porta locale viene usata, è possibile creare un <xref:System.Net.IPEndPoint> usando 0 per il numero di porta. In questo caso, il provider del servizio assegnerà un numero di porta disponibile tra 1024 e 5000.  
  
 Se si usa l'approccio precedente, è possibile individuare quali numero di porta e indirizzo di rete locale è stato assegnato tramite la chiamata di <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> non restituirà l'indirizzo di rete locale assegnato fino a dopo che è stata effettuata una chiamata per il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.EndConnect%2A> (metodo). Se si usa un protocollo senza connessione, non sarà possibile accedere a queste informazioni fino a quando non hanno completato un invio o ricezione.  
  
 Se un socket UDP desidera ricevere informazioni sull'interfaccia in pacchetti ricevuti, il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo deve essere chiamato in modo esplicito con l'opzione di socket impostata su <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediatamente dopo la chiamata di <xref:System.Net.Sockets.Socket.Bind%2A> (metodo).  
  
> [!NOTE]
>  Se si prevede di ricevere datagrammi multicast, è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo con un numero di porta multicast.  
  
> [!NOTE]
>  È necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo se si prevede di ricevere datagrammi senza connessione utilizzando la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice esempio associa un <xref:System.Net.Sockets.Socket> utilizzando l'endpoint locale specificato.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare le connessioni dall'host definito da <paramref name="localEP" />. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il <see cref="T:System.Net.Sockets.Socket" /> è in modalità blocco.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> verrà bloccato, in caso contrario <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà indica se un <xref:System.Net.Sockets.Socket> è in modalità di blocco.  
  
 Se si è in modalità di blocco, e si esegue un metodo di chiamata che non viene completata immediatamente, l'applicazione si bloccherà fino a quando non viene completata l'operazione richiesta. Se si desidera che l'esecuzione continua anche se l'operazione richiesta non è stata completata, modificare il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false`. Il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà non ha alcun effetto sui metodi asincroni. Se si inviano e ricevono i dati in modo asincrono e vuole bloccare l'esecuzione, usare il <xref:System.Threading.ManualResetEvent> classe.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> utilizzato per richiedere la connessione all'host remoto chiamando uno dei metodi <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Annulla una richiesta asincrona di una connessione all'host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> metodo annulla una richiesta asincrona per una connessione all'host remoto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Chiude la connessione all'oggetto <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude la connessione all'oggetto <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Close%2A> metodo chiude la connessione all'host remoto e rilascia tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>. Al momento della chiusura, il <xref:System.Net.Sockets.Socket.Connected%2A> è impostata su `false`.  
  
 Per i protocolli orientati alla connessione, si consiglia di chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo). Ciò garantisce che tutti i dati viene inviato e ricevuto nel socket connessi prima della chiusura.  
  
 Se è necessario chiamare <xref:System.Net.Sockets.Socket.Close%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile garantire che i dati in coda per la trasmissione in uscita vengano inviata mediante l'impostazione di <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> possibilità `false` e specificando un intervallo di timeout diverso da zero. <xref:System.Net.Sockets.Socket.Close%2A> quindi si bloccherà fino a quando i dati vengono inviati o fino a quando non scade il timeout specificato. Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.  
  
> [!NOTE]
>  Per impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione di socket `false`, creare un <xref:System.Net.Sockets.LingerOption>, impostare la proprietà attivata su `true`e impostare il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà per il periodo di timeout desiderato. Usare questa <xref:System.Net.Sockets.LingerOption> lungo con il <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket possibilità di chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo).  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene chiuso un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Attendere fino al numero di secondi specificato in <c>timeout</c> per inviare eventuali dati rimanenti, quindi chiudere il socket.</param>
        <summary>Chiude la connessione <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate con un timeout specificato in modo da consentire l'invio dei dati in coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Close%2A> metodo chiude la connessione all'host remoto e rilascia tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>. Al momento della chiusura, il <xref:System.Net.Sockets.Socket.Connected%2A> è impostata su `false`.  
  
 Per i protocolli orientati alla connessione, si consiglia di chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Close%2A>. Ciò garantisce che tutti i dati viene inviato e ricevuto nel socket connessi prima della chiusura.  
  
 Se è necessario chiamare <xref:System.Net.Sockets.Socket.Close%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile garantire che i dati in coda per la trasmissione in uscita vengano inviata mediante l'impostazione di <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione `false` e specificando un intervallo di timeout diverso da zero. <xref:System.Net.Sockets.Socket.Close%2A> quindi si bloccherà fino a quando i dati vengono inviati o fino a quando non scade il timeout specificato. Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.  
  
> [!NOTE]
>  Per impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione di socket `false`, creare un <xref:System.Net.Sockets.LingerOption>, impostare la proprietà attivata su `true`e impostare il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà per il periodo di timeout desiderato. Usare questa <xref:System.Net.Sockets.LingerOption> lungo con il <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket possibilità di chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo).  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiudere un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stabilisce una connessione a un host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" /> che rappresenta il dispositivo remoto.</param>
        <summary>Stabilisce una connessione a un host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito. Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A>, è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con la <xref:System.Net.Sockets.Socket.Receive%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicare in maniera sincrona con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 Il <xref:System.Net.Sockets.Socket.Connect%2A> metodo si blocca, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>. Se si usa un protocollo orientato alla connessione quali TCP e si disabilita il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché il tempo necessario a stabilire la connessione. Protocolli senza connessione non genererà un'eccezione perché semplicemente stabilito un host remoto predefinito. È possibile usare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto sia stata avviata dal orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata. Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.  
  
> [!NOTE]
>  Se si usa un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale. Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non verrà completata una trasmissione o l'operazione di ricezione. Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo per ripristinare la connessione. Usare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione. Si tratta di una limitazione del provider sottostante.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente si connette a un endpoint remoto e quindi verifica la connessione.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">per la connessione all'host remoto. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">L'indirizzo IP dell'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <summary>Stabilisce una connessione a un host remoto. L'host è specificato da un indirizzo IP e da un numero di porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito. Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con la <xref:System.Net.Sockets.Socket.Receive%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicare in maniera sincrona con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metodo si blocca, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>. Se si usa un protocollo orientato alla connessione quali TCP e si disabilita il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché il tempo necessario a stabilire la connessione. Protocolli senza connessione non genererà un'eccezione perché semplicemente stabilito un host remoto predefinito. È possibile usare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto sia stata avviata dal orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata. Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.  
  
> [!NOTE]
>  Se si usa un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale. Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non verrà completata una trasmissione o l'operazione di ricezione. Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo per ripristinare la connessione. Usare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione. Si tratta di una limitazione del provider sottostante.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente si connette a un endpoint remoto e quindi verifica la connessione.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="address" /> è zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">L'indirizzo IP dell'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <summary>Stabilisce una connessione a un host remoto. L'host è specificato da una matrice di indirizzi IP e da un numero di porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato immediatamente dopo una chiamata a <xref:System.Net.Dns.GetHostAddresses%2A>, che può restituire più indirizzi IP per un singolo host. Se si usa un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito. Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con la <xref:System.Net.Sockets.Socket.Receive%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicare in maniera sincrona con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metodo si blocca, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>. Se si usa un protocollo orientato alla connessione quali TCP e si disabilita il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché il tempo necessario a stabilire la connessione. Protocolli senza connessione non genererà un'eccezione perché semplicemente stabilito un host remoto predefinito. È possibile usare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto sia stata avviata dal orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata. Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.  
  
> [!NOTE]
>  Se si usa un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale. Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non verrà completata una trasmissione o l'operazione di ricezione. Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo per ripristinare la connessione. Usare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione. Si tratta di una limitazione del provider sottostante.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente si connette a un endpoint remoto e quindi verifica la connessione.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="address" /> è zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Il nome dell'host remoto.</param>
        <param name="port">Numero di porta dell'host remoto.</param>
        <summary>Stabilisce una connessione a un host remoto. L'host viene specificato da un nome host e da un numero di porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'host remoto specificato. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito. Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con la <xref:System.Net.Sockets.Socket.Receive%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicare in maniera sincrona con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metodo si blocca, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>. Se si usa un protocollo orientato alla connessione quali TCP e si disabilita il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché il tempo necessario a stabilire la connessione. Protocolli senza connessione non genererà un'eccezione perché semplicemente stabilito un host remoto predefinito. È possibile usare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto sia stata avviata dal orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata. Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.  
  
 Se IPv6 è abilitato e <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> metodo viene chiamato per connettersi a un host che si risolve in IPv6 e indirizzi IPv4, la connessione all'indirizzo IPv6 viene tentata prima di quella dell'indirizzo IPv4. Ciò può avere l'effetto di ritardare il tempo necessario per stabilire la connessione se l'host non è in ascolto sull'indirizzo IPv6.  
  
> [!NOTE]
>  Se si usa un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale. Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non verrà completata una trasmissione o l'operazione di ricezione. Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.  
  
> [!NOTE]
>  Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo per ripristinare la connessione. Usare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione. Si tratta di una limitazione del provider sottostante.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente si connette a un endpoint remoto e quindi verifica la connessione.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di porta non è valido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo avvia una richiesta asincrona per una connessione all'host remoto. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> stabilisce un host remoto predefinito.  
  
 Per ricevere una notifica del completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto a cui connettersi.  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> per comunicare con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo nuovamente con l'endpoint desiderato.  
  
 Se si vuole impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast `true`. Se questa operazione non viene eseguita, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Facoltativamente, fornire un buffer da cui verrà inviato in modo atomico nel socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo. In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostato per il buffer che contiene i dati per l'invio e la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostato sul numero di byte di dati da inviare dal buffer. Dopo aver stabilita una connessione, viene inviato il buffer di dati.  
  
 Se si usa un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato.  
  
 Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo IP rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodi.  
  
 Il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genera un'eccezione <xref:System.NotSupportedException> se la famiglia di indirizzi delle <xref:System.Net.Sockets.Socket> e il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> non appartengono alla stessa famiglia di indirizzi.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama questo metodo, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argomento non è valido. Questa eccezione si verifica se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</exception>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è in attesa o era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva. Questa eccezione si verifica anche se l'endpoint locale e l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non appartengono alla stessa famiglia di indirizzi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia una richiesta asincrona di una connessione all'host remoto.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, il metodo ProtocolType avvia una richiesta asincrona di un connessione all'host remoto. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> stabilisce un host remoto predefinito specificato per il `socketType` e `protocolType` parametri.  
  
 Per ricevere una notifica del completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto a cui connettersi.  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Se si usa un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A> prima di inviare e ricevere dati. È possibile usare <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> per comunicare con un host remoto. Se si chiama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato. Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo nuovamente con l'endpoint desiderato.  
  
 Se si vuole impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast `true`. Se questa operazione non viene eseguita, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Facoltativamente, fornire un buffer da cui verrà inviato in modo atomico nel socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo. In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostato per il buffer che contiene i dati per l'invio e la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostato sul numero di byte di dati da inviare dal buffer. Dopo aver stabilita una connessione, viene inviato il buffer di dati.  
  
 Se si usa un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato.  
  
 Se si usa un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo IP rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodi.  
  
 Il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genera un'eccezione <xref:System.NotSupportedException> se la famiglia di indirizzi delle <xref:System.Net.Sockets.Socket> e il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> non appartengono alla stessa famiglia di indirizzi.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama questo metodo, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argomento non è valido. Questa eccezione si verifica se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</exception>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> è in attesa o era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva. Questa eccezione si verifica anche se l'endpoint locale e l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non appartengono alla stessa famiglia di indirizzi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un <see cref="T:System.Net.Sockets.Socket" /> si è connesso a un host remoto dall'ultima operazione <see cref="Overload:System.Net.Sockets.Socket.Send" /> o <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> è connesso a una risorsa remota nel corso dell'operazione più recente, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Connected` proprietà ottiene lo stato della connessione di <xref:System.Net.Sockets.Socket> al momento della stesura dell'ultima operazione dei / o. Quando viene restituito `false`, il <xref:System.Net.Sockets.Socket> non si è mai connesso o non è più connesso.  
  
 Il valore della <xref:System.Net.Sockets.Socket.Connected%2A> proprietà riflette lo stato della connessione al momento della stesura dell'operazione più recente. Se è necessario determinare lo stato corrente della connessione, chiamare una trasmissione non bloccante, zero byte. Se la chiamata ha esito positivo o genera un errore WAEWOULDBLOCK (10035), il socket è ancora connesso; in caso contrario, il socket non è più connesso.  
  
 Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> su un socket di protocollo UDP (User Datagram), il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà restituisce sempre `true`; tuttavia, questa azione non modifica la natura senza connessione inerente di UDP.  
  
   
  
## Examples  
 Esempio di codice seguente si connette a un endpoint remoto, controlli di <xref:System.Net.Sockets.Socket.Connected%2A> proprietà e controlla lo stato corrente della connessione.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> se il socket può essere riutilizzato una volta chiusa la connessione in corso; in caso contrario, <see langword="false" />.</param>
        <summary>Chiude la connessione al socket consentendo di riutilizzare il socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, è possibile utilizzare questo metodo per chiudere il socket. Questo metodo termina la connessione e imposta il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà `false`. Tuttavia, se `reuseSocket` è `true`, è possibile riutilizzare il socket.  
  
 Per garantire che tutti i dati viene inviato e ricevuto prima della chiusura del socket, è necessario chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare il <xref:System.Net.Sockets.Socket.Disconnect%2A> (metodo).  
  
 Se è necessario chiamare <xref:System.Net.Sockets.Socket.Disconnect%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> possibilità `false` e specificare un intervallo di timeout diverso da zero per garantire che i dati in coda per la trasmissione in uscita viene inviata. <xref:System.Net.Sockets.Socket.Disconnect%2A> quindi si blocca fino a quando i dati vengono inviati o fino a quando non scade il timeout specificato. Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea un socket per la comunicazione sincrona e invia alcuni dati in un host remoto. Chiama poi <xref:System.Net.Sockets.Socket.Shutdown%2A>per arrestare l'invio e ricezione attività, e <xref:System.Net.Sockets.Socket.Disconnect%2A>per chiudere la connessione socket.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Questo metodo richiede Windows 2000 o versioni precedenti; in caso contrario sarà generata un'eccezione.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia una richiesta asincrona di disconnessione da un endpoint remoto.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si usa un protocollo orientato alla connessione, chiamare il <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metodo richiede una disconnessione da un endpoint remoto. Se si imposta <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> al `true` nel `e` parametro, il socket può essere riutilizzato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="e" /> non può essere null.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo `Dispose` dopo aver terminato di utilizzare l'oggetto <xref:System.Net.Sockets.Socket>. Il metodo `Dispose` lascia l'oggetto <xref:System.Net.Sockets.Socket> in una condizione di inutilizzabilità. Dopo la chiamata `Dispose`, è necessario rilasciare tutti i riferimenti per il <xref:System.Net.Sockets.Socket> in modo che il garbage collector di recuperare la memoria che il <xref:System.Net.Sockets.Socket> occupata.  
  
 Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementa un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo `Dispose` prima di rilasciare l'ultimo riferimento a <xref:System.Net.Sockets.Socket>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Net.Sockets.Socket> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.Net.Sockets.Socket" /> e, facoltativamente, elimina le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico `Dispose()` metodo e <xref:System.Object.Finalize%2A> (metodo). `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Net.Sockets.Socket> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per altre informazioni su come implementare <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Per altre informazioni sulle <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> consente la frammentazione dei datagrammi IP (Internet Protocol).</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente la frammentazione dei datagrammi; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagrammi richiedono la frammentazione se le dimensioni superano le unità di MTU (Maximum Transfer) di mezzo di trasmissione. Essi possono essere frammentati tramite l'host di invio (tutte le versioni di Internet Protocol) o un router intermedio (solo Internet Protocol versione 4). Se un datagramma deve essere frammentato e il <xref:System.Net.Sockets.Socket.DontFragment%2A> opzione è impostata, viene eliminato il datagramma e viene inviato un messaggio di errore di controllo messaggio protocollo ICMP (Internet) al mittente del datagramma.  
  
 Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) si avrà alcun effetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.DontFragment%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">È possibile impostare questa proprietà solo per i socket inclusi nella famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore di <see cref="T:System.Boolean" /> che specifica se <see cref="T:System.Net.Sockets.Socket" /> è un socket dual mode usato per IPv4 e IPv6.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Net.Sockets.Socket" /> è un socket dual mode; in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">L'ID del processo di destinazione in cui viene creato un duplicato del riferimento al socket.</param>
        <summary>Duplica il riferimento al socket per il processo di destinazione e chiude il socket per tale processo.</summary>
        <returns>Il riferimento al socket da passare al processo di destinazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il processo di destinazione deve usare <xref:System.Net.Sockets.Socket.%23ctor%2A> per creare l'istanza di socket duplicato.  
  
 Se si chiama il <xref:System.Net.Sockets.Socket.%23ctor%2A> costruttore più volte con la stessa matrice di byte come argomento per ogni chiamata, si creerà più gestiti <xref:System.Net.Sockets.Socket> istanze con lo stesso socket sottostante. Questa pratica è fortemente sconsigliata.  
  
 Se il processo di creazione il socket Usa i metodi asincroni (<xref:System.Net.Sockets.Socket.BeginReceive%2A> o <xref:System.Net.Sockets.Socket.BeginSend%2A>), il processo prima di tutto necessario impostare il <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> proprietà su true; in caso contrario, il socket è associato alla porta di completamento del processo di creazione, che potrebbe causare un <xref:System.ArgumentNullException> generata nel processo di destinazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> non è un ID di processo valido. 
oppure 
La duplicazione del riferimento al socket non è riuscita.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> può inviare o ricevere pacchetti broadcast.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente lo scambio di pacchetti broadcast; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La trasmissione è limitata a una subnet specifica e deve utilizzare User Datagram Protocol (UDP). Per protocollo Internet versione 4, è possibile trasmettere alla subnet locale mediante l'invio di un pacchetto a 255.255.255.255; oppure è possibile usare l'indirizzo di broadcast, ovvero la parte di rete di un indirizzo IP (Internet Protocol) con tutti i bit impostati nella porzione di host. Ad esempio, se l'indirizzo IP è 192.168.1.40 (un indirizzo di classe C, con una netmask 255.255.255.0, la porzione di rete è i primi tre ottetti e la parte host è l'ultimo ottetto), l'indirizzo broadcast è diretto 192.168.1.255.  
  
 Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) si avrà alcun effetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Questa opzione è valida solo per i socket di datagrammi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accetta un tentativo di connessione in ingresso in modalità asincrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> contenente i byte trasferiti.</param>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto. Questo metodo restituisce un buffer contenente i dati iniziali trasferiti.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che viene richiamato dal <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> restituzione del metodo.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare correttamente il tentativo di connessione. Il `buffer` di overload di questo parametro contiene i dati che è stati ricevuti nella chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A> e il `bytesTransferred` parametro contiene il numero di byte che sono stati trasferiti nella chiamata.  
  
 Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessioni in ingresso. Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare dati e ricevere dati dall'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.BeginAccept%2A> per creare e connettere un socket e accettare i primi 10 byte di dati. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndAccept%2A> per terminare la richiesta asincrona. Il numero di byte trasmessi e i dati vengono restituiti nel `buffer` e `bytesTransferred` parametri di questo metodo e vengono visualizzati nella console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è vuoto.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> restituzione del metodo. Deve accettare il `asyncResult` restituito dal parametro di <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo).  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare correttamente il tentativo di connessione.  
  
 Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessioni in ingresso. Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare dati e ricevere dati dall'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina una richiesta asincrona e crea un nuovo <xref:System.Net.Sockets.Socket> per accettare una richiesta di connessione in ingresso. Per un esempio completo che illustra le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Per altre informazioni, vedere la sezione Osservazioni.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> contenente i byte trasferiti.</param>
        <param name="bytesTransferred">Il numero di byte trasferiti.</param>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto. Questo metodo restituisce un buffer contenente i dati iniziali e il numero di byte trasferiti.</summary>
        <returns>Oggetto <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che viene richiamato dal <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> restituzione del metodo. Deve accettare il `asyncResult` restituito dal parametro di <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo).  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare correttamente il tentativo di connessione. Il `buffer` di overload di questo parametro contiene i dati che è stati ricevuti nella chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A> e il `bytesTransferred` parametro contiene il numero di byte che sono stati trasferiti nella chiamata.  
  
 Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessioni in ingresso. Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare dati e ricevere dati dall'host remoto.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.BeginAccept%2A> per creare e connettere un socket e accettare i primi 10 byte di dati. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndAccept%2A> per terminare la richiesta asincrona. Il numero di byte trasmessi e i dati vengono restituiti nel `buffer` e `bytesTransferred` parametri di questo metodo e vengono visualizzati nella console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è vuoto.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Termina una richiesta di connessione sincrona in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> viene avviato un metodo di blocco che viene completata la richiesta di connessione asincrona host remoto nel <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo).  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginConnect%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo per completare correttamente il tentativo di connessione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina il tentativo di connessione asincrona. Per un esempio completo che illustra le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> è stato precedentemente chiamato per la connessione asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Termina una richiesta di disconnessione asincrona in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. Il <xref:System.Net.Sockets.Socket.EndDisconnect%2A> metodo si blocca fino a quando non viene completata la disconnessione. Per informazioni sulle operazioni asincrone, vedere l'argomento di panoramica di programmazione asincrona in MSDN library.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea un socket per la comunicazione asincrona e vengono inviati dati a un host remoto. Quando i dati sono stati inviati, <xref:System.Net.Sockets.Socket.Shutdown%2A> viene chiamato per arrestare l'invio e ricezione attività. Quindi <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> viene chiamato per avviare una richiesta di disconnessione. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndDisconnect%2A> per terminare la richiesta asincrona. Al completamento della richiesta, il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà viene eseguita una query per verificare se il socket è disconnesso.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> è stato precedentemente chiamato per la connessione asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.Net.WebException">Timeout della richiesta di disconnessione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termina una lettura asincrona in attesa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Termina una lettura asincrona in attesa.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceive%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo). Estrarre la ricezione <xref:System.Net.Sockets.Socket> da questo oggetto di stato. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo per completare l'operazione di lettura e restituisce il numero di byte letti.  
  
 Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo si blocca fino a quando non sono disponibili dati. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndReceive%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso. Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo leggerà quantità di dati è disponibile fino al numero di byte specificato nella `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo). Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo di <xref:System.IAsyncResult>ed estrarre il buffer contenuto nell'oggetto stato risultante.  
  
 Per annullare un'in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina una lettura asincrona in sospeso. Per un esempio completo che illustra le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> è stato precedentemente chiamato per la lettura asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Termina una lettura asincrona in attesa.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceive%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo). Estrarre la ricezione <xref:System.Net.Sockets.Socket> da questo oggetto di stato. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo per completare l'operazione di lettura e restituisce il numero di byte letti.  
  
 Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo si blocca fino a quando non sono disponibili dati. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndReceive%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso. Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo leggerà quantità di dati è disponibile fino al numero di byte specificato nella `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo). Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo di <xref:System.IAsyncResult>ed estrarre il buffer contenuto nell'oggetto stato risultante.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> è stato precedentemente chiamato per la lettura asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="endPoint">Il <see cref="T:System.Net.EndPoint" /> di origine.</param>
        <param name="end_point">Il <see cref="T:System.Net.EndPoint" /> di origine.</param>
        <summary>Termina una lettura asincrona in sospeso da uno specifico endpoint.</summary>
        <returns>Se ha esito positivo, numero di byte ricevuti. Se ha esito negativo restituisce 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo).  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo). Estrarre la ricezione <xref:System.Net.Sockets.Socket> da questo oggetto di stato. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo per completare l'operazione di lettura e restituisce il numero di byte letti.  
  
 Il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo si blocca fino a quando non sono disponibili dati. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso. Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo leggerà quantità di dati è disponibile fino al numero di byte specificato nella `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo). Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo verrà completata immediatamente e restituire zero byte. Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo del <xref:System.IAsyncResult> oggetto ed estrarre il buffer contenuto nell'oggetto stato risultante. Per identificare l'host di origine, estrarre il <xref:System.Net.EndPoint> eseguire il cast a un <xref:System.Net.IPEndPoint>. Usare la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per ottenere l'indirizzo IP e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per ottenere il numero di porta.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina una lettura asincrona in sospeso da una determinata <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> è stato precedentemente chiamato per la lettura asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" /> relativi al pacchetto ricevuto.</param>
        <param name="endPoint">Il <see cref="T:System.Net.EndPoint" /> di origine.</param>
        <param name="ipPacketInformation">L'<see cref="T:System.Net.IPAddress" /> e l'interfaccia del pacchetto ricevuto.</param>
        <summary>Termina una lettura asincrona in sospeso da uno specifico endpoint. Questo metodo fornisce inoltre ulteriori informazioni sul pacchetto rispetto a <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Se ha esito positivo, numero di byte ricevuti. Se ha esito negativo restituisce 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene.  
  
 Per eseguire questa operazione in modo sincrono, usare il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (metodo).  
  
 Esaminare `ipPacketInformation` se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />  
  
oppure 
 <paramref name="endPoint" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> è stato precedentemente chiamato per la lettura asincrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termina un invio asincrono in attesa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</param>
        <summary>Termina un invio asincrono in attesa.</summary>
        <returns>Se ha esito positivo, numero di byte inviati al <see cref="T:System.Net.Sockets.Socket" />. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSend%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati.  
  
 Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> si bloccherà fino a quando non viene inviato datagramma. Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> si bloccherà fino a quando l'invio di una parte del buffer. Se il valore restituito da <xref:System.Net.Sockets.Socket.EndSend%2A> indica che il buffer non è stato inviato completamente, chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo nuovo, modificando il buffer per contenere i dati non inviati.  
  
 Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina un invio asincrono in sospeso.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Termina un invio asincrono in attesa.</summary>
        <returns>Se ha esito positivo, numero di byte inviati al <see cref="T:System.Net.Sockets.Socket" />. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSend%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati.  
  
 Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> si bloccherà fino a quando non viene inviato datagramma. Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> si bloccherà fino a quando l'invio di una parte del buffer. Se il valore restituito da <xref:System.Net.Sockets.Socket.EndSend%2A> indica che il buffer non è stato inviato completamente, chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo nuovo, modificando il buffer per contenere i dati non inviati.  
  
 Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Tutti i/o avviato da un determinato thread è stata annullata all'uscita dal thread. Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</param>
        <summary>Termina l'invio asincrono di un file in sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSendFile%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> oggetto restituito dal <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodo per completare correttamente l'operazione di invio.  
  
 Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocca finché non viene inviato datagramma. Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocca finché non viene inviato l'intero file. Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea e si connette a un socket per la comunicazione asincrona e inizia a inviare il file "txt" in modo asincrono all'host remoto. Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Per questo metodo è richiesto Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è vuoto.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> è stato precedentemente chiamato il <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asincrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</param>
        <summary>Termina un invio asincrono in sospeso a una posizione specifica.</summary>
        <returns>Se ha esito positivo, numero di byte trasmessi. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare. Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce. Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo come parametro.  
  
 All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>. Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati.  
  
 Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.EndSendTo%2A> si bloccherà fino a quando non viene inviato datagramma. Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSendTo%2A> si bloccherà fino a quando non viene inviato il numero di byte richiesto. Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente termina un invio asincrono in un percorso specifico.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> consente di associare a una porta un unico processo.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente a un solo socket di essere associato a una porta specifica; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" /> per Windows Server 2003 e Windows XP Service Pack 2 e <see langword="false" /> per tutte le altre versioni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> viene `false`, più socket può utilizzare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo da associare a una porta specifica; tuttavia, solo uno dei socket può eseguire operazioni sul traffico di rete inviati alla porta. Se più di un socket tenta di usare il <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metodo da associare a una porta specifica, quindi l'uno con l'indirizzo IP più specifico gestirà il traffico di rete inviato a tale porta.  
  
 Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> viene `true`, al primo utilizzo delle <xref:System.Net.Sockets.Socket.Bind%2A> metodo per tentare di associare a una porta specifica, indipendentemente dall'indirizzo IP (Internet Protocol), verrà eseguito correttamente, vengono utilizzati tutti i successivi del <xref:System.Net.Sockets.Socket.Bind%2A> metodo tenta di associare a tale porta verrà esito negativo fino a quando il socket associato originale viene eliminato definitivamente.  
  
 Questa proprietà deve essere impostata prima <xref:System.Net.Sockets.Socket.Bind%2A> viene chiamato; in caso contrario un <xref:System.InvalidOperationException> verrà generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> è stato chiamato per questo <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse usate dalla classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket> classe finalizzatore chiama il <xref:System.Net.Sockets.Socket.Close%2A> metodo per chiudere la <xref:System.Net.Sockets.Socket> e rilasciare le risorse associate di <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il valore di un'opzione di <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Restituisce il valore di un'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata, rappresentata da un oggetto.</summary>
        <returns>Oggetto che rappresenta il valore dell'opzione. Quando il parametro <paramref name="optionName" /> è impostato su <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, il valore restituito è un'istanza della classe <see cref="T:System.Net.Sockets.LingerOption" />. Quando <paramref name="optionName" /> è impostato su <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> o <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, il valore restituito è un'istanza della classe <see cref="T:System.Net.Sockets.MulticastOption" />. Quando <paramref name="optionName" /> è qualsiasi altro valore, il valore restituito è un intero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Utilizzare questo overload per ottenere il <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opzioni. Per il <xref:System.Net.Sockets.SocketOptionName.Linger> opzione, utilizzare <xref:System.Net.Sockets.Socket> per il `optionLevel` parametro. Per la <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, usare <xref:System.Net.Sockets.SocketOptionLevel.IP>. Se si desidera impostare il valore di una qualsiasi delle opzioni elencate in precedenza, usare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.  
  
oppure 
 <paramref name="optionName" /> è stato impostato su un valore di <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> non supportato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Matrice di tipo <see cref="T:System.Byte" /> che deve ricevere l'impostazione dell'opzione.</param>
        <summary>Restituisce l'impostazione dell'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata, rappresentata come una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Al completamento di questo metodo, la matrice specificata per il `optionValue` parametro contiene il valore dell'oggetto specificato <xref:System.Net.Sockets.Socket> opzione.  
  
 Quando la lunghezza del `optionValue` matrice è inferiore al numero di byte necessari per archiviare il valore dell'oggetto specificato <xref:System.Net.Sockets.Socket> opzione <xref:System.Net.Sockets.Socket.GetSocketOption%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Utilizzare questo overload per qualsiasi socket che sono rappresentati da numeri interi o valori booleani.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.  
  
\- oppure - 
Nelle applicazioni di .NET Compact Framework, lo spazio di buffer predefinito per Windows CE è impostato su 32768 byte. È possibile modificare lo spazio di buffer per ciascun socket chiamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">Lunghezza in byte del valore restituito previsto.</param>
        <summary>Restituisce in una matrice il valore dell'opzione di <see cref="T:System.Net.Sockets.Socket" /> specificata.</summary>
        <returns>Matrice di tipo <see cref="T:System.Byte" /> che contiene il valore dell'opzione di socket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `optionLength` parametro imposta la dimensione massima della matrice di byte restituita. Se il valore dell'opzione richiede un minor numero di byte, la matrice conterrà solo tale numero di byte. Se il valore dell'opzione richiede più byte, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> genererà un <xref:System.Net.Sockets.SocketException>. Utilizzare questo overload per qualsiasi socket che sono rappresentati da numeri interi o valori booleani.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.  
  
\- oppure - 
Nelle applicazioni di .NET Compact Framework, lo spazio di buffer predefinito per Windows CE è impostato su 32768 byte. È possibile modificare lo spazio di buffer per ciascun socket chiamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle del sistema operativo per il <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Valore <see cref="T:System.IntPtr" /> che rappresenta l'handle del sistema operativo per il <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valore di <see cref="T:System.Int32" /> che specifica il codice di controllo dell'operazione da eseguire.</param>
        <param name="optionInValue">Matrice <see cref="T:System.Byte" /> che contiene i dati di input richiesti dall'operazione.</param>
        <param name="optionOutValue">Matrice <see cref="T:System.Byte" /> che contiene i dati di output richiesti dall'operazione.</param>
        <summary>Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" /> utilizzando codici di controllo numerici.</summary>
        <returns>Numero di byte nel parametro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.IOControl%2A> metodo offre l'accesso a basso livello per il sistema operativo <xref:System.Net.Sockets.Socket> sottostante l'istanza corrente del <xref:System.Net.Sockets.Socket> classe. Per altre informazioni, vedere la documentazione di WSAIoctl in MSDN library.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono confrontati i risultati della FIONREAD e le proprietà disponibili.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">È stato effettuato un tentativo di modificare la modalità di blocco senza utilizzare la proprietà <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per eseguire il codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valore di <see cref="T:System.Net.Sockets.IOControlCode" /> che specifica il codice di controllo dell'operazione da eseguire.</param>
        <param name="optionInValue">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati di input richiesti dall'operazione.</param>
        <param name="optionOutValue">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati di output restituiti dall'operazione.</param>
        <summary>Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" /> utilizzando l'enumerazione <see cref="T:System.Net.Sockets.IOControlCode" /> per specificare i codici di controllo.</summary>
        <returns>Numero di byte nel parametro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce l'accesso a basso livello per il sistema operativo <xref:System.Net.Sockets.Socket> sottostante dell'istanza corrente di <xref:System.Net.Sockets.Socket> classe. Per altre informazioni, vedere la documentazione di WSAIoctl in MSDN library.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono confrontati i risultati della chiamata al metodo <xref:System.Net.Sockets.Socket.IOControl%2A> con <xref:System.Net.Sockets.IOControlCode.DataToRead> e il <xref:System.Net.Sockets.Socket.Available%2A> proprietà.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">È stato effettuato un tentativo di modificare la modalità di blocco senza utilizzare la proprietà <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per eseguire il codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il <see cref="T:System.Net.Sockets.Socket" /> è associato a una porta locale specifica.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> è associato a una porta locale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un socket è considerato associato a una porta locale se è associato in modo esplicito chiamando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, o da associare in modo implicito chiamando i membri, ad esempio <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, che utilizzano una porta locale temporanea (una porta disponibile maggiore di 1024, selezionata per il sistema operativo.) I server usano il <xref:System.Net.Sockets.Socket.Bind%2A> metodo da associare a una porta nota in modo che i client possono connettersi a essi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.IsBound%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se il <see cref="T:System.Net.Sockets.Socket" /> ritarderà la chiusura di un socket durante un tentativo di invio di tutti i dati in sospeso.</summary>
        <value>
          <see cref="T:System.Net.Sockets.LingerOption" /> che specifica la modalità di attivazione del ritardo durante la chiusura di un socket.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà viene modificata la modalità <xref:System.Net.Sockets.Socket.Close%2A> comportamento del metodo. Questa proprietà quando è impostata Modifica le condizioni in cui la connessione può essere reimpostata Winsock. Reimpostazione della connessione può essere comunque eseguita in base al comportamento del protocollo IP.  
  
 Questa proprietà controlla il periodo di tempo che una connessione orientato alla connessione rimarrà aperta dopo una chiamata a <xref:System.Net.Sockets.Socket.Close%2A> quando i dati rimangono da inviare.  
  
 Quando si chiamano metodi per inviare dati a un peer, questi dati viene inseriti nel buffer di rete in uscita. Questa proprietà può essere utilizzata per garantire che i dati siano inviati all'host remoto prima di <xref:System.Net.Sockets.TcpClient.Close%2A> metodo rilascia la connessione.  
  
 Per abilitare il tempo di ritardo, creare un <xref:System.Net.Sockets.LingerOption> dell'istanza contenente i valori desiderati e impostare il <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà a questa istanza.  
  
 La tabella seguente descrive il comportamento del <xref:System.Net.Sockets.Socket.Close%2A> metodo per i valori possibili del <xref:System.Net.Sockets.LingerOption.Enabled%2A> proprietà e il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà archiviata nel <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportamento|  
|-------------------------|----------------------------|--------------|  
|`false` (disabilitato), il valore predefinito|Non è applicabile, il timeout (impostazione predefinita).|Tenta di inviare dati in sospeso fino a quando non scade il timeout di protocollo IP predefinito.|  
|`true` (abilitato)|Un timeout diverso da zero|Tenta di inviare dati in sospeso fino a quando non scade il timeout specificato e se il tentativo non riesce, Winsock reimposta la connessione.|  
|`true` (abilitato)|Un timeout pari a zero.|Ignora tutti i dati in sospeso. Per il socket orientati alla connessione (TCP, ad esempio), Winsock reimposta la connessione.|  
  
 Lo stack IP calcola il periodo di timeout predefinito protocollo IP da usare in base all'ora di andata e ritorno della connessione. Nella maggior parte dei casi, il timeout calcolato da parte dello stack è più utile rispetto a quello definito da un'applicazione. Si tratta del comportamento predefinito per un socket quando il <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà non è impostata.  
  
 Quando la <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà archiviata nel <xref:System.Net.Sockets.Socket.LingerState%2A> viene impostata maggiore del timeout di protocollo IP predefinito, il timeout predefinito di protocollo IP verrà comunque applicare ed eseguire l'override.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Lunghezza massima della coda delle connessioni in sospeso.</param>
        <summary>Colloca un <see cref="T:System.Net.Sockets.Socket" /> in uno stato di attesa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> fa sì che un orientato alla connessione <xref:System.Net.Sockets.Socket> in ascolto di tentativi di connessione in ingresso. Il `backlog` parametro specifica il numero di connessioni in ingresso che possono essere inseriti nella coda per l'accettazione. Per determinare il numero massimo di connessioni è possibile specificare, recuperare il <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valore. <xref:System.Net.Sockets.Socket.Listen%2A> non si blocca.  
  
 Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore. Uso <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> per accettare una connessione dalla coda.  
  
> [!NOTE]
>  È necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.Listen%2A>, o <xref:System.Net.Sockets.Socket.Listen%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Il parametro di backlog è limitato a valori diversi a seconda del sistema operativo. È possibile specificare un valore più elevato, ma il backlog verranno limitato sulla base del sistema operativo.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare <xref:System.Net.Sockets.Socket> per ascoltare le connessioni in ingresso.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'endpoint locale.</summary>
        <value>L'oggetto <see cref="T:System.Net.EndPoint" /> utilizzato dall'oggetto <see cref="T:System.Net.Sockets.Socket" /> per le comunicazioni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property get un' <xref:System.Net.EndPoint> che contiene l'IP indirizzo e la porta numero locale a cui il <xref:System.Net.Sockets.Socket> è associato. È necessario eseguire il cast di questo <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> prima di recuperare tutte le informazioni. È quindi possibile chiamare il <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per recuperare l'oggetto locale <xref:System.Net.IPAddress>e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per recuperare il numero di porta locale.  
  
 Il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> viene in genere impostata dopo aver effettuato una chiamata al <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). Se si consente al sistema di assegnare l'indirizzo IP locale del socket e numero di porta, il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà verrà impostata dopo la prima operazione dei / o. Per i protocolli orientati alla connessione, la prima operazione dei / o sarebbe una chiamata per il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Per protocolli senza connessione, la prima operazione dei / o potrebbe essere uno di trasmissione o ricevere le chiamate.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente recupera e visualizza gli endpoint locali e remoti.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se i pacchetti multicast in uscita devono essere recapitati all'applicazione mittente.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> riceve pacchetti multicast; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il multicast è un metodo scalabile per la comunicazione di molti-a-molti in Internet. Un processo esegue la sottoscrizione a un indirizzo multicast. quindi, tutti i pacchetti inviati da un processo sottoscritto vengono ricevuti da ogni altro processo ha sottoscritto l'indirizzo multicast.  
  
 Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) si avrà alcun effetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> di flusso utilizza l'algoritmo Nagle.</summary>
        <value>
          <see langword="false" /> se il <see cref="T:System.Net.Sockets.Socket" /> utilizza l'algoritmo Nagle; in caso contrario, <see langword="true" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'algoritmo Nagle è progettato per ridurre il traffico di rete, causando il socket per pacchetti di piccole dimensioni del buffer e quindi combinare e inviarli in un pacchetto in determinate circostanze. Un pacchetto TCP è costituito da 40 byte di intestazione e i dati inviati. Quando i pacchetti di piccole dimensioni dei dati vengono inviati con TCP, l'overhead derivante dall'intestazione TCP può diventare una parte significativa del traffico di rete. In rete con carico elevati, la congestione risultanti da questo sovraccarico può comportare la perdita di datagrammi e tra le ritrasmissioni, nonché il tempo di propagazione eccessivo dovuto congestione. L'algoritmo Nagle impedisce l'invio di nuove TCP segmentswhen nuovo i dati in uscita provenienti dall'utente se tutti i dati trasmessi in precedenza per la connessione rimangano non riconosciuti.  
  
 La maggior parte delle applicazioni di rete deve utilizzare l'algoritmo Nagle.  
  
 Impostazione di questa proprietà su un socket di protocollo UDP (User Datagram) avrà alcun effetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.NoDelay%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il sistema operativo sottostante e gli adattatori di rete supportano il protocollo IPv4.</summary>
        <value>
          <see langword="true" /> se il sistema operativo e gli adattatori di rete supportano il protocollo IPv4. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo può supportare i protocolli IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il sistema operativo sottostante e gli adattatori di rete supportano il protocollo IPv6.</summary>
        <value>
          <see langword="true" /> se il sistema operativo e gli adattatori di rete supportano il protocollo IPv6; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo può supportare i protocolli IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Tempo di attesa per una risposta, espresso in microsecondi.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Determina lo stato del <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Stato dell'oggetto <see cref="T:System.Net.Sockets.Socket" /> in base al valore della modalità di polling passato nel parametro <paramref name="mode" />.  
  
 <list type="table"><listheader><term> Modalità  </term><description> Valore restituito  </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> se è stato chiamato <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> e una connessione è in sospeso;  - oppure - <see langword="true" /> se i dati sono disponibili per la lettura;  - oppure - <see langword="true" /> se la connessione è stata chiusa, reimpostata o terminata;  in caso contrario, restituisce <see langword="false" />.  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, se viene eseguita l'elaborazione di <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> e la connessione è riuscita;  - oppure -  <see langword="true" /> se i dati possono essere inviati;  in caso contrario, restituisce <see langword="false" />.  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> se viene elaborato <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> che non esegue un blocco e la connessione non è riuscita;  - oppure - <see langword="true" /> se <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> non è impostato e sono disponibili dati fuori banda;  in caso contrario, restituisce <see langword="false" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Poll%2A> metodo controllerà lo stato del <xref:System.Net.Sockets.Socket>. Specificare <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> per il `selectMode` parametro per determinare se il <xref:System.Net.Sockets.Socket> è leggibile. Specificare <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> per determinare se il <xref:System.Net.Sockets.Socket> è accessibile in scrittura. Usare <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> per rilevare una condizione di errore. <xref:System.Net.Sockets.Socket.Poll%2A> non bloccherà l'esecuzione fino al periodo di tempo specificato, misurato in `microseconds`, allo scadere. Impostare il `microSeconds` parametro a un numero intero negativo se si desidera attendere una risposta per un periodo illimitato. Se si desidera controllare lo stato di più socket, è preferibile usare il <xref:System.Net.Sockets.Socket.Select%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo metodo non è in grado di rilevare determinati tipi di problemi di connessione, ad esempio un cavo di rete danneggiato o che l'host remoto è stato arrestato in modo anomalo. È necessario tentare di inviare o ricevere dati che consente di rilevare questi tipi di errori.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea un socket, si connette a un server e Usa <xref:System.Net.Sockets.Socket.Poll%2A> per controllare lo stato del socket.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="mode" /> non è uno dei valori di <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Note riportata di seguito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di protocollo del <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ProtocolType%2A> proprietà viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato e specifica il protocollo utilizzato da tale <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <summary>Riceve dati in un buffer di ricezione da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro di buffer e restituisce il numero di byte letti in modo corretto. È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.  
  
 Questo overload è sufficiente fornire un buffer di ricezione. Il valore predefinito è 0, i valori predefiniti delle dimensioni per la lunghezza del parametro di buffer, l'offset del buffer e il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino alla dimensione del buffer. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il datagramma in coda prima dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffer` parametro, `buffer` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente riceve dati su un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</param>
        <summary>Riceve dati da un <see cref="T:System.Net.Sockets.Socket" /> associato nell'elenco dei buffer di ricezione.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge i dati nel parametro del buffer e restituisce il numero di byte letti in modo corretto. È possibile chiamare dal socket orientati alla connessione e senza connessione.  
  
 Questo overload richiede di specificare uno o più buffer di ricezione.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati ricevuti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino alla dimensione del buffer. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffers` parametro, `buffers` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
 **Nota** questo membro genera informazioni di traccia quando si abilita la traccia di rete nell'applicazione. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Riceve dati in un buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro di buffer e restituisce il numero di byte letti in modo corretto. È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.  
  
 Questo overload solo è necessario fornire un buffer di ricezione e le necessarie <xref:System.Net.Sockets.SocketFlags>. L'offset del buffer il valore predefinito è 0, e le dimensioni del valore predefinito è la lunghezza del parametro di byte.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono disponibili per la lettura, dati il <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati. Se si è in modalità non bloccante e non sono presenti dati nel buffer di stack del protocollo, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata una <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile fino alla dimensione del buffer. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffer` parametro, `buffer` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente specifica un buffer di dati, e <xref:System.Net.Sockets.SocketFlags> per la ricezione di dati in un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Riceve dati in un elenco di buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge i dati nel `buffers` parametro e restituisce il numero di byte letti. È possibile chiamare dal socket orientati alla connessione e senza connessione.  
  
 Questo overload richiede di specificare uno o più buffer di ricezione. Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati ricevuti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamare genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino alla dimensione del buffer. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffers` parametro, `buffers` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ricevere i dati su un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.  
  
oppure 
 <paramref name="buffers" />. Il numero totale è zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Riceve in un buffer di ricezione il numero specificato di byte di dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Receive%2A> legge i dati nel metodo il `buffer` parametro e restituisce il numero di byte letti. È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.  
  
 Questo overload solo è necessario fornire un buffer di ricezione, il numero di byte che si desidera ricevere e le necessarie <xref:System.Net.Sockets.SocketFlags>.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino al numero di byte specificato da di `size` parametro. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il datagramma in coda prima dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffer` parametro, `buffer` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il seguente riceve i dati presenti nelle `buffer`e specifica <xref:System.Net.Sockets.SocketFlags.None> per <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> supera la dimensione di <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Riceve dati in un elenco di buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo legge i dati nel `buffers` parametro e restituisce il numero di byte letti. È possibile chiamare dal socket orientati alla connessione e senza connessione.  
  
 Questo overload richiede di specificare uno o più buffer di ricezione. Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati ricevuti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamare genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino alla dimensione del buffer. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> leggerà il datagramma in coda prima dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffers` parametro, `buffers` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.  
  
oppure 
 <paramref name="buffers" />. Il numero totale è zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</param>
        <param name="offset">Posizione in <c>buffer</c> per archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Riceve il numero specificato di byte da un <see cref="T:System.Net.Sockets.Socket" /> associato nella posizione di offset predefinita del buffer di ricezione, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro di buffer e restituisce il numero di byte letti in modo corretto. È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino al numero di byte specificato dal parametro di dimensione. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il datagramma in coda prima dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffer` parametro, `buffer` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente specifica un buffer di dati, un offset, una dimensione e un flag di socket prima della ricezione di dati in un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="offset">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Riceve dati in un buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro di buffer e restituisce il numero di byte letti in modo corretto. È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>. Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si usa un protocollo senza connessione, è anche possibile usare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.  
  
 Se non sono dati disponibili per la lettura, la <xref:System.Net.Sockets.Socket.Receive%2A> metodo si blocca fino a quando non sono disponibili dati, a meno che non è stato impostato un valore di timeout con <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Se si usa una connessione orientato <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà quantità di dati è disponibile, fino al numero di byte specificato dal parametro di dimensione. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
 Se si usa un orientati <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il datagramma in coda prima dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> (metodo). Se il datagramma ricevuto è maggiore della dimensione dei `buffer` parametro, `buffer` viene riempita con la prima parte del messaggio, i dati in eccesso vengono persi e un <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è impostata.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia una richiesta asincrona per ricevere dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> viene usato il metodo socket connessi o socket privi di connessione associata e viene usato per leggere i dati in ingresso. Indirizzo locale del socket deve essere noto.  
  
 Per socket associati senza connessione, questa funzione consente di limitare gli indirizzi da cui vengono accettati i messaggi ricevuti. La funzione restituisce solo i messaggi dall'indirizzo remoto specificato nella connessione. I messaggi provenienti da altri indirizzi vengono scartati.  
  
 Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce al provider di servizio finestra socket con informazioni aggiuntive sulla richiesta di lettura. Per altre informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Per i socket di tipo flusso di byte, i dati in ingresso viene inseriti nel buffer fino a quando non viene riempito il buffer, la connessione viene chiusa o i dati memorizzati internamente nel buffer vengono esauriti.  
  
 Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alla dimensione totale di buffer associato il `e` parametro. Se il messaggio è maggiore del buffer, viene riempito il buffer con la prima parte del messaggio.  
  
 Per i socket orientati alla connessione, il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodo può indicare la chiusura del circuito virtuale in uno dei due modi che variano a seconda se il socket è un flusso di byte o orientato ai messaggi. Per i flussi di byte, pari a zero byte letti indica la chiusura e che nessun più byte verranno mai letto. Per i socket orientato ai messaggi, in cui un messaggio a zero byte spesso è consentito, un <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> insieme al codice di errore Winsock WSAEDISCON nativo (10101) viene utilizzato per indicare la chiusura normale. In ogni caso, un <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> impostato su Winsock WSAECONNRESET nativo il codice di errore (10054) indica una chiusura anomala si è verificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argomento non è valido. Le proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sul parametro <paramref name="e" /> devono fare riferimento a buffer validi. È possibile impostare una di queste due proprietà, ma non entrambe contemporaneamente.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica le dimensioni del buffer di ricezione del <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> contenente le dimensioni, in byte, del buffer di ricezione. Il valore predefinito è 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dimensioni maggiori del buffer potenzialmente riduce il numero di riconoscimenti vuoti (pacchetti TCP che non contengono dati), ma potrebbero anche ritardare il riconoscimento di problemi di connessione. È consigliabile aumentare le dimensioni del buffer se vengono trasferiti i file di grandi dimensioni, o se si utilizza una larghezza di banda elevata, una connessione con latenza elevata (ad esempio un satellite provider di banda larga.)  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione di impostazione è minore di 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve un datagramma e memorizza l'endpoint di origine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</param>
        <summary>Riceve un datagramma nel buffer di dati e memorizza l'endpoint.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati. Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.  
  
 Questo overload solo è necessario fornire un'operazione di ricezione `buffer`e un <xref:System.Net.EndPoint> che rappresenta l'host remoto. L'offset del buffer il valore predefinito è 0. Le dimensioni la lunghezza del valore predefinito è il `buffer` parametro e il `socketFlags` valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale usando il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale. Se il datagramma ricevuto è maggiore della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo riempirà `buffer` con il maggior numero del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo non affidabile, i dati in eccesso andranno perse. Se si usa un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperarla chiamando il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer di dimensione sufficienti.  
  
 Se non sono disponibili per la lettura, dati il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo si blocca fino a quando non sono disponibili dati. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Sebbene <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile usare anche un protocollo orientato alla connessione. Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo o accettare un'istanza remota in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e ricevere solo i dati da connesso o dell'host remoto predefinito.  
  
 Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà quantità di dati è disponibile fino alla dimensione di `buffer`. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usati in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usato in <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente riceve un datagramma senza connessione da un host remoto.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</param>
        <summary>Riceve un datagramma nel buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati. Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.  
  
 Questo overload solo è necessario fornire un buffer di ricezione, necessari <xref:System.Net.Sockets.SocketFlags>e un <xref:System.Net.EndPoint> che rappresenta l'host remoto. L'offset valore predefinito è 0 e le dimensioni il valore predefinito è la lunghezza del parametro di buffer.  
  
> [!NOTE]
>  Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale usando il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale. Se il datagramma ricevuto è maggiore della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo riempirà `buffer` con il maggior numero del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo non affidabile, i dati in eccesso andranno perse. Se si usa un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperarla chiamando il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer di dimensione sufficienti.  
  
 Se non sono disponibili per la lettura, dati il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo si blocca fino a quando non sono disponibili dati. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Sebbene <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile usare anche un protocollo orientato alla connessione. Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo o accettare un'istanza remota in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e ricevere solo i dati da connesso o dell'host remoto predefinito.  
  
 Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà quantità di dati è disponibile fino alla dimensione di `buffer`. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usati in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usato in <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente riceve un datagramma senza connessione da un host remoto. <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</param>
        <summary>Riceve il numero di byte specificato nel buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati. Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.  
  
 Questo overload solo è necessario fornire un buffer di ricezione, il numero di byte che si desidera ricevere, necessari <xref:System.Net.Sockets.SocketFlags>e un <xref:System.Net.EndPoint> che rappresenta l'host remoto. L'offset del buffer il valore predefinito è 0.  
  
 Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale. Se il datagramma ricevuto è maggiore della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo riempirà `buffer` con il maggior numero del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo non affidabile, i dati in eccesso andranno perse. Se si usa un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperarla chiamando il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer di dimensione sufficienti.  
  
 Se non sono disponibili per la lettura, dati il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo si blocca fino a quando non sono disponibili dati. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Sebbene <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile usare anche un protocollo orientato alla connessione. Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo o accettare un'istanza remota in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e ricevere solo i dati da connesso o dell'host remoto predefinito.  
  
 Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà quantità di dati è disponibile fino al numero di byte specificato da di `size` parametro. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
> [!NOTE]
>  Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale usando il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usati in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usato in <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente riceve un datagramma senza connessione da un host remoto. Le dimensioni del buffer, e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</param>
        <param name="offset">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</param>
        <summary>Riceve il numero specificato di byte di dati nella posizione specificata del buffer di dati usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e archivia l'endpoint.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati. Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.  
  
 Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale. Se il datagramma ricevuto è maggiore della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo riempirà `buffer` con il maggior numero del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo non affidabile, i dati in eccesso andranno perse. Se si usa un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperarla chiamando il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer di dimensione sufficienti.  
  
 Se non sono disponibili per la lettura, dati il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo si blocca fino a quando non sono disponibili dati. Se si è in modalità non bloccante e non sono presenti dati disponibili nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e verrà generata un <xref:System.Net.Sockets.SocketException>. È possibile usare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati. Quando si <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.  
  
 Sebbene <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile usare anche un protocollo orientato alla connessione. Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo o accettare un'istanza remota in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo). In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e ricevere solo i dati da connesso o dell'host remoto predefinito.  
  
 Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà quantità di dati è disponibile fino alla quantità di byte specificato da di `size` parametro. Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completata immediatamente e restituire zero byte.  
  
> [!NOTE]
>  Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale usando il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usati in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usato in <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente riceve un datagramma senza connessione da un host remoto. L'offset, la dimensione del buffer, e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro di offset.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.  
  
oppure 
Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Inizia a ricevere dati in modalità asincrona da un dispositivo di rete specificato.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> metodo viene utilizzato principalmente per la ricezione dei dati su un socket non orientato alla connessione. Indirizzo locale del socket deve essere noto.  
  
 Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto da cui deve essere ricevuti i dati.  
  
 Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce al provider di servizio finestra socket con informazioni aggiuntive sulla richiesta di lettura. Per altre informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alla dimensione totale di buffer. Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> proprietà determinano dove vengono inseriti i dati nel buffer e la quantità di dati.  
  
 Per i socket di flusso di tipo byte, i dati in ingresso viene inseriti nel buffer fino a quando non viene riempito il buffer, la connessione viene chiusa o i dati memorizzati internamente nel buffer vengono esauriti. Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> proprietà determinano dove vengono inseriti i dati nel buffer e la quantità di dati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</param>
        <param name="offset">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</param>
        <param name="size">Numero di byte da ricevere.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.Sockets.IPPacketInformation" /> contenente informazioni sull'indirizzo e sull'interfaccia.</param>
        <summary>Riceve il numero specificato di byte di dati nella posizione specificata del buffer dei dati usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e archivia le informazioni dell'endpoint e del pacchetto.</summary>
        <returns>Numero di byte ricevuti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui è stati inviati i dati, nonché informazioni sul pacchetto ricevuto.  
  
 Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo viene utilizzato principalmente per ricevere i dati del messaggio su un socket non orientato alla connessione. Indirizzo locale del socket deve essere noto. Questo metodo può essere utilizzato solo con datagramma e raw socket. Il socket deve essere inizializzato con il tipo di socket impostato su <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> prima di chiamare questo metodo. Ciò può essere eseguita quando il socket viene costruito usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Per i socket orientato ai messaggi, è stato inserito un messaggio in arrivo il `buffer` fino alla dimensione totale, specificata nel parametro il `size` parametro. Il `offset` parametro determina la posizione di `buffer` vengono inseriti i dati. La quantità effettiva di dati inseriti nel `buffer` restituito dal <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> (metodo).  
  
 Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo imposta automaticamente il <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` la prima volta che viene chiamato per un determinato <xref:System.Net.Sockets.Socket>. Tuttavia, l'oggetto restituito <xref:System.Net.Sockets.IPPacketInformation> oggetto sarà valido solo per i pacchetti che arrivano al computer locale dopo aver impostato l'opzione di socket. Se vengono inviati i pacchetti tra un socket quando è associato a un endpoint locale (in modo esplicito dal <xref:System.Net.Sockets.Socket.Bind%2A> metodo o in modo implicito da uno del <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodi) e la prima chiamata al <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo, le chiamate a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo restituirà valido <xref:System.Net.Sockets.IPPacketInformation> oggetti per tali pacchetti.  
  
 Per garantire che tutti i <xref:System.Net.Sockets.IPPacketInformation> gli oggetti sono validi, un'applicazione deve impostare la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` prima che venga associato a un endpoint locale usando il <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (metodo).  
  
 Un'applicazione può esaminare la `ipPacketInformation` parametro se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.  
  
> [!NOTE]
>  Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usati in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> usato in <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
\- oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro di offset.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.  
  
oppure 
.NET Framework viene eseguito in un processore AMD a 64 bit.  
  
oppure 
Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">per accettare connessioni dalla rete. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Avvia la ricezione asincrona del numero di byte specificato in una posizione specificata nel buffer di dati, utilizzando l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> specificato, e memorizza l'endpoint e le informazioni sui pacchetti.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo viene utilizzato principalmente per ricevere i dati del messaggio su un socket non orientato alla connessione. Indirizzo locale del socket deve essere noto. Questo metodo può essere utilizzato solo con datagramma e raw socket. Il socket deve essere inizializzato con il tipo di socket impostato su <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> prima di chiamare questo metodo. Ciò può essere eseguita quando il socket viene costruito usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto da cui deve essere ricevuti i dati.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alla dimensione totale di buffer. Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> proprietà determinano dove vengono inseriti i dati nel buffer e la quantità di dati.  
  
 Il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo imposta automaticamente il <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` la prima volta che viene chiamato per un determinato <xref:System.Net.Sockets.Socket>. Tuttavia, il <xref:System.Net.Sockets.IPPacketInformation> oggetto sarà valido solo per i pacchetti che arrivano al computer locale dopo aver impostato l'opzione di socket. Se vengono inviati i pacchetti tra un socket quando il socket è associato a un endpoint locale (in modo esplicito dal <xref:System.Net.Sockets.Socket.Bind%2A> metodo o in modo implicito da uno del <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodi) e la prima chiamata al <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>metodo, le chiamate a <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo comporterà valido <xref:System.Net.Sockets.IPPacketInformation> oggetti per tali pacchetti.  
  
 Per garantire che tutti i <xref:System.Net.Sockets.IPPacketInformation> gli oggetti sono validi, un'applicazione deve impostare la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket`true` prima che venga associato a un endpoint locale usando il <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> (metodo).  
  
 Un'applicazione può esaminare l'oggetto risultante <xref:System.Net.Sockets.IPPacketInformation> oggetti se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica l'intervallo di tempo dopo il quale si verifica il timeout di una chiamata <see cref="Overload:System.Net.Sockets.Socket.Receive" /> sincrona.</summary>
        <value>Valore di timeout in millisecondi. Il valore predefinito è 0, che indica un periodo di timeout indeterminato. Anche il valore -1 indica un periodo di timeout indeterminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa opzione si applica a sincrono <xref:System.Net.Sockets.Socket.Receive%2A> solo le chiamate. Se viene superato il periodo di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione set è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'endpoint remoto.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> con cui comunica il <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property get il <xref:System.Net.EndPoint> che contiene l'IP indirizzo e la porta numero remoto a cui il <xref:System.Net.Sockets.Socket> è connesso. Se si usa un protocollo senza connessione, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contiene l'indirizzo IP remoto predefinito e il numero di porta con cui il <xref:System.Net.Sockets.Socket> comunicherà. È necessario eseguire il cast di questo <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> prima di recuperare tutte le informazioni. È quindi possibile chiamare il <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per recuperare il computer remoto <xref:System.Net.IPAddress>e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per recuperare il numero di porta remota.  
  
 Il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> viene impostata dopo una chiamata a uno <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.Connect%2A>. Se si prova ad accedere a versioni precedenti, questa proprietà <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente recupera e visualizza gli endpoint locali e remoti.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> di cui verificare la possibilità di lettura.</param>
        <param name="checkWrite">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> di cui verificare la possibilità di scrittura.</param>
        <param name="checkError">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> in cui verificare la presenza di errori.</param>
        <param name="microSeconds">Valore di timeout in microsecondi. Il valore -1 indica un periodo di timeout infinito.</param>
        <summary>Determina lo stato di uno o più socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> è un metodo statico che determina lo stato di uno o più <xref:System.Net.Sockets.Socket> istanze. È necessario inserire uno o più socket in un <xref:System.Collections.IList> prima di poter usare il <xref:System.Net.Sockets.Socket.Select%2A> (metodo). Verificare la presenza di una maggiore leggibilità chiamando <xref:System.Net.Sockets.Socket.Select%2A> con il <xref:System.Collections.IList> come la `checkRead` parametro. Per controllare la leggibilità dei socket, usare il `checkWrite` parametro. Per il rilevamento di condizioni di errore, usare `checkError`. Dopo avere chiamato <xref:System.Net.Sockets.Socket.Select%2A>, il <xref:System.Collections.IList> verrà compilato solo con i socket che soddisfano le condizioni.  
  
 Se trovano in uno stato di ascolto, migliorare la leggibilità significa che una chiamata a <xref:System.Net.Sockets.Socket.Accept%2A> avrà esito positivo senza bloccare. Se è stato già accettato la connessione, la leggibilità significa che sono disponibili per la lettura dei dati. In questi casi, tutte le operazioni di ricezione avranno esito positivo senza bloccare. Leggibilità può anche indicare se il computer remoto <xref:System.Net.Sockets.Socket> ha chiuso la connessione all'oggetto; in tal caso una chiamata a <xref:System.Net.Sockets.Socket.Receive%2A> restituirà immediatamente il controllo con zero byte.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> restituito quando almeno uno dei socket di interesse (i socket nel `checkRead`, `checkWrite`, e `checkError` Elenca) soddisfa i criteri specificati, o `microSeconds` parametro viene superato, a seconda del valore raggiunto per primo. Impostazione `microSeconds` su -1 specifica un timeout infinito.  
  
 Se si effettua una chiamata non bloccante per <xref:System.Net.Sockets.Socket.Connect%2A>, scrivibilità significa che è stata stabilita. Se già stata stabilita una connessione, la scrivibilità indica che tutte invio operazioni avrà esito positivo senza bloccare.  
  
 Se è stata effettuata una chiamata non bloccante per <xref:System.Net.Sockets.Socket.Connect%2A>, il `checkerror` parametro identifica i socket che non si sono connessi correttamente.  
  
> [!NOTE]
>  Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo se si vuole solo determinare lo stato di una singola <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Questo metodo non è in grado di rilevare determinati tipi di problemi di connessione, ad esempio un cavo di rete danneggiato o che l'host remoto è stato arrestato in modo anomalo. È necessario tentare di inviare o ricevere dati che consente di rilevare questi tipi di errori.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.Select%2A> per determinare quali socket in attesa una richiesta di connessione.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="checkRead" /> è <see langword="null" /> o vuoto.  
  
-e- 
Il parametro <paramref name="checkWrite" /> è <see langword="null" /> o vuoto 
-e- 
Il parametro <paramref name="checkError" /> è <see langword="null" /> o vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia dati a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <summary>Invia dati a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dei dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo e restituisce il numero di byte inviato. <xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 Questo overload richiede un buffer che contiene i dati da inviare. Il <xref:System.Net.Sockets.SocketFlags> valore valore predefinito è 0, l'offset del buffer il valore predefinito è 0 e il numero di byte da inviare le impostazioni predefinite per le dimensioni del buffer.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato correttamente, anche se invia inferiore al numero di byte nel buffer. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'invio dei dati in un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</param>
        <summary>Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 Questo overload richiede almeno un buffer che contiene i dati da inviare.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato correttamente, anche se invia inferiore al numero di byte nel buffer. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> è vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Vedere la sezione Osservazioni riportata di seguito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Invia dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dei dati all'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo e restituisce il numero di byte inviato. Il <xref:System.Net.Sockets.Socket.Send%2A> metodo può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 Questo overload richiede un buffer che contiene i dati desiderati per l'invio e una combinazione bit per bit di <xref:System.Net.Sockets.SocketFlags>. L'offset del buffer il valore predefinito è 0 e il numero di byte da inviare le impostazioni predefinite per le dimensioni del buffer. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` valore del parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata al metodo <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato correttamente, anche se invia inferiore al numero di byte nel buffer. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  È necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'invio dei dati in un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando i <see cref="T:System.Net.Sockets.SocketFlags" /> specificati.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload richiede almeno un buffer che contiene i dati da inviare. Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketFlags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato correttamente, anche se invia inferiore al numero di byte nel buffer. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> è vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dei dati all'host remoto stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo e restituisce il numero di byte inviato. <xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 Questo overload richiede un buffer che contiene i dati da inviare, il numero di byte da inviare e una combinazione bit per bit di qualsiasi <xref:System.Net.Sockets.SocketFlags>. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata al metodo il <xref:System.Net.Sockets.Socket.Send%2A> (metodo). È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Con un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato anche se invia inferiore al numero di byte richiesto. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  È necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente invia i dati trovati nel buffer e specifica <xref:System.Net.Sockets.SocketFlags.None> per <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> è inferiore a 0 o supera la dimensione del buffer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
Si è verificato un errore del sistema operativo durante l'accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando i <see cref="T:System.Net.Sockets.SocketFlags" /> specificati.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload richiede almeno un buffer che contiene i dati da inviare. Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketFlags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). Se non si usa la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato correttamente, anche se invia inferiore al numero di byte nel buffer. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> è vuoto.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione nel buffer di dati da cui iniziare l'invio di dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, a partire dall'offset specificato e usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dei dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo e restituisce il numero di byte inviato. <xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 In questo overload, se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo oppure <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A>. Se non si usa <xref:System.Net.Sockets.Socket.SendTo%2A>, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 È anche necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato anche se invia inferiore al numero di byte richiesto. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente specifica il buffer dei dati, un offset, una dimensione, e <xref:System.Net.Sockets.SocketFlags> per inviare dati a un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione nel buffer di dati da cui iniziare l'invio di dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</param>
        <summary>Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, a partire dall'offset specificato e utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dei dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo e restituisce il numero di byte inviato. <xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.  
  
 In questo overload, se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo oppure <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo senza connessione e si intende inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A>. Se non si usa <xref:System.Net.Sockets.Socket.SendTo%2A>, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>. È possibile usare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>. È anche possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> eseguendo un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 È anche necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.Send%2A> bloccherà fino a quando non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genera un <xref:System.Net.Sockets.SocketException>. In modalità non di blocco, <xref:System.Net.Sockets.Socket.Send%2A> può essere completato anche se invia inferiore al numero di byte richiesto. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Il completamento di una trasmissione non indica che i dati è stati recapitati correttamente. Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente specifica il buffer dei dati, un offset, una dimensione, e <xref:System.Net.Sockets.SocketFlags> per inviare dati a un elemento connesso <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Invia i dati in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo viene utilizzato per scrivere dati in uscita da uno o più buffer su un socket orientato alla connessione. Questo metodo è anche utilizzabile, tuttavia, sui socket orientati che hanno specificato un host remoto in un'operazione di connessione.  
  
 Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo avvia un'operazione di invio asincrono per l'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (metodo).  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo genererà un'eccezione se non è necessario chiamare innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 La chiamata di <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato.  
  
 Per i socket orientato ai messaggi, non superare la dimensione massima dei messaggi del provider di servizi sottostante Windows sockets. Se i dati sono troppo lunghi da passare in modo atomico tramite il provider del servizio sottostante, non vengono trasmessi dati e il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo genera un <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> impostato per il codice di errore Winsock WSAEMSGSIZE (10040) nativo.  
  
 Si noti che il completamento del <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo non indica che i dati è stati recapitati correttamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sul parametro <paramref name="e" /> devono fare riferimento a buffer validi. È possibile impostare una di queste due proprietà, ma non entrambe contemporaneamente.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è ancora connesso o non è stato ottenuto tramite un metodo <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> o <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica le dimensioni del buffer di invio del <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> contenente le dimensioni, in byte, del buffer di invio. Il valore predefinito è 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una dimensione del buffer più grande potrebbe ritardare il riconoscimento di problemi di connessione. È consigliabile aumentare le dimensioni del buffer se vengono trasferiti i file di grandi dimensioni, o se si utilizza una larghezza di banda elevata, una connessione con latenza elevata (ad esempio un satellite provider di banda larga.)  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.SendBufferSize%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione di impostazione è minore di 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia un file e dati opzionali in modalità sincrona a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Oggetto <see cref="T:System.String" /> che contiene il percorso e il nome del file da inviare. Questo parametro può essere <see langword="null" />.</param>
        <summary>Invia il file <paramref name="fileName" /> a un oggetto connesso <see cref="T:System.Net.Sockets.Socket" /> con il flag di trasmissione <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload invia il file `fileName` al socket connesso. Il `flags` parametro viene impostato su <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) e il `preBuffer` e `postBuffer` per impostazione predefinita i parametri `null`. Se `fileName` è nella directory locale, potrebbe essere identificato utilizzando solo il nome del file; in caso contrario, deve essere specificati il percorso completo e nome del file. I caratteri jolly (".. \\\myfile.txt ") e nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati. Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.  
  
 Questo metodo Usa il `TransmitFile` funzione disponibile nell'API di Windows Sockets versione 2. Per altre informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di socket di Windows in MSDN Library.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> Invia in modo sincrono un file nell'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). <xref:System.Net.Sockets.Socket.SendFile%2A> può essere utilizzato per entrambi orientato alla connessione e protocolli senza connessione.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, in caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> genera un <xref:System.Net.Sockets.SocketException> eccezione. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.SendFile%2A> blocca finché non viene inviato il file. In modalità non di blocco, <xref:System.Net.Sockets.Socket.SendFile%2A> può essere completato prima che l'intero file è stato inviato. Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendFile%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea e si connette a un socket e invia quindi un file all'host remoto. Il file "test. txt" si trova nella directory radice del computer locale.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il socket non è connesso a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è in modalità di blocco e non può accettare questa chiamata sincrona.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="fileName" /> del file non è stato trovato.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Oggetto <see cref="T:System.String" /> che contiene il percorso e il nome del file da inviare. Questo parametro può essere <see langword="null" />.</param>
        <param name="preBuffer">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare prima dell'invio del file. Questo parametro può essere <see langword="null" />.</param>
        <param name="postBuffer">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare dopo l'invio del file. Questo parametro può essere <see langword="null" />.</param>
        <param name="flags">Uno o più valori di <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Invia il file <paramref name="fileName" /> e i buffer di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso usando il valore di <see cref="T:System.Net.Sockets.TransmitFileOptions" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload richiede il nome del file da inviare e una combinazione bit per bit di <xref:System.Net.Sockets.TransmitFileOptions> valori. Il `preBuffer` parametro contiene tutti i dati che si desidera far precedere il file. `postBuffer` contiene dati che si desidera eseguire il file. Se `fileName` è nella directory di lavoro corrente, potrebbe essere identificato utilizzando solo il nome del file; in caso contrario, deve essere specificati il percorso completo e nome del file. I caratteri jolly (".. \\\myfile.txt ") e nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati.  
  
 Il `flags` parametro fornisce al provider di servizio finestra socket con informazioni aggiuntive sul trasferimento di file. Per altre informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Questo metodo Usa il `TransmitFile` funzione disponibile nell'API di Windows Sockets versione 2. Per altre informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di socket di Windows in MSDN Library.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> Invia in modo sincrono un file nell'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). <xref:System.Net.Sockets.Socket.SendFile%2A> può essere utilizzato per entrambi orientato alla connessione e protocolli senza connessione.  
  
 Se si usa un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo; in caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> genera un <xref:System.Net.Sockets.SocketException>. Se si usa un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.  
  
 Se si usa un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.SendFile%2A> blocca finché non viene inviato l'intero file. In modalità non di blocco, <xref:System.Net.Sockets.Socket.SendFile%2A> può essere completato prima che l'intero file è stato inviato. Non c'è garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendFile%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea e connette un socket. Il file "test. txt" si trova nella directory radice del computer locale. In questo esempio, si crea un prebuffer e postbuffer dei dati e inviarli all'host remoto con il file. Il valore predefinito <xref:System.Net.Sockets.TransmitFileOptions> vengono usati.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il sistema operativo non è Windows NT o versioni successive.  
  
\- oppure - 
Il socket non è connesso a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è in modalità di blocco e non può accettare questa chiamata sincrona.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="fileName" /> del file non è stato trovato.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Invia in modo asincrono un insieme di file o di buffer di dati in memoria a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo viene utilizzato per inviare una raccolta di file o della memoria buffer di dati all'host remoto. Il <xref:System.Net.Sockets.Socket> deve già essere connesso all'host remoto.  
  
 Se un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> fa riferimento a un file nella directory di lavoro, può essere identificato utilizzando solo il nome del file; in caso contrario, deve essere specificati il percorso completo e nome del file. Sono supportati i caratteri jolly e i nomi delle condivisioni UNC. Se il file non viene trovato, <xref:System.IO.FileNotFoundException> viene generata un'eccezione.  
  
 Per ricevere una notifica del completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce al provider di servizio finestra socket con informazioni aggiuntive sul trasferimento di file. Per altre informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Questo metodo Usa la funzione TransmitPackets disponibile nell'API di Windows Sockets versione 2. Per altre informazioni sulla funzione TransmitPackets e i relativi flag, vedere la documentazione di socket di Windows in MSDN Library.  
  
 Sebbene sia destinato ai protocolli orientati alla connessione, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo per stabilire un host remoto predefinito. Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non viene inviato datagramma e <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> genera un <xref:System.Net.Sockets.SocketException> eccezione.  
  
 Il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo è ottimizzato in base al sistema operativo in cui viene usato. Nelle edizioni di Windows server, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo sia ottimizzato per prestazioni elevate.  
  
 Nelle edizioni di client Windows, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo è ottimizzato per l'utilizzo della memoria e risorse minima.  
  
 Usare il <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag nel <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> proprietà il `e` parametri possono offrire vantaggi significativi delle prestazioni. Se l'avvio di thread di <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> chiamata al metodo viene utilizzata per i calcoli elevati, è possibile, anche se improbabile, che inizializza potrebbe essere impedito l'avvio. Si noti che sussiste una differenza tra Inizializza in modalità utente e kernel. Kernel vengono avviate quando un thread si trova in uno stato di attesa. In modalità utente vengono avviate quando un thread si trova in uno stato di attesa di avviso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file specificato dalla proprietà <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva. Questa eccezione si verifica anche se l'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è connesso a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">È in uso un oggetto <see cref="T:System.Net.Sockets.Socket" /> privo di connessione e il file inviato supera la dimensione massima del pacchetto del trasporto sottostante.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica l'intervallo di tempo dopo il quale si verifica il timeout di una chiamata <see cref="Overload:System.Net.Sockets.Socket.Send" /> sincrona.</summary>
        <value>Valore di timeout in millisecondi. Se si imposta per la proprietà un valore compreso tra 1 e 499, il valore verrà impostato su 500. Il valore predefinito è 0, che indica un periodo di timeout indeterminato. Anche il valore -1 indica un periodo di timeout indeterminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa opzione si applica a sincrono <xref:System.Net.Sockets.Socket.Send%2A> solo le chiamate. Se viene superato il periodo di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.SendTimeout%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione set è minore di -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia dati a uno specifico endpoint.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="remoteEP">Classe <see cref="T:System.Net.EndPoint" /> che rappresenta la destinazione dei dati.</param>
        <summary>Invia dati a un endpoint specifico.</summary>
        <returns>Numero di byte inviati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questo overload, l'offset del buffer il valore predefinito è 0, il numero di byte da inviare le impostazioni predefinite per le dimensioni dei `buffer` parametro e il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0.  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.Send%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro ignora l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se è necessario identificare il numero di porta e indirizzo di rete locale assegnata, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.  
  
 Sebbene sia destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione. Se si usa un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso usando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione all'host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). In entrambi i casi <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo inviare dati a connesso o l'host remoto predefinito.  
  
 Socket di blocco si bloccherà fino a quando non vengono inviati tutti i byte nel buffer. Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte di `buffer`. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia tutti i byte di `buffer`. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
 Se si usa un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> si bloccherà fino a quando non viene inviato datagramma. Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. È anche necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente invia un datagramma privo di connessione all'host remoto specificato.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</param>
        <summary>Invia dati a un endpoint specifico utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questo overload, il valore predefinito è 0 e il numero di byte da inviare le impostazioni predefinite per le dimensioni di l'offset del buffer di `buffer`. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.Send%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro ignora l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se è necessario identificare il numero di porta e indirizzo di rete locale assegnata, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.  
  
 Sebbene sia destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione. Se si usa un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso usando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione all'host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). In entrambi i casi <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo inviare dati a connesso o l'host remoto predefinito.  
  
 Blocco sockets bloccherà finché l'oggetto richiesto tutti i byte nel `buffer` vengono inviati. Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte di `buffer`. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia tutti i byte di `buffer`. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
 Se si usa un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> si bloccherà fino a quando non viene inviato datagramma. Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. È anche necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente invia un datagramma privo di connessione all'host remoto specificato. <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</param>
        <summary>Invia il numero specificato di byte di dati all'endpoint specificato, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questo overload, l'offset del buffer il valore predefinito è 0. Se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.Send%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro ignora l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se è necessario identificare il numero di porta e indirizzo di rete locale assegnata, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.  
  
 Sebbene sia destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione. Se si usa un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso usando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione all'host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). In entrambi i casi <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo inviare dati a connesso o l'host remoto predefinito.  
  
 Socket di blocco si bloccherà fino a quando non viene inviato il numero di byte richiesto. Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte richiesti in un'unica operazione. È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
 Se si usa un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> si bloccherà fino a quando non viene inviato datagramma. Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. È anche necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente invia un datagramma privo di connessione all'host remoto specificato. Le dimensioni e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="size" /> eccede la dimensione di <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</param>
        <param name="offset">Posizione nel buffer di dati da cui iniziare l'invio di dati.</param>
        <param name="size">Numero di byte da inviare.</param>
        <param name="socketFlags">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</param>
        <summary>Invia il numero di byte di dati specificato all'endpoint specificato, a partire dalla posizione specificata nel buffer, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</summary>
        <returns>Numero di byte inviati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questo overload, se si specifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegnare come il `socketflags` parametro, i dati si invia non verranno indirizzati.  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.Send%2A> (metodo). Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro ignora l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider di servizi sottostante verrà assegnato il numero di porta e indirizzo di rete locale più appropriato. Se è necessario identificare il numero di porta e indirizzo di rete locale assegnata, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.  
  
 Sebbene sia destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione. Se si usa un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso usando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo). Se si non stabilire o accettare una connessione all'host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>. È anche possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo). In entrambi i casi <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo inviare dati a connesso o l'host remoto predefinito.  
  
 Socket di blocco si bloccherà fino a quando non viene inviato il numero di byte richiesto. Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte richiesti in un'unica operazione. È responsabilità dell'utente delle applicazioni per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto. Non vi è alcuna garanzia che i dati inviati verranno visualizzati immediatamente nella rete. Per aumentare l'efficienza della rete, il sistema sottostante può ritardare la trasmissione fino a quando non vengono raccolti una notevole quantità di dati in uscita. Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante ha spazio sufficiente per buffer per l'invio dei dati per una rete.  
  
 Se si usa un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> si bloccherà fino a quando non viene inviato datagramma. Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. È anche necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Esempio di codice seguente invia un datagramma privo di connessione all'host remoto specificato. L'offset, le dimensioni, e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> (metodo).  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.  
  
oppure 
 <paramref name="remoteEP" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> è minore di 0.  
  
oppure 
 <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.  
  
oppure 
 <paramref name="size" /> è minore di 0.  
  
oppure 
 <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> non è una combinazione valida di valori.  
  
oppure 
Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</param>
        <summary>Invia i dati in modo asincrono a un host remoto specifico.</summary>
        <returns>Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso. Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.  
  
Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono. In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo avvia un'operazione di invio asincrono per l'host remoto specificato nella <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà del `e` parametro. La chiamata di <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo offre la possibilità di inviare dati all'interno di un thread di esecuzione separato. Sebbene questo metodo è destinato ai protocolli senza connessione <xref:System.Net.Sockets.Socket.SendToAsync%2A> funziona con i protocolli senza connessione e orientato alla connessione.  
  
 Per ricevere una notifica del completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 Proprietà ed eventi in seguito il <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà su qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo, in modo che le informazioni non potrà essere recuperate tramite il metodo di callback. Se il callback richiede più informazioni rispetto a un singolo oggetto, è possibile creare una classe piccola per contenere le altre informazioni sullo stato necessarie come membri.  
  
 Se si usa un protocollo orientato alla connessione, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (metodo). In caso contrario <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>. Quando si usa un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo ignorerà il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà e invia dati al <xref:System.Net.EndPoint?displayProperty=nameWithType> stabilita nel <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (metodo).  
  
 Se si usa un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendToAsync%2A>. È sufficiente eseguire questa operazione se si prevede di chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.SendAsync%2A> metodi. Se si chiama il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendToAsync%2A>, il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio. Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> (metodo). In questo caso, il provider di servizi sottostanti assegnerà il più appropriato retelocale indirizzo IP e porta numero. Se si desidera che il provider di servizi sottostante per selezionare una porta disponibile, usare un numero di porta pari a zero. Se è necessario identificare il numero di porta e indirizzo IP assegnato rete locale, è possibile usare la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento viene segnalato e i delegati associati vengono chiamati.  
  
 Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare innanzitutto le <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> su true. È anche necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante. In caso affermativo, non verrà inviato datagramma e <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>.  
  
 Se si specifica il flag DontRoute nel <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà, i dati si invia non verranno indirizzati.  
  
 Per i socket orientato ai messaggi, prestare attenzione a non superare la dimensione massima dei messaggi del trasporto sottostante. Se le dimensioni del buffer superano le dimensioni massime del provider del servizio sottostante, non viene inviato datagramma e <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>. Il completamento di un <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo non indica che i dati è stati recapitati correttamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</exception>
        <exception cref="T:System.InvalidOperationException">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Per questo metodo è necessario Windows XP o versione successiva.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Il protocollo specificato è orientato alla connessione, ma l'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è ancora connesso.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Livello di protezione IP da impostare in questo socket.</param>
        <summary>Imposta il livello di protezione IP in un socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> metodo consente di limitare un un socket IPv6 o indirizzo IP per l'ascolto su un ambito specificato, ad esempio indirizzi con lo stesso prefisso locale del sito o al collegano. Questa opzione socket consente alle applicazioni di inserire restrizioni di accesso sui socket IPv6 o indirizzo IP. Tali restrizioni consentono a un'applicazione in esecuzione su una LAN privata di proteggersi in modo semplice e affidabile da attacchi esterni. Questa opzione socket è anche utilizzabile per rimuovere le restrizioni di accesso se il `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Questa opzione socket allarga o restringe l'ambito di un socket in attesa, consentendo l'accesso illimitato di utenti pubblici e privati, laddove appropriato, o limitando l'accesso solo al medesimo sito, secondo le necessità.  
  
 Questa opzione socket ha definito i livelli di protezione specificati nell'enumerazione <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 Il <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> metodo viene utilizzato per abilitare o disabilitare l'attraversamento di indirizzo di rete (NAT) per un <xref:System.Net.Sockets.Socket> istanza. Attraversamento NAT può essere fornito tramite un tunnel ISATAP, 6to4 o Teredo.  
  
 Quando la `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, o <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, si disabilita in modo esplicito l'attraversamento di NAT per un <xref:System.Net.Sockets.Socket> istanza.  
  
 Quando la `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, può consentire l'attraversamento di NAT per una <xref:System.Net.Sockets.Socket> a seconda delle regole firewall attive sul sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="level" /> non può essere <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Non è possibile impostare il livello di protezione IP su non specificato.</exception>
        <exception cref="T:System.NotSupportedException">Il <see cref="T:System.Net.Sockets.AddressFamily" /> del socket deve essere <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta un'opzione di <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Il valore dell'opzione, rappresentato come <see cref="T:System.Boolean" />.</param>
        <summary>Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore <see cref="T:System.Boolean" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Impostare `optionValue` al `true` per abilitare l'opzione, oppure a `false` per disabilitare l'opzione.  
  
 <xref:System.Net.Sockets.Socket> le opzioni sono raggruppate in base a livello di supporto del protocollo.  
  
 Di seguito sono elencati i vari <xref:System.Net.Sockets.Socket> opzioni che possono essere impostate tramite l'overload. Queste opzioni sono raggruppate in base appropriata <xref:System.Net.Sockets.SocketOptionLevel> valore. Se si prevede di impostare queste opzioni, assicurarsi di usare appropriato <xref:System.Net.Sockets.SocketOptionLevel> valore per il `optionLevel` parametro. È necessario specificare l'opzione da impostare nel `optionName` parametro. Se si desidera ottenere il valore corrente di una delle opzioni elencate, usare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (metodo).  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Per altre informazioni su queste opzioni, vedere il <xref:System.Net.Sockets.SocketOptionName> enumerazione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
   
  
## Examples  
 Esempio di codice seguente consente di aprire un socket e abilita il `DontLinger` e il `OutOfBandInline` opzioni del socket.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta il valore dell'opzione.</param>
        <summary>Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore specificato, rappresentato come una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Utilizzare questo overload per configurare tali <xref:System.Net.Sockets.Socket> le opzioni che richiedono una matrice di byte come valore di opzione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> i valori di timeout.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Valore dell'opzione.</param>
        <summary>Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sull'intero specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Per un'opzione con un <xref:System.Boolean> tipo di dati, specificare un valore diverso da zero per abilitare l'opzione e il valore zero per disabilitare l'opzione. Per un'opzione con un tipo di dati integer, specificare il valore appropriato. <xref:System.Net.Sockets.Socket> le opzioni sono raggruppate in base a livello di supporto del protocollo.  
  
 Di seguito sono elencati i vari <xref:System.Net.Sockets.Socket> opzioni che possono essere impostate tramite l'overload. Queste opzioni sono raggruppate in base appropriata <xref:System.Net.Sockets.SocketOptionLevel>. Se si prevede di impostare queste opzioni, assicurarsi di usare appropriato <xref:System.Net.Sockets.SocketOptionLevel> per il `optionLevel` parametro. È necessario specificare l'opzione da impostare nel `optionName` parametro. Se si desidera ottenere il valore corrente di una delle opzioni elencate, usare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (metodo).  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> opzioni che possono essere impostate tramite l'overload.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Per altre informazioni su queste opzioni, vedere il <xref:System.Net.Sockets.SocketOptionName> enumerazione.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> i valori di timeout.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">
          <see cref="T:System.Net.Sockets.LingerOption" /> o <see cref="T:System.Net.Sockets.MulticastOption" /> contenente il valore dell'opzione.</param>
        <summary>Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore specificato, rappresentato come un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>. Utilizzare questo overload per impostare il <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opzioni. Per il <xref:System.Net.Sockets.SocketOptionName.Linger> opzione, utilizzare <xref:System.Net.Sockets.Socket> per il `optionLevel` parametro. Per la <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, usare <xref:System.Net.Sockets.SocketOptionLevel.IP>. Se si desidera ottenere il valore corrente di una delle opzioni elencate in precedenza, usare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> (metodo).  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
   
  
## Examples  
 I seguente esempio di codice impostare il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> i valori di timeout.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Uno dei valori <see cref="T:System.Net.Sockets.SocketShutdown" /> che specifica che l'operazione non sarà più consentita.</param>
        <summary>Disabilita le operazioni di invio e di ricezione su un <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si usa una connessione orientato <xref:System.Net.Sockets.Socket>, chiamare sempre il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo prima della chiusura di <xref:System.Net.Sockets.Socket>. Ciò garantisce che tutti i dati viene inviato e ricevuto nel socket connessi prima della chiusura.  
  
 Chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo da liberare tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>. Non tentare di riutilizzare il <xref:System.Net.Sockets.Socket> dopo la chiusura.  
  
 La tabella seguente illustra il <xref:System.Net.Sockets.SocketShutdown> valori di enumerazione validi per il `how` parametro.  
  
|Valore|Descrizione|  
|-----------|-----------------|  
|Invia|Disabilita l'invio sul <xref:System.Net.Sockets.Socket>.|  
|Receive|Disabilita la ricezione sul <xref:System.Net.Sockets.Socket>.|  
|Entrambi|Disabilitare l'invio e ricezione su questo <xref:System.Net.Sockets.Socket>.|  
  
 L'impostazione `how` al <xref:System.Net.Sockets.SocketShutdown.Send> specifica che le successive chiamate a <xref:System.Net.Sockets.Socket.Send%2A> non sono consentiti. Se si usa un orientati <xref:System.Net.Sockets.Socket>, specificando <xref:System.Net.Sockets.SocketShutdown.Send> non avrà alcun effetto.  
  
 L'impostazione `how` al <xref:System.Net.Sockets.SocketShutdown.Receive> specifica che le successive chiamate a <xref:System.Net.Sockets.Socket.Receive%2A> non sono consentiti. Ciò ha effetto su livelli inferiori di protocollo. Se si usa un protocollo orientato alla connessione, la connessione viene terminata se si verifica una delle condizioni seguenti dopo una chiamata a <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   I dati sono nel buffer di rete in ingresso in attesa di essere ricevuti.  
  
-   È ora disponibile maggiore quantità di dati.  
  
 Se si usa un protocollo senza connessione, i datagrammi sono accettati e accodati. Tuttavia, se lo spazio di buffer non è disponibile per i datagrammi in ingresso aggiuntive, verranno ignorate e non verrà restituito alcun errore al mittente. Usando <xref:System.Net.Sockets.Socket.Shutdown%2A> su un oggetto senza connessione <xref:System.Net.Sockets.Socket> non è consigliata.  
  
 L'impostazione `how` a <xref:System.Net.Sockets.SocketShutdown.Both> Disabilita entrambi Invia e riceve come descritto in precedenza.  
  
> [!NOTE]
>  Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
> [!NOTE]
>  Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso. Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.Shutdown%2A> per disabilitare il <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> è di sola lettura e viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è disponibile il supporto per IPv4 e se IPv4 è abilitato sull'host corrente.</summary>
        <value>
          <see langword="true" /> se l'host corrente supporta il protocollo IPv4; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo può supportare i protocolli IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se Framework supporta IPv6 per determinati membri <see cref="T:System.Net.Dns" /> obsoleti.</summary>
        <value>
          <see langword="true" /> se Framework supporta IPv6 per determinati metodi <see cref="T:System.Net.Dns" /> obsoleti; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo può supportare i protocolli IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica la durata (TTL) dei pacchetti IP inviati dal <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>La durata (TTL).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di durata (TTL) indica il numero massimo di router, il pacchetto può attraversare prima che il router scarta il pacchetto e un messaggio di protocollo ICMP (Internet Control) "TTL superato" viene restituito al mittente del messaggio di errore.  
  
 Il valore di durata (TTL) può essere impostato su un valore compreso tra 0 e 255. Quando questa proprietà non è impostata, il valore di durata (TTL) predefinito per un socket è 32.  
  
 Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) viene ignorato da parte dello stack TCP/IP se è stata stabilita una connessione utilizzando il socket.  
  
 Se si riceve un <xref:System.Net.Sockets.SocketException>, usare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico. Dopo aver ottenuto il codice, fare riferimento alla versione di Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.Ttl%2A> proprietà.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Non è possibile impostare il valore TTL su un numero negativo.</exception>
        <exception cref="T:System.NotSupportedException">È possibile impostare questa proprietà solo per i socket inclusi nella famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore durante il tentativo di accesso al socket. Questo errore viene restituito anche quando si tenta di impostare TTL su un valore superiore a 255.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica se il socket deve utilizzare solo la modalità operazioni di I/O sovrapposte.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> utilizza solo operazioni di I/O sovrapposte; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su `true` per un <xref:System.Net.Sockets.Socket> si intende chiamare <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. In caso contrario, il Framework può assegnare una porta di completamento il socket, consentendo l'uso di <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il socket è stato associato a una porta di completamento.</exception>
      </Docs>
    </Member>
  </Members>
</Type>